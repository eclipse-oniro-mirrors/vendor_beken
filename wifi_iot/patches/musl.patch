diff --git a/third_party/musl/.gitignore b/third_party/musl/.gitignore
old mode 100644
new mode 100755
diff --git a/third_party/musl/.mailmap b/third_party/musl/.mailmap
old mode 100644
new mode 100755
diff --git a/third_party/musl/BUILD.gn b/third_party/musl/BUILD.gn
new file mode 100755
index 000000000..d3518359c
--- /dev/null
+++ b/third_party/musl/BUILD.gn
@@ -0,0 +1,224 @@
+import("musl_template.gni")
+
+group("musl_all") {
+  deps = [
+    ":musl_headers",
+    ":soft_libs",
+    ":a7_soft_libs",
+    ":a7_softfp_neon_libs",
+    ":a7_hard_neon_libs",
+  ]
+}
+
+musl_libs("soft") {
+  target_abi = "soft"
+}
+
+musl_libs("a7_soft") {
+  target_abi = "a7_soft"
+}
+
+musl_libs("a7_softfp_neon") {
+  target_abi = "a7_softfp_neon-vfpv4"
+}
+
+musl_libs("a7_hard_neon") {
+  target_abi = "a7_hard_neon-vfpv4"
+}
+
+group("musl_headers") {
+  deps = [
+    ":create_alltypes_h",
+    ":create_syscall_h",
+    ":create_version_h",
+    ":musl_copy_inc_arpa",
+    ":musl_copy_inc_bits",
+    ":musl_copy_inc_net",
+    ":musl_copy_inc_netinet",
+    ":musl_copy_inc_netpacket",
+    ":musl_copy_inc_root",
+    ":musl_copy_inc_scsi",
+    ":musl_copy_inc_sys",
+  ]
+}
+
+action("create_porting_src") {
+  script = "scripts/porting.sh"
+
+  sources = [
+    "//third_party/musl",
+  ]
+
+  outdir = [ "${target_out_dir}/${musl_ported_dir}" ]
+
+  src_files = musl_src_arch_file
+  src_files += musl_src_file
+  src_files += musl_src_ldso
+  src_files += musl_inc_bits_files
+  src_files += musl_inc_arpa_files
+  src_files += musl_inc_net_files
+  src_files += musl_inc_netinet_files
+  src_files += musl_inc_netpacket_files
+  src_files += musl_inc_scsi_files
+  src_files += musl_inc_sys_files
+  src_files += musl_inc_root_files
+  src_files += [
+    "crt/${musl_arch}/crti.s",
+    "crt/${musl_arch}/crtn.s",
+    "crt/Scrt1.c",
+    "crt/crt1.c",
+    "crt/rcrt1.c",
+    "tools/mkalltypes.sed",
+    "arch/${musl_arch}/bits/alltypes.h.in",
+    "arch/${musl_arch}/bits/syscall.h.in",
+    "include/alltypes.h.in",
+    "VERSION",
+    "tools/version.sh",
+    "tools/install.sh",
+    "scripts/install.py",
+    "scripts/create_alltypes.sh",
+    "scripts/create_vesion.sh",
+    "scripts/create_syscall.sh",
+  ]
+
+  outputs = []
+  foreach(s, src_files) {
+    outputs += [ "${target_out_dir}/${musl_ported_dir}/${s}" ]
+  }
+ 
+  args = [ "-i" ] + rebase_path(sources)
+  args += [ "-o" ] + rebase_path(outdir) 
+  args += [ "-p" ] + [ "${musl_target_os}" ]
+}
+
+action("create_alltypes_h") {
+  script = "${target_out_dir}/${musl_ported_dir}/scripts/create_alltypes.sh"
+
+  outputs = [ "${target_out_dir}/${musl_inc_out_dir}/bits/alltypes.h" ]
+
+  sources = [
+    "${target_out_dir}/${musl_ported_dir}/tools/mkalltypes.sed",
+    "${target_out_dir}/${musl_ported_dir}/arch/${musl_arch}/bits/alltypes.h.in",
+    "${target_out_dir}/${musl_ported_dir}/include/alltypes.h.in",
+  ]
+
+  args = [ "-o" ] + rebase_path(outputs, root_build_dir)
+  args += rebase_path(sources, root_build_dir)
+
+  deps = [ ":create_porting_src" ]
+}
+
+action("create_version_h") {
+  script = "${target_out_dir}/${musl_ported_dir}/scripts/create_vesion.sh"
+
+  outputs = [ "${target_out_dir}/${musl_inc_out_dir}/version.h" ]
+
+  sources = [
+    "${target_out_dir}/${musl_ported_dir}/VERSION",
+    "${target_out_dir}/${musl_ported_dir}/tools/version.sh",
+  ]
+
+  args = rebase_path(sources, root_build_dir)
+  args +=
+      [ rebase_path("${target_out_dir}/${musl_inc_out_dir}", root_build_dir) ]
+
+  deps = [ ":create_porting_src" ]
+}
+
+action("create_syscall_h") {
+  script = "${target_out_dir}/${musl_ported_dir}/scripts/create_syscall.sh"
+
+  outputs = [ "${target_out_dir}/${musl_inc_out_dir}/bits/syscall.h" ]
+
+  sources = [ "${target_out_dir}/${musl_ported_dir}/arch/${musl_arch}/bits/syscall.h.in" ]
+
+  args = rebase_path(sources, root_build_dir)
+  args += rebase_path(outputs, root_build_dir)
+
+  deps = [ ":create_porting_src" ]
+}
+
+copy("musl_copy_inc_bits") {
+  sources = []
+  sources_orig = musl_inc_bits_files
+  foreach(s, sources_orig) {
+    sources += [ "${target_out_dir}/${musl_ported_dir}/${s}" ]
+  }
+  outputs =
+      [ "${target_out_dir}/${musl_inc_out_dir}/bits/{{source_file_part}}" ]
+  deps = [ ":create_porting_src" ]
+}
+
+copy("musl_copy_inc_arpa") {
+  sources = []
+  sources_orig = musl_inc_arpa_files
+  foreach(s, sources_orig) {
+    sources += [ "${target_out_dir}/${musl_ported_dir}/${s}" ]
+  }
+  outputs =
+      [ "${target_out_dir}/${musl_inc_out_dir}/arpa/{{source_file_part}}" ]
+  deps = [ ":create_porting_src" ]
+}
+
+copy("musl_copy_inc_net") {
+  sources = []
+  sources_orig = musl_inc_net_files
+  foreach(s, sources_orig) {
+    sources += [ "${target_out_dir}/${musl_ported_dir}/${s}" ]
+  }
+  outputs = [ "${target_out_dir}/${musl_inc_out_dir}/net/{{source_file_part}}" ]
+  deps = [ ":create_porting_src" ]
+}
+
+copy("musl_copy_inc_netinet") {
+  sources = []
+  sources_orig = musl_inc_netinet_files
+  foreach(s, sources_orig) {
+    sources += [ "${target_out_dir}/${musl_ported_dir}/${s}" ]
+  }
+  outputs =
+      [ "${target_out_dir}/${musl_inc_out_dir}/netinet/{{source_file_part}}" ]
+  deps = [ ":create_porting_src" ]
+}
+
+copy("musl_copy_inc_netpacket") {
+  sources = []
+  sources_orig = musl_inc_netpacket_files
+  foreach(s, sources_orig) {
+    sources += [ "${target_out_dir}/${musl_ported_dir}/${s}" ]
+  }
+  outputs =
+      [ "${target_out_dir}/${musl_inc_out_dir}/netpacket/{{source_file_part}}" ]
+  deps = [ ":create_porting_src" ]
+}
+
+copy("musl_copy_inc_scsi") {
+  sources = []
+  sources_orig = musl_inc_scsi_files
+  foreach(s, sources_orig) {
+    sources += [ "${target_out_dir}/${musl_ported_dir}/${s}" ]
+  }
+  outputs =
+      [ "${target_out_dir}/${musl_inc_out_dir}/scsi/{{source_file_part}}" ]
+  deps = [ ":create_porting_src" ]
+}
+
+copy("musl_copy_inc_sys") {
+  sources = []
+  sources_orig = musl_inc_sys_files
+  foreach(s, sources_orig) {
+    sources += [ "${target_out_dir}/${musl_ported_dir}/${s}" ]
+  }
+  outputs = [ "${target_out_dir}/${musl_inc_out_dir}/sys/{{source_file_part}}" ]
+  deps = [ ":create_porting_src" ]
+}
+
+copy("musl_copy_inc_root") {
+  sources = []
+  sources_orig = musl_inc_root_files
+  foreach(s, sources_orig) {
+    sources += [ "${target_out_dir}/${musl_ported_dir}/${s}" ]
+  }
+  outputs = [ "${target_out_dir}/${musl_inc_out_dir}/{{source_file_part}}" ]
+  deps = [ ":create_porting_src" ]
+}
diff --git a/third_party/musl/Makefile b/third_party/musl/Makefile
index e8b925c0e..bd8f5c389 100644
--- a/third_party/musl/Makefile
+++ b/third_party/musl/Makefile
@@ -8,8 +8,6 @@
 # Do not make changes here.
 #
 
-HIDE := @
-
 srcdir = .
 exec_prefix = /usr/local
 bindir = $(exec_prefix)/bin
@@ -48,7 +46,7 @@ CFLAGS_AUTO = -Os -pipe
 CFLAGS_C99FSE = -std=c99 -ffreestanding -nostdinc 
 
 CFLAGS_ALL = $(CFLAGS_C99FSE)
-CFLAGS_ALL += -D_XOPEN_SOURCE=700 -I$(srcdir)/arch/$(ARCH) -I$(srcdir)/arch/generic -Iobj/src/internal -I$(srcdir)/src/include -I$(srcdir)/src/internal -Iobj/include -I$(srcdir)/include -I$(SYSROOT)/usr/include
+CFLAGS_ALL += -D_XOPEN_SOURCE=700 -I$(srcdir)/arch/$(ARCH) -I$(srcdir)/arch/generic -Iobj/src/internal -I$(srcdir)/src/include -I$(srcdir)/src/internal -Iobj/include -I$(srcdir)/include
 CFLAGS_ALL += $(CPPFLAGS) $(CFLAGS_AUTO) $(CFLAGS)
 
 LDFLAGS_ALL = $(LDFLAGS_AUTO) $(LDFLAGS)
@@ -94,17 +92,17 @@ OBJ_DIRS = $(sort $(patsubst %/,%,$(dir $(ALL_LIBS) $(ALL_TOOLS) $(ALL_OBJS) $(G
 $(ALL_LIBS) $(ALL_TOOLS) $(ALL_OBJS) $(ALL_OBJS:%.o=%.lo) $(GENH) $(GENH_INT): | $(OBJ_DIRS)
 
 $(OBJ_DIRS):
-	$(HIDE)mkdir -p $@
+	mkdir -p $@
 
 obj/include/bits/alltypes.h: $(srcdir)/arch/$(ARCH)/bits/alltypes.h.in $(srcdir)/include/alltypes.h.in $(srcdir)/tools/mkalltypes.sed
-	$(HIDE)sed -f $(srcdir)/tools/mkalltypes.sed $(srcdir)/arch/$(ARCH)/bits/alltypes.h.in $(srcdir)/include/alltypes.h.in > $@
+	sed -f $(srcdir)/tools/mkalltypes.sed $(srcdir)/arch/$(ARCH)/bits/alltypes.h.in $(srcdir)/include/alltypes.h.in > $@
 
 obj/include/bits/syscall.h: $(srcdir)/arch/$(ARCH)/bits/syscall.h.in
-	$(HIDE)cp $< $@
-	$(HIDE)sed -n -e s/__NR_/SYS_/p < $< >> $@
+	cp $< $@
+	sed -n -e s/__NR_/SYS_/p < $< >> $@
 
 obj/src/internal/version.h: $(wildcard $(srcdir)/VERSION $(srcdir)/.git)
-	$(HIDE)printf '#define VERSION "%s"\n' "$$(cd $(srcdir); sh tools/version.sh)" > $@
+	printf '#define VERSION "%s"\n' "$$(cd $(srcdir); sh tools/version.sh)" > $@
 
 obj/src/internal/version.o obj/src/internal/version.lo: obj/src/internal/version.h
 
@@ -142,76 +140,76 @@ else
 endif
 
 obj/%.o: $(srcdir)/%.s
-	$(HIDE)$(AS_CMD)
+	$(AS_CMD)
 
 obj/%.o: $(srcdir)/%.S
-	$(HIDE)$(CC_CMD)
+	$(CC_CMD)
 
 obj/%.o: $(srcdir)/%.c $(GENH) $(IMPH)
-	$(HIDE)$(CC_CMD)
+	$(CC_CMD)
 
 obj/%.lo: $(srcdir)/%.s
-	$(HIDE)$(AS_CMD)
+	$(AS_CMD)
 
 obj/%.lo: $(srcdir)/%.S
-	$(HIDE)$(CC_CMD)
+	$(CC_CMD)
 
 obj/%.lo: $(srcdir)/%.c $(GENH) $(IMPH)
-	$(HIDE)$(CC_CMD)
+	$(CC_CMD)
 
 lib/libc.so: $(LOBJS) $(LDSO_OBJS)
-	$(HIDE)$(CC) $(CFLAGS_ALL) $(LDFLAGS_ALL) -nostdlib -shared \
+	$(CC) $(CFLAGS_ALL) $(LDFLAGS_ALL) -nostdlib -shared \
 	-Wl,-e,_dlstart -o $@ $(LOBJS) $(LDSO_OBJS) $(LIBCC)
 
 lib/libc.a: $(AOBJS)
-	$(HIDE)rm -f $@
-	$(HIDE)$(AR) rc $@ $(AOBJS)
-	$(HIDE)$(RANLIB) $@
+	rm -f $@
+	$(AR) rc $@ $(AOBJS)
+	$(RANLIB) $@
 
 $(EMPTY_LIBS):
-	$(HIDE)rm -f $@
-	$(HIDE)$(AR) rc $@
+	rm -f $@
+	$(AR) rc $@
 
 lib/%.o: obj/crt/$(ARCH)/%.o
-	$(HIDE)cp $< $@
+	cp $< $@
 
 lib/%.o: obj/crt/%.o
-	$(HIDE)cp $< $@
+	cp $< $@
 
 lib/musl-gcc.specs: $(srcdir)/tools/musl-gcc.specs.sh config.mak
-	$(HIDE)sh $< "$(includedir)" "$(libdir)" "$(LDSO_PATHNAME)" > $@
+	sh $< "$(includedir)" "$(libdir)" "$(LDSO_PATHNAME)" > $@
 
 obj/musl-gcc: config.mak
-	$(HIDE)printf '#!/bin/sh\nexec "$${REALGCC:-$(WRAPCC_GCC)}" "$$@" -specs "%s/musl-gcc.specs"\n' "$(libdir)" > $@
-	$(HIDE)chmod +x $@
+	printf '#!/bin/sh\nexec "$${REALGCC:-$(WRAPCC_GCC)}" "$$@" -specs "%s/musl-gcc.specs"\n' "$(libdir)" > $@
+	chmod +x $@
 
 obj/%-clang: $(srcdir)/tools/%-clang.in config.mak
-	$(HIDE)sed -e 's!@CC@!$(WRAPCC_CLANG)!g' -e 's!@PREFIX@!$(prefix)!g' -e 's!@INCDIR@!$(includedir)!g' -e 's!@LIBDIR@!$(libdir)!g' -e 's!@LDSO@!$(LDSO_PATHNAME)!g' $< > $@
-	$(HIDE)chmod +x $@
+	sed -e 's!@CC@!$(WRAPCC_CLANG)!g' -e 's!@PREFIX@!$(prefix)!g' -e 's!@INCDIR@!$(includedir)!g' -e 's!@LIBDIR@!$(libdir)!g' -e 's!@LDSO@!$(LDSO_PATHNAME)!g' $< > $@
+	chmod +x $@
 
 $(DESTDIR)$(bindir)/%: obj/%
-	$(HIDE)$(INSTALL) -D $< $@
+	$(INSTALL) -D $< $@
 
 $(DESTDIR)$(libdir)/%.so: lib/%.so
-	$(HIDE)$(INSTALL) -D -m 755 $< $@
+	$(INSTALL) -D -m 755 $< $@
 
 $(DESTDIR)$(libdir)/%: lib/%
-	$(HIDE)$(INSTALL) -D -m 644 $< $@
+	$(INSTALL) -D -m 644 $< $@
 
 $(DESTDIR)$(includedir)/bits/%: $(srcdir)/arch/$(ARCH)/bits/%
-	$(HIDE)$(INSTALL) -D -m 644 $< $@
+	$(INSTALL) -D -m 644 $< $@
 
 $(DESTDIR)$(includedir)/bits/%: $(srcdir)/arch/generic/bits/%
-	$(HIDE)$(INSTALL) -D -m 644 $< $@
+	$(INSTALL) -D -m 644 $< $@
 
 $(DESTDIR)$(includedir)/bits/%: obj/include/bits/%
-	$(HIDE)$(INSTALL) -D -m 644 $< $@
+	$(INSTALL) -D -m 644 $< $@
 
 $(DESTDIR)$(includedir)/%: $(srcdir)/include/%
-	$(HIDE)$(INSTALL) -D -m 644 $< $@
+	$(INSTALL) -D -m 644 $< $@
 
 $(DESTDIR)$(LDSO_PATHNAME): $(DESTDIR)$(libdir)/libc.so
-	$(HIDE)$(INSTALL) -D -l $(libdir)/libc.so $@ || true
+	$(INSTALL) -D -l $(libdir)/libc.so $@ || true
 
 install-libs: $(ALL_LIBS:lib/%=$(DESTDIR)$(libdir)/%) $(if $(SHARED_LIBS),$(DESTDIR)$(LDSO_PATHNAME),)
 
@@ -222,17 +220,17 @@ install-tools: $(ALL_TOOLS:obj/%=$(DESTDIR)$(bindir)/%)
 install: install-libs install-headers install-tools
 
 musl-git-%.tar.gz: .git
-	 $(HIDE)git --git-dir=$(srcdir)/.git archive --format=tar.gz --prefix=$(patsubst %.tar.gz,%,$@)/ -o $@ $(patsubst musl-git-%.tar.gz,%,$@)
+	 git --git-dir=$(srcdir)/.git archive --format=tar.gz --prefix=$(patsubst %.tar.gz,%,$@)/ -o $@ $(patsubst musl-git-%.tar.gz,%,$@)
 
 musl-%.tar.gz: .git
-	 $(HIDE)git --git-dir=$(srcdir)/.git archive --format=tar.gz --prefix=$(patsubst %.tar.gz,%,$@)/ -o $@ v$(patsubst musl-%.tar.gz,%,$@)
+	 git --git-dir=$(srcdir)/.git archive --format=tar.gz --prefix=$(patsubst %.tar.gz,%,$@)/ -o $@ v$(patsubst musl-%.tar.gz,%,$@)
 
 endif
 
 clean:
-	$(HIDE)rm -rf obj lib
+	rm -rf obj lib
 
 distclean: clean
-	$(HIDE)rm -f config.mak
+	rm -f config.mak
 
 .PHONY: all clean install install-libs install-headers install-tools
diff --git a/third_party/musl/arch/arm/bits/stdint.h b/third_party/musl/arch/arm/bits/stdint.h
index 1cd984605..d1b271219 100644
--- a/third_party/musl/arch/arm/bits/stdint.h
+++ b/third_party/musl/arch/arm/bits/stdint.h
@@ -1,4 +1,3 @@
-#ifndef __ICCARM__
 typedef int32_t int_fast16_t;
 typedef int32_t int_fast32_t;
 typedef uint32_t uint_fast16_t;
@@ -19,4 +18,3 @@ typedef uint32_t uint_fast32_t;
 #define PTRDIFF_MIN     INT32_MIN
 #define PTRDIFF_MAX     INT32_MAX
 #define SIZE_MAX        UINT32_MAX
-#endif
\ No newline at end of file
diff --git a/third_party/musl/arch/arm/bits/syscall.h.in b/third_party/musl/arch/arm/bits/syscall.h.in
index 33b4676a0..11d677635 100755
--- a/third_party/musl/arch/arm/bits/syscall.h.in
+++ b/third_party/musl/arch/arm/bits/syscall.h.in
@@ -16,7 +16,6 @@
 #define __NR_lseek	19
 #define __NR_getpid	20
 #define __NR_mount	21
-#define __NR_umount	22
 #define __NR_setuid	23
 #define __NR_getuid	24
 #define __NR_ptrace	26
@@ -210,8 +209,6 @@
 #define __NR_epoll_ctl	251
 #define __NR_epoll_wait	252
 #define __NR_remap_file_pages	253
-#define __NR_set_thread_area	254
-#define __NR_get_thread_area	255
 #define __NR_set_tid_address	256
 #define __NR_timer_create	257
 #define __NR_timer_settime32	258
@@ -360,6 +357,26 @@
 #define __NR_io_pgetevents	399
 #define __NR_migrate_pages	400
 #define __NR_kexec_file_load	401
+#define __NR_clock_gettime64	403
+#define __NR_clock_settime64	404
+#define __NR_clock_adjtime64	405
+#define __NR_clock_getres_time64	406
+#define __NR_clock_nanosleep_time64	407
+#define __NR_timer_gettime64	408
+#define __NR_timer_settime64	409
+#define __NR_timerfd_gettime64	410
+#define __NR_timerfd_settime64	411
+#define __NR_utimensat_time64	412
+#define __NR_pselect6_time64	413
+#define __NR_ppoll_time64	414
+#define __NR_io_pgetevents_time64	416
+#define __NR_recvmmsg_time64	417
+#define __NR_mq_timedsend_time64	418
+#define __NR_mq_timedreceive_time64	419
+#define __NR_semtimedop_time64	420
+#define __NR_rt_sigtimedwait_time64	421
+#define __NR_futex_time64	422
+#define __NR_sched_rr_get_interval_time64	423
 #define __NR_pidfd_send_signal	424
 #define __NR_io_uring_setup	425
 #define __NR_io_uring_enter	426
@@ -373,28 +390,10 @@
 #define __NR_pidfd_open		434
 #define __NR_clone3		435
 
-/* OHOS customized syscalls, not compatible with ARM EABI */
-#define __NR_OHOS_BEGIN         500
-#define __NR_pthread_set_detach (__NR_OHOS_BEGIN + 0)
-#define __NR_pthread_join       (__NR_OHOS_BEGIN + 1)
-#define __NR_pthread_deatch     (__NR_OHOS_BEGIN + 2)
-#define __NR_creat_user_thread  (__NR_OHOS_BEGIN + 3)
-#define __NR_processcreat       (__NR_OHOS_BEGIN + 4)
-#define __NR_processtart        (__NR_OHOS_BEGIN + 5)
-#define __NR_printf             (__NR_OHOS_BEGIN + 6)
-#define __NR_dumpmemory         (__NR_OHOS_BEGIN + 13)
-#define __NR_mkfifo             (__NR_OHOS_BEGIN + 14)
-#define __NR_mqclose            (__NR_OHOS_BEGIN + 15)
-#define __NR_realpath           (__NR_OHOS_BEGIN + 16)
-#define __NR_format             (__NR_OHOS_BEGIN + 17)
-#define __NR_shellexec          (__NR_OHOS_BEGIN + 18)
-#define __NR_ohoscapget         (__NR_OHOS_BEGIN + 19)
-#define __NR_ohoscapset         (__NR_OHOS_BEGIN + 20)
-#define __NR_syscallend         (__NR_OHOS_BEGIN + 21)
-
 #define __ARM_NR_breakpoint	0x0f0001
 #define __ARM_NR_cacheflush	0x0f0002
 #define __ARM_NR_usr26		0x0f0003
 #define __ARM_NR_usr32		0x0f0004
 #define __ARM_NR_set_tls	0x0f0005
 #define __ARM_NR_get_tls	0x0f0006
+
diff --git a/third_party/musl/arch/arm/crt_arch.h b/third_party/musl/arch/arm/crt_arch.h
index 219464e07..99508b1db 100644
--- a/third_party/musl/arch/arm/crt_arch.h
+++ b/third_party/musl/arch/arm/crt_arch.h
@@ -7,8 +7,8 @@ START ": \n"
 "	mov lr, #0 \n"
 "	ldr a2, 1f \n"
 "	add a2, pc, a2 \n"
-"	mov a3, sp \n"
-"2:	and ip, a3, #-16 \n"
+"	mov a1, sp \n"
+"2:	and ip, a1, #-16 \n"
 "	mov sp, ip \n"
 "	bl " START "_c \n"
 ".weak _DYNAMIC \n"
diff --git a/third_party/musl/arch/arm/pthread_arch.h b/third_party/musl/arch/arm/pthread_arch.h
index 14119c953..e689ea212 100644
--- a/third_party/musl/arch/arm/pthread_arch.h
+++ b/third_party/musl/arch/arm/pthread_arch.h
@@ -1,4 +1,3 @@
-#if 0
 #if ((__ARM_ARCH_6K__ || __ARM_ARCH_6KZ__ || __ARM_ARCH_6ZK__) && !__thumb__) \
  || __ARM_ARCH_7A__ || __ARM_ARCH_7R__ || __ARM_ARCH >= 7
 
@@ -25,9 +24,6 @@ static inline pthread_t __pthread_self()
 	return (void *)(p-sizeof(struct pthread));
 }
 
-#endif
-#else
-extern pthread_t __pthread_self();
 #endif
 
 #define TLS_ABOVE_TP
diff --git a/third_party/musl/arch/arm/reloc.h b/third_party/musl/arch/arm/reloc.h
index 843dd6211..d091d2ad9 100644
--- a/third_party/musl/arch/arm/reloc.h
+++ b/third_party/musl/arch/arm/reloc.h
@@ -29,4 +29,4 @@
 #define TLSDESC_BACKWARDS
 
 #define CRTJMP(pc,sp) __asm__ __volatile__( \
-	"mov r0,%1 ; bx %0" : : "r"(pc), "r"(sp) : "memory", "r0" )
+	"mov sp,%1 ; bx %0" : : "r"(pc), "r"(sp) : "memory" )
diff --git a/third_party/musl/arch/arm/syscall_arch.h b/third_party/musl/arch/arm/syscall_arch.h
index 9b5a52491..4b08762d7 100644
--- a/third_party/musl/arch/arm/syscall_arch.h
+++ b/third_party/musl/arch/arm/syscall_arch.h
@@ -99,10 +99,10 @@ static inline long __syscall6(long n, long a, long b, long c, long d, long e, lo
 }
 
 #define VDSO_USEFUL
-#define VDSO_CGT32_SYM "VdsoClockGettime"
-#define VDSO_CGT32_VER "OHOS"
-#define VDSO_CGT_SYM "VdsoClockGettime"
-#define VDSO_CGT_VER "OHOS"
+#define VDSO_CGT32_SYM "__vdso_clock_gettime"
+#define VDSO_CGT32_VER "LINUX_2.6"
+#define VDSO_CGT_SYM "__vdso_clock_gettime64"
+#define VDSO_CGT_VER "LINUX_2.6"
 
 #define SYSCALL_FADVISE_6_ARG
 
diff --git a/third_party/musl/include/assert.h b/third_party/musl/include/assert.h
index a9bfa7d56..d14ec94e7 100755
--- a/third_party/musl/include/assert.h
+++ b/third_party/musl/include/assert.h
@@ -1,6 +1,3 @@
-#ifdef __ICCARM__ /* for iar */
-#include_next <assert.h>
-#else
 #include <features.h>
 
 #undef assert
@@ -23,6 +20,4 @@ _Noreturn void __assert_fail (const char *, const char *, int, const char *);
 
 #ifdef __cplusplus
 }
-
-#endif /* __ICCARM__ */
 #endif
diff --git a/third_party/musl/include/complex.h b/third_party/musl/include/complex.h
index e56b1c37d..008b3c7e3 100755
--- a/third_party/musl/include/complex.h
+++ b/third_party/musl/include/complex.h
@@ -1,10 +1,6 @@
 #ifndef _COMPLEX_H
 #define _COMPLEX_H
 
-#ifdef __ICCARM__ /* for iar */
-#include_next <complex.h>
-#else
-
 #ifdef __cplusplus
 extern "C" {
 #endif
@@ -134,6 +130,4 @@ long double creall(long double complex);
 #ifdef __cplusplus
 }
 #endif
-
-#endif /* __ICCARM__ */
 #endif
diff --git a/third_party/musl/include/ctype.h b/third_party/musl/include/ctype.h
index 61e826d05..7936536f5 100755
--- a/third_party/musl/include/ctype.h
+++ b/third_party/musl/include/ctype.h
@@ -1,10 +1,6 @@
 #ifndef	_CTYPE_H
 #define	_CTYPE_H
 
-#ifdef __ICCARM__ /* for iar */
-#include_next <ctype.h>
-#else
-
 #ifdef __cplusplus
 extern "C" {
 #endif
@@ -76,5 +72,4 @@ int   toascii(int);
 }
 #endif
 
-#endif /* __ICCARM__ */
 #endif
diff --git a/third_party/musl/include/errno.h b/third_party/musl/include/errno.h
index 306c02b30..0361b33ad 100755
--- a/third_party/musl/include/errno.h
+++ b/third_party/musl/include/errno.h
@@ -1,54 +1,6 @@
 #ifndef	_ERRNO_H
 #define _ERRNO_H
 
-#ifdef __ICCARM__ /* for iar */
-
-#include_next <errno.h>
-
-#ifdef errno
-#undef errno
-#endif
-
-#ifdef EDOM
-#undef EDOM
-#endif
-
-#ifdef ERANGE
-#undef ERANGE
-#endif
-
-#ifdef EFPOS
-#undef EFPOS
-#endif
-
-#ifdef EILSEQ
-#undef EILSEQ
-#endif
-
-#ifdef _NERR
-#undef _NERR
-#endif
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-#include <features.h>
-
-#include <bits/errno.h>
-
-#ifdef __GNUC__
-__attribute__((const))
-#endif
-int *__errno_location(void);
-#define errno (*__errno_location())
-
-#ifdef __cplusplus
-}
-#endif
-
-#else
-
 #ifdef __cplusplus
 extern "C" {
 #endif
@@ -71,6 +23,5 @@ extern char *program_invocation_short_name, *program_invocation_name;
 }
 #endif
 
-#endif /* __ICCARM__ */
 #endif
 
diff --git a/third_party/musl/include/features.h b/third_party/musl/include/features.h
index b5fd3184e..85cfb72a0 100755
--- a/third_party/musl/include/features.h
+++ b/third_party/musl/include/features.h
@@ -16,7 +16,7 @@
 #define _XOPEN_SOURCE 700
 #endif
 
-#if __STDC_VERSION__ >= 199901L && !defined(__cplusplus)
+#if __STDC_VERSION__ >= 199901L
 #define __restrict restrict
 #elif !defined(__GNUC__)
 #define __restrict
@@ -28,13 +28,7 @@
 #define __inline
 #endif
 
-#if defined(__cplusplus)
-#if __cplusplus >= 201103L
-#define _Noreturn [[ noreturn ]]
-#else
-#define _Noreturn
-#endif
-#elif __STDC_VERSION__ >= 201112L
+#if __STDC_VERSION__ >= 201112L
 #elif defined(__GNUC__)
 #define _Noreturn __attribute__((__noreturn__))
 #else
diff --git a/third_party/musl/include/fenv.h b/third_party/musl/include/fenv.h
index 1fcb2ffd6..05de990c0 100755
--- a/third_party/musl/include/fenv.h
+++ b/third_party/musl/include/fenv.h
@@ -1,10 +1,6 @@
 #ifndef _FENV_H
 #define _FENV_H
 
-#ifdef __ICCARM__ /* for iar */
-#include_next <fenv.h>
-#else
-
 #ifdef __cplusplus
 extern "C" {
 #endif
@@ -28,7 +24,5 @@ int feupdateenv(const fenv_t *);
 #ifdef __cplusplus
 }
 #endif
-
-#endif /* __ICCARM__ */
 #endif
 
diff --git a/third_party/musl/include/float.h b/third_party/musl/include/float.h
index a4c1b54e9..713aadb90 100755
--- a/third_party/musl/include/float.h
+++ b/third_party/musl/include/float.h
@@ -1,10 +1,6 @@
 #ifndef _FLOAT_H
 #define _FLOAT_H
 
-#ifdef __ICCARM__ /* for iar */
-#include_next <float.h>
-#else
-
 #ifdef __cplusplus
 extern "C" {
 #endif
@@ -53,5 +49,4 @@ int __flt_rounds(void);
 }
 #endif
 
-#endif /* __ICCARM__ */
 #endif
diff --git a/third_party/musl/include/inttypes.h b/third_party/musl/include/inttypes.h
index d6c5c6ef5..61dcb7273 100755
--- a/third_party/musl/include/inttypes.h
+++ b/third_party/musl/include/inttypes.h
@@ -1,10 +1,6 @@
 #ifndef _INTTYPES_H
 #define _INTTYPES_H
 
-#ifdef __ICCARM__ /* for iar */
-#include_next <inttypes.h>
-#else
-
 #ifdef __cplusplus
 extern "C" {
 #endif
@@ -229,6 +225,5 @@ uintmax_t wcstoumax(const wchar_t *__restrict, wchar_t **__restrict, int);
 }
 #endif
 
-#endif /* __ICCARM__ */
 #endif
 
diff --git a/third_party/musl/include/iso646.h b/third_party/musl/include/iso646.h
index 10c6eb16d..88ff53d7b 100755
--- a/third_party/musl/include/iso646.h
+++ b/third_party/musl/include/iso646.h
@@ -1,10 +1,6 @@
 #ifndef _ISO646_H
 #define _ISO646_H
 
-#ifdef __ICCARM__ /* for iar */
-#include_next <iso646.h>
-#else
-
 #ifndef __cplusplus
 
 #define and    &&
@@ -21,5 +17,4 @@
 
 #endif
 
-#endif /* __ICCARM__ */
 #endif
diff --git a/third_party/musl/include/limits.h b/third_party/musl/include/limits.h
index 57ad9c694..53a27b9de 100755
--- a/third_party/musl/include/limits.h
+++ b/third_party/musl/include/limits.h
@@ -1,10 +1,6 @@
 #ifndef _LIMITS_H
 #define _LIMITS_H
 
-#ifdef __ICCARM__ /* for iar */
-#include_next <limits.h>
-#else
-
 #include <features.h>
 
 #include <bits/alltypes.h> /* __LONG_MAX */
@@ -48,9 +44,9 @@
 #ifndef NAME_MAX
 #define NAME_MAX 255
 #endif
-#define PATH_MAX 256
+#define PATH_MAX 4096
 #define NGROUPS_MAX 32
-#define ARG_MAX 4096
+#define ARG_MAX 131072
 #define IOV_MAX 1024
 #define SYMLOOP_MAX 40
 #define WORD_BIT 32
@@ -73,7 +69,7 @@
 #define SEM_VALUE_MAX 0x7fffffff
 #define SEM_NSEMS_MAX 256
 #define DELAYTIMER_MAX 0x7fffffff
-#define MQ_PRIO_MAX 1
+#define MQ_PRIO_MAX 32768
 #define LOGIN_NAME_MAX 256
 
 /* Arbitrary numbers... */
@@ -167,5 +163,4 @@
 #define _XOPEN_NAME_MAX         255
 #define _XOPEN_PATH_MAX         1024
 
-#endif /* __ICCARM__ */
 #endif
diff --git a/third_party/musl/include/locale.h b/third_party/musl/include/locale.h
index 0e1fa87fd..ce384381c 100755
--- a/third_party/musl/include/locale.h
+++ b/third_party/musl/include/locale.h
@@ -1,10 +1,6 @@
 #ifndef	_LOCALE_H
 #define	_LOCALE_H
 
-#ifdef __ICCARM__ /* for iar */
-#include_next <locale.h>
-#else
-
 #ifdef __cplusplus
 extern "C" {
 #endif
@@ -87,5 +83,4 @@ locale_t uselocale(locale_t);
 }
 #endif
 
-#endif /* __ICCARM__ */
 #endif
diff --git a/third_party/musl/include/math.h b/third_party/musl/include/math.h
index 74a4e7f77..14f28ec8c 100755
--- a/third_party/musl/include/math.h
+++ b/third_party/musl/include/math.h
@@ -1,10 +1,6 @@
 #ifndef _MATH_H
 #define _MATH_H
 
-#ifdef __ICCARM__ /* for iar */
-#include_next <math.h>
-#else
-
 #ifdef __cplusplus
 extern "C" {
 #endif
@@ -443,5 +439,4 @@ long double pow10l(long double);
 }
 #endif
 
-#endif /* __ICCARM__ */
 #endif
diff --git a/third_party/musl/include/setjmp.h b/third_party/musl/include/setjmp.h
index 0d22f5f4f..2d43abf84 100755
--- a/third_party/musl/include/setjmp.h
+++ b/third_party/musl/include/setjmp.h
@@ -1,10 +1,6 @@
 #ifndef	_SETJMP_H
 #define	_SETJMP_H
 
-#ifdef __ICCARM__ /* for iar */
-#include_next <setjmp.h>
-#else
-
 #ifdef __cplusplus
 extern "C" {
 #endif
@@ -42,5 +38,4 @@ _Noreturn void longjmp (jmp_buf, int);
 }
 #endif
 
-#endif /* __ICCARM__ */
 #endif
diff --git a/third_party/musl/include/signal.h b/third_party/musl/include/signal.h
index d3ab2d786..fbdf667b2 100755
--- a/third_party/musl/include/signal.h
+++ b/third_party/musl/include/signal.h
@@ -1,42 +1,6 @@
 #ifndef _SIGNAL_H
 #define _SIGNAL_H
 
-#ifdef __ICCARM__ /* for iar */
-
-#include_next <signal.h>
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-#define __NEED_pthread_attr_t
-
-#include <bits/alltypes.h>
-
-union sigval {
-	int sival_int;
-	void *sival_ptr;
-};
-
-struct sigevent {
-	union sigval sigev_value;
-	int sigev_signo;
-	int sigev_notify;
-	void (*sigev_notify_function)(union sigval);
-	pthread_attr_t *sigev_notify_attributes;
-	char __pad[56-3*sizeof(long)];
-};
-
-#define SIGEV_SIGNAL 0
-#define SIGEV_NONE 1
-#define SIGEV_THREAD 2
-
-#ifdef __cplusplus
-}
-#endif
-
-#else
-
 #ifdef __cplusplus
 extern "C" {
 #endif
@@ -319,5 +283,4 @@ __REDIR(sigtimedwait, __sigtimedwait_time64);
 }
 #endif
 
-#endif /* __ICCARM__ */
 #endif
diff --git a/third_party/musl/include/stdalign.h b/third_party/musl/include/stdalign.h
index 428e85338..2cc94be3f 100755
--- a/third_party/musl/include/stdalign.h
+++ b/third_party/musl/include/stdalign.h
@@ -1,10 +1,6 @@
 #ifndef _STDALIGN_H
 #define _STDALIGN_H
 
-#ifdef __ICCARM__ /* for iar */
-#include_next <stdalign.h>
-#else
-
 #ifndef __cplusplus
 
 /* this whole header only works in C11 or with compiler extensions */
@@ -21,5 +17,4 @@
 #define __alignas_is_defined 1
 #define __alignof_is_defined 1
 
-#endif /* __ICCARM__ */
 #endif
diff --git a/third_party/musl/include/stdarg.h b/third_party/musl/include/stdarg.h
index e29626680..3256f8050 100755
--- a/third_party/musl/include/stdarg.h
+++ b/third_party/musl/include/stdarg.h
@@ -1,10 +1,6 @@
 #ifndef _STDARG_H
 #define _STDARG_H
 
-#ifdef __ICCARM__ /* for iar */
-#include_next <stdarg.h>
-#else
-
 #ifdef __cplusplus
 extern "C" {
 #endif
@@ -22,5 +18,4 @@ extern "C" {
 }
 #endif
 
-#endif /* __ICCARM__ */
 #endif
diff --git a/third_party/musl/include/stdbool.h b/third_party/musl/include/stdbool.h
index cc849df46..a9d7ab787 100755
--- a/third_party/musl/include/stdbool.h
+++ b/third_party/musl/include/stdbool.h
@@ -1,10 +1,6 @@
 #ifndef _STDBOOL_H
 #define _STDBOOL_H
 
-#ifdef __ICCARM__ /* for iar */
-#include_next <stdbool.h>
-#else
-
 #ifndef __cplusplus
 
 #define true 1
@@ -15,5 +11,4 @@
 
 #define __bool_true_false_are_defined 1
 
-#endif /* __ICCARM__ */
 #endif
diff --git a/third_party/musl/include/stddef.h b/third_party/musl/include/stddef.h
index 27b5a9ad7..bd7538535 100755
--- a/third_party/musl/include/stddef.h
+++ b/third_party/musl/include/stddef.h
@@ -1,10 +1,6 @@
 #ifndef _STDDEF_H
 #define _STDDEF_H
 
-#ifdef __ICCARM__ /* for iar */
-#include_next <stddef.h>
-#else
-
 #ifdef __cplusplus
 #define NULL 0L
 #else
@@ -26,5 +22,4 @@
 #define offsetof(type, member) ((size_t)( (char *)&(((type *)0)->member) - (char *)0 ))
 #endif
 
-#endif /* __ICCARM__ */
 #endif
diff --git a/third_party/musl/include/stdint.h b/third_party/musl/include/stdint.h
index 7f8bdd37d..a2968197d 100755
--- a/third_party/musl/include/stdint.h
+++ b/third_party/musl/include/stdint.h
@@ -1,10 +1,6 @@
 #ifndef _STDINT_H
 #define _STDINT_H
 
-#ifdef __ICCARM__ /* for iar */
-#include_next <stdint.h>
-#else
-
 #define __NEED_int8_t
 #define __NEED_int16_t
 #define __NEED_int32_t
@@ -118,5 +114,4 @@ typedef uint64_t uint_least64_t;
 #define UINTMAX_C(c) c ## ULL
 #endif
 
-#endif /* __ICCARM__ */
 #endif
diff --git a/third_party/musl/include/stdio.h b/third_party/musl/include/stdio.h
index fb5539ff5..3604198c3 100755
--- a/third_party/musl/include/stdio.h
+++ b/third_party/musl/include/stdio.h
@@ -1,11 +1,6 @@
 #ifndef _STDIO_H
 #define _STDIO_H
 
-#ifdef __ICCARM__ /* for iar */
-#include_next <stdio.h>
-int rename(const char *, const char *);
-#else
-
 #ifdef __cplusplus
 extern "C" {
 #endif
@@ -224,5 +219,4 @@ FILE *fopencookie(void *, const char *, cookie_io_functions_t);
 }
 #endif
 
-#endif /* __ICCARM__ */
 #endif
diff --git a/third_party/musl/include/stdlib.h b/third_party/musl/include/stdlib.h
index d292fb0a8..194c20339 100755
--- a/third_party/musl/include/stdlib.h
+++ b/third_party/musl/include/stdlib.h
@@ -1,10 +1,6 @@
 #ifndef _STDLIB_H
 #define _STDLIB_H
 
-#ifdef __ICCARM__ /* for iar */
-#include_next <stdlib.h>
-#else
-
 #ifdef __cplusplus
 extern "C" {
 #endif
@@ -176,5 +172,4 @@ long double strtold_l(const char *__restrict, char **__restrict, struct __locale
 }
 #endif
 
-#endif /* __ICCARM__ */
 #endif
diff --git a/third_party/musl/include/stdnoreturn.h b/third_party/musl/include/stdnoreturn.h
index 8fc256bf0..5c6aeeb00 100755
--- a/third_party/musl/include/stdnoreturn.h
+++ b/third_party/musl/include/stdnoreturn.h
@@ -1,14 +1,7 @@
 #ifndef _STDNORETURN_H
 #define _STDNORETURN_H
-
-#ifdef __ICCARM__ /* for iar */
-#include_next <stdnoreturn.h>
-#else
-
 #ifndef __cplusplus
 #include <features.h>
 #define noreturn _Noreturn
 #endif
-
-#endif /* __ICCARM__ */
 #endif
diff --git a/third_party/musl/include/string.h b/third_party/musl/include/string.h
index 56b204f6a..795a2abcd 100755
--- a/third_party/musl/include/string.h
+++ b/third_party/musl/include/string.h
@@ -1,10 +1,6 @@
 #ifndef	_STRING_H
 #define	_STRING_H
 
-#ifdef __ICCARM__ /* for iar */
-#include_next <string.h>
-#else
-
 #ifdef __cplusplus
 extern "C" {
 #endif
@@ -106,5 +102,4 @@ char *basename();
 }
 #endif
 
-#endif /* __ICCARM__ */
-#endif
\ No newline at end of file
+#endif
diff --git a/third_party/musl/include/tgmath.h b/third_party/musl/include/tgmath.h
index 94b2add17..e41ccac9e 100755
--- a/third_party/musl/include/tgmath.h
+++ b/third_party/musl/include/tgmath.h
@@ -1,10 +1,6 @@
 #ifndef _TGMATH_H
 #define _TGMATH_H
 
-#ifdef __ICCARM__ /* for iar */
-#include_next <tgmath.h>
-#else
-
 /*
 the return types are only correct with gcc (__GNUC__)
 otherwise they are long double or long double complex
@@ -271,5 +267,4 @@ so they can be in null pointer constants
 #define tgamma(x)       __tg_real(tgamma, (x))
 #define trunc(x)        __tg_real(trunc, (x))
 
-#endif /* __ICCARM__ */
 #endif
diff --git a/third_party/musl/include/threads.h b/third_party/musl/include/threads.h
index e4ace4faa..52ec3100e 100755
--- a/third_party/musl/include/threads.h
+++ b/third_party/musl/include/threads.h
@@ -1,10 +1,6 @@
 #ifndef _THREADS_H
 #define _THREADS_H
 
-#ifdef __ICCARM__ /* for iar */
-#include_next <threads.h>
-#else
-
 #include <features.h>
 #include <time.h>
 
@@ -94,5 +90,4 @@ __REDIR(cnd_timedwait, __cnd_timedwait_time64);
 }
 #endif
 
-#endif /* __ICCARM__ */
 #endif
diff --git a/third_party/musl/include/time.h b/third_party/musl/include/time.h
index e03764da6..5494df183 100755
--- a/third_party/musl/include/time.h
+++ b/third_party/musl/include/time.h
@@ -1,78 +1,6 @@
 #ifndef	_TIME_H
 #define _TIME_H
 
-#ifdef __ICCARM__ /* for iar */
-
-#ifndef tm_isdst
-#define tm_isdst    tm_isdst;	\
-	long __tm_gmtoff;	\
-	const char *__tm_zone
-
-#if defined(_BSD_SOURCE) || defined(_GNU_SOURCE)
-#define __tm_gmtoff tm_gmtoff
-#define __tm_zone tm_zone
-#endif
-
-#include_next <time.h>
-#undef tm_isdst
-
-#else /* tm_isdst */
-
-#include_next <time.h>
-
-#endif /* tm_isdst */
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-#define __NEED_timer_t
-#define __NEED_clockid_t
-
-#include <bits/alltypes.h>
-
-struct itimerspec {
-	struct timespec it_interval;
-	struct timespec it_value;
-};
-
-#define CLOCK_REALTIME           0
-#define CLOCK_MONOTONIC          1
-#define CLOCK_PROCESS_CPUTIME_ID 2
-#define CLOCK_THREAD_CPUTIME_ID  3
-#define CLOCK_MONOTONIC_RAW      4
-#define CLOCK_REALTIME_COARSE    5
-#define CLOCK_MONOTONIC_COARSE   6
-#define CLOCK_BOOTTIME           7
-#define CLOCK_REALTIME_ALARM     8
-#define CLOCK_BOOTTIME_ALARM     9
-#define CLOCK_SGI_CYCLE         10
-#define CLOCK_TAI               11
-
-#define TIMER_ABSTIME 1
-
-struct tm *gmtime_r (const time_t *__restrict, struct tm *__restrict);
-struct tm *localtime_r (const time_t *__restrict, struct tm *__restrict);
-
-int nanosleep (const struct timespec *, struct timespec *);
-int clock_getres (clockid_t, struct timespec *);
-int clock_gettime (clockid_t, struct timespec *);
-int clock_settime (clockid_t, const struct timespec *);
-int clock_nanosleep (clockid_t, int, const struct timespec *, struct timespec *);
-
-struct sigevent;
-int timer_create (clockid_t, struct sigevent *__restrict, timer_t *__restrict);
-int timer_delete (timer_t);
-int timer_settime (timer_t, int, const struct itimerspec *__restrict, struct itimerspec *__restrict);
-int timer_gettime (timer_t, struct itimerspec *);
-int timer_getoverrun (timer_t);
-
-#ifdef __cplusplus
-}
-#endif
-
-#else
-
 #ifdef __cplusplus
 extern "C" {
 #endif
@@ -234,5 +162,5 @@ __REDIR(timegm, __timegm_time64);
 }
 #endif
 
-#endif /* __ICCARM__ */
+
 #endif
diff --git a/third_party/musl/include/uchar.h b/third_party/musl/include/uchar.h
index 8c39db3f4..7e5c4d406 100755
--- a/third_party/musl/include/uchar.h
+++ b/third_party/musl/include/uchar.h
@@ -1,10 +1,6 @@
 #ifndef _UCHAR_H
 #define _UCHAR_H
 
-#ifdef __ICCARM__ /* for iar */
-#include_next <uchar.h>
-#else
-
 #ifdef __cplusplus
 extern "C" {
 #endif
@@ -30,5 +26,4 @@ size_t mbrtoc32(char32_t *__restrict, const char *__restrict, size_t, mbstate_t
 }
 #endif
 
-#endif /* __ICCARM__ */
 #endif
diff --git a/third_party/musl/include/unistd.h b/third_party/musl/include/unistd.h
index b4ff3db86..7bcbff943 100644
--- a/third_party/musl/include/unistd.h
+++ b/third_party/musl/include/unistd.h
@@ -73,30 +73,6 @@ int ftruncate(int, off_t);
 int access(const char *, int);
 int faccessat(int, const char *, int, int);
 
-
-/* Format options */
-#define FMT_FAT      0x01
-#define FMT_FAT32    0x02
-#define FMT_ANY      0x07
-#define FMT_ERASE    0x08
-
-/** 
-  * @brief format FAT device (SD card, U disk, and MMC card), this function is OHOS-specific
-  * @param dev device name.
-  * @param sectors sectors per cluster, can be 0 OR power of 2. The sector size for standard FAT volumes is 512 bytes.
-  *    -- sector number is 0 OR >128: automatically choose the appropriate cluster size.
-  *    -- sector number is 1 ~ 128: cluster size = sectors per cluster * 512B.
-  * @param option file system type.
-  *    -- FMT_FAT
-  *    -- FMT_FAT32
-  *    -- FMT_ANY
-  *    -- FMT_ERASE (USB not supported)
-  * @return format result
-  * @retval -1 format error
-  * @retval 0 format successful
-  */
-int format(const char *dev, int sectors, int option);
-
 int chdir(const char *);
 int fchdir(int);
 char *getcwd(char *, size_t);
diff --git a/third_party/musl/include/wchar.h b/third_party/musl/include/wchar.h
index 6369f116f..88eb55b18 100755
--- a/third_party/musl/include/wchar.h
+++ b/third_party/musl/include/wchar.h
@@ -1,10 +1,6 @@
 #ifndef _WCHAR_H
 #define _WCHAR_H
 
-#ifdef __ICCARM__ /* for iar */
-#include_next <wchar.h>
-#else
-
 #ifdef __cplusplus
 extern "C" {
 #endif
@@ -206,5 +202,4 @@ wctype_t  wctype(const char *);
 }
 #endif
 
-#endif /* __ICCARM__ */
 #endif
diff --git a/third_party/musl/include/wctype.h b/third_party/musl/include/wctype.h
index 9a3faea47..bc2420d3f 100755
--- a/third_party/musl/include/wctype.h
+++ b/third_party/musl/include/wctype.h
@@ -1,10 +1,6 @@
 #ifndef _WCTYPE_H
 #define _WCTYPE_H
 
-#ifdef __ICCARM__ /* for iar */
-#include_next <wctype.h>
-#else
-
 #ifdef __cplusplus
 extern "C" {
 #endif
@@ -80,5 +76,4 @@ wctype_t  wctype_l(const char *, locale_t);
 }
 #endif
 
-#endif /* __ICCARM__ */
 #endif
diff --git a/third_party/musl/kernel/include/sys/poll.h b/third_party/musl/kernel/include/sys/poll.h
deleted file mode 120000
index 953ec76a9..000000000
--- a/third_party/musl/kernel/include/sys/poll.h
+++ /dev/null
@@ -1 +0,0 @@
-../poll.h
\ No newline at end of file
diff --git a/third_party/musl/kernel/src/env/getenv.c b/third_party/musl/kernel/src/env/getenv.c
deleted file mode 100644
index 0d6ba4d99..000000000
--- a/third_party/musl/kernel/src/env/getenv.c
+++ /dev/null
@@ -1,25 +0,0 @@
-#include "stdlib.h"
-#include "string.h"
-#include "los_exc.h"
-
-/*
- * getenv --
- *  Returns ptr to value associated with name, if any, else NULL.
- */
-char *
-getenv(const char *name)
-{
-#ifdef LOSCFG_LLTREPORT
-    if (strncmp(name, "GCOV_PREFIX", sizeof("GCOV_PREFIX")) == 0) {
-#ifdef LOSCFG_LLTSER
-        extern const char *gcov_dir;
-        return (char *)gcov_dir;
-#else
-        return "/bin/vs/sd";
-#endif
-    }
-    if (strncmp(name, "GCOV_PREFIX_STRIP", sizeof("GCOV_PREFIX_STRIP")) == 0)
-        return "6";
-#endif
-    return (NULL);
-}
diff --git a/third_party/musl/kernel/src/errno/errno.c b/third_party/musl/kernel/src/errno/errno.c
deleted file mode 100644
index 3c17e1d35..000000000
--- a/third_party/musl/kernel/src/errno/errno.c
+++ /dev/null
@@ -1,58 +0,0 @@
-#include "errno.h"
-#include "los_errno.h"
-#include "los_task_pri.h"
-
-/* the specific errno get or set in interrupt service routine */
-static int errno_isr;
-
-void set_errno(int err_code) {
-  LosTaskCB *runTask = NULL;
-
-  /* errno can not be set to 0 as posix standard */
-  if (err_code == 0)
-    return;
-
-  if (OS_INT_INACTIVE) {
-    runTask = OsCurrTaskGet();
-    runTask->errorNo = err_code;
-  }
-  else {
-    errno_isr = err_code;
-  }
-}
-
-int get_errno(void) {
-  LosTaskCB *runTask = NULL;
-
-  if (OS_INT_INACTIVE) {
-    runTask = OsCurrTaskGet();
-    return runTask->errorNo;
-  }
-  else {
-    return errno_isr;
-  }
-}
-
-int *__errno_location(void) {
-  LosTaskCB *runTask = NULL;
-
-  if (OS_INT_INACTIVE) {
-    runTask = OsCurrTaskGet();
-    return &runTask->errorNo;
-  }
-  else {
-    return &errno_isr;
-  }
-}
-
-volatile int *__errno(void) {
-  LosTaskCB *runTask = NULL;
-
-  if (OS_INT_INACTIVE) {
-    runTask = OsCurrTaskGet();
-    return (volatile int *)(&runTask->errorNo);
-  }
-  else {
-    return (volatile int *)(&errno_isr);
-  }
-}
diff --git a/third_party/musl/kernel/src/exit/exit.c b/third_party/musl/kernel/src/exit/exit.c
deleted file mode 100644
index 82249685e..000000000
--- a/third_party/musl/kernel/src/exit/exit.c
+++ /dev/null
@@ -1,13 +0,0 @@
-#include <errno.h>
-#include "los_printf.h"
-
-void _exit(int status) {
-  PRINT_ERR("%s NOT SUPPORT\n", __FUNCTION__);
-  errno = ENOSYS;
-}
-
-void exit(int status) {
-  PRINT_ERR("%s NOT SUPPORT\n", __FUNCTION__);
-  errno = ENOSYS;
-  while (1);
-}
diff --git a/third_party/musl/kernel/src/internal/Makefile b/third_party/musl/kernel/src/internal/Makefile
deleted file mode 100755
index 1a76920bf..000000000
--- a/third_party/musl/kernel/src/internal/Makefile
+++ /dev/null
@@ -1,9 +0,0 @@
-include $(LITEOSTOPDIR)/config.mk
-
-all : $(LOCAL_COBJS_INTERNAL)
-
-$(LOCAL_COBJS_INTERNAL): $(OBJOUT)/musl/src/internal/%.o: %.c
-	$(HIDE)if [ ! -d $(dir $@) ]; then mkdir -p $(dir $@); fi
-	$(HIDE)$(CC) $(LITEOS_CFLAGS) $(LOCAL_FLAGS) -c $< -o $@
-
-.PHONY: all
\ No newline at end of file
diff --git a/third_party/musl/kernel/src/math/Makefile b/third_party/musl/kernel/src/math/Makefile
deleted file mode 100755
index 0da83b0c7..000000000
--- a/third_party/musl/kernel/src/math/Makefile
+++ /dev/null
@@ -1,9 +0,0 @@
-include $(LITEOSTOPDIR)/config.mk
-
-all : $(LOCAL_COBJS_MATH)
-
-$(LOCAL_COBJS_MATH): $(OBJOUT)/musl/src/math/%.o: %.c
-	$(HIDE)if [ ! -d $(dir $@) ]; then mkdir -p $(dir $@); fi
-	$(HIDE)$(CC) $(LITEOS_CFLAGS) $(LOCAL_FLAGS) -c $< -o $@
-
-.PHONY: all
\ No newline at end of file
diff --git a/third_party/musl/kernel/src/prng/rand.c b/third_party/musl/kernel/src/prng/rand.c
deleted file mode 100644
index e04cb0b9e..000000000
--- a/third_party/musl/kernel/src/prng/rand.c
+++ /dev/null
@@ -1,14 +0,0 @@
-#include <stdlib.h>
-#include <stdint.h>
-
-static uint64_t seed;
-
-void srand(unsigned s)
-{
-    return srandom(seed);
-}
-
-int rand(void)
-{
-   return random();
-}
diff --git a/third_party/musl/kernel/src/sched/sched_yield.c b/third_party/musl/kernel/src/sched/sched_yield.c
deleted file mode 100644
index 545bf0ef7..000000000
--- a/third_party/musl/kernel/src/sched/sched_yield.c
+++ /dev/null
@@ -1,8 +0,0 @@
-#include <sched.h>
-#include "los_process.h"
-
-int sched_yield()
-{
-    (void)LOS_TaskYield();
-    return 0;
-}
diff --git a/third_party/musl/kernel/src/stdio/Makefile b/third_party/musl/kernel/src/stdio/Makefile
deleted file mode 100755
index f31f4d2db..000000000
--- a/third_party/musl/kernel/src/stdio/Makefile
+++ /dev/null
@@ -1,9 +0,0 @@
-include $(LITEOSTOPDIR)/config.mk
-
-all : $(LOCAL_COBJS_STDIO)
-
-$(LOCAL_COBJS_STDIO): $(OBJOUT)/musl/src/stdio/%.o: %.c
-	$(HIDE)if [ ! -d $(dir $@) ]; then mkdir -p $(dir $@); fi
-	$(HIDE)$(CC) $(LITEOS_CFLAGS) $(LOCAL_FLAGS) -c $< -o $@
-
-.PHONY: all
\ No newline at end of file
diff --git a/third_party/musl/kernel/src/string/Makefile b/third_party/musl/kernel/src/string/Makefile
deleted file mode 100755
index 5e36c9a4f..000000000
--- a/third_party/musl/kernel/src/string/Makefile
+++ /dev/null
@@ -1,9 +0,0 @@
-include $(LITEOSTOPDIR)/config.mk
-
-all : $(LOCAL_COBJS_STRING)
-
-$(LOCAL_COBJS_STRING): $(OBJOUT)/musl/src/string/%.o: %.c
-	$(HIDE)if [ ! -d $(dir $@) ]; then mkdir -p $(dir $@); fi
-	$(HIDE)$(CC) $(LITEOS_CFLAGS) $(LOCAL_FLAGS) -c $< -o $@
-
-.PHONY: all
\ No newline at end of file
diff --git a/third_party/musl/kernel/src/time/Makefile b/third_party/musl/kernel/src/time/Makefile
deleted file mode 100755
index df4116348..000000000
--- a/third_party/musl/kernel/src/time/Makefile
+++ /dev/null
@@ -1,9 +0,0 @@
-include $(LITEOSTOPDIR)/config.mk
-
-all : $(LOCAL_COBJS_TIME)
-
-$(LOCAL_COBJS_TIME): $(OBJOUT)/musl/src/time/%.o: %.c
-	$(HIDE)if [ ! -d $(dir $@) ]; then mkdir -p $(dir $@); fi
-	$(HIDE)$(CC) $(LITEOS_CFLAGS) $(LOCAL_FLAGS) -c $< -o $@
-
-.PHONY: all
\ No newline at end of file
diff --git a/third_party/musl/kernel/src/time/time.c b/third_party/musl/kernel/src/time/time.c
deleted file mode 100644
index 50840a13c..000000000
--- a/third_party/musl/kernel/src/time/time.c
+++ /dev/null
@@ -1,20 +0,0 @@
-#include "los_typedef.h"
-#include <time.h>
-#include <sys/time.h>
-
-time_t time(time_t *t)
-{
-    struct timeval tp;
-    int ret;
-
-    /* Get the current time from the system */
-    ret = gettimeofday(&tp, (struct timezone *)NULL);
-    if (ret == LOS_OK) {
-        /* Return the seconds since the epoch */
-        if (t) {
-            *t = tp.tv_sec;
-        }
-        return tp.tv_sec;
-    }
-    return (time_t)OS_ERROR;
-}
diff --git a/third_party/musl/kernel_m/arch/arm/bits/alltypes.h.in b/third_party/musl/kernel_m/arch/arm/bits/alltypes.h.in
deleted file mode 100755
index 27f847be9..000000000
--- a/third_party/musl/kernel_m/arch/arm/bits/alltypes.h.in
+++ /dev/null
@@ -1,46 +0,0 @@
-/* The time64 has not been used yet in liteos_m */
-#define _REDIR_TIME64 0
-#define _Addr int
-#define _Int64 long long
-#define _Reg int
-
-#if __ARMEB__
-#define __BYTE_ORDER 4321
-#else
-#define __BYTE_ORDER 1234
-#endif
-
-#define __LONG_MAX 0x7fffffffL
-
-#ifdef __ICCARM__
-#ifndef __cplusplus
-#if defined(__NEED_wchar_t) && !defined(__DEFINED_wchar_t)
-#include <stddef.h>
-#define __DEFINED_wchar_t
-#endif
-#endif
-
-#if defined(__NEED_float_t) && !defined(__DEFINED_float_t)
-#include <math.h>
-#define __DEFINED_float_t
-#endif
-
-#if defined(__NEED_double_t) && !defined(__DEFINED_double_t)
-#include <math.h>
-#define __DEFINED_double_t
-#endif
-
-#if defined(__NEED_max_align_t) && !defined(__DEFINED_max_align_t)
-#include <stddef.h>
-#define __DEFINED_max_align_t
-#endif
-#endif /* __ICCARM__ */
-
-#ifndef __cplusplus
-TYPEDEF unsigned wchar_t;
-#endif
-
-TYPEDEF float float_t;
-TYPEDEF double double_t;
-
-TYPEDEF struct { long long __ll; long double __ld; } max_align_t;
diff --git a/third_party/musl/ldso/dynlink.c b/third_party/musl/ldso/dynlink.c
index 40e05220a..afec985a3 100755
--- a/third_party/musl/ldso/dynlink.c
+++ b/third_party/musl/ldso/dynlink.c
@@ -68,6 +68,8 @@ struct dso {
 	size_t *lazy, lazy_cnt;
 	unsigned char *map;
 	size_t map_len;
+	dev_t dev;
+	ino_t ino;
 	char relocated;
 	char constructed;
 	char kernel_mapped;
@@ -754,20 +756,6 @@ static void *map_library(int fd, struct dso *dso)
 		prot = (((ph->p_flags&PF_R) ? PROT_READ : 0) |
 			((ph->p_flags&PF_W) ? PROT_WRITE: 0) |
 			((ph->p_flags&PF_X) ? PROT_EXEC : 0));
-		if ((ph->p_flags & PF_R) && (ph->p_flags & PF_X) && (!(ph->p_flags & PF_W))) {
-			Phdr *next_ph = ph;
-			for (int j = i - 1; j > 0; j--) {
-				next_ph = (void *)((char *)next_ph+eh->e_phentsize);
-				if (next_ph->p_type != PT_LOAD) {
-					continue;
-				}
-				size_t p_vaddr = (next_ph->p_vaddr & -(PAGE_SIZE));
-				if (p_vaddr > this_max) {
-					mprotect(base + this_max, p_vaddr - this_max , PROT_READ);
-				}
-				break;
-			}
-		}
 		/* Reuse the existing mapping for the lowest-address LOAD */
 		if ((ph->p_vaddr & -PAGE_SIZE) != addr_min || DL_NOMMU_SUPPORT)
 			if (mmap_fixed(base+this_min, this_max-this_min, prot, MAP_PRIVATE|MAP_FIXED, fd, off_start) == MAP_FAILED)
@@ -810,7 +798,7 @@ static int path_open(const char *name, const char *s, char *buf, size_t buf_size
 		l = strcspn(s, ":\n");
 		if (l-1 >= INT_MAX) return -1;
 		if (snprintf(buf, buf_size, "%.*s/%s", (int)l, s, name) < buf_size) {
-			if ((fd = open(buf, O_RDONLY))>=0) return fd; // open(buf, O_RDONLY|O_CLOEXEC)
+			if ((fd = open(buf, O_RDONLY|O_CLOEXEC))>=0) return fd;
 			switch (errno) {
 			case ENOENT:
 			case ENOTDIR:
@@ -986,7 +974,6 @@ static void makefuncdescs(struct dso *p)
 static struct dso *load_library(const char *name, struct dso *needed_by)
 {
 	char buf[2*NAME_MAX+2];
-	char fullpath[2*NAME_MAX+2];
 	const char *pathname;
 	unsigned char *map;
 	struct dso *p, temp_dso = {0};
@@ -1038,7 +1025,7 @@ static struct dso *load_library(const char *name, struct dso *needed_by)
 	}
 	if (strchr(name, '/')) {
 		pathname = name;
-		fd = open(name, O_RDONLY); // open(name, O_RDONLY|O_CLOEXEC);
+		fd = open(name, O_RDONLY|O_CLOEXEC);
 	} else {
 		/* Search for the name to see if it's already loaded */
 		for (p=head->next; p; p=p->next) {
@@ -1087,23 +1074,18 @@ static struct dso *load_library(const char *name, struct dso *needed_by)
 					sys_path = "";
 				}
 			}
-			if (!sys_path || sys_path[0] == 0) sys_path = "/usr/lib:/lib:/usr/local/lib";
+			if (!sys_path) sys_path = "/lib:/usr/local/lib:/usr/lib";
 			fd = path_open(name, sys_path, buf, sizeof buf);
 		}
 		pathname = buf;
 	}
 	if (fd < 0) return 0;
-
-	if (pathname[0] != '/') {
-		if (!realpath(pathname, fullpath)) {
-			close(fd);
-			return 0;
-		}
-		pathname = fullpath;
+	if (fstat(fd, &st) < 0) {
+		close(fd);
+		return 0;
 	}
-
 	for (p=head->next; p; p=p->next) {
-		if (!strcmp(p->name, pathname)) {
+		if (p->dev == st.st_dev && p->ino == st.st_ino) {
 			/* If this library was previously loaded with a
 			 * pathname but a search found the same inode,
 			 * setup its shortname so it can be found by name. */
@@ -1114,6 +1096,7 @@ static struct dso *load_library(const char *name, struct dso *needed_by)
 		}
 	}
 	map = noload ? 0 : map_library(fd, &temp_dso);
+	close(fd);
 	if (!map) return 0;
 
 	/* Avoid the danger of getting two versions of libc mapped into the
@@ -1150,6 +1133,8 @@ static struct dso *load_library(const char *name, struct dso *needed_by)
 		return 0;
 	}
 	memcpy(p, &temp_dso, sizeof temp_dso);
+	p->dev = st.st_dev;
+	p->ino = st.st_ino;
 	p->needed_by = needed_by;
 	p->name = p->buf;
 	p->runtime_loaded = runtime;
@@ -1757,18 +1742,11 @@ void __dls3(size_t *sp, size_t *auxv)
 		if (DL_FDPIC) app.loadmap = app_loadmap;
 		if (app.tls.size) app.tls.image = laddr(&app, tls_image);
 		if (interp_off) ldso.name = laddr(&app, interp_off);
-#if 0
 		if ((aux[0] & (1UL<<AT_EXECFN))
 		    && strncmp((char *)aux[AT_EXECFN], "/proc/", 6))
 			app.name = (char *)aux[AT_EXECFN];
 		else
 			app.name = argv[0];
-#else
-		if (argv[0])
-			app.name = argv[0];
-		else
-			app.name = "none";
-#endif
 		kernel_mapped_dso(&app);
 	} else {
 		int fd;
@@ -1819,6 +1797,7 @@ void __dls3(size_t *sp, size_t *auxv)
 			dprintf(2, "%s: %s: Not a valid dynamic program\n", ldname, argv[0]);
 			_exit(1);
 		}
+		close(fd);
 		ldso.name = ldname;
 		app.name = argv[0];
 		aux[AT_ENTRY] = (size_t)laddr(&app, ehdr->e_entry);
@@ -1889,7 +1868,7 @@ void __dls3(size_t *sp, size_t *auxv)
 				vdso.base = (void *)(vdso_base - phdr->p_vaddr + phdr->p_offset);
 		}
 		vdso.name = "";
-		vdso.shortname = "OHOS-vdso.so";
+		vdso.shortname = "linux-gate.so.1";
 		vdso.relocated = 1;
 		vdso.deps = (struct dso **)no_deps;
 		decode_dyn(&vdso);
@@ -2012,16 +1991,6 @@ void *dlopen(const char *file, int mode)
 	jmp_buf jb;
 	struct dso **volatile ctor_queue = 0;
 
-	if (mode & ~(RTLD_LAZY | RTLD_NOW | RTLD_NOLOAD | RTLD_GLOBAL | RTLD_LOCAL | RTLD_NODELETE)) {
-		error("invalid mode parameter for dlopen().");
-		return NULL;
-	}
-
-	if ((mode & (RTLD_LAZY | RTLD_NOW)) == 0) {
-		error("invalid mode, one of RTLD_LAZY and RTLD_NOW must be set.");
-		return NULL;
-	}
-
 	if (!file) return head;
 
 	pthread_setcancelstate(PTHREAD_CANCEL_DISABLE, &cs);
diff --git a/third_party/musl/musl_config.gni b/third_party/musl/musl_config.gni
new file mode 100755
index 000000000..eeb1881bf
--- /dev/null
+++ b/third_party/musl/musl_config.gni
@@ -0,0 +1,46 @@
+# Copyright 2014 The Chromium Authors. All rights reserved.
+# Use of this source code is governed by a BSD-style license that can be
+# found in the LICENSE file.
+import("//build/config/sanitizers/sanitizers.gni")
+
+declare_args() {
+  if (target_cpu == "arm") {
+    musl_arch = "arm"
+  } else if (target_cpu == "arm64") {
+    musl_arch = "aarch64"
+  }
+  # musl_root = "$root_out_dir/obj/third_party/musl"
+  # musl_sub_arch = ""
+  # musl_syslib_dir = "/system/bin"
+  # musl_linker_extension = "so.1"
+}
+
+declare_args() {
+  if ((defined(target_os) && target_os == "ohos") ||
+      (defined(ohos_kernel_type) && ohos_kernel_type == "linux")) {
+    musl_target_os = "linux"
+    musl_target_triple = "${musl_arch}-linux-ohosmusl"
+  } else if (defined(ohos_kernel_type) && ohos_kernel_type == "liteos_a") {
+    musl_target_os = "liteos_a"
+    musl_target_triple = "arm-liteos"
+  }
+}
+
+declare_args() {
+  runtime_lib_path = "//prebuilts/clang/ohos/linux-x86_64/llvm/lib/clang/10.0.1/lib"
+  user_custom_libc = true
+  musl_ported_dir = "intermidiates/${musl_target_os}/musl_src_ported" 
+  musl_inc_out_dir = "usr/include/${musl_target_triple}"
+
+  # if (is_asan) {
+  #   musl_linker_asan_name =
+  #       musl_syslib_dir + "/ld-musl-${musl_arch}${musl_sub_arch}-asan"
+  #   musl_ldso_path =
+  #       musl_syslib_dir + "/ld-musl-${musl_arch}${musl_sub_arch}-asan." +
+  #       musl_linker_extension
+  # } else {
+  #   musl_ldso_path =
+  #       musl_syslib_dir + "/ld-musl-${musl_arch}${musl_sub_arch}." +
+  #       musl_linker_extension
+  # }
+}
diff --git a/third_party/musl/musl_src.gni b/third_party/musl/musl_src.gni
new file mode 100755
index 000000000..35fc989a2
--- /dev/null
+++ b/third_party/musl/musl_src.gni
@@ -0,0 +1,1823 @@
+import("musl_config.gni")
+
+if (musl_arch == "arm") {
+  musl_src_arch_file = [
+    "src/exit/arm/__aeabi_atexit.c",
+    "src/fenv/arm/fenv-hf.S",
+    "src/fenv/arm/fenv.c",
+    "src/ldso/arm/dlsym.s",
+    "src/ldso/arm/dlsym_time64.S",
+    "src/ldso/arm/find_exidx.c",
+    "src/ldso/arm/tlsdesc.S",
+    "src/math/arm/fabs.c",
+    "src/math/arm/fabsf.c",
+    "src/math/arm/fma.c",
+    "src/math/arm/fmaf.c",
+    "src/math/arm/sqrt.c",
+    "src/math/arm/sqrtf.c",
+    "src/process/arm/vfork.s",
+    "src/setjmp/arm/longjmp.S",
+    "src/setjmp/arm/setjmp.S",
+    "src/signal/arm/restore.s",
+    "src/signal/arm/sigsetjmp.s",
+    "src/string/arm/__aeabi_memcpy.s",
+    "src/string/arm/__aeabi_memset.s",
+    "src/string/arm/memcpy.c",
+    "src/string/arm/memcpy_le.S",
+    "src/thread/arm/__aeabi_read_tp.s",
+    "src/thread/arm/__set_thread_area.c",
+    "src/thread/arm/__unmapself.s",
+    "src/thread/arm/atomics.s",
+    "src/thread/arm/clone.s",
+    "src/thread/arm/syscall_cp.s",
+    "compat/time32/adjtime32.c",
+    "compat/time32/adjtimex_time32.c",
+    "compat/time32/aio_suspend_time32.c",
+    "compat/time32/clock_adjtime32.c",
+    "compat/time32/clock_getres_time32.c",
+    "compat/time32/clock_gettime32.c",
+    "compat/time32/clock_nanosleep_time32.c",
+    "compat/time32/clock_settime32.c",
+    "compat/time32/cnd_timedwait_time32.c",
+    "compat/time32/ctime32.c",
+    "compat/time32/ctime32_r.c",
+    "compat/time32/difftime32.c",
+    "compat/time32/fstatat_time32.c",
+    "compat/time32/fstat_time32.c",
+    "compat/time32/ftime32.c",
+    "compat/time32/futimens_time32.c",
+    "compat/time32/futimesat_time32.c",
+    "compat/time32/futimes_time32.c",
+    "compat/time32/getitimer_time32.c",
+    "compat/time32/getrusage_time32.c",
+    "compat/time32/gettimeofday_time32.c",
+    "compat/time32/gmtime32.c",
+    "compat/time32/gmtime32_r.c",
+    "compat/time32/localtime32.c",
+    "compat/time32/localtime32_r.c",
+    "compat/time32/lstat_time32.c",
+    "compat/time32/lutimes_time32.c",
+    "compat/time32/mktime32.c",
+    "compat/time32/mq_timedreceive_time32.c",
+    "compat/time32/mq_timedsend_time32.c",
+    "compat/time32/mtx_timedlock_time32.c",
+    "compat/time32/nanosleep_time32.c",
+    "compat/time32/ppoll_time32.c",
+    "compat/time32/pselect_time32.c",
+    "compat/time32/pthread_cond_timedwait_time32.c",
+    "compat/time32/pthread_mutex_timedlock_time32.c",
+    "compat/time32/pthread_rwlock_timedrdlock_time32.c",
+    "compat/time32/pthread_rwlock_timedwrlock_time32.c",
+    "compat/time32/pthread_timedjoin_np_time32.c",
+    "compat/time32/recvmmsg_time32.c",
+    "compat/time32/sched_rr_get_interval_time32.c",
+    "compat/time32/select_time32.c",
+    "compat/time32/semtimedop_time32.c",
+    "compat/time32/sem_timedwait_time32.c",
+    "compat/time32/setitimer_time32.c",
+    "compat/time32/settimeofday_time32.c",
+    "compat/time32/sigtimedwait_time32.c",
+    "compat/time32/stat_time32.c",
+    "compat/time32/stime32.c",
+    "compat/time32/thrd_sleep_time32.c",
+    "compat/time32/time32.c",
+    "compat/time32/time32gm.c",
+    "compat/time32/time32.h",
+    "compat/time32/timerfd_gettime32.c",
+    "compat/time32/timerfd_settime32.c",
+    "compat/time32/timer_gettime32.c",
+    "compat/time32/timer_settime32.c",
+    "compat/time32/timespec_get_time32.c",
+    "compat/time32/utimensat_time32.c",
+    "compat/time32/utimes_time32.c",
+    "compat/time32/utime_time32.c",
+    "compat/time32/wait3_time32.c",
+    "compat/time32/wait4_time32.c",
+    "compat/time32/__xstat.c",
+  ]
+} else if (musl_arch == "aarch64") {
+  musl_src_arch_file = [
+    "src/fenv/aarch64/fenv.s",
+    "src/ldso/aarch64/dlsym.s",
+    "src/ldso/aarch64/tlsdesc.s",
+    "src/math/aarch64/ceil.c",
+    "src/math/aarch64/ceilf.c",
+    "src/math/aarch64/fabs.c",
+    "src/math/aarch64/fabsf.c",
+    "src/math/aarch64/floor.c",
+    "src/math/aarch64/floorf.c",
+    "src/math/aarch64/fma.c",
+    "src/math/aarch64/fmaf.c",
+    "src/math/aarch64/fmax.c",
+    "src/math/aarch64/fmaxf.c",
+    "src/math/aarch64/fmin.c",
+    "src/math/aarch64/fminf.c",
+    "src/math/aarch64/llrint.c",
+    "src/math/aarch64/llrintf.c",
+    "src/math/aarch64/llround.c",
+    "src/math/aarch64/llroundf.c",
+    "src/math/aarch64/lrint.c",
+    "src/math/aarch64/lrintf.c",
+    "src/math/aarch64/lround.c",
+    "src/math/aarch64/lroundf.c",
+    "src/math/aarch64/nearbyint.c",
+    "src/math/aarch64/nearbyintf.c",
+    "src/math/aarch64/rint.c",
+    "src/math/aarch64/rintf.c",
+    "src/math/aarch64/round.c",
+    "src/math/aarch64/roundf.c",
+    "src/math/aarch64/sqrt.c",
+    "src/math/aarch64/sqrtf.c",
+    "src/math/aarch64/trunc.c",
+    "src/math/aarch64/truncf.c",
+    "src/setjmp/aarch64/longjmp.s",
+    "src/setjmp/aarch64/setjmp.s",
+    "src/signal/aarch64/restore.s",
+    "src/signal/aarch64/sigsetjmp.s",
+    "src/thread/aarch64/__set_thread_area.s",
+    "src/thread/aarch64/__unmapself.s",
+    "src/thread/aarch64/clone.s",
+    "src/thread/aarch64/syscall_cp.s",
+  ]
+}
+
+musl_src_file = [
+  "src/aio/aio.c",
+  "src/aio/aio_suspend.c",
+  "src/aio/lio_listio.c",
+  "src/complex/__cexp.c",
+  "src/complex/__cexpf.c",
+  "src/complex/cabs.c",
+  "src/complex/cabsf.c",
+  "src/complex/cabsl.c",
+  "src/complex/cacos.c",
+  "src/complex/cacosf.c",
+  "src/complex/cacosh.c",
+  "src/complex/cacoshf.c",
+  "src/complex/cacoshl.c",
+  "src/complex/cacosl.c",
+  "src/complex/carg.c",
+  "src/complex/cargf.c",
+  "src/complex/cargl.c",
+  "src/complex/casin.c",
+  "src/complex/casinf.c",
+  "src/complex/casinh.c",
+  "src/complex/casinhf.c",
+  "src/complex/casinhl.c",
+  "src/complex/casinl.c",
+  "src/complex/catan.c",
+  "src/complex/catanf.c",
+  "src/complex/catanh.c",
+  "src/complex/catanhf.c",
+  "src/complex/catanhl.c",
+  "src/complex/catanl.c",
+  "src/complex/ccos.c",
+  "src/complex/ccosf.c",
+  "src/complex/ccosh.c",
+  "src/complex/ccoshf.c",
+  "src/complex/ccoshl.c",
+  "src/complex/ccosl.c",
+  "src/complex/cexp.c",
+  "src/complex/cexpf.c",
+  "src/complex/cexpl.c",
+  "src/complex/cimag.c",
+  "src/complex/cimagf.c",
+  "src/complex/cimagl.c",
+  "src/complex/clog.c",
+  "src/complex/clogf.c",
+  "src/complex/clogl.c",
+  "src/complex/conj.c",
+  "src/complex/conjf.c",
+  "src/complex/conjl.c",
+  "src/complex/cpow.c",
+  "src/complex/cpowf.c",
+  "src/complex/cpowl.c",
+  "src/complex/cproj.c",
+  "src/complex/cprojf.c",
+  "src/complex/cprojl.c",
+  "src/complex/creal.c",
+  "src/complex/crealf.c",
+  "src/complex/creall.c",
+  "src/complex/csin.c",
+  "src/complex/csinf.c",
+  "src/complex/csinh.c",
+  "src/complex/csinhf.c",
+  "src/complex/csinhl.c",
+  "src/complex/csinl.c",
+  "src/complex/csqrt.c",
+  "src/complex/csqrtf.c",
+  "src/complex/csqrtl.c",
+  "src/complex/ctan.c",
+  "src/complex/ctanf.c",
+  "src/complex/ctanh.c",
+  "src/complex/ctanhf.c",
+  "src/complex/ctanhl.c",
+  "src/complex/ctanl.c",
+  "src/conf/confstr.c",
+  "src/conf/fpathconf.c",
+  "src/conf/legacy.c",
+  "src/conf/pathconf.c",
+  "src/conf/sysconf.c",
+  "src/crypt/crypt.c",
+  "src/crypt/crypt_blowfish.c",
+  "src/crypt/crypt_des.c",
+  "src/crypt/crypt_md5.c",
+  "src/crypt/crypt_r.c",
+  "src/crypt/crypt_sha256.c",
+  "src/crypt/crypt_sha512.c",
+  "src/crypt/encrypt.c",
+  "src/ctype/__ctype_b_loc.c",
+  "src/ctype/__ctype_get_mb_cur_max.c",
+  "src/ctype/__ctype_tolower_loc.c",
+  "src/ctype/__ctype_toupper_loc.c",
+  "src/ctype/isalnum.c",
+  "src/ctype/isalpha.c",
+  "src/ctype/isascii.c",
+  "src/ctype/isblank.c",
+  "src/ctype/iscntrl.c",
+  "src/ctype/isdigit.c",
+  "src/ctype/isgraph.c",
+  "src/ctype/islower.c",
+  "src/ctype/isprint.c",
+  "src/ctype/ispunct.c",
+  "src/ctype/isspace.c",
+  "src/ctype/isupper.c",
+  "src/ctype/iswalnum.c",
+  "src/ctype/iswalpha.c",
+  "src/ctype/iswblank.c",
+  "src/ctype/iswcntrl.c",
+  "src/ctype/iswctype.c",
+  "src/ctype/iswdigit.c",
+  "src/ctype/iswgraph.c",
+  "src/ctype/iswlower.c",
+  "src/ctype/iswprint.c",
+  "src/ctype/iswpunct.c",
+  "src/ctype/iswspace.c",
+  "src/ctype/iswupper.c",
+  "src/ctype/iswxdigit.c",
+  "src/ctype/isxdigit.c",
+  "src/ctype/toascii.c",
+  "src/ctype/tolower.c",
+  "src/ctype/toupper.c",
+  "src/ctype/towctrans.c",
+  "src/ctype/wcswidth.c",
+  "src/ctype/wctrans.c",
+  "src/ctype/wcwidth.c",
+  "src/dirent/alphasort.c",
+  "src/dirent/closedir.c",
+  "src/dirent/dirfd.c",
+  "src/dirent/fdopendir.c",
+  "src/dirent/opendir.c",
+  "src/dirent/readdir.c",
+  "src/dirent/readdir_r.c",
+  "src/dirent/rewinddir.c",
+  "src/dirent/scandir.c",
+  "src/dirent/seekdir.c",
+  "src/dirent/telldir.c",
+  "src/dirent/versionsort.c",
+  "src/env/__environ.c",
+  "src/env/__init_tls.c",
+  "src/env/__libc_start_main.c",
+  "src/env/__reset_tls.c",
+  "src/env/__stack_chk_fail.c",
+  "src/env/clearenv.c",
+  "src/env/getenv.c",
+  "src/env/putenv.c",
+  "src/env/secure_getenv.c",
+  "src/env/setenv.c",
+  "src/env/unsetenv.c",
+  "src/errno/__errno_location.c",
+  "src/errno/strerror.c",
+  "src/exit/_Exit.c",
+  "src/exit/abort.c",
+  "src/exit/assert.c",
+  "src/exit/at_quick_exit.c",
+  "src/exit/atexit.c",
+  "src/exit/exit.c",
+  "src/exit/quick_exit.c",
+  "src/fcntl/creat.c",
+  "src/fcntl/fcntl.c",
+  "src/fcntl/open.c",
+  "src/fcntl/openat.c",
+  "src/fcntl/posix_fadvise.c",
+  "src/fcntl/posix_fallocate.c",
+  "src/fenv/__flt_rounds.c",
+  "src/fenv/fegetexceptflag.c",
+  "src/fenv/feholdexcept.c",
+  "src/fenv/fenv.c",
+  "src/fenv/fesetexceptflag.c",
+  "src/fenv/fesetround.c",
+  "src/fenv/feupdateenv.c",
+  "src/internal/defsysinfo.c",
+  "src/internal/floatscan.c",
+  "src/internal/intscan.c",
+  "src/internal/libc.c",
+  "src/internal/procfdname.c",
+  "src/internal/shgetc.c",
+  "src/internal/syscall_ret.c",
+  "src/internal/vdso.c",
+  "src/internal/version.c",
+  "src/ipc/ftok.c",
+  "src/ipc/msgctl.c",
+  "src/ipc/msgget.c",
+  "src/ipc/msgrcv.c",
+  "src/ipc/msgsnd.c",
+  "src/ipc/semctl.c",
+  "src/ipc/semget.c",
+  "src/ipc/semop.c",
+  "src/ipc/semtimedop.c",
+  "src/ipc/shmat.c",
+  "src/ipc/shmctl.c",
+  "src/ipc/shmdt.c",
+  "src/ipc/shmget.c",
+  "src/ldso/__dlsym.c",
+  "src/ldso/dl_iterate_phdr.c",
+  "src/ldso/dladdr.c",
+  "src/ldso/dlclose.c",
+  "src/ldso/dlerror.c",
+  "src/ldso/dlinfo.c",
+  "src/ldso/dlopen.c",
+  "src/ldso/dlsym.c",
+  "src/ldso/tlsdesc.c",
+  "src/legacy/cuserid.c",
+  "src/legacy/daemon.c",
+  "src/legacy/err.c",
+  "src/legacy/euidaccess.c",
+  "src/legacy/ftw.c",
+  "src/legacy/futimes.c",
+  "src/legacy/getdtablesize.c",
+  "src/legacy/getloadavg.c",
+  "src/legacy/getpagesize.c",
+  "src/legacy/getpass.c",
+  "src/legacy/getusershell.c",
+  "src/legacy/isastream.c",
+  "src/legacy/lutimes.c",
+  "src/legacy/ulimit.c",
+  "src/legacy/utmpx.c",
+  "src/legacy/valloc.c",
+  "src/linux/adjtime.c",
+  "src/linux/adjtimex.c",
+  "src/linux/arch_prctl.c",
+  "src/linux/brk.c",
+  "src/linux/cache.c",
+  "src/linux/cap.c",
+  "src/linux/chroot.c",
+  "src/linux/clock_adjtime.c",
+  "src/linux/clone.c",
+  "src/linux/copy_file_range.c",
+  "src/linux/epoll.c",
+  "src/linux/eventfd.c",
+  "src/linux/fallocate.c",
+  "src/linux/fanotify.c",
+  "src/linux/flock.c",
+  "src/linux/getdents.c",
+  "src/linux/getrandom.c",
+  "src/linux/inotify.c",
+  "src/linux/ioperm.c",
+  "src/linux/iopl.c",
+  "src/linux/klogctl.c",
+  "src/linux/membarrier.c",
+  "src/linux/memfd_create.c",
+  "src/linux/mlock2.c",
+  "src/linux/module.c",
+  "src/linux/mount.c",
+  "src/linux/name_to_handle_at.c",
+  "src/linux/open_by_handle_at.c",
+  "src/linux/personality.c",
+  "src/linux/pivot_root.c",
+  "src/linux/ppoll.c",
+  "src/linux/prctl.c",
+  "src/linux/prlimit.c",
+  "src/linux/process_vm.c",
+  "src/linux/ptrace.c",
+  "src/linux/quotactl.c",
+  "src/linux/readahead.c",
+  "src/linux/reboot.c",
+  "src/linux/remap_file_pages.c",
+  "src/linux/sbrk.c",
+  "src/linux/sendfile.c",
+  "src/linux/setfsgid.c",
+  "src/linux/setfsuid.c",
+  "src/linux/setgroups.c",
+  "src/linux/sethostname.c",
+  "src/linux/setns.c",
+  "src/linux/settimeofday.c",
+  "src/linux/signalfd.c",
+  "src/linux/splice.c",
+  "src/linux/stime.c",
+  "src/linux/swap.c",
+  "src/linux/sync_file_range.c",
+  "src/linux/syncfs.c",
+  "src/linux/sysinfo.c",
+  "src/linux/tee.c",
+  "src/linux/timerfd.c",
+  "src/linux/unshare.c",
+  "src/linux/utimes.c",
+  "src/linux/vhangup.c",
+  "src/linux/vmsplice.c",
+  "src/linux/wait3.c",
+  "src/linux/wait4.c",
+  "src/linux/xattr.c",
+  "src/locale/__lctrans.c",
+  "src/locale/__mo_lookup.c",
+  "src/locale/bind_textdomain_codeset.c",
+  "src/locale/c_locale.c",
+  "src/locale/catclose.c",
+  "src/locale/catgets.c",
+  "src/locale/catopen.c",
+  "src/locale/dcngettext.c",
+  "src/locale/duplocale.c",
+  "src/locale/freelocale.c",
+  "src/locale/iconv.c",
+  "src/locale/iconv_close.c",
+  "src/locale/langinfo.c",
+  "src/locale/locale_map.c",
+  "src/locale/localeconv.c",
+  "src/locale/newlocale.c",
+  "src/locale/pleval.c",
+  "src/locale/setlocale.c",
+  "src/locale/strcoll.c",
+  "src/locale/strfmon.c",
+  "src/locale/strxfrm.c",
+  "src/locale/textdomain.c",
+  "src/locale/uselocale.c",
+  "src/locale/wcscoll.c",
+  "src/locale/wcsxfrm.c",
+  "src/malloc/aligned_alloc.c",
+  "src/malloc/expand_heap.c",
+  "src/malloc/lite_malloc.c",
+  "src/malloc/malloc.c",
+  "src/malloc/malloc_usable_size.c",
+  "src/malloc/memalign.c",
+  "src/malloc/posix_memalign.c",
+  "src/math/__cos.c",
+  "src/math/__cosdf.c",
+  "src/math/__cosl.c",
+  "src/math/__expo2.c",
+  "src/math/__expo2f.c",
+  "src/math/__fpclassify.c",
+  "src/math/__fpclassifyf.c",
+  "src/math/__fpclassifyl.c",
+  "src/math/__invtrigl.c",
+  "src/math/__math_divzero.c",
+  "src/math/__math_divzerof.c",
+  "src/math/__math_invalid.c",
+  "src/math/__math_invalidf.c",
+  "src/math/__math_oflow.c",
+  "src/math/__math_oflowf.c",
+  "src/math/__math_uflow.c",
+  "src/math/__math_uflowf.c",
+  "src/math/__math_xflow.c",
+  "src/math/__math_xflowf.c",
+  "src/math/__polevll.c",
+  "src/math/__rem_pio2.c",
+  "src/math/__rem_pio2_large.c",
+  "src/math/__rem_pio2f.c",
+  "src/math/__rem_pio2l.c",
+  "src/math/__signbit.c",
+  "src/math/__signbitf.c",
+  "src/math/__signbitl.c",
+  "src/math/__sin.c",
+  "src/math/__sindf.c",
+  "src/math/__sinl.c",
+  "src/math/__tan.c",
+  "src/math/__tandf.c",
+  "src/math/__tanl.c",
+  "src/math/acos.c",
+  "src/math/acosf.c",
+  "src/math/acosh.c",
+  "src/math/acoshf.c",
+  "src/math/acoshl.c",
+  "src/math/acosl.c",
+  "src/math/asin.c",
+  "src/math/asinf.c",
+  "src/math/asinh.c",
+  "src/math/asinhf.c",
+  "src/math/asinhl.c",
+  "src/math/asinl.c",
+  "src/math/atan.c",
+  "src/math/atan2.c",
+  "src/math/atan2f.c",
+  "src/math/atan2l.c",
+  "src/math/atanf.c",
+  "src/math/atanh.c",
+  "src/math/atanhf.c",
+  "src/math/atanhl.c",
+  "src/math/atanl.c",
+  "src/math/cbrt.c",
+  "src/math/cbrtf.c",
+  "src/math/cbrtl.c",
+  "src/math/ceil.c",
+  "src/math/ceilf.c",
+  "src/math/ceill.c",
+  "src/math/copysign.c",
+  "src/math/copysignf.c",
+  "src/math/copysignl.c",
+  "src/math/cos.c",
+  "src/math/cosf.c",
+  "src/math/cosh.c",
+  "src/math/coshf.c",
+  "src/math/coshl.c",
+  "src/math/cosl.c",
+  "src/math/erf.c",
+  "src/math/erff.c",
+  "src/math/erfl.c",
+  "src/math/exp.c",
+  "src/math/exp10.c",
+  "src/math/exp10f.c",
+  "src/math/exp10l.c",
+  "src/math/exp2.c",
+  "src/math/exp2f.c",
+  "src/math/exp2f_data.c",
+  "src/math/exp2l.c",
+  "src/math/exp_data.c",
+  "src/math/expf.c",
+  "src/math/expl.c",
+  "src/math/expm1.c",
+  "src/math/expm1f.c",
+  "src/math/expm1l.c",
+  "src/math/fabs.c",
+  "src/math/fabsf.c",
+  "src/math/fabsl.c",
+  "src/math/fdim.c",
+  "src/math/fdimf.c",
+  "src/math/fdiml.c",
+  "src/math/finite.c",
+  "src/math/finitef.c",
+  "src/math/floor.c",
+  "src/math/floorf.c",
+  "src/math/floorl.c",
+  "src/math/fma.c",
+  "src/math/fmaf.c",
+  "src/math/fmal.c",
+  "src/math/fmax.c",
+  "src/math/fmaxf.c",
+  "src/math/fmaxl.c",
+  "src/math/fmin.c",
+  "src/math/fminf.c",
+  "src/math/fminl.c",
+  "src/math/fmod.c",
+  "src/math/fmodf.c",
+  "src/math/fmodl.c",
+  "src/math/frexp.c",
+  "src/math/frexpf.c",
+  "src/math/frexpl.c",
+  "src/math/hypot.c",
+  "src/math/hypotf.c",
+  "src/math/hypotl.c",
+  "src/math/ilogb.c",
+  "src/math/ilogbf.c",
+  "src/math/ilogbl.c",
+  "src/math/j0.c",
+  "src/math/j0f.c",
+  "src/math/j1.c",
+  "src/math/j1f.c",
+  "src/math/jn.c",
+  "src/math/jnf.c",
+  "src/math/ldexp.c",
+  "src/math/ldexpf.c",
+  "src/math/ldexpl.c",
+  "src/math/lgamma.c",
+  "src/math/lgamma_r.c",
+  "src/math/lgammaf.c",
+  "src/math/lgammaf_r.c",
+  "src/math/lgammal.c",
+  "src/math/llrint.c",
+  "src/math/llrintf.c",
+  "src/math/llrintl.c",
+  "src/math/llround.c",
+  "src/math/llroundf.c",
+  "src/math/llroundl.c",
+  "src/math/log.c",
+  "src/math/log10.c",
+  "src/math/log10f.c",
+  "src/math/log10l.c",
+  "src/math/log1p.c",
+  "src/math/log1pf.c",
+  "src/math/log1pl.c",
+  "src/math/log2.c",
+  "src/math/log2_data.c",
+  "src/math/log2f.c",
+  "src/math/log2f_data.c",
+  "src/math/log2l.c",
+  "src/math/log_data.c",
+  "src/math/logb.c",
+  "src/math/logbf.c",
+  "src/math/logbl.c",
+  "src/math/logf.c",
+  "src/math/logf_data.c",
+  "src/math/logl.c",
+  "src/math/lrint.c",
+  "src/math/lrintf.c",
+  "src/math/lrintl.c",
+  "src/math/lround.c",
+  "src/math/lroundf.c",
+  "src/math/lroundl.c",
+  "src/math/modf.c",
+  "src/math/modff.c",
+  "src/math/modfl.c",
+  "src/math/nan.c",
+  "src/math/nanf.c",
+  "src/math/nanl.c",
+  "src/math/nearbyint.c",
+  "src/math/nearbyintf.c",
+  "src/math/nearbyintl.c",
+  "src/math/nextafter.c",
+  "src/math/nextafterf.c",
+  "src/math/nextafterl.c",
+  "src/math/nexttoward.c",
+  "src/math/nexttowardf.c",
+  "src/math/nexttowardl.c",
+  "src/math/pow.c",
+  "src/math/pow_data.c",
+  "src/math/powf.c",
+  "src/math/powf_data.c",
+  "src/math/powl.c",
+  "src/math/remainder.c",
+  "src/math/remainderf.c",
+  "src/math/remainderl.c",
+  "src/math/remquo.c",
+  "src/math/remquof.c",
+  "src/math/remquol.c",
+  "src/math/rint.c",
+  "src/math/rintf.c",
+  "src/math/rintl.c",
+  "src/math/round.c",
+  "src/math/roundf.c",
+  "src/math/roundl.c",
+  "src/math/scalb.c",
+  "src/math/scalbf.c",
+  "src/math/scalbln.c",
+  "src/math/scalblnf.c",
+  "src/math/scalblnl.c",
+  "src/math/scalbn.c",
+  "src/math/scalbnf.c",
+  "src/math/scalbnl.c",
+  "src/math/signgam.c",
+  "src/math/significand.c",
+  "src/math/significandf.c",
+  "src/math/sin.c",
+  "src/math/sincos.c",
+  "src/math/sincosf.c",
+  "src/math/sincosl.c",
+  "src/math/sinf.c",
+  "src/math/sinh.c",
+  "src/math/sinhf.c",
+  "src/math/sinhl.c",
+  "src/math/sinl.c",
+  "src/math/sqrt.c",
+  "src/math/sqrtf.c",
+  "src/math/sqrtl.c",
+  "src/math/tan.c",
+  "src/math/tanf.c",
+  "src/math/tanh.c",
+  "src/math/tanhf.c",
+  "src/math/tanhl.c",
+  "src/math/tanl.c",
+  "src/math/tgamma.c",
+  "src/math/tgammaf.c",
+  "src/math/tgammal.c",
+  "src/math/trunc.c",
+  "src/math/truncf.c",
+  "src/math/truncl.c",
+  "src/misc/a64l.c",
+  "src/misc/basename.c",
+  "src/misc/dirname.c",
+  "src/misc/ffs.c",
+  "src/misc/ffsl.c",
+  "src/misc/ffsll.c",
+  "src/misc/fmtmsg.c",
+  "src/misc/forkpty.c",
+  "src/misc/get_current_dir_name.c",
+  "src/misc/getauxval.c",
+  "src/misc/getdomainname.c",
+  "src/misc/getentropy.c",
+  "src/misc/gethostid.c",
+  "src/misc/getopt.c",
+  "src/misc/getopt_long.c",
+  "src/misc/getpriority.c",
+  "src/misc/getresgid.c",
+  "src/misc/getresuid.c",
+  "src/misc/getrlimit.c",
+  "src/misc/getrusage.c",
+  "src/misc/getsubopt.c",
+  "src/misc/initgroups.c",
+  "src/misc/ioctl.c",
+  "src/misc/issetugid.c",
+  "src/misc/lockf.c",
+  "src/misc/login_tty.c",
+  "src/misc/mntent.c",
+  "src/misc/nftw.c",
+  "src/misc/openpty.c",
+  "src/misc/ptsname.c",
+  "src/misc/pty.c",
+  "src/misc/realpath.c",
+  "src/misc/setdomainname.c",
+  "src/misc/setpriority.c",
+  "src/misc/setrlimit.c",
+  "src/misc/syscall.c",
+  "src/misc/syslog.c",
+  "src/misc/uname.c",
+  "src/misc/wordexp.c",
+  "src/mman/madvise.c",
+  "src/mman/mincore.c",
+  "src/mman/mlock.c",
+  "src/mman/mlockall.c",
+  "src/mman/mmap.c",
+  "src/mman/mprotect.c",
+  "src/mman/mremap.c",
+  "src/mman/msync.c",
+  "src/mman/munlock.c",
+  "src/mman/munlockall.c",
+  "src/mman/munmap.c",
+  "src/mman/posix_madvise.c",
+  "src/mman/shm_open.c",
+  "src/mq/mq_close.c",
+  "src/mq/mq_getattr.c",
+  "src/mq/mq_notify.c",
+  "src/mq/mq_open.c",
+  "src/mq/mq_receive.c",
+  "src/mq/mq_send.c",
+  "src/mq/mq_setattr.c",
+  "src/mq/mq_timedreceive.c",
+  "src/mq/mq_timedsend.c",
+  "src/mq/mq_unlink.c",
+  "src/multibyte/btowc.c",
+  "src/multibyte/c16rtomb.c",
+  "src/multibyte/c32rtomb.c",
+  "src/multibyte/internal.c",
+  "src/multibyte/mblen.c",
+  "src/multibyte/mbrlen.c",
+  "src/multibyte/mbrtoc16.c",
+  "src/multibyte/mbrtoc32.c",
+  "src/multibyte/mbrtowc.c",
+  "src/multibyte/mbsinit.c",
+  "src/multibyte/mbsnrtowcs.c",
+  "src/multibyte/mbsrtowcs.c",
+  "src/multibyte/mbstowcs.c",
+  "src/multibyte/mbtowc.c",
+  "src/multibyte/wcrtomb.c",
+  "src/multibyte/wcsnrtombs.c",
+  "src/multibyte/wcsrtombs.c",
+  "src/multibyte/wcstombs.c",
+  "src/multibyte/wctob.c",
+  "src/multibyte/wctomb.c",
+  "src/network/accept.c",
+  "src/network/accept4.c",
+  "src/network/bind.c",
+  "src/network/connect.c",
+  "src/network/dn_comp.c",
+  "src/network/dn_expand.c",
+  "src/network/dn_skipname.c",
+  "src/network/dns_parse.c",
+  "src/network/ent.c",
+  "src/network/ether.c",
+  "src/network/freeaddrinfo.c",
+  "src/network/gai_strerror.c",
+  "src/network/getaddrinfo.c",
+  "src/network/gethostbyaddr.c",
+  "src/network/gethostbyaddr_r.c",
+  "src/network/gethostbyname.c",
+  "src/network/gethostbyname2.c",
+  "src/network/gethostbyname2_r.c",
+  "src/network/gethostbyname_r.c",
+  "src/network/getifaddrs.c",
+  "src/network/getnameinfo.c",
+  "src/network/getpeername.c",
+  "src/network/getservbyname.c",
+  "src/network/getservbyname_r.c",
+  "src/network/getservbyport.c",
+  "src/network/getservbyport_r.c",
+  "src/network/getsockname.c",
+  "src/network/getsockopt.c",
+  "src/network/h_errno.c",
+  "src/network/herror.c",
+  "src/network/hstrerror.c",
+  "src/network/htonl.c",
+  "src/network/htons.c",
+  "src/network/if_freenameindex.c",
+  "src/network/if_indextoname.c",
+  "src/network/if_nameindex.c",
+  "src/network/if_nametoindex.c",
+  "src/network/in6addr_any.c",
+  "src/network/in6addr_loopback.c",
+  "src/network/inet_addr.c",
+  "src/network/inet_aton.c",
+  "src/network/inet_legacy.c",
+  "src/network/inet_ntoa.c",
+  "src/network/inet_ntop.c",
+  "src/network/inet_pton.c",
+  "src/network/listen.c",
+  "src/network/lookup_ipliteral.c",
+  "src/network/lookup_name.c",
+  "src/network/lookup_serv.c",
+  "src/network/netlink.c",
+  "src/network/netname.c",
+  "src/network/ns_parse.c",
+  "src/network/ntohl.c",
+  "src/network/ntohs.c",
+  "src/network/proto.c",
+  "src/network/recv.c",
+  "src/network/recvfrom.c",
+  "src/network/recvmmsg.c",
+  "src/network/recvmsg.c",
+  "src/network/res_init.c",
+  "src/network/res_mkquery.c",
+  "src/network/res_msend.c",
+  "src/network/res_query.c",
+  "src/network/res_querydomain.c",
+  "src/network/res_send.c",
+  "src/network/res_state.c",
+  "src/network/resolvconf.c",
+  "src/network/send.c",
+  "src/network/sendmmsg.c",
+  "src/network/sendmsg.c",
+  "src/network/sendto.c",
+  "src/network/serv.c",
+  "src/network/setsockopt.c",
+  "src/network/shutdown.c",
+  "src/network/sockatmark.c",
+  "src/network/socket.c",
+  "src/network/socketpair.c",
+  "src/passwd/fgetgrent.c",
+  "src/passwd/fgetpwent.c",
+  "src/passwd/fgetspent.c",
+  "src/passwd/getgr_a.c",
+  "src/passwd/getgr_r.c",
+  "src/passwd/getgrent.c",
+  "src/passwd/getgrent_a.c",
+  "src/passwd/getgrouplist.c",
+  "src/passwd/getpw_a.c",
+  "src/passwd/getpw_r.c",
+  "src/passwd/getpwent.c",
+  "src/passwd/getpwent_a.c",
+  "src/passwd/getspent.c",
+  "src/passwd/getspnam.c",
+  "src/passwd/getspnam_r.c",
+  "src/passwd/lckpwdf.c",
+  "src/passwd/nscd_query.c",
+  "src/passwd/putgrent.c",
+  "src/passwd/putpwent.c",
+  "src/passwd/putspent.c",
+  "src/prng/__rand48_step.c",
+  "src/prng/__seed48.c",
+  "src/prng/drand48.c",
+  "src/prng/lcong48.c",
+  "src/prng/lrand48.c",
+  "src/prng/mrand48.c",
+  "src/prng/rand.c",
+  "src/prng/rand_r.c",
+  "src/prng/random.c",
+  "src/prng/seed48.c",
+  "src/prng/srand48.c",
+  "src/process/execl.c",
+  "src/process/execle.c",
+  "src/process/execlp.c",
+  "src/process/execv.c",
+  "src/process/execve.c",
+  "src/process/execvp.c",
+  "src/process/fexecve.c",
+  "src/process/fork.c",
+  "src/process/posix_spawn.c",
+  "src/process/posix_spawn_file_actions_addchdir.c",
+  "src/process/posix_spawn_file_actions_addclose.c",
+  "src/process/posix_spawn_file_actions_adddup2.c",
+  "src/process/posix_spawn_file_actions_addfchdir.c",
+  "src/process/posix_spawn_file_actions_addopen.c",
+  "src/process/posix_spawn_file_actions_destroy.c",
+  "src/process/posix_spawn_file_actions_init.c",
+  "src/process/posix_spawnattr_destroy.c",
+  "src/process/posix_spawnattr_getflags.c",
+  "src/process/posix_spawnattr_getpgroup.c",
+  "src/process/posix_spawnattr_getsigdefault.c",
+  "src/process/posix_spawnattr_getsigmask.c",
+  "src/process/posix_spawnattr_init.c",
+  "src/process/posix_spawnattr_sched.c",
+  "src/process/posix_spawnattr_setflags.c",
+  "src/process/posix_spawnattr_setpgroup.c",
+  "src/process/posix_spawnattr_setsigdefault.c",
+  "src/process/posix_spawnattr_setsigmask.c",
+  "src/process/posix_spawnp.c",
+  "src/process/system.c",
+  "src/process/vfork.c",
+  "src/process/wait.c",
+  "src/process/waitid.c",
+  "src/process/waitpid.c",
+  "src/regex/fnmatch.c",
+  "src/regex/glob.c",
+  "src/regex/regcomp.c",
+  "src/regex/regerror.c",
+  "src/regex/regexec.c",
+  "src/regex/tre-mem.c",
+  "src/sched/affinity.c",
+  "src/sched/sched_cpucount.c",
+  "src/sched/sched_get_priority_max.c",
+  "src/sched/sched_getcpu.c",
+  "src/sched/sched_getparam.c",
+  "src/sched/sched_getscheduler.c",
+  "src/sched/sched_rr_get_interval.c",
+  "src/sched/sched_setparam.c",
+  "src/sched/sched_setscheduler.c",
+  "src/sched/sched_yield.c",
+  "src/search/hsearch.c",
+  "src/search/insque.c",
+  "src/search/lsearch.c",
+  "src/search/tdelete.c",
+  "src/search/tdestroy.c",
+  "src/search/tfind.c",
+  "src/search/tsearch.c",
+  "src/search/twalk.c",
+  "src/select/poll.c",
+  "src/select/pselect.c",
+  "src/select/select.c",
+  "src/setjmp/longjmp.c",
+  "src/setjmp/setjmp.c",
+  "src/signal/block.c",
+  "src/signal/getitimer.c",
+  "src/signal/kill.c",
+  "src/signal/killpg.c",
+  "src/signal/psiginfo.c",
+  "src/signal/psignal.c",
+  "src/signal/raise.c",
+  "src/signal/restore.c",
+  "src/signal/setitimer.c",
+  "src/signal/sigaction.c",
+  "src/signal/sigaddset.c",
+  "src/signal/sigaltstack.c",
+  "src/signal/sigandset.c",
+  "src/signal/sigdelset.c",
+  "src/signal/sigemptyset.c",
+  "src/signal/sigfillset.c",
+  "src/signal/sighold.c",
+  "src/signal/sigignore.c",
+  "src/signal/siginterrupt.c",
+  "src/signal/sigisemptyset.c",
+  "src/signal/sigismember.c",
+  "src/signal/siglongjmp.c",
+  "src/signal/signal.c",
+  "src/signal/sigorset.c",
+  "src/signal/sigpause.c",
+  "src/signal/sigpending.c",
+  "src/signal/sigprocmask.c",
+  "src/signal/sigqueue.c",
+  "src/signal/sigrelse.c",
+  "src/signal/sigrtmax.c",
+  "src/signal/sigrtmin.c",
+  "src/signal/sigset.c",
+  "src/signal/sigsetjmp.c",
+  "src/signal/sigsetjmp_tail.c",
+  "src/signal/sigsuspend.c",
+  "src/signal/sigtimedwait.c",
+  "src/signal/sigwait.c",
+  "src/signal/sigwaitinfo.c",
+  "src/stat/__xstat.c",
+  "src/stat/chmod.c",
+  "src/stat/fchmod.c",
+  "src/stat/fchmodat.c",
+  "src/stat/fstat.c",
+  "src/stat/fstatat.c",
+  "src/stat/futimens.c",
+  "src/stat/futimesat.c",
+  "src/stat/lchmod.c",
+  "src/stat/lstat.c",
+  "src/stat/mkdir.c",
+  "src/stat/mkdirat.c",
+  "src/stat/mkfifo.c",
+  "src/stat/mkfifoat.c",
+  "src/stat/mknod.c",
+  "src/stat/mknodat.c",
+  "src/stat/stat.c",
+  "src/stat/statvfs.c",
+  "src/stat/umask.c",
+  "src/stat/utimensat.c",
+  "src/stdio/__fclose_ca.c",
+  "src/stdio/__fdopen.c",
+  "src/stdio/__fmodeflags.c",
+  "src/stdio/__fopen_rb_ca.c",
+  "src/stdio/__lockfile.c",
+  "src/stdio/__overflow.c",
+  "src/stdio/__stdio_close.c",
+  "src/stdio/__stdio_exit.c",
+  "src/stdio/__stdio_read.c",
+  "src/stdio/__stdio_seek.c",
+  "src/stdio/__stdio_write.c",
+  "src/stdio/__stdout_write.c",
+  "src/stdio/__string_read.c",
+  "src/stdio/__toread.c",
+  "src/stdio/__towrite.c",
+  "src/stdio/__uflow.c",
+  "src/stdio/asprintf.c",
+  "src/stdio/clearerr.c",
+  "src/stdio/dprintf.c",
+  "src/stdio/ext.c",
+  "src/stdio/ext2.c",
+  "src/stdio/fclose.c",
+  "src/stdio/feof.c",
+  "src/stdio/ferror.c",
+  "src/stdio/fflush.c",
+  "src/stdio/fgetc.c",
+  "src/stdio/fgetln.c",
+  "src/stdio/fgetpos.c",
+  "src/stdio/fgets.c",
+  "src/stdio/fgetwc.c",
+  "src/stdio/fgetws.c",
+  "src/stdio/fileno.c",
+  "src/stdio/flockfile.c",
+  "src/stdio/fmemopen.c",
+  "src/stdio/fopen.c",
+  "src/stdio/fopencookie.c",
+  "src/stdio/fprintf.c",
+  "src/stdio/fputc.c",
+  "src/stdio/fputs.c",
+  "src/stdio/fputwc.c",
+  "src/stdio/fputws.c",
+  "src/stdio/fread.c",
+  "src/stdio/freopen.c",
+  "src/stdio/fscanf.c",
+  "src/stdio/fseek.c",
+  "src/stdio/fsetpos.c",
+  "src/stdio/ftell.c",
+  "src/stdio/ftrylockfile.c",
+  "src/stdio/funlockfile.c",
+  "src/stdio/fwide.c",
+  "src/stdio/fwprintf.c",
+  "src/stdio/fwrite.c",
+  "src/stdio/fwscanf.c",
+  "src/stdio/getc.c",
+  "src/stdio/getc_unlocked.c",
+  "src/stdio/getchar.c",
+  "src/stdio/getchar_unlocked.c",
+  "src/stdio/getdelim.c",
+  "src/stdio/getline.c",
+  "src/stdio/gets.c",
+  "src/stdio/getw.c",
+  "src/stdio/getwc.c",
+  "src/stdio/getwchar.c",
+  "src/stdio/ofl.c",
+  "src/stdio/ofl_add.c",
+  "src/stdio/open_memstream.c",
+  "src/stdio/open_wmemstream.c",
+  "src/stdio/pclose.c",
+  "src/stdio/perror.c",
+  "src/stdio/popen.c",
+  "src/stdio/printf.c",
+  "src/stdio/putc.c",
+  "src/stdio/putc_unlocked.c",
+  "src/stdio/putchar.c",
+  "src/stdio/putchar_unlocked.c",
+  "src/stdio/puts.c",
+  "src/stdio/putw.c",
+  "src/stdio/putwc.c",
+  "src/stdio/putwchar.c",
+  "src/stdio/remove.c",
+  "src/stdio/rename.c",
+  "src/stdio/rewind.c",
+  "src/stdio/scanf.c",
+  "src/stdio/setbuf.c",
+  "src/stdio/setbuffer.c",
+  "src/stdio/setlinebuf.c",
+  "src/stdio/setvbuf.c",
+  "src/stdio/snprintf.c",
+  "src/stdio/sprintf.c",
+  "src/stdio/sscanf.c",
+  "src/stdio/stderr.c",
+  "src/stdio/stdin.c",
+  "src/stdio/stdout.c",
+  "src/stdio/swprintf.c",
+  "src/stdio/swscanf.c",
+  "src/stdio/tempnam.c",
+  "src/stdio/tmpfile.c",
+  "src/stdio/tmpnam.c",
+  "src/stdio/ungetc.c",
+  "src/stdio/ungetwc.c",
+  "src/stdio/vasprintf.c",
+  "src/stdio/vdprintf.c",
+  "src/stdio/vfprintf.c",
+  "src/stdio/vfscanf.c",
+  "src/stdio/vfwprintf.c",
+  "src/stdio/vfwscanf.c",
+  "src/stdio/vprintf.c",
+  "src/stdio/vscanf.c",
+  "src/stdio/vsnprintf.c",
+  "src/stdio/vsprintf.c",
+  "src/stdio/vsscanf.c",
+  "src/stdio/vswprintf.c",
+  "src/stdio/vswscanf.c",
+  "src/stdio/vwprintf.c",
+  "src/stdio/vwscanf.c",
+  "src/stdio/wprintf.c",
+  "src/stdio/wscanf.c",
+  "src/stdlib/abs.c",
+  "src/stdlib/atof.c",
+  "src/stdlib/atoi.c",
+  "src/stdlib/atol.c",
+  "src/stdlib/atoll.c",
+  "src/stdlib/bsearch.c",
+  "src/stdlib/div.c",
+  "src/stdlib/ecvt.c",
+  "src/stdlib/fcvt.c",
+  "src/stdlib/gcvt.c",
+  "src/stdlib/imaxabs.c",
+  "src/stdlib/imaxdiv.c",
+  "src/stdlib/labs.c",
+  "src/stdlib/ldiv.c",
+  "src/stdlib/llabs.c",
+  "src/stdlib/lldiv.c",
+  "src/stdlib/qsort.c",
+  "src/stdlib/strtod.c",
+  "src/stdlib/strtol.c",
+  "src/stdlib/wcstod.c",
+  "src/stdlib/wcstol.c",
+  "src/string/bcmp.c",
+  "src/string/bcopy.c",
+  "src/string/bzero.c",
+  "src/string/explicit_bzero.c",
+  "src/string/index.c",
+  "src/string/memccpy.c",
+  "src/string/memchr.c",
+  "src/string/memcmp.c",
+  "src/string/memcpy.c",
+  "src/string/memmem.c",
+  "src/string/memmove.c",
+  "src/string/mempcpy.c",
+  "src/string/memrchr.c",
+  "src/string/memset.c",
+  "src/string/rindex.c",
+  "src/string/stpcpy.c",
+  "src/string/stpncpy.c",
+  "src/string/strcasecmp.c",
+  "src/string/strcasestr.c",
+  "src/string/strcat.c",
+  "src/string/strchr.c",
+  "src/string/strchrnul.c",
+  "src/string/strcmp.c",
+  "src/string/strcpy.c",
+  "src/string/strcspn.c",
+  "src/string/strdup.c",
+  "src/string/strerror_r.c",
+  "src/string/strlcat.c",
+  "src/string/strlcpy.c",
+  "src/string/strlen.c",
+  "src/string/strncasecmp.c",
+  "src/string/strncat.c",
+  "src/string/strncmp.c",
+  "src/string/strncpy.c",
+  "src/string/strndup.c",
+  "src/string/strnlen.c",
+  "src/string/strpbrk.c",
+  "src/string/strrchr.c",
+  "src/string/strsep.c",
+  "src/string/strsignal.c",
+  "src/string/strspn.c",
+  "src/string/strstr.c",
+  "src/string/strtok.c",
+  "src/string/strtok_r.c",
+  "src/string/strverscmp.c",
+  "src/string/swab.c",
+  "src/string/wcpcpy.c",
+  "src/string/wcpncpy.c",
+  "src/string/wcscasecmp.c",
+  "src/string/wcscasecmp_l.c",
+  "src/string/wcscat.c",
+  "src/string/wcschr.c",
+  "src/string/wcscmp.c",
+  "src/string/wcscpy.c",
+  "src/string/wcscspn.c",
+  "src/string/wcsdup.c",
+  "src/string/wcslen.c",
+  "src/string/wcsncasecmp.c",
+  "src/string/wcsncasecmp_l.c",
+  "src/string/wcsncat.c",
+  "src/string/wcsncmp.c",
+  "src/string/wcsncpy.c",
+  "src/string/wcsnlen.c",
+  "src/string/wcspbrk.c",
+  "src/string/wcsrchr.c",
+  "src/string/wcsspn.c",
+  "src/string/wcsstr.c",
+  "src/string/wcstok.c",
+  "src/string/wcswcs.c",
+  "src/string/wmemchr.c",
+  "src/string/wmemcmp.c",
+  "src/string/wmemcpy.c",
+  "src/string/wmemmove.c",
+  "src/string/wmemset.c",
+  "src/temp/__randname.c",
+  "src/temp/mkdtemp.c",
+  "src/temp/mkostemp.c",
+  "src/temp/mkostemps.c",
+  "src/temp/mkstemp.c",
+  "src/temp/mkstemps.c",
+  "src/temp/mktemp.c",
+  "src/termios/cfgetospeed.c",
+  "src/termios/cfmakeraw.c",
+  "src/termios/cfsetospeed.c",
+  "src/termios/tcdrain.c",
+  "src/termios/tcflow.c",
+  "src/termios/tcflush.c",
+  "src/termios/tcgetattr.c",
+  "src/termios/tcgetsid.c",
+  "src/termios/tcsendbreak.c",
+  "src/termios/tcsetattr.c",
+  "src/thread/__lock.c",
+  "src/thread/__set_thread_area.c",
+  "src/thread/__syscall_cp.c",
+  "src/thread/__timedwait.c",
+  "src/thread/__tls_get_addr.c",
+  "src/thread/__unmapself.c",
+  "src/thread/__wait.c",
+  "src/thread/call_once.c",
+  "src/thread/clone.c",
+  "src/thread/cnd_broadcast.c",
+  "src/thread/cnd_destroy.c",
+  "src/thread/cnd_init.c",
+  "src/thread/cnd_signal.c",
+  "src/thread/cnd_timedwait.c",
+  "src/thread/cnd_wait.c",
+  "src/thread/default_attr.c",
+  "src/thread/lock_ptc.c",
+  "src/thread/mtx_destroy.c",
+  "src/thread/mtx_init.c",
+  "src/thread/mtx_lock.c",
+  "src/thread/mtx_timedlock.c",
+  "src/thread/mtx_trylock.c",
+  "src/thread/mtx_unlock.c",
+  "src/thread/pthread_atfork.c",
+  "src/thread/pthread_attr_destroy.c",
+  "src/thread/pthread_attr_get.c",
+  "src/thread/pthread_attr_init.c",
+  "src/thread/pthread_attr_setdetachstate.c",
+  "src/thread/pthread_attr_setguardsize.c",
+  "src/thread/pthread_attr_setinheritsched.c",
+  "src/thread/pthread_attr_setschedparam.c",
+  "src/thread/pthread_attr_setschedpolicy.c",
+  "src/thread/pthread_attr_setscope.c",
+  "src/thread/pthread_attr_setstack.c",
+  "src/thread/pthread_attr_setstacksize.c",
+  "src/thread/pthread_barrier_destroy.c",
+  "src/thread/pthread_barrier_init.c",
+  "src/thread/pthread_barrier_wait.c",
+  "src/thread/pthread_barrierattr_destroy.c",
+  "src/thread/pthread_barrierattr_init.c",
+  "src/thread/pthread_barrierattr_setpshared.c",
+  "src/thread/pthread_cancel.c",
+  "src/thread/pthread_cleanup_push.c",
+  "src/thread/pthread_cond_broadcast.c",
+  "src/thread/pthread_cond_destroy.c",
+  "src/thread/pthread_cond_init.c",
+  "src/thread/pthread_cond_signal.c",
+  "src/thread/pthread_cond_timedwait.c",
+  "src/thread/pthread_cond_wait.c",
+  "src/thread/pthread_condattr_destroy.c",
+  "src/thread/pthread_condattr_init.c",
+  "src/thread/pthread_condattr_setclock.c",
+  "src/thread/pthread_condattr_setpshared.c",
+  "src/thread/pthread_create.c",
+  "src/thread/pthread_detach.c",
+  "src/thread/pthread_equal.c",
+  "src/thread/pthread_getattr_np.c",
+  "src/thread/pthread_getconcurrency.c",
+  "src/thread/pthread_getcpuclockid.c",
+  "src/thread/pthread_getschedparam.c",
+  "src/thread/pthread_getspecific.c",
+  "src/thread/pthread_join.c",
+  "src/thread/pthread_key_create.c",
+  "src/thread/pthread_kill.c",
+  "src/thread/pthread_mutex_consistent.c",
+  "src/thread/pthread_mutex_destroy.c",
+  "src/thread/pthread_mutex_getprioceiling.c",
+  "src/thread/pthread_mutex_init.c",
+  "src/thread/pthread_mutex_lock.c",
+  "src/thread/pthread_mutex_setprioceiling.c",
+  "src/thread/pthread_mutex_timedlock.c",
+  "src/thread/pthread_mutex_trylock.c",
+  "src/thread/pthread_mutex_unlock.c",
+  "src/thread/pthread_mutexattr_destroy.c",
+  "src/thread/pthread_mutexattr_init.c",
+  "src/thread/pthread_mutexattr_setprotocol.c",
+  "src/thread/pthread_mutexattr_setpshared.c",
+  "src/thread/pthread_mutexattr_setrobust.c",
+  "src/thread/pthread_mutexattr_settype.c",
+  "src/thread/pthread_once.c",
+  "src/thread/pthread_rwlock_destroy.c",
+  "src/thread/pthread_rwlock_init.c",
+  "src/thread/pthread_rwlock_rdlock.c",
+  "src/thread/pthread_rwlock_timedrdlock.c",
+  "src/thread/pthread_rwlock_timedwrlock.c",
+  "src/thread/pthread_rwlock_tryrdlock.c",
+  "src/thread/pthread_rwlock_trywrlock.c",
+  "src/thread/pthread_rwlock_unlock.c",
+  "src/thread/pthread_rwlock_wrlock.c",
+  "src/thread/pthread_rwlockattr_destroy.c",
+  "src/thread/pthread_rwlockattr_init.c",
+  "src/thread/pthread_rwlockattr_setpshared.c",
+  "src/thread/pthread_self.c",
+  "src/thread/pthread_setattr_default_np.c",
+  "src/thread/pthread_setcancelstate.c",
+  "src/thread/pthread_setcanceltype.c",
+  "src/thread/pthread_setconcurrency.c",
+  "src/thread/pthread_setname_np.c",
+  "src/thread/pthread_setschedparam.c",
+  "src/thread/pthread_setschedprio.c",
+  "src/thread/pthread_setspecific.c",
+  "src/thread/pthread_sigmask.c",
+  "src/thread/pthread_spin_destroy.c",
+  "src/thread/pthread_spin_init.c",
+  "src/thread/pthread_spin_lock.c",
+  "src/thread/pthread_spin_trylock.c",
+  "src/thread/pthread_spin_unlock.c",
+  "src/thread/pthread_testcancel.c",
+  "src/thread/sem_destroy.c",
+  "src/thread/sem_getvalue.c",
+  "src/thread/sem_init.c",
+  "src/thread/sem_open.c",
+  "src/thread/sem_post.c",
+  "src/thread/sem_timedwait.c",
+  "src/thread/sem_trywait.c",
+  "src/thread/sem_unlink.c",
+  "src/thread/sem_wait.c",
+  "src/thread/synccall.c",
+  "src/thread/syscall_cp.c",
+  "src/thread/thrd_create.c",
+  "src/thread/thrd_exit.c",
+  "src/thread/thrd_join.c",
+  "src/thread/thrd_sleep.c",
+  "src/thread/thrd_yield.c",
+  "src/thread/tls.c",
+  "src/thread/tss_create.c",
+  "src/thread/tss_delete.c",
+  "src/thread/tss_set.c",
+  "src/thread/vmlock.c",
+  "src/time/__map_file.c",
+  "src/time/__month_to_secs.c",
+  "src/time/__secs_to_tm.c",
+  "src/time/__tm_to_secs.c",
+  "src/time/__tz.c",
+  "src/time/__year_to_secs.c",
+  "src/time/asctime.c",
+  "src/time/asctime_r.c",
+  "src/time/clock.c",
+  "src/time/clock_getcpuclockid.c",
+  "src/time/clock_getres.c",
+  "src/time/clock_gettime.c",
+  "src/time/clock_nanosleep.c",
+  "src/time/clock_settime.c",
+  "src/time/ctime.c",
+  "src/time/ctime_r.c",
+  "src/time/difftime.c",
+  "src/time/ftime.c",
+  "src/time/getdate.c",
+  "src/time/gettimeofday.c",
+  "src/time/gmtime.c",
+  "src/time/gmtime_r.c",
+  "src/time/localtime.c",
+  "src/time/localtime_r.c",
+  "src/time/mktime.c",
+  "src/time/nanosleep.c",
+  "src/time/strftime.c",
+  "src/time/strptime.c",
+  "src/time/time.c",
+  "src/time/timegm.c",
+  "src/time/timer_create.c",
+  "src/time/timer_delete.c",
+  "src/time/timer_getoverrun.c",
+  "src/time/timer_gettime.c",
+  "src/time/timer_settime.c",
+  "src/time/times.c",
+  "src/time/timespec_get.c",
+  "src/time/utime.c",
+  "src/time/wcsftime.c",
+  "src/unistd/_exit.c",
+  "src/unistd/access.c",
+  "src/unistd/acct.c",
+  "src/unistd/alarm.c",
+  "src/unistd/chdir.c",
+  "src/unistd/chown.c",
+  "src/unistd/close.c",
+  "src/unistd/ctermid.c",
+  "src/unistd/dup.c",
+  "src/unistd/dup2.c",
+  "src/unistd/dup3.c",
+  "src/unistd/faccessat.c",
+  "src/unistd/fchdir.c",
+  "src/unistd/fchown.c",
+  "src/unistd/fchownat.c",
+  "src/unistd/fdatasync.c",
+  "src/unistd/fsync.c",
+  "src/unistd/ftruncate.c",
+  "src/unistd/getcwd.c",
+  "src/unistd/getegid.c",
+  "src/unistd/geteuid.c",
+  "src/unistd/getgid.c",
+  "src/unistd/getgroups.c",
+  "src/unistd/gethostname.c",
+  "src/unistd/getlogin.c",
+  "src/unistd/getlogin_r.c",
+  "src/unistd/getpgid.c",
+  "src/unistd/getpgrp.c",
+  "src/unistd/getpid.c",
+  "src/unistd/getppid.c",
+  "src/unistd/getsid.c",
+  "src/unistd/getuid.c",
+  "src/unistd/isatty.c",
+  "src/unistd/lchown.c",
+  "src/unistd/link.c",
+  "src/unistd/linkat.c",
+  "src/unistd/lseek.c",
+  "src/unistd/nice.c",
+  "src/unistd/pause.c",
+  "src/unistd/pipe.c",
+  "src/unistd/pipe2.c",
+  "src/unistd/posix_close.c",
+  "src/unistd/pread.c",
+  "src/unistd/preadv.c",
+  "src/unistd/pwrite.c",
+  "src/unistd/pwritev.c",
+  "src/unistd/read.c",
+  "src/unistd/readlink.c",
+  "src/unistd/readlinkat.c",
+  "src/unistd/readv.c",
+  "src/unistd/renameat.c",
+  "src/unistd/rmdir.c",
+  "src/unistd/setegid.c",
+  "src/unistd/seteuid.c",
+  "src/unistd/setgid.c",
+  "src/unistd/setpgid.c",
+  "src/unistd/setpgrp.c",
+  "src/unistd/setregid.c",
+  "src/unistd/setresgid.c",
+  "src/unistd/setresuid.c",
+  "src/unistd/setreuid.c",
+  "src/unistd/setsid.c",
+  "src/unistd/setuid.c",
+  "src/unistd/setxid.c",
+  "src/unistd/sleep.c",
+  "src/unistd/symlink.c",
+  "src/unistd/symlinkat.c",
+  "src/unistd/sync.c",
+  "src/unistd/tcgetpgrp.c",
+  "src/unistd/tcsetpgrp.c",
+  "src/unistd/truncate.c",
+  "src/unistd/ttyname.c",
+  "src/unistd/ttyname_r.c",
+  "src/unistd/ualarm.c",
+  "src/unistd/unlink.c",
+  "src/unistd/unlinkat.c",
+  "src/unistd/usleep.c",
+  "src/unistd/write.c",
+  "src/unistd/writev.c",
+]
+
+if (musl_arch == "arm") {
+  musl_src_filterout = [
+    "src/fenv/fenv.c",
+    "src/ldso/dlsym.c",
+    "src/ldso/tlsdesc.c",
+    "src/math/fabs.c",
+    "src/math/fabsf.c",
+    "src/math/fma.c",
+    "src/math/fmaf.c",
+    "src/math/sqrt.c",
+    "src/math/sqrtf.c",
+    "src/process/vfork.c",
+    "src/setjmp/longjmp.c",
+    "src/setjmp/setjmp.c",
+    "src/signal/restore.c",
+    "src/signal/sigsetjmp.c",
+    "src/string/memcpy.c",
+    "src/thread/__set_thread_area.c",
+    "src/thread/__unmapself.c",
+    "src/thread/clone.c",
+    "src/thread/syscall_cp.c",
+  ]
+} else if (musl_arch == "aarch64") {
+  musl_src_filterout = [
+    "src/fenv/fenv.c",
+    "src/ldso/dlsym.c",
+    "src/ldso/tlsdesc.c",
+    "src/math/ceil.c",
+    "src/math/ceilf.c",
+    "src/math/fabs.c",
+    "src/math/fabsf.c",
+    "src/math/floor.c",
+    "src/math/floorf.c",
+    "src/math/fma.c",
+    "src/math/fmaf.c",
+    "src/math/fmax.c",
+    "src/math/fmaxf.c",
+    "src/math/fmin.c",
+    "src/math/fminf.c",
+    "src/math/llrint.c",
+    "src/math/llrintf.c",
+    "src/math/llround.c",
+    "src/math/llroundf.c",
+    "src/math/lrint.c",
+    "src/math/lrintf.c",
+    "src/math/lround.c",
+    "src/math/lroundf.c",
+    "src/math/nearbyint.c",
+    "src/math/nearbyintf.c",
+    "src/math/rint.c",
+    "src/math/rintf.c",
+    "src/math/round.c",
+    "src/math/roundf.c",
+    "src/math/sqrt.c",
+    "src/math/sqrtf.c",
+    "src/math/trunc.c",
+    "src/math/truncf.c",
+    "src/setjmp/longjmp.c",
+    "src/setjmp/setjmp.c",
+    "src/signal/restore.c",
+    "src/signal/sigsetjmp.c",
+    "src/thread/__set_thread_area.c",
+    "src/thread/__unmapself.c",
+    "src/thread/clone.c",
+    "src/thread/syscall_cp.c",
+  ]
+}
+
+musl_src_ldso = [
+  "ldso/dlstart.c",
+  "ldso/dynlink.c",
+]
+
+if (musl_arch == "arm") {
+  musl_inc_bits_files = [
+    "arch/arm/bits/fcntl.h",
+    "arch/arm/bits/fenv.h",
+    "arch/arm/bits/float.h",
+    "arch/arm/bits/hwcap.h",
+    "arch/arm/bits/ioctl_fix.h",
+    "arch/arm/bits/ipcstat.h",
+    "arch/arm/bits/msg.h",
+    "arch/arm/bits/posix.h",
+    "arch/arm/bits/ptrace.h",
+    "arch/arm/bits/reg.h",
+    "arch/arm/bits/sem.h",
+    "arch/arm/bits/setjmp.h",
+    "arch/arm/bits/shm.h",
+    "arch/arm/bits/signal.h",
+    "arch/arm/bits/stat.h",
+    "arch/arm/bits/stdint.h",
+    "arch/arm/bits/user.h",
+
+    "arch/generic/bits/dirent.h",
+    "arch/generic/bits/errno.h",
+    "arch/generic/bits/ioctl.h",
+    "arch/generic/bits/io.h",
+    "arch/generic/bits/ipc.h",
+    "arch/generic/bits/kd.h",
+    "arch/generic/bits/limits.h",
+    "arch/generic/bits/link.h",
+    "arch/generic/bits/mman.h",
+    "arch/generic/bits/poll.h",
+    "arch/generic/bits/resource.h",
+    "arch/generic/bits/socket.h",
+    "arch/generic/bits/soundcard.h",
+    "arch/generic/bits/statfs.h",
+    "arch/generic/bits/termios.h",
+    "arch/generic/bits/vt.h",
+  ]
+} else if (musl_arch == "aarch64") {
+  musl_inc_bits_files = [
+    "arch/aarch64/bits/fcntl.h",
+    "arch/aarch64/bits/fenv.h",
+    "arch/aarch64/bits/float.h",
+    "arch/aarch64/bits/hwcap.h",
+    "arch/aarch64/bits/posix.h",
+    "arch/aarch64/bits/reg.h",
+    "arch/aarch64/bits/setjmp.h",
+    "arch/aarch64/bits/signal.h",
+    "arch/aarch64/bits/stat.h",
+    "arch/aarch64/bits/stdint.h",
+    "arch/aarch64/bits/user.h",
+
+    "arch/generic/bits/dirent.h",
+    "arch/generic/bits/errno.h",
+    "arch/generic/bits/fcntl.h",
+    "arch/generic/bits/fenv.h",
+    "arch/generic/bits/hwcap.h",
+    "arch/generic/bits/ioctl_fix.h",
+    "arch/generic/bits/ioctl.h",
+    "arch/generic/bits/io.h",
+    "arch/generic/bits/ipc.h",
+    "arch/generic/bits/ipcstat.h",
+    "arch/generic/bits/kd.h",
+    "arch/generic/bits/limits.h",
+    "arch/generic/bits/link.h",
+    "arch/generic/bits/mman.h",
+    "arch/generic/bits/msg.h",
+    "arch/generic/bits/poll.h",
+    "arch/generic/bits/ptrace.h",
+    "arch/generic/bits/resource.h",
+    "arch/generic/bits/sem.h",
+    "arch/generic/bits/shm.h",
+    "arch/generic/bits/socket.h",
+    "arch/generic/bits/soundcard.h",
+    "arch/generic/bits/statfs.h",
+    "arch/generic/bits/termios.h",
+    "arch/generic/bits/vt.h",
+  ]
+}
+
+musl_inc_arpa_files = [
+  "include/arpa/ftp.h",
+  "include/arpa/inet.h",
+  "include/arpa/nameser_compat.h",
+  "include/arpa/nameser.h",
+  "include/arpa/telnet.h",
+  "include/arpa/tftp.h",
+]
+
+musl_inc_net_files = [
+  "include/net/ethernet.h",
+  "include/net/if_arp.h",
+  "include/net/if.h",
+  "include/net/route.h",
+]
+
+musl_inc_netinet_files = [
+  "include/netinet/ether.h",
+  "include/netinet/icmp6.h",
+  "include/netinet/if_ether.h",
+  "include/netinet/igmp.h",
+  "include/netinet/in.h",
+  "include/netinet/in_systm.h",
+  "include/netinet/ip6.h",
+  "include/netinet/ip.h",
+  "include/netinet/ip_icmp.h",
+  "include/netinet/tcp.h",
+  "include/netinet/udp.h",
+]
+
+musl_inc_netpacket_files = [ "include/netpacket/packet.h" ]
+
+musl_inc_scsi_files = [
+  "include/scsi/scsi.h",
+  "include/scsi/scsi_ioctl.h",
+  "include/scsi/sg.h",
+]
+
+musl_inc_sys_files = [
+  "include/sys/acct.h",
+  "include/sys/auxv.h",
+  "include/sys/cachectl.h",
+  "include/sys/dir.h",
+  "include/sys/epoll.h",
+  "include/sys/errno.h",
+  "include/sys/eventfd.h",
+  "include/sys/fanotify.h",
+  "include/sys/fcntl.h",
+  "include/sys/file.h",
+  "include/sys/fsuid.h",
+  "include/sys/inotify.h",
+  "include/sys/ioctl.h",
+  "include/sys/io.h",
+  "include/sys/ipc.h",
+  "include/sys/kd.h",
+  "include/sys/klog.h",
+  "include/sys/membarrier.h",
+  "include/sys/mman.h",
+  "include/sys/mount.h",
+  "include/sys/msg.h",
+  "include/sys/mtio.h",
+  "include/sys/param.h",
+  "include/sys/personality.h",
+  "include/sys/poll.h",
+  "include/sys/prctl.h",
+  "include/sys/procfs.h",
+  "include/sys/ptrace.h",
+  "include/sys/quota.h",
+  "include/sys/random.h",
+  "include/sys/reboot.h",
+  "include/sys/reg.h",
+  "include/sys/resource.h",
+  "include/sys/select.h",
+  "include/sys/sem.h",
+  "include/sys/sendfile.h",
+  "include/sys/shm.h",
+  "include/sys/signalfd.h",
+  "include/sys/signal.h",
+  "include/sys/socket.h",
+  "include/sys/soundcard.h",
+  "include/sys/statfs.h",
+  "include/sys/stat.h",
+  "include/sys/statvfs.h",
+  "include/sys/stropts.h",
+  "include/sys/swap.h",
+  "include/sys/syscall.h",
+  "include/sys/sysinfo.h",
+  "include/sys/syslog.h",
+  "include/sys/sysmacros.h",
+  "include/sys/termios.h",
+  "include/sys/timeb.h",
+  "include/sys/time.h",
+  "include/sys/timerfd.h",
+  "include/sys/times.h",
+  "include/sys/timex.h",
+  "include/sys/ttydefaults.h",
+  "include/sys/types.h",
+  "include/sys/ucontext.h",
+  "include/sys/uio.h",
+  "include/sys/un.h",
+  "include/sys/user.h",
+  "include/sys/utsname.h",
+  "include/sys/vfs.h",
+  "include/sys/vt.h",
+  "include/sys/wait.h",
+  "include/sys/xattr.h",
+]
+
+musl_inc_root_files = [
+  "include/aio.h",
+  "include/alloca.h",
+  "include/ar.h",
+  "include/assert.h",
+  "include/byteswap.h",
+  "include/complex.h",
+  "include/cpio.h",
+  "include/crypt.h",
+  "include/ctype.h",
+  "include/dirent.h",
+  "include/dlfcn.h",
+  "include/elf.h",
+  "include/endian.h",
+  "include/err.h",
+  "include/errno.h",
+  "include/fcntl.h",
+  "include/features.h",
+  "include/fenv.h",
+  "include/float.h",
+  "include/fmtmsg.h",
+  "include/fnmatch.h",
+  "include/ftw.h",
+  "include/getopt.h",
+  "include/glob.h",
+  "include/grp.h",
+  "include/iconv.h",
+  "include/ifaddrs.h",
+  "include/inttypes.h",
+  "include/iso646.h",
+  "include/langinfo.h",
+  "include/lastlog.h",
+  "include/libgen.h",
+  "include/libintl.h",
+  "include/limits.h",
+  "include/link.h",
+  "include/locale.h",
+  "include/malloc.h",
+  "include/math.h",
+  "include/memory.h",
+  "include/mntent.h",
+  "include/monetary.h",
+  "include/mqueue.h",
+  "include/netdb.h",
+  "include/nl_types.h",
+  "include/paths.h",
+  "include/poll.h",
+  "include/pthread.h",
+  "include/pty.h",
+  "include/pwd.h",
+  "include/regex.h",
+  "include/resolv.h",
+  "include/sched.h",
+  "include/search.h",
+  "include/semaphore.h",
+  "include/setjmp.h",
+  "include/shadow.h",
+  "include/signal.h",
+  "include/spawn.h",
+  "include/stdalign.h",
+  "include/stdarg.h",
+  "include/stdbool.h",
+  "include/stdc-predef.h",
+  "include/stddef.h",
+  "include/stdint.h",
+  "include/stdio_ext.h",
+  "include/stdio.h",
+  "include/stdlib.h",
+  "include/stdnoreturn.h",
+  "include/string.h",
+  "include/strings.h",
+  "include/stropts.h",
+  "include/syscall.h",
+  "include/sysexits.h",
+  "include/syslog.h",
+  "include/tar.h",
+  "include/termios.h",
+  "include/tgmath.h",
+  "include/threads.h",
+  "include/time.h",
+  "include/uchar.h",
+  "include/ucontext.h",
+  "include/ulimit.h",
+  "include/unistd.h",
+  "include/utime.h",
+  "include/utmp.h",
+  "include/utmpx.h",
+  "include/values.h",
+  "include/wait.h",
+  "include/wchar.h",
+  "include/wctype.h",
+  "include/wordexp.h",
+]
diff --git a/third_party/musl/musl_template.gni b/third_party/musl/musl_template.gni
new file mode 100755
index 000000000..e976e8bb6
--- /dev/null
+++ b/third_party/musl/musl_template.gni
@@ -0,0 +1,401 @@
+import("//build/ohos.gni")
+import("musl_src.gni")
+
+template("musl_libs") {
+
+  no_default_deps = true
+
+  forward_variables_from(invoker, ["target_abi"])
+  abi_prefix = "${target_name}"
+  
+  porting_deps = [
+    "//third_party/musl:create_porting_src",
+    "//third_party/musl:create_alltypes_h",
+    "//third_party/musl:create_syscall_h",
+    "//third_party/musl:create_version_h",
+  ]
+
+  if (target_abi == "soft") {
+    static_lib_out_dir = "usr/lib/${musl_target_triple}"
+    shared_lib_out_dir = "."
+  } else {
+    static_lib_out_dir = "usr/lib/${musl_target_triple}/${target_abi}"
+    shared_lib_out_dir = "${target_abi}"
+  }
+
+  musl_subarch = ""
+  if (target_abi == "a7_hard_neon-vfpv4") {
+    musl_subarch = "hf"
+  }
+
+  group("${abi_prefix}_libs") {
+    deps = [
+      ":${abi_prefix}_libc_musl_shared",
+      ":${abi_prefix}_libc_musl_static",
+      ":${abi_prefix}_libcrypt",
+      ":${abi_prefix}_libdl",
+      ":${abi_prefix}_libm",
+      ":${abi_prefix}_libpthread",
+      ":${abi_prefix}_libresolv",
+      ":${abi_prefix}_librt",
+      ":${abi_prefix}_libutil",
+      ":${abi_prefix}_libxnet",
+      ":${abi_prefix}_musl_crt_install_action",
+      ":${abi_prefix}_create_linker",
+    ]
+  }
+
+  # part of default_compiler_configs from build/config/BUILDCONFIG.gn
+  musl_inherited_configs = [
+    "//build/config/compiler:afdo",
+    "//build/config/compiler:afdo_optimize_size",
+    "//build/config/compiler:compiler",
+    "//build/config/compiler:compiler_arm_fpu",
+    "//build/config/compiler:compiler_arm_thumb",
+    "//build/config/compiler:chromium_code",
+    "//build/config/compiler:default_include_dirs",
+    "//build/config/compiler:default_optimization",
+    "//build/config/compiler:default_stack_frames",
+    "//build/config/compiler:default_symbols",
+    "//build/config/compiler:export_dynamic",
+    "//build/config/compiler:no_exceptions",
+    "//build/config/compiler:no_rtti",
+    "//build/config/compiler:runtime_library",
+    "//build/config/compiler:thin_archive",
+  ]
+
+  config("${abi_prefix}_musl_abi_config") {
+    if (target_abi == "soft") {
+      cflags = [ "-mfloat-abi=soft" ]
+    } else if (target_abi == "a7_soft") {
+      cflags = [
+        "-mcpu=cortex-a7",
+        "-mfloat-abi=soft",
+      ]
+    } else if (target_abi == "a7_softfp_neon-vfpv4") {
+      cflags = [
+        "-mcpu=cortex-a7",
+        "-mfloat-abi=softfp",
+        "-mfpu=neon-vfpv4",
+      ]
+    } else if (target_abi == "a7_hard_neon-vfpv4") {
+      cflags = [
+        "-mcpu=cortex-a7",
+        "-mfloat-abi=hard",
+        "-mfpu=neon-vfpv4",
+      ]
+    }
+  }
+
+  config("${abi_prefix}_musl_config") {
+    configs = [ ":${abi_prefix}_musl_abi_config" ]
+
+    include_dirs = [
+      "${target_out_dir}/${musl_ported_dir}/arch/${musl_arch}",
+      "${target_out_dir}/${musl_ported_dir}/arch/generic",
+      "${target_out_dir}/${musl_ported_dir}/src/internal",
+      "${target_out_dir}/${musl_ported_dir}/src/include",
+      "${target_out_dir}/${musl_ported_dir}/include",
+      "${target_out_dir}/${musl_inc_out_dir}",
+    ]
+
+    cflags_basic = [
+      "--target=${musl_target_triple}",
+      "-march=armv7-a",
+      "-O2",
+      "-Wall",
+      "-D_FORTIFY_SOURCE=2",
+      "-Wl,-z,relro,-z,now,-z,noexecstack",
+    ]
+
+    cflags_auto = [
+      "-D_XOPEN_SOURCE=700",
+      "-Os",
+      "-pipe",
+      "-fomit-frame-pointer",
+      "-fno-unwind-tables",
+      "-fno-asynchronous-unwind-tables",
+      "-ffunction-sections",
+      "-fdata-sections",
+      "-Werror=implicit-function-declaration",
+      "-Werror=implicit-int",
+      "-Werror=pointer-sign",
+      "-Werror=pointer-arith",
+      "-Qunused-arguments",
+    ]
+
+    cflags_c99fse = [
+      "-std=c99",
+      "-nostdinc",  
+      "-ffreestanding",
+      "-frounding-math",
+      "-Wa,--noexecstack",
+    ]
+
+    cflags_all = cflags_basic +
+                 cflags_c99fse +
+                 cflags_auto         
+
+    cflags = cflags_all
+
+    if ("${target_abi}" != "a7_hard_neon-vfpv4") {
+      defines = [ "BROKEN_VFP_ASM" ]
+    }
+
+    dynamic_list = rebase_path("${target_out_dir}/${musl_ported_dir}/dynamic.list")
+
+    ldflags = cflags_all
+    ldflags += [
+      "--target=${musl_target_triple}",
+      "-fuse-ld=lld",
+      "-Wl,--sort-section,alignment",
+      "-Wl,--sort-common",
+      "-Wl,--gc-sections",
+      "-Wl,--hash-style=both",
+      "-Wl,--no-undefined",
+      "-Wl,--exclude-libs=ALL",
+      "-Wl,--dynamic-list=${dynamic_list}",
+    ]
+    asmflags = cflags
+  }
+
+  source_set("${abi_prefix}_musl_crt") {
+    sources = [
+      "${target_out_dir}/${musl_ported_dir}/crt/${musl_arch}/crti.s",
+      "${target_out_dir}/${musl_ported_dir}/crt/${musl_arch}/crtn.s",
+      "${target_out_dir}/${musl_ported_dir}/crt/Scrt1.c",
+      "${target_out_dir}/${musl_ported_dir}/crt/crt1.c",
+      "${target_out_dir}/${musl_ported_dir}/crt/rcrt1.c",
+    ]
+
+    defines = [ "CRT" ]
+
+    configs -= musl_inherited_configs
+    configs += [ ":${abi_prefix}_musl_config" ]
+    cflags = [
+      "-fPIC",
+      "-fno-stack-protector",
+    ]
+
+    deps = porting_deps
+
+    asmflags = cflags
+  }
+
+  source_set("${abi_prefix}_musl_src") {
+    sources_orig = []
+    sources = []
+    set_sources_assignment_filter([])
+
+    sources_orig = musl_src_arch_file + musl_src_file
+    sources_orig -= musl_src_filterout
+    sources_orig -= [
+      "src/string/mempcpy.c",
+      "src/string/memset.c",
+      "src/env/__init_tls.c",
+      "src/env/__libc_start_main.c",
+      "src/env/__stack_chk_fail.c",
+      "src/thread/${musl_arch}/__set_thread_area.c",
+    ]
+
+    if ("${target_abi}" == "a7_hard_neon-vfpv4") {
+      defines = [ "__ARM_PCS_VFP" ]
+    }
+
+    foreach(s, sources_orig) {
+      sources += [ "${target_out_dir}/${musl_ported_dir}/${s}" ]
+    }
+
+    cflags = [
+      "-O3",
+      "-fPIC",
+      "-fstack-protector-strong",
+    ]
+
+    configs -= musl_inherited_configs
+    configs += [ ":${abi_prefix}_musl_config" ]
+
+    deps = porting_deps
+  }
+
+  source_set("${abi_prefix}_musl_src_nossp") {
+    sources = []
+    sources_orig = [
+      "src/string/mempcpy.c",
+      "src/string/memset.c",
+      "src/env/__init_tls.c",
+      "src/env/__libc_start_main.c",
+      "src/env/__stack_chk_fail.c",
+      "src/thread/${musl_arch}/__set_thread_area.c",
+    ]
+
+    foreach(s, sources_orig) {
+      sources += [ "${target_out_dir}/${musl_ported_dir}/${s}" ]
+    }
+
+    configs -= musl_inherited_configs
+    configs += [ ":${abi_prefix}_musl_config" ]
+    cflags = [
+      "-O3",
+      "-fPIC",
+      "-fno-stack-protector",
+    ]
+
+    deps = porting_deps
+  }
+
+  source_set("${abi_prefix}_musl_ldso") {
+    sources = []
+    sources_orig = musl_src_ldso
+
+    foreach(s, sources_orig) {
+      sources += [ "${target_out_dir}/${musl_ported_dir}/${s}" ]
+    }
+
+    configs -= musl_inherited_configs
+    configs += [ ":${abi_prefix}_musl_config" ]
+    cflags = [
+      "-fPIC",
+      "-fno-stack-protector",
+    ]
+
+    deps = porting_deps
+  }
+
+  static_library("${abi_prefix}_libc_musl_static") {
+    output_name = "libc"
+    complete_static_lib = true
+
+    configs -= musl_inherited_configs
+
+    output_dir = "${target_out_dir}/${static_lib_out_dir}"
+    deps = [
+      ":${abi_prefix}_musl_src",
+      ":${abi_prefix}_musl_src_nossp",
+    ]
+  }
+
+  static_library("${abi_prefix}_libm") {
+    complete_static_lib = true
+    configs -= musl_inherited_configs
+    output_name = "libm"
+    output_dir = "${target_out_dir}/${static_lib_out_dir}"
+  }
+
+  static_library("${abi_prefix}_librt") {
+    complete_static_lib = true
+    configs -= musl_inherited_configs
+    output_name = "librt"
+    output_dir = "${target_out_dir}/${static_lib_out_dir}"
+  }
+
+  static_library("${abi_prefix}_libpthread") {
+    complete_static_lib = true
+    configs -= musl_inherited_configs
+    output_name = "libpthread"
+    output_dir = "${target_out_dir}/${static_lib_out_dir}"
+  }
+
+  static_library("${abi_prefix}_libcrypt") {
+    complete_static_lib = true
+    configs -= musl_inherited_configs
+    output_name = "libcrypt"
+    output_dir = "${target_out_dir}/${static_lib_out_dir}"
+  }
+
+  static_library("${abi_prefix}_libutil") {
+    complete_static_lib = true
+    configs -= musl_inherited_configs
+    output_name = "libutil"
+    output_dir = "${target_out_dir}/${static_lib_out_dir}"
+  }
+
+  static_library("${abi_prefix}_libresolv") {
+    complete_static_lib = true
+    configs -= musl_inherited_configs
+    output_name = "libresolv"
+    output_dir = "${target_out_dir}/${static_lib_out_dir}"
+  }
+
+  static_library("${abi_prefix}_libxnet") {
+    complete_static_lib = true
+    configs -= musl_inherited_configs
+    output_name = "libxnet"
+    output_dir = "${target_out_dir}/${static_lib_out_dir}"
+  }
+
+  static_library("${abi_prefix}_libdl") {
+    complete_static_lib = true
+    configs -= musl_inherited_configs
+    output_name = "libdl"
+    output_dir = "${target_out_dir}/${static_lib_out_dir}"
+  }
+
+  shared_library("${abi_prefix}_libc_musl_shared") {
+    output_dir = "${root_out_dir}/common/common/libc/${shared_lib_out_dir}"
+    output_name = "libc"
+    output_extension = "so"
+
+    libclang_rt_path = rebase_path("${runtime_lib_path}/${musl_target_triple}/${shared_lib_out_dir}")
+
+    ldflags = [
+      "-nostdlib",
+      "-Wl,-e,_dlstart",
+      "-L${libclang_rt_path}",
+      "-lclang_rt.builtins",
+    ]
+
+    remove_configs = musl_inherited_configs
+    remove_configs += [ "//build/config:default_libs" ]
+
+    configs -= musl_inherited_configs
+    configs -= [ "//build/config:default_libs" ]
+    configs += [ ":${abi_prefix}_musl_config" ]
+
+    deps = [
+      ":${abi_prefix}_musl_ldso",
+      ":${abi_prefix}_musl_src",
+      ":${abi_prefix}_musl_src_nossp",
+    ]
+  }
+
+  action_foreach("${abi_prefix}_musl_crt_install_action") {
+    redir = "${root_out_dir}/obj"
+    script = "${target_out_dir}/${musl_ported_dir}/scripts/install.py"
+    sources = [
+      "${redir}/${target_out_dir}/${musl_ported_dir}/crt/${musl_arch}/${abi_prefix}_musl_crt/crti.o",
+      "${redir}/${target_out_dir}/${musl_ported_dir}/crt/${musl_arch}/${abi_prefix}_musl_crt/crtn.o",
+      "${redir}/${target_out_dir}/${musl_ported_dir}/crt/${abi_prefix}_musl_crt/Scrt1.o",
+      "${redir}/${target_out_dir}/${musl_ported_dir}/crt/${abi_prefix}_musl_crt/crt1.o",
+      "${redir}/${target_out_dir}/${musl_ported_dir}/crt/${abi_prefix}_musl_crt/rcrt1.o",
+     ]
+
+    outputs = [ "${target_out_dir}/${static_lib_out_dir}/{{source_file_part}}" ]
+
+    args = [
+      "--input",
+      "{{source}}",
+    ]
+    args += [ "--output" ] + rebase_path(outputs, root_build_dir)
+
+    deps = [ ":${abi_prefix}_musl_crt" ]
+  }
+
+  action("${abi_prefix}_create_linker") {
+    script = "${target_out_dir}/${musl_ported_dir}/tools/install.sh"
+    
+    sources = [ "${root_out_dir}/common/common/libc/${shared_lib_out_dir}/libc.so" ]
+
+    outputs = [ "${root_out_dir}/common/common/libc/${shared_lib_out_dir}/ld-musl-${musl_arch}${musl_subarch}.so.1" ]
+
+    args = [ 
+      "-D",
+      "-r",
+    ]
+    args +=  rebase_path(sources)
+    args +=  rebase_path(outputs)
+
+    deps = [ ":${abi_prefix}_libc_musl_shared" ]
+  }
+
+}
diff --git a/third_party/musl/porting/linux/user/Makefile b/third_party/musl/porting/linux/user/Makefile
new file mode 100755
index 000000000..d93a1a0a1
--- /dev/null
+++ b/third_party/musl/porting/linux/user/Makefile
@@ -0,0 +1,236 @@
+#
+# Makefile for musl (requires GNU make)
+#
+# This is how simple every makefile should be...
+# No, I take that back - actually most should be less than half this size.
+#
+# Use config.mak to override any of the following variables.
+# Do not make changes here.
+#
+
+srcdir = .
+exec_prefix = /usr/local
+bindir = $(exec_prefix)/bin
+
+prefix = /usr/local/musl
+includedir = $(prefix)/include
+libdir = $(prefix)/lib
+syslibdir = /lib
+
+SRC_DIRS = $(addprefix $(srcdir)/,src/* crt ldso $(COMPAT_SRC_DIRS))
+BASE_GLOBS = $(addsuffix /*.c,$(SRC_DIRS))
+ARCH_GLOBS = $(addsuffix /$(ARCH)/*.[csS],$(SRC_DIRS))
+BASE_SRCS = $(sort $(wildcard $(BASE_GLOBS)))
+ARCH_SRCS = $(sort $(wildcard $(ARCH_GLOBS)))
+BASE_OBJS = $(patsubst $(srcdir)/%,%.o,$(basename $(BASE_SRCS)))
+ARCH_OBJS = $(patsubst $(srcdir)/%,%.o,$(basename $(ARCH_SRCS)))
+REPLACED_OBJS = $(sort $(subst /$(ARCH)/,/,$(ARCH_OBJS)))
+ALL_OBJS = $(addprefix obj/, $(filter-out $(REPLACED_OBJS), $(sort $(BASE_OBJS) $(ARCH_OBJS))))
+
+LIBC_OBJS = $(filter obj/src/%,$(ALL_OBJS)) $(filter obj/compat/%,$(ALL_OBJS))
+LDSO_OBJS = $(filter obj/ldso/%,$(ALL_OBJS:%.o=%.lo))
+CRT_OBJS = $(filter obj/crt/%,$(ALL_OBJS))
+
+AOBJS = $(LIBC_OBJS)
+LOBJS = $(LIBC_OBJS:.o=.lo)
+GENH = obj/include/bits/alltypes.h obj/include/bits/syscall.h
+GENH_INT = obj/src/internal/version.h
+IMPH = $(addprefix $(srcdir)/, src/internal/stdio_impl.h src/internal/pthread_impl.h src/internal/locale_impl.h src/internal/libc.h)
+
+LDFLAGS =
+LDFLAGS_AUTO =
+LIBCC = -lgcc
+CPPFLAGS =
+CFLAGS =
+CFLAGS_AUTO = -Os -pipe
+CFLAGS_C99FSE = -std=c99 -ffreestanding -nostdinc 
+
+CFLAGS_ALL = $(CFLAGS_C99FSE)
+CFLAGS_ALL += -D_XOPEN_SOURCE=700 -I$(srcdir)/arch/$(ARCH) -I$(srcdir)/arch/generic -Iobj/src/internal -I$(srcdir)/src/include -I$(srcdir)/src/internal -Iobj/include -I$(srcdir)/include
+CFLAGS_ALL += $(CPPFLAGS) $(CFLAGS_AUTO) $(CFLAGS)
+
+LDFLAGS_ALL = $(LDFLAGS_AUTO) $(LDFLAGS)
+
+AR      = $(CROSS_COMPILE)ar
+RANLIB  = $(CROSS_COMPILE)ranlib
+INSTALL = $(srcdir)/tools/install.sh
+
+ARCH_INCLUDES = $(wildcard $(srcdir)/arch/$(ARCH)/bits/*.h)
+GENERIC_INCLUDES = $(wildcard $(srcdir)/arch/generic/bits/*.h)
+INCLUDES = $(wildcard $(srcdir)/include/*.h $(srcdir)/include/*/*.h)
+ALL_INCLUDES = $(sort $(INCLUDES:$(srcdir)/%=%) $(GENH:obj/%=%) $(ARCH_INCLUDES:$(srcdir)/arch/$(ARCH)/%=include/%) $(GENERIC_INCLUDES:$(srcdir)/arch/generic/%=include/%))
+
+EMPTY_LIB_NAMES = m rt pthread crypt util xnet resolv dl
+EMPTY_LIBS = $(EMPTY_LIB_NAMES:%=lib/lib%.a)
+CRT_LIBS = $(addprefix lib/,$(notdir $(CRT_OBJS)))
+STATIC_LIBS = lib/libc.a
+SHARED_LIBS = lib/libc.so
+TOOL_LIBS = lib/musl-gcc.specs
+ALL_LIBS = $(CRT_LIBS) $(STATIC_LIBS) $(SHARED_LIBS) $(EMPTY_LIBS) $(TOOL_LIBS)
+ALL_TOOLS = obj/musl-gcc
+
+WRAPCC_GCC = gcc
+WRAPCC_CLANG = clang
+
+LDSO_PATHNAME = $(syslibdir)/ld-musl-$(ARCH)$(SUBARCH).so.1
+
+-include config.mak
+-include $(srcdir)/arch/$(ARCH)/arch.mak
+
+ifeq ($(ARCH),)
+
+all:
+	@echo "Please set ARCH in config.mak before running make."
+	@exit 1
+
+else
+
+all: $(ALL_LIBS) $(ALL_TOOLS)
+
+OBJ_DIRS = $(sort $(patsubst %/,%,$(dir $(ALL_LIBS) $(ALL_TOOLS) $(ALL_OBJS) $(GENH) $(GENH_INT))) obj/include)
+
+$(ALL_LIBS) $(ALL_TOOLS) $(ALL_OBJS) $(ALL_OBJS:%.o=%.lo) $(GENH) $(GENH_INT): | $(OBJ_DIRS)
+
+$(OBJ_DIRS):
+	mkdir -p $@
+
+obj/include/bits/alltypes.h: $(srcdir)/arch/$(ARCH)/bits/alltypes.h.in $(srcdir)/include/alltypes.h.in $(srcdir)/tools/mkalltypes.sed
+	sed -f $(srcdir)/tools/mkalltypes.sed $(srcdir)/arch/$(ARCH)/bits/alltypes.h.in $(srcdir)/include/alltypes.h.in > $@
+
+obj/include/bits/syscall.h: $(srcdir)/arch/$(ARCH)/bits/syscall.h.in
+	cp $< $@
+	sed -n -e s/__NR_/SYS_/p < $< >> $@
+
+obj/src/internal/version.h: $(wildcard $(srcdir)/VERSION $(srcdir)/.git)
+	printf '#define VERSION "%s"\n' "$$(cd $(srcdir); sh tools/version.sh)" > $@
+
+obj/src/internal/version.o obj/src/internal/version.lo: obj/src/internal/version.h
+
+obj/crt/rcrt1.o obj/ldso/dlstart.lo obj/ldso/dynlink.lo: $(srcdir)/src/internal/dynlink.h $(srcdir)/arch/$(ARCH)/reloc.h
+
+obj/crt/crt1.o obj/crt/scrt1.o obj/crt/rcrt1.o obj/ldso/dlstart.lo: $(srcdir)/arch/$(ARCH)/crt_arch.h
+
+obj/crt/rcrt1.o: $(srcdir)/ldso/dlstart.c
+
+obj/crt/Scrt1.o obj/crt/rcrt1.o: CFLAGS_ALL += -fPIC
+
+OPTIMIZE_SRCS = $(wildcard $(OPTIMIZE_GLOBS:%=$(srcdir)/src/%))
+$(OPTIMIZE_SRCS:$(srcdir)/%.c=obj/%.o) $(OPTIMIZE_SRCS:$(srcdir)/%.c=obj/%.lo): CFLAGS += -O3
+
+MEMOPS_OBJS = $(filter %/memcpy.o %/memmove.o %/memcmp.o %/memset.o, $(LIBC_OBJS))
+$(MEMOPS_OBJS) $(MEMOPS_OBJS:%.o=%.lo): CFLAGS_ALL += $(CFLAGS_MEMOPS)
+
+NOSSP_OBJS = $(CRT_OBJS) $(LDSO_OBJS) $(filter \
+	%/__libc_start_main.o %/__init_tls.o %/__stack_chk_fail.o \
+	%/__set_thread_area.o %/memset.o %/memcpy.o \
+	, $(LIBC_OBJS))
+$(NOSSP_OBJS) $(NOSSP_OBJS:%.o=%.lo): CFLAGS_ALL += $(CFLAGS_NOSSP)
+
+$(CRT_OBJS): CFLAGS_ALL += -DCRT
+
+$(LOBJS) $(LDSO_OBJS): CFLAGS_ALL += -fPIC
+
+CC_CMD = $(CC) $(CFLAGS_ALL) -c -o $@ $<
+
+# Choose invocation of assembler to be used
+ifeq ($(ADD_CFI),yes)
+	AS_CMD = LC_ALL=C awk -f $(srcdir)/tools/add-cfi.common.awk -f $(srcdir)/tools/add-cfi.$(ARCH).awk $< | $(CC) $(CFLAGS_ALL) -x assembler -c -o $@ -
+else
+	AS_CMD = $(CC_CMD)
+endif
+
+obj/%.o: $(srcdir)/%.s
+	$(AS_CMD)
+
+obj/%.o: $(srcdir)/%.S
+	$(CC_CMD)
+
+obj/%.o: $(srcdir)/%.c $(GENH) $(IMPH)
+	$(CC_CMD)
+
+obj/%.lo: $(srcdir)/%.s
+	$(AS_CMD)
+
+obj/%.lo: $(srcdir)/%.S
+	$(CC_CMD)
+
+obj/%.lo: $(srcdir)/%.c $(GENH) $(IMPH)
+	$(CC_CMD)
+
+lib/libc.so: $(LOBJS) $(LDSO_OBJS)
+	$(CC) $(CFLAGS_ALL) $(LDFLAGS_ALL) -nostdlib -shared \
+	-Wl,-e,_dlstart -o $@ $(LOBJS) $(LDSO_OBJS) $(LIBCC)
+
+lib/libc.a: $(AOBJS)
+	rm -f $@
+	$(AR) rc $@ $(AOBJS)
+	$(RANLIB) $@
+
+$(EMPTY_LIBS):
+	rm -f $@
+	$(AR) rc $@
+
+lib/%.o: obj/crt/$(ARCH)/%.o
+	cp $< $@
+
+lib/%.o: obj/crt/%.o
+	cp $< $@
+
+lib/musl-gcc.specs: $(srcdir)/tools/musl-gcc.specs.sh config.mak
+	sh $< "$(includedir)" "$(libdir)" "$(LDSO_PATHNAME)" > $@
+
+obj/musl-gcc: config.mak
+	printf '#!/bin/sh\nexec "$${REALGCC:-$(WRAPCC_GCC)}" "$$@" -specs "%s/musl-gcc.specs"\n' "$(libdir)" > $@
+	chmod +x $@
+
+obj/%-clang: $(srcdir)/tools/%-clang.in config.mak
+	sed -e 's!@CC@!$(WRAPCC_CLANG)!g' -e 's!@PREFIX@!$(prefix)!g' -e 's!@INCDIR@!$(includedir)!g' -e 's!@LIBDIR@!$(libdir)!g' -e 's!@LDSO@!$(LDSO_PATHNAME)!g' $< > $@
+	chmod +x $@
+
+$(DESTDIR)$(bindir)/%: obj/%
+	$(INSTALL) -D $< $@
+
+$(DESTDIR)$(libdir)/%.so: lib/%.so
+	$(INSTALL) -D -m 755 $< $@
+
+$(DESTDIR)$(libdir)/%: lib/%
+	$(INSTALL) -D -m 644 $< $@
+
+$(DESTDIR)$(includedir)/bits/%: $(srcdir)/arch/$(ARCH)/bits/%
+	$(INSTALL) -D -m 644 $< $@
+
+$(DESTDIR)$(includedir)/bits/%: $(srcdir)/arch/generic/bits/%
+	$(INSTALL) -D -m 644 $< $@
+
+$(DESTDIR)$(includedir)/bits/%: obj/include/bits/%
+	$(INSTALL) -D -m 644 $< $@
+
+$(DESTDIR)$(includedir)/%: $(srcdir)/include/%
+	$(INSTALL) -D -m 644 $< $@
+
+$(DESTDIR)$(LDSO_PATHNAME): $(DESTDIR)$(libdir)/libc.so
+	$(INSTALL) -D -r $(DESTDIR)$(libdir)/libc.so $@ || true
+
+install-libs: $(ALL_LIBS:lib/%=$(DESTDIR)$(libdir)/%) $(if $(SHARED_LIBS),$(DESTDIR)$(LDSO_PATHNAME),)
+
+install-headers: $(ALL_INCLUDES:include/%=$(DESTDIR)$(includedir)/%)
+
+install-tools: $(ALL_TOOLS:obj/%=$(DESTDIR)$(bindir)/%)
+
+install: install-libs install-headers install-tools
+
+musl-git-%.tar.gz: .git
+	 git --git-dir=$(srcdir)/.git archive --format=tar.gz --prefix=$(patsubst %.tar.gz,%,$@)/ -o $@ $(patsubst musl-git-%.tar.gz,%,$@)
+
+musl-%.tar.gz: .git
+	 git --git-dir=$(srcdir)/.git archive --format=tar.gz --prefix=$(patsubst %.tar.gz,%,$@)/ -o $@ v$(patsubst musl-%.tar.gz,%,$@)
+
+endif
+
+clean:
+	rm -rf obj lib
+
+distclean: clean
+	rm -f config.mak
+
+.PHONY: all clean install install-libs install-headers install-tools
diff --git a/third_party/musl/porting/linux/user/arch/arm/bits/fenv.h b/third_party/musl/porting/linux/user/arch/arm/bits/fenv.h
new file mode 100755
index 000000000..b497a9878
--- /dev/null
+++ b/third_party/musl/porting/linux/user/arch/arm/bits/fenv.h
@@ -0,0 +1,23 @@
+#ifndef __ARM_PCS_VFP
+#define FE_ALL_EXCEPT 0
+#define FE_TONEAREST  0
+#else
+#define FE_INVALID    1
+#define FE_DIVBYZERO  2
+#define FE_OVERFLOW   4
+#define FE_UNDERFLOW  8
+#define FE_INEXACT    16
+#define FE_ALL_EXCEPT 31
+#define FE_TONEAREST  0
+#define FE_TOWARDZERO 0xc00000
+#endif
+#define FE_DOWNWARD   0x800000
+#define FE_UPWARD     0x400000
+
+typedef unsigned long fexcept_t;
+
+typedef struct {
+	unsigned long __cw;
+} fenv_t;
+
+#define FE_DFL_ENV      ((const fenv_t *) -1)
diff --git a/third_party/musl/porting/linux/user/arch/generic/bits/shm.h b/third_party/musl/porting/linux/user/arch/generic/bits/shm.h
new file mode 100755
index 000000000..da07a2a0c
--- /dev/null
+++ b/third_party/musl/porting/linux/user/arch/generic/bits/shm.h
@@ -0,0 +1,24 @@
+#define SHMLBA (4*4096)
+
+struct shmid_ds {
+	struct ipc_perm shm_perm;
+	size_t shm_segsz;
+	time_t shm_atime;
+	time_t shm_dtime;
+	time_t shm_ctime;
+	pid_t shm_cpid;
+	pid_t shm_lpid;
+	unsigned long shm_nattch;
+	unsigned long __pad1;
+	unsigned long __pad2;
+};
+
+struct shminfo {
+	unsigned long shmmax, shmmin, shmmni, shmseg, shmall, __unused[4];
+};
+
+struct shm_info {
+	int __used_ids;
+	unsigned long shm_tot, shm_rss, shm_swp;
+	unsigned long __swap_attempts, __swap_successes;
+};
diff --git a/third_party/musl/kernel_m/include/alltypes.h.in b/third_party/musl/porting/linux/user/include/alltypes.h.in
similarity index 53%
rename from third_party/musl/kernel_m/include/alltypes.h.in
rename to third_party/musl/porting/linux/user/include/alltypes.h.in
index 2348b3bd6..8903736cd 100755
--- a/third_party/musl/kernel_m/include/alltypes.h.in
+++ b/third_party/musl/porting/linux/user/include/alltypes.h.in
@@ -2,113 +2,6 @@
 #define __BIG_ENDIAN 4321
 #define __USE_TIME_BITS64 1
 
-#ifdef __ICCARM__
-#if defined(__NEED_size_t) && !defined(__DEFINED_size_t)
-#include <stddef.h>
-#define __DEFINED_size_t
-#endif
-
-#if defined(__NEED_uintptr_t) && !defined(__DEFINED_uintptr_t)
-#include <stdint.h>
-#define __DEFINED_uintptr_t
-#endif
-
-#if defined(__NEED_ptrdiff_t) && !defined(__DEFINED_ptrdiff_t)
-#include <stddef.h>
-#define __DEFINED_ptrdiff_t
-#endif
-
-#if defined(__NEED_intptr_t) && !defined(__DEFINED_intptr_t)
-#include <stdint.h>
-#define __DEFINED_intptr_t
-#endif
-
-#if defined(__NEED_time_t) && !defined(__DEFINED_time_t)
-#include <time.h>
-#define __DEFINED_time_t
-#endif
-
-#if defined(__NEED_clock_t) && !defined(__DEFINED_clock_t)
-#include <time.h>
-#define __DEFINED_clock_t
-#endif
-
-#if defined(__NEED_struct_timespec) && !defined(__DEFINED_struct_timespec)
-#include <time.h>
-#define __DEFINED_struct_timespec
-#endif
-
-#if defined(__NEED_wint_t) && !defined(__DEFINED_wint_t)
-#include <wchar.h>
-#define __DEFINED_wint_t
-#endif
-
-#if defined(__NEED_wctype_t) && !defined(__DEFINED_wctype_t)
-#include <wchar.h>
-#define __DEFINED_wctype_t
-#endif
-
-#if defined(__NEED_va_list) && !defined(__DEFINED_va_list)
-#include <stdarg.h>
-#define __DEFINED_va_list
-#endif
-
-#if defined(__NEED_mbstate_t) && !defined(__DEFINED_mbstate_t)
-#include <wchar.h>
-#define __DEFINED_mbstate_t
-#endif
-
-#if defined(__NEED_int8_t) && !defined(__DEFINED_int8_t) && defined(__INT8_T_TYPE__)
-#include <stdint.h>
-#define __DEFINED_int8_t
-#endif
-
-#if defined(__NEED_int16_t) && !defined(__DEFINED_int16_t) && defined(__INT16_T_TYPE__)
-#include <stdint.h>
-#define __DEFINED_int16_t
-#endif
-
-#if defined(__NEED_int32_t) && !defined(__DEFINED_int32_t) && defined(__INT32_T_TYPE__)
-#include <stdint.h>
-#define __DEFINED_int32_t
-#endif
-
-#if defined(__NEED_int64_t) && !defined(__DEFINED_int64_t) && defined(__INT64_T_TYPE__)
-#include <stdint.h>
-#define __DEFINED_int64_t
-#endif
-
-#if defined(__NEED_uint8_t) && !defined(__DEFINED_uint8_t) && defined(__UINT8_T_TYPE__)
-#include <stdint.h>
-#define __DEFINED_uint8_t
-#endif
-
-#if defined(__NEED_uint16_t) && !defined(__DEFINED_uint16_t) && defined(__UINT16_T_TYPE__)
-#include <stdint.h>
-#define __DEFINED_uint16_t
-#endif
-
-#if defined(__NEED_uint32_t) && !defined(__DEFINED_uint32_t) && defined(__UINT32_T_TYPE__)
-#include <stdint.h>
-#define __DEFINED_uint32_t
-#endif
-
-#if defined(__NEED_uint64_t) && !defined(__DEFINED_uint64_t) && defined(__UINT64_T_TYPE__)
-#include <stdint.h>
-#define __DEFINED_uint64_t
-#endif
-
-#if defined(__NEED_intmax_t) && !defined(__DEFINED_intmax_t)
-#include <stdint.h>
-#define __DEFINED_intmax_t
-#endif
-
-#if defined(__NEED_uintmax_t) && !defined(__DEFINED_uintmax_t)
-#include <stdint.h>
-#define __DEFINED_uintmax_t
-#endif
-#endif /* __ICCARM__ */
-
 TYPEDEF unsigned _Addr size_t;
 TYPEDEF unsigned _Addr uintptr_t;
 TYPEDEF _Addr ptrdiff_t;
@@ -116,8 +9,8 @@ TYPEDEF _Addr ssize_t;
 TYPEDEF _Addr intptr_t;
 TYPEDEF _Addr regoff_t;
 TYPEDEF _Reg register_t;
-TYPEDEF _Int64 time_t;
-TYPEDEF _Int64 suseconds_t;
+TYPEDEF long time_t;
+TYPEDEF long suseconds_t;
 
 TYPEDEF signed char     int8_t;
 TYPEDEF signed short    int16_t;
@@ -188,7 +81,7 @@ TYPEDEF unsigned socklen_t;
 TYPEDEF unsigned short sa_family_t;
 
 TYPEDEF struct { union { int __i[sizeof(long)==8?14:9]; volatile int __vi[sizeof(long)==8?14:9]; unsigned long __s[sizeof(long)==8?7:9]; } __u; } pthread_attr_t;
-TYPEDEF struct { unsigned int magic; unsigned int handle; } pthread_mutex_t;
+TYPEDEF struct { union { int __i[sizeof(long)==8?10:6]; volatile int __vi[sizeof(long)==8?10:6]; volatile void *volatile __p[sizeof(long)==8?5:6]; } __u; } pthread_mutex_t;
 TYPEDEF struct { union { int __i[sizeof(long)==8?10:6]; volatile int __vi[sizeof(long)==8?10:6]; volatile void *volatile __p[sizeof(long)==8?5:6]; } __u; } mtx_t;
 TYPEDEF struct { union { int __i[12]; volatile int __vi[12]; void *__p[12*sizeof(int)/sizeof(void*)]; } __u; } pthread_cond_t;
 TYPEDEF struct { union { int __i[12]; volatile int __vi[12]; void *__p[12*sizeof(int)/sizeof(void*)]; } __u; } cnd_t;
diff --git a/third_party/musl/porting/linux/user/include/ctype.h b/third_party/musl/porting/linux/user/include/ctype.h
new file mode 100755
index 000000000..7b91d3ef6
--- /dev/null
+++ b/third_party/musl/porting/linux/user/include/ctype.h
@@ -0,0 +1,80 @@
+#ifndef	_CTYPE_H
+#define	_CTYPE_H
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#include <features.h>
+
+int   isalnum(int);
+int   isalpha(int);
+int   isblank(int);
+int   iscntrl(int);
+int   isdigit(int);
+int   isgraph(int);
+int   islower(int);
+int   isprint(int);
+int   ispunct(int);
+int   isspace(int);
+int   isupper(int);
+int   isxdigit(int);
+int   tolower(int);
+int   toupper(int);
+
+#ifndef __cplusplus
+static __inline int __isspace(int _c)
+{
+	return _c == ' ' || (unsigned)_c-'\t' < 5;
+}
+
+#define isalpha(a) (0 ? isalpha(a) : (((unsigned)(a)|32)-'a') < 26)
+#define isdigit(a) (0 ? isdigit(a) : ((unsigned)(a)-'0') < 10)
+#define islower(a) (0 ? islower(a) : ((unsigned)(a)-'a') < 26)
+#define isupper(a) (0 ? isupper(a) : ((unsigned)(a)-'A') < 26)
+#define isprint(a) (0 ? isprint(a) : ((unsigned)(a)-0x20) < 0x5f)
+#define isgraph(a) (0 ? isgraph(a) : ((unsigned)(a)-0x21) < 0x5e)
+#define isspace(a) __isspace(a)
+#endif
+
+
+#if defined(_POSIX_SOURCE) || defined(_POSIX_C_SOURCE) \
+ || defined(_XOPEN_SOURCE) || defined(_GNU_SOURCE) \
+ || defined(_BSD_SOURCE)
+
+#define __NEED_locale_t
+#include <bits/alltypes.h>
+
+int   isalnum_l(int, locale_t);
+int   isalpha_l(int, locale_t);
+int   isblank_l(int, locale_t);
+int   iscntrl_l(int, locale_t);
+int   isdigit_l(int, locale_t);
+int   isgraph_l(int, locale_t);
+int   islower_l(int, locale_t);
+int   isprint_l(int, locale_t);
+int   ispunct_l(int, locale_t);
+int   isspace_l(int, locale_t);
+int   isupper_l(int, locale_t);
+int   isxdigit_l(int, locale_t);
+int   tolower_l(int, locale_t);
+int   toupper_l(int, locale_t);
+
+int   isascii(int);
+int   toascii(int);
+#define _tolower(a) ((a)|0x20)
+#define _toupper(a) ((a)&0x5f)
+#define isascii(a) (0 ? isascii(a) : (unsigned)(a) < 128)
+
+#include <stdint.h>
+
+const int32_t **__ctype_tolower_loc(void);
+const int32_t **__ctype_toupper_loc(void);
+
+#endif
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
diff --git a/third_party/musl/porting/linux/user/include/pthread.h b/third_party/musl/porting/linux/user/include/pthread.h
new file mode 100755
index 000000000..73793e47e
--- /dev/null
+++ b/third_party/musl/porting/linux/user/include/pthread.h
@@ -0,0 +1,258 @@
+#ifndef _PTHREAD_H
+#define _PTHREAD_H
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#include <features.h>
+
+/* Musl did not provide the "owner" macro directly,
+ * so users can not access the mutex-ower-ID.
+ * Thus we added this macro for getting the owner-ID
+ * of the mutex. */
+#define MUTEX_OWNER __u.__vi[1] & 0x7fffffff
+
+/* These macros provides macros for accessing inner
+ * attributes of the pthread_mutex_t struct.
+ * It is intended for solving the coompiling failure
+ * of Dopra codes which claims that .__data.* realm
+ * can not be found in pthread_mutex_t. */
+#define MUTEX_TYPE __u.__i[0]
+#define MUTEX_LOCK __u.__vi[1]
+#define MUTEX_WAITERS __u.__vi[2]
+#define MUTEX_PREV __u.__p[3]
+#define MUTEX_NEXT __u.__p[4]
+#define MUTEX_COUNT __u.__i[5]
+
+#define __NEED_time_t
+#define __NEED_clockid_t
+#define __NEED_struct_timespec
+#define __NEED_sigset_t
+#define __NEED_pthread_t
+#define __NEED_pthread_attr_t
+#define __NEED_pthread_mutexattr_t
+#define __NEED_pthread_condattr_t
+#define __NEED_pthread_rwlockattr_t
+#define __NEED_pthread_barrierattr_t
+#define __NEED_pthread_mutex_t
+#define __NEED_pthread_cond_t
+#define __NEED_pthread_rwlock_t
+#define __NEED_pthread_barrier_t
+#define __NEED_pthread_spinlock_t
+#define __NEED_pthread_key_t
+#define __NEED_pthread_once_t
+#define __NEED_size_t
+
+#include <bits/alltypes.h>
+
+#include <sched.h>
+#include <time.h>
+
+#define PTHREAD_CREATE_JOINABLE 0
+#define PTHREAD_CREATE_DETACHED 1
+
+#define PTHREAD_MUTEX_NORMAL 0
+#define PTHREAD_MUTEX_DEFAULT 0
+#define PTHREAD_MUTEX_RECURSIVE 1
+#define PTHREAD_MUTEX_ERRORCHECK 2
+
+#define PTHREAD_MUTEX_STALLED 0
+#define PTHREAD_MUTEX_ROBUST 1
+
+#define PTHREAD_PRIO_NONE 0
+#define PTHREAD_PRIO_INHERIT 1
+#define PTHREAD_PRIO_PROTECT 2
+
+#define PTHREAD_INHERIT_SCHED 0
+#define PTHREAD_EXPLICIT_SCHED 1
+
+#define PTHREAD_SCOPE_SYSTEM 0
+#define PTHREAD_SCOPE_PROCESS 1
+
+#define PTHREAD_PROCESS_PRIVATE 0
+#define PTHREAD_PROCESS_SHARED 1
+
+
+#define PTHREAD_MUTEX_INITIALIZER {{{0}}}
+#define PTHREAD_RWLOCK_INITIALIZER {{{0}}}
+#define PTHREAD_COND_INITIALIZER {{{0}}}
+#define PTHREAD_ONCE_INIT 0
+
+
+#define PTHREAD_CANCEL_ENABLE 0
+#define PTHREAD_CANCEL_DISABLE 1
+#define PTHREAD_CANCEL_MASKED 2
+
+#define PTHREAD_CANCEL_DEFERRED 0
+#define PTHREAD_CANCEL_ASYNCHRONOUS 1
+
+#define PTHREAD_CANCELED ((void *)-1)
+
+
+#define PTHREAD_BARRIER_SERIAL_THREAD (-1)
+
+
+int pthread_create(pthread_t *__restrict, const pthread_attr_t *__restrict, void *(*)(void *), void *__restrict);
+int pthread_detach(pthread_t);
+_Noreturn void pthread_exit(void *);
+int pthread_join(pthread_t, void **);
+
+#ifdef __GNUC__
+__attribute__((const))
+#endif
+pthread_t pthread_self(void);
+
+int pthread_equal(pthread_t, pthread_t);
+#ifndef __cplusplus
+#define pthread_equal(x,y) ((x)==(y))
+#endif
+
+int pthread_setcancelstate(int, int *);
+int pthread_setcanceltype(int, int *);
+void pthread_testcancel(void);
+int pthread_cancel(pthread_t);
+
+int pthread_getschedparam(pthread_t, int *__restrict, struct sched_param *__restrict);
+int pthread_setschedparam(pthread_t, int, const struct sched_param *);
+int pthread_setschedprio(pthread_t, int);
+
+int pthread_once(pthread_once_t *, void (*)(void));
+
+int pthread_mutex_init(pthread_mutex_t *__restrict, const pthread_mutexattr_t *__restrict);
+int pthread_mutex_lock(pthread_mutex_t *);
+int pthread_mutex_unlock(pthread_mutex_t *);
+int pthread_mutex_trylock(pthread_mutex_t *);
+int pthread_mutex_timedlock(pthread_mutex_t *__restrict, const struct timespec *__restrict);
+int pthread_mutex_destroy(pthread_mutex_t *);
+int pthread_mutex_consistent(pthread_mutex_t *);
+
+int pthread_mutex_getprioceiling(const pthread_mutex_t *__restrict, int *__restrict);
+int pthread_mutex_setprioceiling(pthread_mutex_t *__restrict, int, int *__restrict);
+
+int pthread_cond_init(pthread_cond_t *__restrict, const pthread_condattr_t *__restrict);
+int pthread_cond_destroy(pthread_cond_t *);
+int pthread_cond_wait(pthread_cond_t *__restrict, pthread_mutex_t *__restrict);
+int pthread_cond_timedwait(pthread_cond_t *__restrict, pthread_mutex_t *__restrict, const struct timespec *__restrict);
+int pthread_cond_broadcast(pthread_cond_t *);
+int pthread_cond_signal(pthread_cond_t *);
+
+int pthread_rwlock_init(pthread_rwlock_t *__restrict, const pthread_rwlockattr_t *__restrict);
+int pthread_rwlock_destroy(pthread_rwlock_t *);
+int pthread_rwlock_rdlock(pthread_rwlock_t *);
+int pthread_rwlock_tryrdlock(pthread_rwlock_t *);
+int pthread_rwlock_timedrdlock(pthread_rwlock_t *__restrict, const struct timespec *__restrict);
+int pthread_rwlock_wrlock(pthread_rwlock_t *);
+int pthread_rwlock_trywrlock(pthread_rwlock_t *);
+int pthread_rwlock_timedwrlock(pthread_rwlock_t *__restrict, const struct timespec *__restrict);
+int pthread_rwlock_unlock(pthread_rwlock_t *);
+
+int pthread_spin_init(pthread_spinlock_t *, int);
+int pthread_spin_destroy(pthread_spinlock_t *);
+int pthread_spin_lock(pthread_spinlock_t *);
+int pthread_spin_trylock(pthread_spinlock_t *);
+int pthread_spin_unlock(pthread_spinlock_t *);
+
+int pthread_barrier_init(pthread_barrier_t *__restrict, const pthread_barrierattr_t *__restrict, unsigned);
+int pthread_barrier_destroy(pthread_barrier_t *);
+int pthread_barrier_wait(pthread_barrier_t *);
+
+int pthread_key_create(pthread_key_t *, void (*)(void *));
+int pthread_key_delete(pthread_key_t);
+void *pthread_getspecific(pthread_key_t);
+int pthread_setspecific(pthread_key_t, const void *);
+
+int pthread_attr_init(pthread_attr_t *);
+int pthread_attr_destroy(pthread_attr_t *);
+
+int pthread_attr_getguardsize(const pthread_attr_t *__restrict, size_t *__restrict);
+int pthread_attr_setguardsize(pthread_attr_t *, size_t);
+int pthread_attr_getstacksize(const pthread_attr_t *__restrict, size_t *__restrict);
+int pthread_attr_setstacksize(pthread_attr_t *, size_t);
+int pthread_attr_getdetachstate(const pthread_attr_t *, int *);
+int pthread_attr_setdetachstate(pthread_attr_t *, int);
+int pthread_attr_getstack(const pthread_attr_t *__restrict, void **__restrict, size_t *__restrict);
+int pthread_attr_setstack(pthread_attr_t *, void *, size_t);
+int pthread_attr_getscope(const pthread_attr_t *__restrict, int *__restrict);
+int pthread_attr_setscope(pthread_attr_t *, int);
+int pthread_attr_getschedpolicy(const pthread_attr_t *__restrict, int *__restrict);
+int pthread_attr_setschedpolicy(pthread_attr_t *, int);
+int pthread_attr_getschedparam(const pthread_attr_t *__restrict, struct sched_param *__restrict);
+int pthread_attr_setschedparam(pthread_attr_t *__restrict, const struct sched_param *__restrict);
+int pthread_attr_getinheritsched(const pthread_attr_t *__restrict, int *__restrict);
+int pthread_attr_setinheritsched(pthread_attr_t *, int);
+
+int pthread_mutexattr_destroy(pthread_mutexattr_t *);
+int pthread_mutexattr_getprioceiling(const pthread_mutexattr_t *__restrict, int *__restrict);
+int pthread_mutexattr_getprotocol(const pthread_mutexattr_t *__restrict, int *__restrict);
+int pthread_mutexattr_getpshared(const pthread_mutexattr_t *__restrict, int *__restrict);
+int pthread_mutexattr_getrobust(const pthread_mutexattr_t *__restrict, int *__restrict);
+int pthread_mutexattr_gettype(const pthread_mutexattr_t *__restrict, int *__restrict);
+int pthread_mutexattr_init(pthread_mutexattr_t *);
+int pthread_mutexattr_setprioceiling(pthread_mutexattr_t *, int);
+int pthread_mutexattr_setprotocol(pthread_mutexattr_t *, int);
+int pthread_mutexattr_setpshared(pthread_mutexattr_t *, int);
+int pthread_mutexattr_setrobust(pthread_mutexattr_t *, int);
+int pthread_mutexattr_settype(pthread_mutexattr_t *, int);
+
+int pthread_condattr_init(pthread_condattr_t *);
+int pthread_condattr_destroy(pthread_condattr_t *);
+int pthread_condattr_setclock(pthread_condattr_t *, clockid_t);
+int pthread_condattr_setpshared(pthread_condattr_t *, int);
+int pthread_condattr_getclock(const pthread_condattr_t *__restrict, clockid_t *__restrict);
+int pthread_condattr_getpshared(const pthread_condattr_t *__restrict, int *__restrict);
+
+int pthread_rwlockattr_init(pthread_rwlockattr_t *);
+int pthread_rwlockattr_destroy(pthread_rwlockattr_t *);
+int pthread_rwlockattr_setpshared(pthread_rwlockattr_t *, int);
+int pthread_rwlockattr_getpshared(const pthread_rwlockattr_t *__restrict, int *__restrict);
+
+int pthread_barrierattr_destroy(pthread_barrierattr_t *);
+int pthread_barrierattr_getpshared(const pthread_barrierattr_t *__restrict, int *__restrict);
+int pthread_barrierattr_init(pthread_barrierattr_t *);
+int pthread_barrierattr_setpshared(pthread_barrierattr_t *, int);
+
+int pthread_atfork(void (*)(void), void (*)(void), void (*)(void));
+
+int pthread_getconcurrency(void);
+int pthread_setconcurrency(int);
+
+int pthread_getcpuclockid(pthread_t, clockid_t *);
+
+struct __ptcb {
+	void (*__f)(void *);
+	void *__x;
+	struct __ptcb *__next;
+};
+
+void _pthread_cleanup_push(struct __ptcb *, void (*)(void *), void *);
+void _pthread_cleanup_pop(struct __ptcb *, int);
+
+#define pthread_cleanup_push(f, x) do { struct __ptcb __cb; _pthread_cleanup_push(&__cb, f, x);
+#define pthread_cleanup_pop(r) _pthread_cleanup_pop(&__cb, (r)); } while(0)
+
+#ifdef _GNU_SOURCE
+struct cpu_set_t;
+int pthread_getaffinity_np(pthread_t, size_t, struct cpu_set_t *);
+int pthread_setaffinity_np(pthread_t, size_t, const struct cpu_set_t *);
+int pthread_getattr_np(pthread_t, pthread_attr_t *);
+int pthread_setname_np(pthread_t, const char *);
+int pthread_getattr_default_np(pthread_attr_t *);
+int pthread_setattr_default_np(const pthread_attr_t *);
+int pthread_tryjoin_np(pthread_t, void **);
+int pthread_timedjoin_np(pthread_t, void **, const struct timespec *);
+#endif
+
+#if _REDIR_TIME64
+__REDIR(pthread_mutex_timedlock, __pthread_mutex_timedlock_time64);
+__REDIR(pthread_cond_timedwait, __pthread_cond_timedwait_time64);
+__REDIR(pthread_rwlock_timedrdlock, __pthread_rwlock_timedrdlock_time64);
+__REDIR(pthread_rwlock_timedwrlock, __pthread_rwlock_timedwrlock_time64);
+#ifdef _GNU_SOURCE
+__REDIR(pthread_timedjoin_np, __pthread_timedjoin_np_time64);
+#endif
+#endif
+
+#ifdef __cplusplus
+}
+#endif
+#endif
diff --git a/third_party/musl/porting/linux/user/include/sys/capability.h b/third_party/musl/porting/linux/user/include/sys/capability.h
new file mode 100755
index 000000000..ed2ff9778
--- /dev/null
+++ b/third_party/musl/porting/linux/user/include/sys/capability.h
@@ -0,0 +1,48 @@
+/*
+ * Copyright (c) 2013-2019, Huawei Technologies Co., Ltd. All rights reserved.
+ * Copyright (c) 2020, Huawei Device Co., Ltd. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without modification,
+ * are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice, this list of
+ *    conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright notice, this list
+ *    of conditions and the following disclaimer in the documentation and/or other materials
+ *    provided with the distribution.
+ *
+ * 3. Neither the name of the copyright holder nor the names of its contributors may be used
+ *    to endorse or promote products derived from this software without specific prior written
+ *    permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+ * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+ * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
+ * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
+ * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
+ * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#ifndef _SYS_CAPABILITY_H
+#define _SYS_CAPABILITY_H
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#include <linux/capability.h>
+
+int capget(cap_user_header_t hdr_ptr, cap_user_data_t data_ptr);
+int capset(cap_user_header_t hdr_ptr, const cap_user_data_t data_ptr);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* _SYS_CAPABILITY_H */
diff --git a/third_party/musl/porting/linux/user/include/sys/socket.h b/third_party/musl/porting/linux/user/include/sys/socket.h
new file mode 100755
index 000000000..fe3c46841
--- /dev/null
+++ b/third_party/musl/porting/linux/user/include/sys/socket.h
@@ -0,0 +1,419 @@
+#ifndef	_SYS_SOCKET_H
+#define	_SYS_SOCKET_H
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#include <features.h>
+
+#define __NEED_socklen_t
+#define __NEED_sa_family_t
+#define __NEED_size_t
+#define __NEED_ssize_t
+#define __NEED_uid_t
+#define __NEED_pid_t
+#define __NEED_gid_t
+#define __NEED_struct_iovec
+
+#include <bits/alltypes.h>
+
+#include <bits/socket.h>
+
+#ifdef __MUSL__
+#include <linux/socket.h>
+#endif
+
+struct msghdr {
+	void *msg_name;
+	socklen_t msg_namelen;
+	struct iovec *msg_iov;
+#if __LONG_MAX > 0x7fffffff && __BYTE_ORDER == __BIG_ENDIAN
+	int __pad1;
+#endif
+	int msg_iovlen;
+#if __LONG_MAX > 0x7fffffff && __BYTE_ORDER == __LITTLE_ENDIAN
+	int __pad1;
+#endif
+	void *msg_control;
+#if __LONG_MAX > 0x7fffffff && __BYTE_ORDER == __BIG_ENDIAN
+	int __pad2;
+#endif
+	socklen_t msg_controllen;
+#if __LONG_MAX > 0x7fffffff && __BYTE_ORDER == __LITTLE_ENDIAN
+	int __pad2;
+#endif
+	int msg_flags;
+};
+
+struct cmsghdr {
+#if __LONG_MAX > 0x7fffffff && __BYTE_ORDER == __BIG_ENDIAN
+	int __pad1;
+#endif
+	socklen_t cmsg_len;
+#if __LONG_MAX > 0x7fffffff && __BYTE_ORDER == __LITTLE_ENDIAN
+	int __pad1;
+#endif
+	int cmsg_level;
+	int cmsg_type;
+};
+
+#ifdef _GNU_SOURCE
+struct ucred {
+	pid_t pid;
+	uid_t uid;
+	gid_t gid;
+};
+
+struct mmsghdr {
+	struct msghdr msg_hdr;
+	unsigned int  msg_len;
+};
+
+struct timespec;
+
+int sendmmsg (int, struct mmsghdr *, unsigned int, unsigned int);
+int recvmmsg (int, struct mmsghdr *, unsigned int, unsigned int, struct timespec *);
+#endif
+
+struct linger {
+	int l_onoff;
+	int l_linger;
+};
+
+#define SHUT_RD 0
+#define SHUT_WR 1
+#define SHUT_RDWR 2
+
+#ifndef SOCK_STREAM
+#define SOCK_STREAM    1
+#define SOCK_DGRAM     2
+#endif
+
+#define SOCK_RAW       3
+#define SOCK_RDM       4
+#define SOCK_SEQPACKET 5
+#define SOCK_DCCP      6
+#define SOCK_PACKET    10
+
+#ifndef SOCK_CLOEXEC
+#define SOCK_CLOEXEC   02000000
+#define SOCK_NONBLOCK  04000
+#endif
+
+#define PF_UNSPEC       0
+#define PF_LOCAL        1
+#define PF_UNIX         PF_LOCAL
+#define PF_FILE         PF_LOCAL
+#define PF_INET         2
+#define PF_AX25         3
+#define PF_IPX          4
+#define PF_APPLETALK    5
+#define PF_NETROM       6
+#define PF_BRIDGE       7
+#define PF_ATMPVC       8
+#define PF_X25          9
+#define PF_INET6        10
+#define PF_ROSE         11
+#define PF_DECnet       12
+#define PF_NETBEUI      13
+#define PF_SECURITY     14
+#define PF_KEY          15
+#define PF_NETLINK      16
+#define PF_ROUTE        PF_NETLINK
+#define PF_PACKET       17
+#define PF_ASH          18
+#define PF_ECONET       19
+#define PF_ATMSVC       20
+#define PF_RDS          21
+#define PF_SNA          22
+#define PF_IRDA         23
+#define PF_PPPOX        24
+#define PF_WANPIPE      25
+#define PF_LLC          26
+#define PF_IB           27
+#define PF_MPLS         28
+#define PF_CAN          29
+#define PF_TIPC         30
+#define PF_BLUETOOTH    31
+#define PF_IUCV         32
+#define PF_RXRPC        33
+#define PF_ISDN         34
+#define PF_PHONET       35
+#define PF_IEEE802154   36
+#define PF_CAIF         37
+#define PF_ALG          38
+#define PF_NFC          39
+#define PF_VSOCK        40
+#define PF_KCM          41
+#define PF_QIPCRTR      42
+#define PF_SMC          43
+#define PF_XDP          44
+#define PF_MAX          45
+
+#define AF_UNSPEC       PF_UNSPEC
+#define AF_LOCAL        PF_LOCAL
+#define AF_UNIX         AF_LOCAL
+#define AF_FILE         AF_LOCAL
+#define AF_INET         PF_INET
+#define AF_AX25         PF_AX25
+#define AF_IPX          PF_IPX
+#define AF_APPLETALK    PF_APPLETALK
+#define AF_NETROM       PF_NETROM
+#define AF_BRIDGE       PF_BRIDGE
+#define AF_ATMPVC       PF_ATMPVC
+#define AF_X25          PF_X25
+#define AF_INET6        PF_INET6
+#define AF_ROSE         PF_ROSE
+#define AF_DECnet       PF_DECnet
+#define AF_NETBEUI      PF_NETBEUI
+#define AF_SECURITY     PF_SECURITY
+#define AF_KEY          PF_KEY
+#define AF_NETLINK      PF_NETLINK
+#define AF_ROUTE        PF_ROUTE
+#define AF_PACKET       PF_PACKET
+#define AF_ASH          PF_ASH
+#define AF_ECONET       PF_ECONET
+#define AF_ATMSVC       PF_ATMSVC
+#define AF_RDS          PF_RDS
+#define AF_SNA          PF_SNA
+#define AF_IRDA         PF_IRDA
+#define AF_PPPOX        PF_PPPOX
+#define AF_WANPIPE      PF_WANPIPE
+#define AF_LLC          PF_LLC
+#define AF_IB           PF_IB
+#define AF_MPLS         PF_MPLS
+#define AF_CAN          PF_CAN
+#define AF_TIPC         PF_TIPC
+#define AF_BLUETOOTH    PF_BLUETOOTH
+#define AF_IUCV         PF_IUCV
+#define AF_RXRPC        PF_RXRPC
+#define AF_ISDN         PF_ISDN
+#define AF_PHONET       PF_PHONET
+#define AF_IEEE802154   PF_IEEE802154
+#define AF_CAIF         PF_CAIF
+#define AF_ALG          PF_ALG
+#define AF_NFC          PF_NFC
+#define AF_VSOCK        PF_VSOCK
+#define AF_KCM          PF_KCM
+#define AF_QIPCRTR      PF_QIPCRTR
+#define AF_SMC          PF_SMC
+#define AF_XDP          PF_XDP
+#define AF_MAX          PF_MAX
+
+#ifndef SO_DEBUG
+#define SO_DEBUG        1
+#define SO_REUSEADDR    2
+#define SO_TYPE         3
+#define SO_ERROR        4
+#define SO_DONTROUTE    5
+#define SO_BROADCAST    6
+#define SO_SNDBUF       7
+#define SO_RCVBUF       8
+#define SO_KEEPALIVE    9
+#define SO_OOBINLINE    10
+#define SO_NO_CHECK     11
+#define SO_PRIORITY     12
+#define SO_LINGER       13
+#define SO_BSDCOMPAT    14
+#define SO_REUSEPORT    15
+#define SO_PASSCRED     16
+#define SO_PEERCRED     17
+#define SO_RCVLOWAT     18
+#define SO_SNDLOWAT     19
+#define SO_ACCEPTCONN   30
+#define SO_PEERSEC      31
+#define SO_SNDBUFFORCE  32
+#define SO_RCVBUFFORCE  33
+#define SO_PROTOCOL     38
+#define SO_DOMAIN       39
+#endif
+
+#ifndef SO_RCVTIMEO
+#if __LONG_MAX == 0x7fffffff
+#define SO_RCVTIMEO     66
+#define SO_SNDTIMEO     67
+#else
+#define SO_RCVTIMEO     20
+#define SO_SNDTIMEO     21
+#endif
+#endif
+
+#ifndef SO_TIMESTAMP
+#if __LONG_MAX == 0x7fffffff
+#define SO_TIMESTAMP    63
+#define SO_TIMESTAMPNS  64
+#define SO_TIMESTAMPING 65
+#else
+#define SO_TIMESTAMP    29
+#define SO_TIMESTAMPNS  35
+#define SO_TIMESTAMPING 37
+#endif
+#endif
+
+#define SO_SECURITY_AUTHENTICATION              22
+#define SO_SECURITY_ENCRYPTION_TRANSPORT        23
+#define SO_SECURITY_ENCRYPTION_NETWORK          24
+
+#define SO_BINDTODEVICE 25
+
+#define SO_ATTACH_FILTER        26
+#define SO_DETACH_FILTER        27
+#define SO_GET_FILTER           SO_ATTACH_FILTER
+
+#define SO_PEERNAME             28
+#define SCM_TIMESTAMP           SO_TIMESTAMP
+#define SO_PASSSEC              34
+#define SCM_TIMESTAMPNS         SO_TIMESTAMPNS
+#define SO_MARK                 36
+#define SCM_TIMESTAMPING        SO_TIMESTAMPING
+#define SO_RXQ_OVFL             40
+#define SO_WIFI_STATUS          41
+#define SCM_WIFI_STATUS         SO_WIFI_STATUS
+#define SO_PEEK_OFF             42
+#define SO_NOFCS                43
+#define SO_LOCK_FILTER          44
+#define SO_SELECT_ERR_QUEUE     45
+#define SO_BUSY_POLL            46
+#define SO_MAX_PACING_RATE      47
+#define SO_BPF_EXTENSIONS       48
+#define SO_INCOMING_CPU         49
+#define SO_ATTACH_BPF           50
+#define SO_DETACH_BPF           SO_DETACH_FILTER
+#define SO_ATTACH_REUSEPORT_CBPF 51
+#define SO_ATTACH_REUSEPORT_EBPF 52
+#define SO_CNX_ADVICE           53
+#define SCM_TIMESTAMPING_OPT_STATS 54
+#define SO_MEMINFO              55
+#define SO_INCOMING_NAPI_ID     56
+#define SO_COOKIE               57
+#define SCM_TIMESTAMPING_PKTINFO 58
+#define SO_PEERGROUPS           59
+#define SO_ZEROCOPY             60
+#define SO_TXTIME               61
+#define SCM_TXTIME              SO_TXTIME
+#define SO_BINDTOIFINDEX        62
+#define SO_DETACH_REUSEPORT_BPF 68
+
+#ifndef SOL_SOCKET
+#define SOL_SOCKET      1
+#endif
+
+#define SOL_IP          0
+#define SOL_IPV6        41
+#define SOL_ICMPV6      58
+
+#define SOL_RAW         255
+#define SOL_DECNET      261
+#define SOL_X25         262
+#define SOL_PACKET      263
+#define SOL_ATM         264
+#define SOL_AAL         265
+#define SOL_IRDA        266
+#define SOL_NETBEUI     267
+#define SOL_LLC         268
+#define SOL_DCCP        269
+#define SOL_NETLINK     270
+#define SOL_TIPC        271
+#define SOL_RXRPC       272
+#define SOL_PPPOL2TP    273
+#define SOL_BLUETOOTH   274
+#define SOL_PNPIPE      275
+#define SOL_RDS         276
+#define SOL_IUCV        277
+#define SOL_CAIF        278
+#define SOL_ALG         279
+#define SOL_NFC         280
+#define SOL_KCM         281
+#define SOL_TLS         282
+#define SOL_XDP         283
+
+#define SOMAXCONN       128
+
+#define MSG_OOB       0x0001
+#define MSG_PEEK      0x0002
+#define MSG_DONTROUTE 0x0004
+#define MSG_CTRUNC    0x0008
+#define MSG_PROXY     0x0010
+#define MSG_TRUNC     0x0020
+#define MSG_DONTWAIT  0x0040
+#define MSG_EOR       0x0080
+#define MSG_WAITALL   0x0100
+#define MSG_FIN       0x0200
+#define MSG_SYN       0x0400
+#define MSG_CONFIRM   0x0800
+#define MSG_RST       0x1000
+#define MSG_ERRQUEUE  0x2000
+#define MSG_NOSIGNAL  0x4000
+#define MSG_MORE      0x8000
+#define MSG_WAITFORONE 0x10000
+#define MSG_BATCH     0x40000
+#define MSG_ZEROCOPY  0x4000000
+#define MSG_FASTOPEN  0x20000000
+#define MSG_CMSG_CLOEXEC 0x40000000
+
+#define __CMSG_LEN(cmsg) (((cmsg)->cmsg_len + sizeof(long) - 1) & ~(long)(sizeof(long) - 1))
+#define __CMSG_NEXT(cmsg) ((unsigned char *)(cmsg) + __CMSG_LEN(cmsg))
+#define __MHDR_END(mhdr) ((unsigned char *)(mhdr)->msg_control + (mhdr)->msg_controllen)
+
+#define CMSG_DATA(cmsg) ((unsigned char *) (((struct cmsghdr *)(cmsg)) + 1))
+#define CMSG_NXTHDR(mhdr, cmsg) ((cmsg)->cmsg_len < sizeof (struct cmsghdr) || \
+	__CMSG_LEN(cmsg) + sizeof(struct cmsghdr) >= __MHDR_END(mhdr) - (unsigned char *)(cmsg) \
+	? 0 : (struct cmsghdr *)__CMSG_NEXT(cmsg))
+#define CMSG_FIRSTHDR(mhdr) ((size_t) (mhdr)->msg_controllen >= sizeof (struct cmsghdr) ? (struct cmsghdr *) (mhdr)->msg_control : (struct cmsghdr *) 0)
+
+#define CMSG_ALIGN(len) (((len) + sizeof (size_t) - 1) & (size_t) ~(sizeof (size_t) - 1))
+#define CMSG_SPACE(len) (CMSG_ALIGN (len) + CMSG_ALIGN (sizeof (struct cmsghdr)))
+#define CMSG_LEN(len)   (CMSG_ALIGN (sizeof (struct cmsghdr)) + (len))
+
+#define SCM_RIGHTS      0x01
+#define SCM_CREDENTIALS 0x02
+
+struct sockaddr {
+	sa_family_t sa_family;
+	char sa_data[14];
+};
+
+#ifndef __MUSL__
+struct sockaddr_storage {
+	sa_family_t ss_family;
+	char __ss_padding[128-sizeof(long)-sizeof(sa_family_t)];
+	unsigned long __ss_align;
+};
+#endif
+
+int socket (int, int, int);
+int socketpair (int, int, int, int [2]);
+
+int shutdown (int, int);
+
+int bind (int, const struct sockaddr *, socklen_t);
+int connect (int, const struct sockaddr *, socklen_t);
+int listen (int, int);
+int accept (int, struct sockaddr *__restrict, socklen_t *__restrict);
+int accept4(int, struct sockaddr *__restrict, socklen_t *__restrict, int);
+
+int getsockname (int, struct sockaddr *__restrict, socklen_t *__restrict);
+int getpeername (int, struct sockaddr *__restrict, socklen_t *__restrict);
+
+ssize_t send (int, const void *, size_t, int);
+ssize_t recv (int, void *, size_t, int);
+ssize_t sendto (int, const void *, size_t, int, const struct sockaddr *, socklen_t);
+ssize_t recvfrom (int, void *__restrict, size_t, int, struct sockaddr *__restrict, socklen_t *__restrict);
+ssize_t sendmsg (int, const struct msghdr *, int);
+ssize_t recvmsg (int, struct msghdr *, int);
+
+int getsockopt (int, int, int, void *__restrict, socklen_t *__restrict);
+int setsockopt (int, int, int, const void *, socklen_t);
+
+int sockatmark (int);
+
+#if _REDIR_TIME64
+#ifdef _GNU_SOURCE
+__REDIR(recvmmsg, __recvmmsg_time64);
+#endif
+#endif
+
+#ifdef __cplusplus
+}
+#endif
+#endif
diff --git a/third_party/musl/porting/linux/user/include/sys/sysinfo.h b/third_party/musl/porting/linux/user/include/sys/sysinfo.h
new file mode 100755
index 000000000..9b095ffb5
--- /dev/null
+++ b/third_party/musl/porting/linux/user/include/sys/sysinfo.h
@@ -0,0 +1,38 @@
+#ifndef _SYS_SYSINFO_H
+#define _SYS_SYSINFO_H
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#ifndef _LINUX_KERNEL_H
+#define SI_LOAD_SHIFT 16
+
+struct sysinfo {
+	unsigned long uptime;
+	unsigned long loads[3];
+	unsigned long totalram;
+	unsigned long freeram;
+	unsigned long sharedram;
+	unsigned long bufferram;
+	unsigned long totalswap;
+	unsigned long freeswap;
+	unsigned short procs, pad;
+	unsigned long totalhigh;
+	unsigned long freehigh;
+	unsigned mem_unit;
+	char __reserved[256];
+};
+#endif
+
+int sysinfo (struct sysinfo *);
+int get_nprocs_conf (void);
+int get_nprocs (void);
+long get_phys_pages (void);
+long get_avphys_pages (void);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
diff --git a/third_party/musl/porting/linux/user/include/unistd.h b/third_party/musl/porting/linux/user/include/unistd.h
new file mode 100755
index 000000000..c9a87b1a1
--- /dev/null
+++ b/third_party/musl/porting/linux/user/include/unistd.h
@@ -0,0 +1,483 @@
+#ifndef	_UNISTD_H
+#define	_UNISTD_H
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#include <features.h>
+
+#define STDIN_FILENO  0
+#define STDOUT_FILENO 1
+#define STDERR_FILENO 2
+
+#define SEEK_SET 0
+#define SEEK_CUR 1
+#define SEEK_END 2
+
+#ifdef __cplusplus
+#define NULL 0L
+#else
+#define NULL ((void*)0)
+#endif
+
+#define __NEED_size_t
+#define __NEED_ssize_t
+#define __NEED_uid_t
+#define __NEED_gid_t
+#define __NEED_off_t
+#define __NEED_pid_t
+#define __NEED_intptr_t
+#define __NEED_useconds_t
+
+#include <bits/alltypes.h>
+
+int pipe(int [2]);
+int pipe2(int [2], int);
+int close(int);
+int posix_close(int, int);
+int dup(int);
+int dup2(int, int);
+int dup3(int, int, int);
+off_t lseek(int, off_t, int);
+int fsync(int);
+int fdatasync(int);
+
+ssize_t read(int, void *, size_t);
+ssize_t write(int, const void *, size_t);
+ssize_t pread(int, void *, size_t, off_t);
+ssize_t pwrite(int, const void *, size_t, off_t);
+
+int chown(const char *, uid_t, gid_t);
+int fchown(int, uid_t, gid_t);
+int lchown(const char *, uid_t, gid_t);
+int fchownat(int, const char *, uid_t, gid_t, int);
+
+int link(const char *, const char *);
+int linkat(int, const char *, int, const char *, int);
+int symlink(const char *, const char *);
+int symlinkat(const char *, int, const char *);
+ssize_t readlink(const char *__restrict, char *__restrict, size_t);
+ssize_t readlinkat(int, const char *__restrict, char *__restrict, size_t);
+int unlink(const char *);
+int unlinkat(int, const char *, int);
+int rmdir(const char *);
+int truncate(const char *, off_t);
+int ftruncate(int, off_t);
+
+#define F_OK 0
+#define R_OK 4
+#define W_OK 2
+#define X_OK 1
+
+int access(const char *, int);
+int faccessat(int, const char *, int, int);
+
+int chdir(const char *);
+int fchdir(int);
+char *getcwd(char *, size_t);
+
+unsigned alarm(unsigned);
+unsigned sleep(unsigned);
+int pause(void);
+
+pid_t fork(void);
+int execve(const char *, char *const [], char *const []);
+int execv(const char *, char *const []);
+int execle(const char *, const char *, ...);
+int execl(const char *, const char *, ...);
+int execvp(const char *, char *const []);
+int execlp(const char *, const char *, ...);
+int fexecve(int, char *const [], char *const []);
+_Noreturn void _exit(int);
+
+pid_t getpid(void);
+pid_t getppid(void);
+pid_t getpgrp(void);
+pid_t getpgid(pid_t);
+int setpgid(pid_t, pid_t);
+pid_t setsid(void);
+pid_t getsid(pid_t);
+char *ttyname(int);
+int ttyname_r(int, char *, size_t);
+int isatty(int);
+pid_t tcgetpgrp(int);
+int tcsetpgrp(int, pid_t);
+
+uid_t getuid(void);
+uid_t geteuid(void);
+gid_t getgid(void);
+gid_t getegid(void);
+int getgroups(int, gid_t []);
+int setuid(uid_t);
+int seteuid(uid_t);
+int setgid(gid_t);
+int setegid(gid_t);
+
+char *getlogin(void);
+int getlogin_r(char *, size_t);
+int gethostname(char *, size_t);
+char *ctermid(char *);
+
+int getopt(int, char * const [], const char *);
+extern char *optarg;
+extern int optind, opterr, optopt;
+
+long pathconf(const char *, int);
+long fpathconf(int, int);
+long sysconf(int);
+size_t confstr(int, char *, size_t);
+
+#if defined(_XOPEN_SOURCE) || defined(_GNU_SOURCE) || defined(_BSD_SOURCE)
+#define F_ULOCK 0
+#define F_LOCK  1
+#define F_TLOCK 2
+#define F_TEST  3
+int setreuid(uid_t, uid_t);
+int setregid(gid_t, gid_t);
+int lockf(int, int, off_t);
+long gethostid(void);
+int nice(int);
+void sync(void);
+pid_t setpgrp(void);
+char *crypt(const char *, const char *);
+void encrypt(char *, int);
+void swab(const void *__restrict, void *__restrict, ssize_t);
+#endif
+
+#if defined(_GNU_SOURCE) || defined(_BSD_SOURCE) \
+ || (defined(_XOPEN_SOURCE) && _XOPEN_SOURCE+0 < 700)
+int usleep(unsigned);
+unsigned ualarm(unsigned, unsigned);
+#endif
+
+#if defined(_GNU_SOURCE) || defined(_BSD_SOURCE)
+#define L_SET 0
+#define L_INCR 1
+#define L_XTND 2
+int brk(void *);
+void *sbrk(intptr_t);
+pid_t vfork(void);
+int vhangup(void);
+int chroot(const char *);
+int getpagesize(void);
+int getdtablesize(void);
+int sethostname(const char *, size_t);
+int getdomainname(char *, size_t);
+int setdomainname(const char *, size_t);
+int setgroups(size_t, const gid_t *);
+char *getpass(const char *);
+int daemon(int, int);
+void setusershell(void);
+void endusershell(void);
+char *getusershell(void);
+int acct(const char *);
+long syscall(long, ...);
+int execvpe(const char *, char *const [], char *const []);
+int issetugid(void);
+int getentropy(void *, size_t);
+extern int optreset;
+#endif
+
+#ifdef _GNU_SOURCE
+extern char **environ;
+int setresuid(uid_t, uid_t, uid_t);
+int setresgid(gid_t, gid_t, gid_t);
+int getresuid(uid_t *, uid_t *, uid_t *);
+int getresgid(gid_t *, gid_t *, gid_t *);
+char *get_current_dir_name(void);
+int syncfs(int);
+int euidaccess(const char *, int);
+int eaccess(const char *, int);
+ssize_t copy_file_range(int, off_t *, int, off_t *, size_t, unsigned);
+pid_t gettid(void);
+#endif
+
+#if defined(_LARGEFILE64_SOURCE) || defined(_GNU_SOURCE)
+#define lseek64 lseek
+#define pread64 pread
+#define pwrite64 pwrite
+#define truncate64 truncate
+#define ftruncate64 ftruncate
+#define lockf64 lockf
+#define off64_t off_t
+#endif
+
+#define POSIX_CLOSE_RESTART     0
+
+#define _XOPEN_VERSION          700
+#define _XOPEN_UNIX             1
+#define _XOPEN_ENH_I18N         1
+
+#define _POSIX_VERSION          200809L
+#define _POSIX2_VERSION         _POSIX_VERSION
+
+#define _POSIX_ADVISORY_INFO    _POSIX_VERSION
+#define _POSIX_CHOWN_RESTRICTED 1
+#define _POSIX_IPV6             _POSIX_VERSION
+#define _POSIX_JOB_CONTROL      1
+#define _POSIX_MAPPED_FILES     _POSIX_VERSION
+#define _POSIX_MEMLOCK          _POSIX_VERSION
+#define _POSIX_MEMLOCK_RANGE    _POSIX_VERSION
+#define _POSIX_MEMORY_PROTECTION _POSIX_VERSION
+#define _POSIX_MESSAGE_PASSING  _POSIX_VERSION
+#define _POSIX_FSYNC            _POSIX_VERSION
+#define _POSIX_NO_TRUNC         1
+#define _POSIX_RAW_SOCKETS      _POSIX_VERSION
+#define _POSIX_REALTIME_SIGNALS _POSIX_VERSION
+#define _POSIX_REGEXP           1
+#define _POSIX_SAVED_IDS        1
+#define _POSIX_SHELL            1
+#define _POSIX_SPAWN            _POSIX_VERSION
+#define _POSIX_VDISABLE         0
+
+#define _POSIX_THREADS          _POSIX_VERSION
+#define _POSIX_THREAD_PROCESS_SHARED _POSIX_VERSION
+#define _POSIX_THREAD_SAFE_FUNCTIONS _POSIX_VERSION
+#define _POSIX_THREAD_ATTR_STACKADDR _POSIX_VERSION
+#define _POSIX_THREAD_ATTR_STACKSIZE _POSIX_VERSION
+#define _POSIX_THREAD_PRIORITY_SCHEDULING _POSIX_VERSION
+#define _POSIX_THREAD_CPUTIME   _POSIX_VERSION
+#define _POSIX_TIMERS           _POSIX_VERSION
+#define _POSIX_TIMEOUTS         _POSIX_VERSION
+#define _POSIX_MONOTONIC_CLOCK  _POSIX_VERSION
+#define _POSIX_CPUTIME          _POSIX_VERSION
+#define _POSIX_CLOCK_SELECTION  _POSIX_VERSION
+#define _POSIX_BARRIERS         _POSIX_VERSION
+#define _POSIX_SPIN_LOCKS       _POSIX_VERSION
+#define _POSIX_READER_WRITER_LOCKS _POSIX_VERSION
+#define _POSIX_ASYNCHRONOUS_IO  _POSIX_VERSION
+#define _POSIX_SEMAPHORES       _POSIX_VERSION
+#define _POSIX_SHARED_MEMORY_OBJECTS _POSIX_VERSION
+
+#define _POSIX2_C_BIND          _POSIX_VERSION
+
+#include <bits/posix.h>
+
+
+
+#define _PC_LINK_MAX	0
+#define _PC_MAX_CANON	1
+#define _PC_MAX_INPUT	2
+#define _PC_NAME_MAX	3
+#define _PC_PATH_MAX	4
+#define _PC_PIPE_BUF	5
+#define _PC_CHOWN_RESTRICTED	6
+#define _PC_NO_TRUNC	7
+#define _PC_VDISABLE	8
+#define _PC_SYNC_IO	9
+#define _PC_ASYNC_IO	10
+#define _PC_PRIO_IO	11
+#define _PC_SOCK_MAXBUF	12
+#define _PC_FILESIZEBITS	13
+#define _PC_REC_INCR_XFER_SIZE	14
+#define _PC_REC_MAX_XFER_SIZE	15
+#define _PC_REC_MIN_XFER_SIZE	16
+#define _PC_REC_XFER_ALIGN	17
+#define _PC_ALLOC_SIZE_MIN	18
+#define _PC_SYMLINK_MAX	19
+#define _PC_2_SYMLINKS	20
+
+#define _SC_ARG_MAX	0
+#define _SC_CHILD_MAX	1
+#define _SC_CLK_TCK	2
+#define _SC_NGROUPS_MAX	3
+#define _SC_OPEN_MAX	4
+#define _SC_STREAM_MAX	5
+#define _SC_TZNAME_MAX	6
+#define _SC_JOB_CONTROL	7
+#define _SC_SAVED_IDS	8
+#define _SC_REALTIME_SIGNALS	9
+#define _SC_PRIORITY_SCHEDULING	10
+#define _SC_TIMERS	11
+#define _SC_ASYNCHRONOUS_IO	12
+#define _SC_PRIORITIZED_IO	13
+#define _SC_SYNCHRONIZED_IO	14
+#define _SC_FSYNC	15
+#define _SC_MAPPED_FILES	16
+#define _SC_MEMLOCK	17
+#define _SC_MEMLOCK_RANGE	18
+#define _SC_MEMORY_PROTECTION	19
+#define _SC_MESSAGE_PASSING	20
+#define _SC_SEMAPHORES	21
+#define _SC_SHARED_MEMORY_OBJECTS	22
+#define _SC_AIO_LISTIO_MAX	23
+#define _SC_AIO_MAX	24
+#define _SC_AIO_PRIO_DELTA_MAX	25
+#define _SC_DELAYTIMER_MAX	26
+#define _SC_MQ_OPEN_MAX	27
+#define _SC_MQ_PRIO_MAX	28
+#define _SC_VERSION	29
+#define _SC_PAGE_SIZE	30
+#define _SC_PAGESIZE	30 /* !! */
+#define _SC_RTSIG_MAX	31
+#define _SC_SEM_NSEMS_MAX	32
+#define _SC_SEM_VALUE_MAX	33
+#define _SC_SIGQUEUE_MAX	34
+#define _SC_TIMER_MAX	35
+#define _SC_BC_BASE_MAX	36
+#define _SC_BC_DIM_MAX	37
+#define _SC_BC_SCALE_MAX	38
+#define _SC_BC_STRING_MAX	39
+#define _SC_COLL_WEIGHTS_MAX	40
+#define _SC_EXPR_NEST_MAX	42
+#define _SC_LINE_MAX	43
+#define _SC_RE_DUP_MAX	44
+#define _SC_2_VERSION	46
+#define _SC_2_C_BIND	47
+#define _SC_2_C_DEV	48
+#define _SC_2_FORT_DEV	49
+#define _SC_2_FORT_RUN	50
+#define _SC_2_SW_DEV	51
+#define _SC_2_LOCALEDEF	52
+#define _SC_UIO_MAXIOV	60 /* !! */
+#define _SC_IOV_MAX	60
+#define _SC_THREADS	67
+#define _SC_THREAD_SAFE_FUNCTIONS	68
+#define _SC_GETGR_R_SIZE_MAX	69
+#define _SC_GETPW_R_SIZE_MAX	70
+#define _SC_LOGIN_NAME_MAX	71
+#define _SC_TTY_NAME_MAX	72
+#define _SC_THREAD_DESTRUCTOR_ITERATIONS	73
+#define _SC_THREAD_KEYS_MAX	74
+#define _SC_THREAD_STACK_MIN	75
+#define _SC_THREAD_THREADS_MAX	76
+#define _SC_THREAD_ATTR_STACKADDR	77
+#define _SC_THREAD_ATTR_STACKSIZE	78
+#define _SC_THREAD_PRIORITY_SCHEDULING	79
+#define _SC_THREAD_PRIO_INHERIT	80
+#define _SC_THREAD_PRIO_PROTECT	81
+#define _SC_THREAD_PROCESS_SHARED	82
+#define _SC_NPROCESSORS_CONF	83
+#define _SC_NPROCESSORS_ONLN	84
+#define _SC_PHYS_PAGES	85
+#define _SC_AVPHYS_PAGES	86
+#define _SC_ATEXIT_MAX	87
+#define _SC_PASS_MAX	88
+#define _SC_XOPEN_VERSION	89
+#define _SC_XOPEN_XCU_VERSION	90
+#define _SC_XOPEN_UNIX	91
+#define _SC_XOPEN_CRYPT	92
+#define _SC_XOPEN_ENH_I18N	93
+#define _SC_XOPEN_SHM	94
+#define _SC_2_CHAR_TERM	95
+#define _SC_2_UPE	97
+#define _SC_XOPEN_XPG2	98
+#define _SC_XOPEN_XPG3	99
+#define _SC_XOPEN_XPG4	100
+#define _SC_NZERO	109
+#define _SC_XBS5_ILP32_OFF32	125
+#define _SC_XBS5_ILP32_OFFBIG	126
+#define _SC_XBS5_LP64_OFF64	127
+#define _SC_XBS5_LPBIG_OFFBIG	128
+#define _SC_XOPEN_LEGACY	129
+#define _SC_XOPEN_REALTIME	130
+#define _SC_XOPEN_REALTIME_THREADS	131
+#define _SC_ADVISORY_INFO	132
+#define _SC_BARRIERS	133
+#define _SC_CLOCK_SELECTION	137
+#define _SC_CPUTIME	138
+#define _SC_THREAD_CPUTIME	139
+#define _SC_MONOTONIC_CLOCK	149
+#define _SC_READER_WRITER_LOCKS	153
+#define _SC_SPIN_LOCKS	154
+#define _SC_REGEXP	155
+#define _SC_SHELL	157
+#define _SC_SPAWN	159
+#define _SC_SPORADIC_SERVER	160
+#define _SC_THREAD_SPORADIC_SERVER	161
+#define _SC_TIMEOUTS	164
+#define _SC_TYPED_MEMORY_OBJECTS	165
+#define _SC_2_PBS	168
+#define _SC_2_PBS_ACCOUNTING	169
+#define _SC_2_PBS_LOCATE	170
+#define _SC_2_PBS_MESSAGE	171
+#define _SC_2_PBS_TRACK	172
+#define _SC_SYMLOOP_MAX	173
+#define _SC_STREAMS	174
+#define _SC_2_PBS_CHECKPOINT	175
+#define _SC_V6_ILP32_OFF32	176
+#define _SC_V6_ILP32_OFFBIG	177
+#define _SC_V6_LP64_OFF64	178
+#define _SC_V6_LPBIG_OFFBIG	179
+#define _SC_HOST_NAME_MAX	180
+#define _SC_TRACE	181
+#define _SC_TRACE_EVENT_FILTER	182
+#define _SC_TRACE_INHERIT	183
+#define _SC_TRACE_LOG	184
+
+#define _SC_IPV6	235
+#define _SC_RAW_SOCKETS	236
+#define _SC_V7_ILP32_OFF32	237
+#define _SC_V7_ILP32_OFFBIG	238
+#define _SC_V7_LP64_OFF64	239
+#define _SC_V7_LPBIG_OFFBIG	240
+#define _SC_SS_REPL_MAX	241
+#define _SC_TRACE_EVENT_NAME_MAX	242
+#define _SC_TRACE_NAME_MAX	243
+#define _SC_TRACE_SYS_MAX	244
+#define _SC_TRACE_USER_EVENT_MAX	245
+#define _SC_XOPEN_STREAMS	246
+#define _SC_THREAD_ROBUST_PRIO_INHERIT	247
+#define _SC_THREAD_ROBUST_PRIO_PROTECT	248
+
+#define _CS_PATH	0
+#define _CS_POSIX_V6_WIDTH_RESTRICTED_ENVS	1
+#define _CS_GNU_LIBC_VERSION	2
+#define _CS_GNU_LIBPTHREAD_VERSION	3
+#define _CS_POSIX_V5_WIDTH_RESTRICTED_ENVS	4
+#define _CS_POSIX_V7_WIDTH_RESTRICTED_ENVS	5
+
+#define _CS_POSIX_V6_ILP32_OFF32_CFLAGS	1116
+#define _CS_POSIX_V6_ILP32_OFF32_LDFLAGS	1117
+#define _CS_POSIX_V6_ILP32_OFF32_LIBS	1118
+#define _CS_POSIX_V6_ILP32_OFF32_LINTFLAGS	1119
+#define _CS_POSIX_V6_ILP32_OFFBIG_CFLAGS	1120
+#define _CS_POSIX_V6_ILP32_OFFBIG_LDFLAGS	1121
+#define _CS_POSIX_V6_ILP32_OFFBIG_LIBS	1122
+#define _CS_POSIX_V6_ILP32_OFFBIG_LINTFLAGS	1123
+#define _CS_POSIX_V6_LP64_OFF64_CFLAGS	1124
+#define _CS_POSIX_V6_LP64_OFF64_LDFLAGS	1125
+#define _CS_POSIX_V6_LP64_OFF64_LIBS	1126
+#define _CS_POSIX_V6_LP64_OFF64_LINTFLAGS	1127
+#define _CS_POSIX_V6_LPBIG_OFFBIG_CFLAGS	1128
+#define _CS_POSIX_V6_LPBIG_OFFBIG_LDFLAGS	1129
+#define _CS_POSIX_V6_LPBIG_OFFBIG_LIBS	1130
+#define _CS_POSIX_V6_LPBIG_OFFBIG_LINTFLAGS	1131
+#define _CS_POSIX_V7_ILP32_OFF32_CFLAGS	1132
+#define _CS_POSIX_V7_ILP32_OFF32_LDFLAGS	1133
+#define _CS_POSIX_V7_ILP32_OFF32_LIBS	1134
+#define _CS_POSIX_V7_ILP32_OFF32_LINTFLAGS	1135
+#define _CS_POSIX_V7_ILP32_OFFBIG_CFLAGS	1136
+#define _CS_POSIX_V7_ILP32_OFFBIG_LDFLAGS	1137
+#define _CS_POSIX_V7_ILP32_OFFBIG_LIBS	1138
+#define _CS_POSIX_V7_ILP32_OFFBIG_LINTFLAGS	1139
+#define _CS_POSIX_V7_LP64_OFF64_CFLAGS	1140
+#define _CS_POSIX_V7_LP64_OFF64_LDFLAGS	1141
+#define _CS_POSIX_V7_LP64_OFF64_LIBS	1142
+#define _CS_POSIX_V7_LP64_OFF64_LINTFLAGS	1143
+#define _CS_POSIX_V7_LPBIG_OFFBIG_CFLAGS	1144
+#define _CS_POSIX_V7_LPBIG_OFFBIG_LDFLAGS	1145
+#define _CS_POSIX_V7_LPBIG_OFFBIG_LIBS	1146
+#define _CS_POSIX_V7_LPBIG_OFFBIG_LINTFLAGS	1147
+#define _CS_V6_ENV	1148
+#define _CS_V7_ENV	1149
+
+#ifdef _GNU_SOURCE
+#ifndef TEMP_FAILURE_RETRY
+#define MUSL_TEMP_FAILURE_RETRY(expression) \
+    (__extension__ \
+        ({ long int __result; \
+            do __result = (long int)(expression); \
+            while(__result == -1L&& errno == EINTR); \
+        __result;}))
+
+#define TEMP_FAILURE_RETRY(expression) MUSL_TEMP_FAILURE_RETRY(expression)
+#endif
+#endif
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
diff --git a/third_party/musl/porting/linux/user/src/internal/pthread_impl.h b/third_party/musl/porting/linux/user/src/internal/pthread_impl.h
new file mode 100755
index 000000000..df67a3d4f
--- /dev/null
+++ b/third_party/musl/porting/linux/user/src/internal/pthread_impl.h
@@ -0,0 +1,200 @@
+#ifndef _PTHREAD_IMPL_H
+#define _PTHREAD_IMPL_H
+
+#include <pthread.h>
+#include <signal.h>
+#include <errno.h>
+#include <limits.h>
+#include <sys/mman.h>
+#include "libc.h"
+#include "syscall.h"
+#include "atomic.h"
+#include "futex.h"
+
+#define pthread __pthread
+
+struct pthread {
+	/* Part 1 -- these fields may be external or
+	 * internal (accessed via asm) ABI. Do not change. */
+	struct pthread *self;
+	uintptr_t *dtv;
+	struct pthread *prev, *next; /* non-ABI */
+	uintptr_t sysinfo;
+	uintptr_t canary, canary2;
+
+	/* Part 2 -- implementation details, non-ABI. */
+	int tid;
+	int errno_val;
+	volatile int detach_state;
+	volatile int cancel;
+	volatile unsigned char canceldisable, cancelasync;
+	unsigned char tsd_used:1;
+	unsigned char dlerror_flag:1;
+	unsigned char *map_base;
+	size_t map_size;
+	void *stack;
+	size_t stack_size;
+	size_t guard_size;
+	void *result;
+	struct __ptcb *cancelbuf;
+	void **tsd;
+	struct {
+		volatile void *volatile head;
+		long off;
+		volatile void *volatile pending;
+	} robust_list;
+	volatile int timer_id;
+	locale_t locale;
+	volatile int killlock[1];
+	char *dlerror_buf;
+	void *stdio_locks;
+
+	/* Part 3 -- the positions of these fields relative to
+	 * the end of the structure is external and internal ABI. */
+	uintptr_t canary_at_end;
+	uintptr_t *dtv_copy;
+};
+
+enum {
+	DT_EXITING = 0,
+	DT_JOINABLE,
+	DT_DETACHED,
+};
+
+struct __timer {
+	int timerid;
+	pthread_t thread;
+};
+
+#define __SU (sizeof(size_t)/sizeof(int))
+
+#define _a_stacksize __u.__s[0]
+#define _a_guardsize __u.__s[1]
+#define _a_stackaddr __u.__s[2]
+#define _a_detach __u.__i[3*__SU+0]
+#define _a_sched __u.__i[3*__SU+1]
+#define _a_policy __u.__i[3*__SU+2]
+#define _a_prio __u.__i[3*__SU+3]
+
+/* we define the original value of _m_* in include/pthread.h
+ * as macros MUTEX_* to make the user be able to
+ * access the inner attribute of the mutex struct.
+ * Then, we modify the value of _m_* macros to MUTEX_* here,
+ * so that we can immediately be aware of the changes that
+ * the open source society has made to these original macros,
+ * because patching will fail if the value of the _m_* are
+ * changed by musl society */
+#define _m_type MUTEX_TYPE
+#define _m_lock MUTEX_LOCK
+#define _m_waiters MUTEX_WAITERS
+#define _m_prev MUTEX_PREV
+#define _m_next MUTEX_NEXT
+#define _m_count MUTEX_COUNT
+
+#define _c_shared __u.__p[0]
+#define _c_seq __u.__vi[2]
+#define _c_waiters __u.__vi[3]
+#define _c_clock __u.__i[4]
+#define _c_lock __u.__vi[8]
+#define _c_head __u.__p[1]
+#define _c_tail __u.__p[5]
+#define _rw_lock __u.__vi[0]
+#define _rw_waiters __u.__vi[1]
+#define _rw_shared __u.__i[2]
+#define _b_lock __u.__vi[0]
+#define _b_waiters __u.__vi[1]
+#define _b_limit __u.__i[2]
+#define _b_count __u.__vi[3]
+#define _b_waiters2 __u.__vi[4]
+#define _b_inst __u.__p[3]
+
+#include "pthread_arch.h"
+
+#ifndef CANARY
+#define CANARY canary
+#endif
+
+#ifndef DTP_OFFSET
+#define DTP_OFFSET 0
+#endif
+
+#ifndef tls_mod_off_t
+#define tls_mod_off_t size_t
+#endif
+
+#define SIGTIMER 32
+#define SIGCANCEL 33
+#define SIGSYNCCALL 34
+
+#define SIGALL_SET ((sigset_t *)(const unsigned long long [2]){ -1,-1 })
+#define SIGPT_SET \
+	((sigset_t *)(const unsigned long [_NSIG/8/sizeof(long)]){ \
+	[sizeof(long)==4] = 3UL<<(32*(sizeof(long)>4)) })
+#define SIGTIMER_SET \
+	((sigset_t *)(const unsigned long [_NSIG/8/sizeof(long)]){ \
+	 0x80000000 })
+
+void *__tls_get_addr(tls_mod_off_t *);
+hidden int __init_tp(void *);
+hidden void *__copy_tls(unsigned char *);
+hidden void __reset_tls();
+
+hidden void __membarrier_init(void);
+hidden void __dl_thread_cleanup(void);
+hidden void __testcancel();
+hidden void __do_cleanup_push(struct __ptcb *);
+hidden void __do_cleanup_pop(struct __ptcb *);
+hidden void __pthread_tsd_run_dtors();
+
+hidden void __pthread_key_delete_synccall(void (*)(void *), void *);
+hidden int __pthread_key_delete_impl(pthread_key_t);
+
+extern hidden volatile size_t __pthread_tsd_size;
+extern hidden void *__pthread_tsd_main[];
+extern hidden volatile int __aio_fut;
+extern hidden volatile int __eintr_valid_flag;
+
+hidden int __clone(int (*)(void *), void *, int, void *, ...);
+hidden int __set_thread_area(void *);
+hidden int __libc_sigaction(int, const struct sigaction *, struct sigaction *);
+hidden void __unmapself(void *, size_t);
+
+hidden int __timedwait(volatile int *, int, clockid_t, const struct timespec *, int);
+hidden int __timedwait_cp(volatile int *, int, clockid_t, const struct timespec *, int);
+hidden void __wait(volatile int *, volatile int *, int, int);
+static inline void __wake(volatile void *addr, int cnt, int priv)
+{
+	if (priv) priv = FUTEX_PRIVATE;
+	if (cnt<0) cnt = INT_MAX;
+	__syscall(SYS_futex, addr, FUTEX_WAKE|priv, cnt) != -ENOSYS ||
+	__syscall(SYS_futex, addr, FUTEX_WAKE, cnt);
+}
+static inline void __futexwait(volatile void *addr, int val, int priv)
+{
+	if (priv) priv = FUTEX_PRIVATE;
+	__syscall(SYS_futex, addr, FUTEX_WAIT|priv, val, 0) != -ENOSYS ||
+	__syscall(SYS_futex, addr, FUTEX_WAIT, val, 0);
+}
+
+hidden void __acquire_ptc(void);
+hidden void __release_ptc(void);
+hidden void __inhibit_ptc(void);
+
+hidden void __tl_lock(void);
+hidden void __tl_unlock(void);
+hidden void __tl_sync(pthread_t);
+
+extern hidden volatile int __thread_list_lock;
+
+extern hidden unsigned __default_stacksize;
+extern hidden unsigned __default_guardsize;
+
+#define DEFAULT_STACK_SIZE 131072
+#define DEFAULT_GUARD_SIZE 8192
+
+#define DEFAULT_STACK_MAX (8<<20)
+#define DEFAULT_GUARD_MAX (1<<20)
+
+#define __ATTRP_C11_THREAD ((void*)(uintptr_t)-1)
+
+#endif
diff --git a/third_party/musl/porting/linux/user/src/internal/syscall.h b/third_party/musl/porting/linux/user/src/internal/syscall.h
new file mode 100755
index 000000000..fb64c2822
--- /dev/null
+++ b/third_party/musl/porting/linux/user/src/internal/syscall.h
@@ -0,0 +1,380 @@
+#ifndef _INTERNAL_SYSCALL_H
+#define _INTERNAL_SYSCALL_H
+
+#include <features.h>
+#include <sys/syscall.h>
+#include "syscall_arch.h"
+
+#ifndef SYSCALL_RLIM_INFINITY
+#define SYSCALL_RLIM_INFINITY (~0ULL)
+#endif
+
+#ifndef SYSCALL_MMAP2_UNIT
+#define SYSCALL_MMAP2_UNIT 4096ULL
+#endif
+
+#ifndef __SYSCALL_LL_PRW
+#define __SYSCALL_LL_PRW(x) __SYSCALL_LL_O(x)
+#endif
+
+#ifndef __scc
+#define __scc(X) ((long) (X))
+typedef long syscall_arg_t;
+#endif
+
+hidden long __syscall_ret(unsigned long),
+	__syscall_cp(syscall_arg_t, syscall_arg_t, syscall_arg_t, syscall_arg_t,
+	             syscall_arg_t, syscall_arg_t, syscall_arg_t);
+
+#define __syscall1(n,a) __syscall1(n,__scc(a))
+#define __syscall2(n,a,b) __syscall2(n,__scc(a),__scc(b))
+#define __syscall3(n,a,b,c) __syscall3(n,__scc(a),__scc(b),__scc(c))
+#define __syscall4(n,a,b,c,d) __syscall4(n,__scc(a),__scc(b),__scc(c),__scc(d))
+#define __syscall5(n,a,b,c,d,e) __syscall5(n,__scc(a),__scc(b),__scc(c),__scc(d),__scc(e))
+#define __syscall6(n,a,b,c,d,e,f) __syscall6(n,__scc(a),__scc(b),__scc(c),__scc(d),__scc(e),__scc(f))
+#define __syscall7(n,a,b,c,d,e,f,g) __syscall7(n,__scc(a),__scc(b),__scc(c),__scc(d),__scc(e),__scc(f),__scc(g))
+
+#define __SYSCALL_NARGS_X(a,b,c,d,e,f,g,h,n,...) n
+#define __SYSCALL_NARGS(...) __SYSCALL_NARGS_X(__VA_ARGS__,7,6,5,4,3,2,1,0,)
+#define __SYSCALL_CONCAT_X(a,b) a##b
+#define __SYSCALL_CONCAT(a,b) __SYSCALL_CONCAT_X(a,b)
+#define __SYSCALL_DISP(b,...) __SYSCALL_CONCAT(b,__SYSCALL_NARGS(__VA_ARGS__))(__VA_ARGS__)
+
+#define __syscall(...) __SYSCALL_DISP(__syscall,__VA_ARGS__)
+#define syscall(...) __syscall_ret(__syscall(__VA_ARGS__))
+
+#define socketcall(nm,a,b,c,d,e,f) __syscall_ret(__socketcall(nm,a,b,c,d,e,f))
+#define socketcall_cp(nm,a,b,c,d,e,f) __syscall_ret(__socketcall_cp(nm,a,b,c,d,e,f))
+
+#define __syscall_cp0(n) (__syscall_cp)(n,0,0,0,0,0,0)
+#define __syscall_cp1(n,a) (__syscall_cp)(n,__scc(a),0,0,0,0,0)
+#define __syscall_cp2(n,a,b) (__syscall_cp)(n,__scc(a),__scc(b),0,0,0,0)
+#define __syscall_cp3(n,a,b,c) (__syscall_cp)(n,__scc(a),__scc(b),__scc(c),0,0,0)
+#define __syscall_cp4(n,a,b,c,d) (__syscall_cp)(n,__scc(a),__scc(b),__scc(c),__scc(d),0,0)
+#define __syscall_cp5(n,a,b,c,d,e) (__syscall_cp)(n,__scc(a),__scc(b),__scc(c),__scc(d),__scc(e),0)
+#define __syscall_cp6(n,a,b,c,d,e,f) (__syscall_cp)(n,__scc(a),__scc(b),__scc(c),__scc(d),__scc(e),__scc(f))
+
+#define __syscall_cp(...) __SYSCALL_DISP(__syscall_cp,__VA_ARGS__)
+#define syscall_cp(...) __syscall_ret(__syscall_cp(__VA_ARGS__))
+
+#ifndef SYSCALL_USE_SOCKETCALL
+#define __socketcall(nm,a,b,c,d,e,f) __syscall(SYS_##nm, a, b, c, d, e, f)
+#define __socketcall_cp(nm,a,b,c,d,e,f) __syscall_cp(SYS_##nm, a, b, c, d, e, f)
+#else
+#define __socketcall(nm,a,b,c,d,e,f) __syscall(SYS_socketcall, __SC_##nm, \
+    ((long [6]){ (long)a, (long)b, (long)c, (long)d, (long)e, (long)f }))
+#define __socketcall_cp(nm,a,b,c,d,e,f) __syscall_cp(SYS_socketcall, __SC_##nm, \
+    ((long [6]){ (long)a, (long)b, (long)c, (long)d, (long)e, (long)f }))
+#endif
+
+/* fixup legacy 16-bit junk */
+
+#ifdef SYS_getuid32
+#undef SYS_lchown
+#undef SYS_getuid
+#undef SYS_getgid
+#undef SYS_geteuid
+#undef SYS_getegid
+#undef SYS_setreuid
+#undef SYS_setregid
+#undef SYS_getgroups
+#undef SYS_setgroups
+#undef SYS_fchown
+#undef SYS_setresuid
+#undef SYS_getresuid
+#undef SYS_setresgid
+#undef SYS_getresgid
+#undef SYS_chown
+#undef SYS_setuid
+#undef SYS_setgid
+#undef SYS_setfsuid
+#undef SYS_setfsgid
+#define SYS_lchown SYS_lchown32
+#define SYS_getuid SYS_getuid32
+#define SYS_getgid SYS_getgid32
+#define SYS_geteuid SYS_geteuid32
+#define SYS_getegid SYS_getegid32
+#define SYS_setreuid SYS_setreuid32
+#define SYS_setregid SYS_setregid32
+#define SYS_getgroups SYS_getgroups32
+#define SYS_setgroups SYS_setgroups32
+#define SYS_fchown SYS_fchown32
+#define SYS_setresuid SYS_setresuid32
+#define SYS_getresuid SYS_getresuid32
+#define SYS_setresgid SYS_setresgid32
+#define SYS_getresgid SYS_getresgid32
+#define SYS_chown SYS_chown32
+#define SYS_setuid SYS_setuid32
+#define SYS_setgid SYS_setgid32
+#define SYS_setfsuid SYS_setfsuid32
+#define SYS_setfsgid SYS_setfsgid32
+#endif
+
+
+/* fixup legacy 32-bit-vs-lfs64 junk */
+
+#ifdef SYS_fcntl64
+#undef SYS_fcntl
+#define SYS_fcntl SYS_fcntl64
+#endif
+
+#ifdef SYS_getdents64
+#undef SYS_getdents
+#define SYS_getdents SYS_getdents64
+#endif
+
+#ifdef SYS_ftruncate64
+#undef SYS_ftruncate
+#undef SYS_truncate
+#define SYS_ftruncate SYS_ftruncate64
+#define SYS_truncate SYS_truncate64
+#endif
+
+#ifdef SYS_stat64
+#undef SYS_stat
+#define SYS_stat SYS_stat64
+#endif
+
+#ifdef SYS_fstat64
+#undef SYS_fstat
+#define SYS_fstat SYS_fstat64
+#endif
+
+#ifdef SYS_lstat64
+#undef SYS_lstat
+#define SYS_lstat SYS_lstat64
+#endif
+
+#ifdef SYS_statfs64
+#undef SYS_statfs
+#define SYS_statfs SYS_statfs64
+#endif
+
+#ifdef SYS_fstatfs64
+#undef SYS_fstatfs
+#define SYS_fstatfs SYS_fstatfs64
+#endif
+
+#if defined(SYS_newfstatat)
+#undef SYS_fstatat
+#define SYS_fstatat SYS_newfstatat
+#elif defined(SYS_fstatat64)
+#undef SYS_fstatat
+#define SYS_fstatat SYS_fstatat64
+#endif
+
+#ifdef SYS_ugetrlimit
+#undef SYS_getrlimit
+#define SYS_getrlimit SYS_ugetrlimit
+#endif
+
+#ifdef SYS__newselect
+#undef SYS_select
+#define SYS_select SYS__newselect
+#endif
+
+#ifdef SYS_pread64
+#undef SYS_pread
+#undef SYS_pwrite
+#define SYS_pread SYS_pread64
+#define SYS_pwrite SYS_pwrite64
+#endif
+
+#ifdef SYS_fadvise64_64
+#undef SYS_fadvise
+#define SYS_fadvise SYS_fadvise64_64
+#elif defined(SYS_fadvise64)
+#undef SYS_fadvise
+#define SYS_fadvise SYS_fadvise64
+#endif
+
+#ifdef SYS_sendfile64
+#undef SYS_sendfile
+#define SYS_sendfile SYS_sendfile64
+#endif
+
+#ifndef SYS_timer_settime
+#define SYS_timer_settime SYS_timer_settime32
+#endif
+
+#ifndef SYS_timer_gettime
+#define SYS_timer_gettime SYS_timer_gettime32
+#endif
+
+#ifndef SYS_timerfd_settime
+#define SYS_timerfd_settime SYS_timerfd_settime32
+#endif
+
+#ifndef SYS_timerfd_gettime
+#define SYS_timerfd_gettime SYS_timerfd_gettime32
+#endif
+
+#ifndef SYS_clock_settime
+#define SYS_clock_settime SYS_clock_settime32
+#endif
+
+#ifndef SYS_clock_gettime
+#define SYS_clock_gettime SYS_clock_gettime32
+#endif
+
+#ifndef SYS_clock_getres
+#define SYS_clock_getres SYS_clock_getres_time32
+#endif
+
+#ifndef SYS_clock_nanosleep
+#define SYS_clock_nanosleep SYS_clock_nanosleep_time32
+#endif
+
+#ifndef SYS_gettimeofday
+#define SYS_gettimeofday SYS_gettimeofday_time32
+#endif
+
+#ifndef SYS_settimeofday
+#define SYS_settimeofday SYS_settimeofday_time32
+#endif
+
+/* Ensure that the plain syscall names are defined even for "time64-only"
+ * archs. These facilitate callers passing null time arguments, and make
+ * tests for establishing which to use/fallback-to more consistent when
+ * they do need to be called with time arguments. */
+
+#ifndef SYS_clock_gettime
+#define SYS_clock_gettime SYS_clock_gettime64
+#endif
+
+#ifndef SYS_clock_settime
+#define SYS_clock_settime SYS_clock_settime64
+#endif
+
+#ifndef SYS_clock_adjtime
+#define SYS_clock_adjtime SYS_clock_adjtime64
+#endif
+
+#ifndef SYS_clock_getres
+#define SYS_clock_getres SYS_clock_getres_time64
+#endif
+
+#ifndef SYS_clock_nanosleep
+#define SYS_clock_nanosleep SYS_clock_nanosleep_time64
+#endif
+
+#ifndef SYS_timer_gettime
+#define SYS_timer_gettime SYS_timer_gettime64
+#endif
+
+#ifndef SYS_timer_settime
+#define SYS_timer_settime SYS_timer_settime64
+#endif
+
+#ifndef SYS_timerfd_gettime
+#define SYS_timerfd_gettime SYS_timerfd_gettime64
+#endif
+
+#ifndef SYS_timerfd_settime
+#define SYS_timerfd_settime SYS_timerfd_settime64
+#endif
+
+#ifndef SYS_utimensat
+#define SYS_utimensat SYS_utimensat_time64
+#endif
+
+#ifndef SYS_ppoll
+#define SYS_ppoll SYS_ppoll_time64
+#endif
+
+#ifndef SYS_recvmmsg
+#define SYS_recvmmsg SYS_recvmmsg_time64
+#endif
+
+#ifndef SYS_mq_timedsend
+#define SYS_mq_timedsend SYS_mq_timedsend_time64
+#endif
+
+#ifndef SYS_mq_timedreceive
+#define SYS_mq_timedreceive SYS_mq_timedreceive_time64
+#endif
+
+/* SYS_semtimedop omitted because SYS_ipc may provide it */
+
+#ifndef SYS_rt_sigtimedwait
+#define SYS_rt_sigtimedwait SYS_rt_sigtimedwait_time64
+#endif
+
+#ifndef SYS_futex
+#define SYS_futex SYS_futex_time64
+#endif
+
+#ifndef SYS_sched_rr_get_interval
+#define SYS_sched_rr_get_interval SYS_sched_rr_get_interval_time64
+#endif
+
+
+
+
+/* socketcall calls */
+
+#define __SC_socket      1
+#define __SC_bind        2
+#define __SC_connect     3
+#define __SC_listen      4
+#define __SC_accept      5
+#define __SC_getsockname 6
+#define __SC_getpeername 7
+#define __SC_socketpair  8
+#define __SC_send        9
+#define __SC_recv        10
+#define __SC_sendto      11
+#define __SC_recvfrom    12
+#define __SC_shutdown    13
+#define __SC_setsockopt  14
+#define __SC_getsockopt  15
+#define __SC_sendmsg     16
+#define __SC_recvmsg     17
+#define __SC_accept4     18
+#define __SC_recvmmsg    19
+#define __SC_sendmmsg    20
+
+#ifndef SO_RCVTIMEO_OLD
+#define SO_RCVTIMEO_OLD  20
+#endif
+#ifndef SO_SNDTIMEO_OLD
+#define SO_SNDTIMEO_OLD  21
+#endif
+
+#define SO_TIMESTAMP_OLD    29
+#define SO_TIMESTAMPNS_OLD  35
+#define SO_TIMESTAMPING_OLD 37
+#define SCM_TIMESTAMP_OLD    SO_TIMESTAMP_OLD
+#define SCM_TIMESTAMPNS_OLD  SO_TIMESTAMPNS_OLD
+#define SCM_TIMESTAMPING_OLD SO_TIMESTAMPING_OLD
+
+#ifndef SIOCGSTAMP_OLD
+#define SIOCGSTAMP_OLD 0x8906
+#endif
+#ifndef SIOCGSTAMPNS_OLD
+#define SIOCGSTAMPNS_OLD 0x8907
+#endif
+
+#ifdef SYS_open
+#define __sys_open2(x,pn,fl) __syscall2(SYS_open, pn, (fl)|O_LARGEFILE)
+#define __sys_open3(x,pn,fl,mo) __syscall3(SYS_open, pn, (fl)|O_LARGEFILE, mo)
+#define __sys_open_cp2(x,pn,fl) __syscall_cp2(SYS_open, pn, (fl)|O_LARGEFILE)
+#define __sys_open_cp3(x,pn,fl,mo) __syscall_cp3(SYS_open, pn, (fl)|O_LARGEFILE, mo)
+#else
+#define __sys_open2(x,pn,fl) __syscall3(SYS_openat, AT_FDCWD, pn, (fl)|O_LARGEFILE)
+#define __sys_open3(x,pn,fl,mo) __syscall4(SYS_openat, AT_FDCWD, pn, (fl)|O_LARGEFILE, mo)
+#define __sys_open_cp2(x,pn,fl) __syscall_cp3(SYS_openat, AT_FDCWD, pn, (fl)|O_LARGEFILE)
+#define __sys_open_cp3(x,pn,fl,mo) __syscall_cp4(SYS_openat, AT_FDCWD, pn, (fl)|O_LARGEFILE, mo)
+#endif
+
+#define __sys_open(...) __SYSCALL_DISP(__sys_open,,__VA_ARGS__)
+#define sys_open(...) __syscall_ret(__sys_open(__VA_ARGS__))
+
+#define __sys_open_cp(...) __SYSCALL_DISP(__sys_open_cp,,__VA_ARGS__)
+#define sys_open_cp(...) __syscall_ret(__sys_open_cp(__VA_ARGS__))
+
+hidden void __procfdname(char __buf[static 15+3*sizeof(int)], unsigned);
+
+hidden void *__vdsosym(const char *, const char *);
+
+#endif
diff --git a/third_party/musl/porting/linux/user/src/legacy/ulimit.c b/third_party/musl/porting/linux/user/src/legacy/ulimit.c
new file mode 100755
index 000000000..d1620e6e2
--- /dev/null
+++ b/third_party/musl/porting/linux/user/src/legacy/ulimit.c
@@ -0,0 +1,20 @@
+#include <sys/resource.h>
+#include <ulimit.h>
+#include <stdarg.h>
+#include <limits.h>
+
+long ulimit(int cmd, ...)
+{
+	struct rlimit rl;
+	getrlimit(RLIMIT_FSIZE, &rl);
+	if (cmd == UL_SETFSIZE) {
+		long val;
+		va_list ap;
+		va_start(ap, cmd);
+		val = va_arg(ap, long);
+		va_end(ap);
+		rl.rlim_cur = 512ULL * val;
+		if (setrlimit(RLIMIT_FSIZE, &rl)) return -1;
+	}
+	return rl.rlim_cur == RLIM_INFINITY? LONG_MAX : rl.rlim_cur / 512;
+}
diff --git a/third_party/musl/porting/linux/user/src/linux/gettid.c b/third_party/musl/porting/linux/user/src/linux/gettid.c
new file mode 100755
index 000000000..70767137e
--- /dev/null
+++ b/third_party/musl/porting/linux/user/src/linux/gettid.c
@@ -0,0 +1,8 @@
+#define _GNU_SOURCE
+#include <unistd.h>
+#include "pthread_impl.h"
+
+pid_t gettid(void)
+{
+	return __pthread_self()->tid;
+}
diff --git a/third_party/musl/porting/linux/user/src/malloc/malloc.c b/third_party/musl/porting/linux/user/src/malloc/malloc.c
new file mode 100755
index 000000000..07848ec1e
--- /dev/null
+++ b/third_party/musl/porting/linux/user/src/malloc/malloc.c
@@ -0,0 +1,552 @@
+#define _GNU_SOURCE
+#include <stdlib.h>
+#include <string.h>
+#include <limits.h>
+#include <stdint.h>
+#include <errno.h>
+#include <sys/mman.h>
+#include "libc.h"
+#include "atomic.h"
+#include "pthread_impl.h"
+#include "malloc_impl.h"
+
+#if defined(__GNUC__) && defined(__PIC__)
+#define inline inline __attribute__((always_inline))
+#endif
+
+static struct {
+	volatile uint64_t binmap;
+	struct bin bins[64];
+	volatile int free_lock[2];
+} mal;
+
+int __malloc_replaced;
+
+/* Synchronization tools */
+
+static inline void lock(volatile int *lk)
+{
+	if (libc.threads_minus_1)
+		while(a_swap(lk, 1)) __wait(lk, lk+1, 1, 1);
+}
+
+static inline void unlock(volatile int *lk)
+{
+	if (lk[0]) {
+		a_store(lk, 0);
+		if (lk[1]) __wake(lk, 1, 1);
+	}
+}
+
+static inline void lock_bin(int i)
+{
+	lock(mal.bins[i].lock);
+	if (!mal.bins[i].head)
+		mal.bins[i].head = mal.bins[i].tail = BIN_TO_CHUNK(i);
+}
+
+static inline void unlock_bin(int i)
+{
+	unlock(mal.bins[i].lock);
+}
+
+static int first_set(uint64_t x)
+{
+#if 1
+	return a_ctz_64(x);
+#else
+	static const char debruijn64[64] = {
+		0, 1, 2, 53, 3, 7, 54, 27, 4, 38, 41, 8, 34, 55, 48, 28,
+		62, 5, 39, 46, 44, 42, 22, 9, 24, 35, 59, 56, 49, 18, 29, 11,
+		63, 52, 6, 26, 37, 40, 33, 47, 61, 45, 43, 21, 23, 58, 17, 10,
+		51, 25, 36, 32, 60, 20, 57, 16, 50, 31, 19, 15, 30, 14, 13, 12
+	};
+	static const char debruijn32[32] = {
+		0, 1, 23, 2, 29, 24, 19, 3, 30, 27, 25, 11, 20, 8, 4, 13,
+		31, 22, 28, 18, 26, 10, 7, 12, 21, 17, 9, 6, 16, 5, 15, 14
+	};
+	if (sizeof(long) < 8) {
+		uint32_t y = x;
+		if (!y) {
+			y = x>>32;
+			return 32 + debruijn32[(y&-y)*0x076be629 >> 27];
+		}
+		return debruijn32[(y&-y)*0x076be629 >> 27];
+	}
+	return debruijn64[(x&-x)*0x022fdd63cc95386dull >> 58];
+#endif
+}
+
+static const unsigned char bin_tab[60] = {
+	            32,33,34,35,36,36,37,37,38,38,39,39,
+	40,40,40,40,41,41,41,41,42,42,42,42,43,43,43,43,
+	44,44,44,44,44,44,44,44,45,45,45,45,45,45,45,45,
+	46,46,46,46,46,46,46,46,47,47,47,47,47,47,47,47,
+};
+
+static int bin_index(size_t x)
+{
+	x = x / SIZE_ALIGN - 1;
+	if (x <= 32) return x;
+	if (x < 512) return bin_tab[x/8-4];
+	if (x > 0x1c00) return 63;
+	return bin_tab[x/128-4] + 16;
+}
+
+static int bin_index_up(size_t x)
+{
+	x = x / SIZE_ALIGN - 1;
+	if (x <= 32) return x;
+	x--;
+	if (x < 512) return bin_tab[x/8-4] + 1;
+	return bin_tab[x/128-4] + 17;
+}
+
+#if 0
+void __dump_heap(int x)
+{
+	struct chunk *c;
+	int i;
+	for (c = (void *)mal.heap; CHUNK_SIZE(c); c = NEXT_CHUNK(c))
+		fprintf(stderr, "base %p size %zu (%d) flags %d/%d\n",
+			c, CHUNK_SIZE(c), bin_index(CHUNK_SIZE(c)),
+			c->csize & 15,
+			NEXT_CHUNK(c)->psize & 15);
+	for (i=0; i<64; i++) {
+		if (mal.bins[i].head != BIN_TO_CHUNK(i) && mal.bins[i].head) {
+			fprintf(stderr, "bin %d: %p\n", i, mal.bins[i].head);
+			if (!(mal.binmap & 1ULL<<i))
+				fprintf(stderr, "missing from binmap!\n");
+		} else if (mal.binmap & 1ULL<<i)
+			fprintf(stderr, "binmap wrongly contains %d!\n", i);
+	}
+}
+#endif
+
+static struct chunk *expand_heap(size_t n)
+{
+	static int heap_lock[2];
+	static void *end;
+	void *p;
+	struct chunk *w;
+
+	/* The argument n already accounts for the caller's chunk
+	 * overhead needs, but if the heap can't be extended in-place,
+	 * we need room for an extra zero-sized sentinel chunk. */
+	n += SIZE_ALIGN;
+
+	lock(heap_lock);
+
+	p = __expand_heap(&n);
+	if (!p) {
+		unlock(heap_lock);
+		return 0;
+	}
+
+	/* If not just expanding existing space, we need to make a
+	 * new sentinel chunk below the allocated space. */
+	if (p != end) {
+		/* Valid/safe because of the prologue increment. */
+		n -= SIZE_ALIGN;
+		p = (char *)p + SIZE_ALIGN;
+		w = MEM_TO_CHUNK(p);
+		w->psize = 0 | C_INUSE;
+	}
+
+	/* Record new heap end and fill in footer. */
+	end = (char *)p + n;
+	w = MEM_TO_CHUNK(end);
+	w->psize = n | C_INUSE;
+	w->csize = 0 | C_INUSE;
+
+	/* Fill in header, which may be new or may be replacing a
+	 * zero-size sentinel header at the old end-of-heap. */
+	w = MEM_TO_CHUNK(p);
+	w->csize = n | C_INUSE;
+
+	unlock(heap_lock);
+
+	return w;
+}
+
+static int adjust_size(size_t *n)
+{
+	/* Result of pointer difference must fit in ptrdiff_t. */
+	if (*n-1 > PTRDIFF_MAX - SIZE_ALIGN - PAGE_SIZE) {
+		if (*n) {
+			errno = ENOMEM;
+			return -1;
+		} else {
+			*n = SIZE_ALIGN;
+			return 0;
+		}
+	}
+	*n = (*n + OVERHEAD + SIZE_ALIGN - 1) & SIZE_MASK;
+	return 0;
+}
+
+static void unbin(struct chunk *c, int i)
+{
+	if (c->prev == c->next)
+		a_and_64(&mal.binmap, ~(1ULL<<i));
+	c->prev->next = c->next;
+	c->next->prev = c->prev;
+	c->csize |= C_INUSE;
+	NEXT_CHUNK(c)->psize |= C_INUSE;
+}
+
+static int alloc_fwd(struct chunk *c)
+{
+	int i;
+	size_t k;
+	while (!((k=c->csize) & C_INUSE)) {
+		i = bin_index(k);
+		lock_bin(i);
+		if (c->csize == k) {
+			unbin(c, i);
+			unlock_bin(i);
+			return 1;
+		}
+		unlock_bin(i);
+	}
+	return 0;
+}
+
+static int alloc_rev(struct chunk *c)
+{
+	int i;
+	size_t k;
+	while (!((k=c->psize) & C_INUSE)) {
+		i = bin_index(k);
+		lock_bin(i);
+		if (c->psize == k) {
+			unbin(PREV_CHUNK(c), i);
+			unlock_bin(i);
+			return 1;
+		}
+		unlock_bin(i);
+	}
+	return 0;
+}
+
+
+/* pretrim - trims a chunk _prior_ to removing it from its bin.
+ * Must be called with i as the ideal bin for size n, j the bin
+ * for the _free_ chunk self, and bin j locked. */
+static int pretrim(struct chunk *self, size_t n, int i, int j)
+{
+	size_t n1;
+	struct chunk *next, *split;
+
+	/* We cannot pretrim if it would require re-binning. */
+	if (j < 40) return 0;
+	if (j < i+3) {
+		if (j != 63) return 0;
+		n1 = CHUNK_SIZE(self);
+		if (n1-n <= MMAP_THRESHOLD) return 0;
+	} else {
+		n1 = CHUNK_SIZE(self);
+	}
+	if (bin_index(n1-n) != j) return 0;
+
+	next = NEXT_CHUNK(self);
+	split = (void *)((char *)self + n);
+
+	split->prev = self->prev;
+	split->next = self->next;
+	split->prev->next = split;
+	split->next->prev = split;
+	split->psize = n | C_INUSE;
+	split->csize = n1-n;
+	next->psize = n1-n;
+	self->csize = n | C_INUSE;
+	return 1;
+}
+
+static void trim(struct chunk *self, size_t n)
+{
+	size_t n1 = CHUNK_SIZE(self);
+	struct chunk *next, *split;
+
+	if (n >= n1 - DONTCARE) return;
+
+	next = NEXT_CHUNK(self);
+	split = (void *)((char *)self + n);
+
+	split->psize = n | C_INUSE;
+	split->csize = n1-n | C_INUSE;
+	next->psize = n1-n | C_INUSE;
+	self->csize = n | C_INUSE;
+
+	__bin_chunk(split);
+}
+
+void *malloc(size_t n)
+{
+	struct chunk *c;
+	int i, j;
+
+	if (adjust_size(&n) < 0) return 0;
+
+	if (n > MMAP_THRESHOLD) {
+		size_t len = n + OVERHEAD + PAGE_SIZE - 1 & -PAGE_SIZE;
+		char *base = __mmap(0, len, PROT_READ|PROT_WRITE,
+			MAP_PRIVATE|MAP_ANONYMOUS, -1, 0);
+		if (base == (void *)-1) return 0;
+		c = (void *)(base + SIZE_ALIGN - OVERHEAD);
+		c->csize = len - (SIZE_ALIGN - OVERHEAD);
+		c->psize = SIZE_ALIGN - OVERHEAD;
+		return CHUNK_TO_MEM(c);
+	}
+
+	i = bin_index_up(n);
+	for (;;) {
+		uint64_t mask = mal.binmap & -(1ULL<<i);
+		if (!mask) {
+			c = expand_heap(n);
+			if (!c) return 0;
+			if (alloc_rev(c)) {
+				struct chunk *x = c;
+				c = PREV_CHUNK(c);
+				NEXT_CHUNK(x)->psize = c->csize =
+					x->csize + CHUNK_SIZE(c);
+			}
+			break;
+		}
+		j = first_set(mask);
+		lock_bin(j);
+		c = mal.bins[j].head;
+		if (c != BIN_TO_CHUNK(j)) {
+			if (!pretrim(c, n, i, j)) unbin(c, j);
+			unlock_bin(j);
+			break;
+		}
+		unlock_bin(j);
+	}
+
+	/* Now patch up in case we over-allocated */
+	trim(c, n);
+
+	return CHUNK_TO_MEM(c);
+}
+
+static size_t mal0_clear(char *p, size_t pagesz, size_t n)
+{
+#ifdef __GNUC__
+	typedef uint64_t __attribute__((__may_alias__)) T;
+#else
+	typedef unsigned char T;
+#endif
+	char *pp = p + n;
+	size_t i = (uintptr_t)pp & (pagesz - 1);
+	for (;;) {
+		pp = memset(pp - i, 0, i);
+		if (pp - p < pagesz) return pp - p;
+		for (i = pagesz; i; i -= 2*sizeof(T), pp -= 2*sizeof(T))
+		        if (((T *)pp)[-1] | ((T *)pp)[-2])
+				break;
+	}
+}
+
+void *calloc(size_t m, size_t n)
+{
+	if (n && m > (size_t)-1/n) {
+		errno = ENOMEM;
+		return 0;
+	}
+	n *= m;
+	void *p = malloc(n);
+	if (!p) return p;
+	if (!__malloc_replaced) {
+		if (IS_MMAPPED(MEM_TO_CHUNK(p)))
+			return p;
+		if (n >= PAGE_SIZE)
+			n = mal0_clear(p, PAGE_SIZE, n);
+	}
+	return memset(p, 0, n);
+}
+
+void *realloc(void *p, size_t n)
+{
+	struct chunk *self, *next;
+	size_t n0, n1;
+	void *new;
+
+	if (!p) return malloc(n);
+	if (!n) {
+		free(p);
+		return NULL;
+	}
+
+	if (adjust_size(&n) < 0) return 0;
+
+	self = MEM_TO_CHUNK(p);
+	n1 = n0 = CHUNK_SIZE(self);
+
+	if (IS_MMAPPED(self)) {
+		size_t extra = self->psize;
+		char *base = (char *)self - extra;
+		size_t oldlen = n0 + extra;
+		size_t newlen = n + extra;
+		/* Crash on realloc of freed chunk */
+		if (extra & 1) a_crash();
+		if (newlen < PAGE_SIZE && (new = malloc(n-OVERHEAD))) {
+			n0 = n;
+			goto copy_free_ret;
+		}
+		newlen = (newlen + PAGE_SIZE-1) & -PAGE_SIZE;
+		if (oldlen == newlen) return p;
+		base = __mremap(base, oldlen, newlen, MREMAP_MAYMOVE);
+		if (base == (void *)-1)
+			goto copy_realloc;
+		self = (void *)(base + extra);
+		self->csize = newlen - extra;
+		return CHUNK_TO_MEM(self);
+	}
+
+	next = NEXT_CHUNK(self);
+
+	/* Crash on corrupted footer (likely from buffer overflow) */
+	if (next->psize != self->csize) a_crash();
+
+	/* Merge adjacent chunks if we need more space. This is not
+	 * a waste of time even if we fail to get enough space, because our
+	 * subsequent call to free would otherwise have to do the merge. */
+	if (n > n1 && alloc_fwd(next)) {
+		n1 += CHUNK_SIZE(next);
+		next = NEXT_CHUNK(next);
+	}
+	/* FIXME: find what's wrong here and reenable it..? */
+	if (0 && n > n1 && alloc_rev(self)) {
+		self = PREV_CHUNK(self);
+		n1 += CHUNK_SIZE(self);
+	}
+	self->csize = n1 | C_INUSE;
+	next->psize = n1 | C_INUSE;
+
+	/* If we got enough space, split off the excess and return */
+	if (n <= n1) {
+		//memmove(CHUNK_TO_MEM(self), p, n0-OVERHEAD);
+		trim(self, n);
+		return CHUNK_TO_MEM(self);
+	}
+
+copy_realloc:
+	/* As a last resort, allocate a new chunk and copy to it. */
+	new = malloc(n-OVERHEAD);
+	if (!new) return 0;
+copy_free_ret:
+	memcpy(new, p, n0-OVERHEAD);
+	free(CHUNK_TO_MEM(self));
+	return new;
+}
+
+void __bin_chunk(struct chunk *self)
+{
+	struct chunk *next = NEXT_CHUNK(self);
+	size_t final_size, new_size, size;
+	int reclaim=0;
+	int i;
+
+	final_size = new_size = CHUNK_SIZE(self);
+
+	/* Crash on corrupted footer (likely from buffer overflow) */
+	if (next->psize != self->csize) a_crash();
+
+	for (;;) {
+		if (self->psize & next->csize & C_INUSE) {
+			self->csize = final_size | C_INUSE;
+			next->psize = final_size | C_INUSE;
+			i = bin_index(final_size);
+			lock_bin(i);
+			lock(mal.free_lock);
+			if (self->psize & next->csize & C_INUSE)
+				break;
+			unlock(mal.free_lock);
+			unlock_bin(i);
+		}
+
+		if (alloc_rev(self)) {
+			self = PREV_CHUNK(self);
+			size = CHUNK_SIZE(self);
+			final_size += size;
+			if (new_size+size > RECLAIM && (new_size+size^size) > size)
+				reclaim = 1;
+		}
+
+		if (alloc_fwd(next)) {
+			size = CHUNK_SIZE(next);
+			final_size += size;
+			if (new_size+size > RECLAIM && (new_size+size^size) > size)
+				reclaim = 1;
+			next = NEXT_CHUNK(next);
+		}
+	}
+
+	if (!(mal.binmap & 1ULL<<i))
+		a_or_64(&mal.binmap, 1ULL<<i);
+
+	self->csize = final_size;
+	next->psize = final_size;
+	unlock(mal.free_lock);
+
+	self->next = BIN_TO_CHUNK(i);
+	self->prev = mal.bins[i].tail;
+	self->next->prev = self;
+	self->prev->next = self;
+
+	/* Replace middle of large chunks with fresh zero pages */
+	if (reclaim) {
+		uintptr_t a = (uintptr_t)self + SIZE_ALIGN+PAGE_SIZE-1 & -PAGE_SIZE;
+		uintptr_t b = (uintptr_t)next - SIZE_ALIGN & -PAGE_SIZE;
+#if 1
+		__madvise((void *)a, b-a, MADV_DONTNEED);
+#else
+		__mmap((void *)a, b-a, PROT_READ|PROT_WRITE,
+			MAP_PRIVATE|MAP_ANONYMOUS|MAP_FIXED, -1, 0);
+#endif
+	}
+
+	unlock_bin(i);
+}
+
+static void unmap_chunk(struct chunk *self)
+{
+	size_t extra = self->psize;
+	char *base = (char *)self - extra;
+	size_t len = CHUNK_SIZE(self) + extra;
+	/* Crash on double free */
+	if (extra & 1) a_crash();
+	__munmap(base, len);
+}
+
+void free(void *p)
+{
+	if (!p) return;
+
+	struct chunk *self = MEM_TO_CHUNK(p);
+
+	if (IS_MMAPPED(self))
+		unmap_chunk(self);
+	else
+		__bin_chunk(self);
+}
+
+void __malloc_donate(char *start, char *end)
+{
+	size_t align_start_up = (SIZE_ALIGN-1) & (-(uintptr_t)start - OVERHEAD);
+	size_t align_end_down = (SIZE_ALIGN-1) & (uintptr_t)end;
+
+	/* Getting past this condition ensures that the padding for alignment
+	 * and header overhead will not overflow and will leave a nonzero
+	 * multiple of SIZE_ALIGN bytes between start and end. */
+	if (end - start <= OVERHEAD + align_start_up + align_end_down)
+		return;
+	start += align_start_up + OVERHEAD;
+	end   -= align_end_down;
+
+	struct chunk *c = MEM_TO_CHUNK(start), *n = MEM_TO_CHUNK(end);
+	c->psize = n->csize = C_INUSE;
+	c->csize = n->psize = C_INUSE | (end-start);
+	__bin_chunk(c);
+}
diff --git a/third_party/musl/porting/linux/user/src/multibyte/wcsnrtombs.c b/third_party/musl/porting/linux/user/src/multibyte/wcsnrtombs.c
new file mode 100755
index 000000000..95e25e708
--- /dev/null
+++ b/third_party/musl/porting/linux/user/src/multibyte/wcsnrtombs.c
@@ -0,0 +1,35 @@
+#include <wchar.h>
+#include <limits.h>
+#include <string.h>
+
+size_t wcsnrtombs(char *restrict dst, const wchar_t **restrict wcs, size_t wn, size_t n, mbstate_t *restrict st)
+{
+	const wchar_t *ws = *wcs;
+	size_t cnt = 0;
+	if (!dst) n=0;
+	while (ws && wn) {
+		char tmp[MB_LEN_MAX];
+		size_t l = wcrtomb(n<MB_LEN_MAX ? tmp : dst, *ws, 0);
+		if (l==-1) {
+			cnt = -1;
+			break;
+		}
+		if (dst) {
+			if (n<MB_LEN_MAX) {
+				if (l>n) break;
+				memcpy(dst, tmp, l);
+			}
+			dst += l;
+			n -= l;
+		}
+		if (!*ws) {
+			ws = 0;
+			break;
+		}
+		ws++;
+		wn--;
+		cnt += l;
+	}
+	if (dst) *wcs = ws;
+	return cnt;
+}
diff --git a/third_party/musl/porting/linux/user/src/network/inet_legacy.c b/third_party/musl/porting/linux/user/src/network/inet_legacy.c
new file mode 100755
index 000000000..6d91b6e17
--- /dev/null
+++ b/third_party/musl/porting/linux/user/src/network/inet_legacy.c
@@ -0,0 +1,32 @@
+#include <sys/socket.h>
+#include <netinet/in.h>
+#include <arpa/inet.h>
+
+in_addr_t inet_network(const char *p)
+{
+	return ntohl(inet_addr(p));
+}
+
+struct in_addr inet_makeaddr(in_addr_t n, in_addr_t h)
+{
+	if (n < 256) h |= n<<24;
+	else if (n < 65536) h |= n<<16;
+	else h |= n<<8;
+	return (struct in_addr){ htonl(h) };
+}
+
+in_addr_t inet_lnaof(struct in_addr in)
+{
+	uint32_t h = ntohl(in.s_addr);
+	if (h>>24 < 128) return h & 0xffffff;
+	if (h>>24 < 192) return h & 0xffff;
+	return h & 0xff;
+}
+
+in_addr_t inet_netof(struct in_addr in)
+{
+	uint32_t h = ntohl(in.s_addr);
+	if (h>>24 < 128) return h >> 24;
+	if (h>>24 < 192) return h >> 16;
+	return h >> 8;
+}
diff --git a/third_party/musl/porting/linux/user/src/passwd/getspnam_r.c b/third_party/musl/porting/linux/user/src/passwd/getspnam_r.c
new file mode 100755
index 000000000..e738d656c
--- /dev/null
+++ b/third_party/musl/porting/linux/user/src/passwd/getspnam_r.c
@@ -0,0 +1,132 @@
+#include <fcntl.h>
+#include <unistd.h>
+#include <sys/stat.h>
+#include <ctype.h>
+#include <pthread.h>
+#include "pwf.h"
+
+/* This implementation support Openwall-style TCB passwords in place of
+ * traditional shadow, if the appropriate directories and files exist.
+ * Thus, it is careful to avoid following symlinks or blocking on fifos
+ * which a malicious user might create in place of his or her TCB shadow
+ * file. It also avoids any allocation to prevent memory-exhaustion
+ * attacks via huge TCB shadow files. */
+
+static long xatol(char **s)
+{
+	long x;
+	int sign;
+	if (**s == ':' || **s == '\n') return -1;
+
+	sign = (int)(unsigned char)**s;
+	if (sign == '-' || sign == '+') ++*s;
+
+	for (x=0; **s-'0'<10U; ++*s) x=10*x+(**s-'0');
+
+	if (sign == '-') return -x;
+	return x;
+}
+
+int __parsespent(char *s, struct spwd *sp)
+{
+	sp->sp_namp = s;
+	if (!(s = strchr(s, ':'))) return -1;
+	*s = 0;
+
+	sp->sp_pwdp = ++s;
+	if (!(s = strchr(s, ':'))) return -1;
+	*s = 0;
+
+	s++; sp->sp_lstchg = xatol(&s);
+	if (*s != ':') return -1;
+
+	s++; sp->sp_min = xatol(&s);
+	if (*s != ':') return -1;
+
+	s++; sp->sp_max = xatol(&s);
+	if (*s != ':') return -1;
+
+	s++; sp->sp_warn = xatol(&s);
+	if (*s != ':') return -1;
+
+	s++; sp->sp_inact = xatol(&s);
+	if (*s != ':') return -1;
+
+	s++; sp->sp_expire = xatol(&s);
+	if (*s != ':') return -1;
+
+	s++; sp->sp_flag = xatol(&s);
+	if (*s != '\n') return -1;
+	return 0;
+}
+
+static void cleanup(void *p)
+{
+	fclose(p);
+}
+
+int getspnam_r(const char *name, struct spwd *sp, char *buf, size_t size, struct spwd **res)
+{
+	char path[20+NAME_MAX];
+	FILE *f = 0;
+	int rv = 0;
+	int fd;
+	size_t k, l = strlen(name);
+	int skip = 0;
+	int cs;
+	int orig_errno = errno;
+
+	*res = 0;
+
+	/* Disallow potentially-malicious user names */
+	if (*name=='.' || strchr(name, '/') || !l)
+		return errno = EINVAL;
+
+	/* Buffer size must at least be able to hold name, plus some.. */
+	if (size < l+100)
+		return errno = ERANGE;
+
+	/* Protect against truncation */
+	if (snprintf(path, sizeof path, "/etc/tcb/%s/shadow", name) >= sizeof path)
+		return errno = EINVAL;
+
+	fd = open(path, O_RDONLY|O_NOFOLLOW|O_NONBLOCK|O_CLOEXEC);
+	if (fd >= 0) {
+		struct stat st = { 0 };
+		errno = EINVAL;
+		if (fstat(fd, &st) || !S_ISREG(st.st_mode) || !(f = fdopen(fd, "rb"))) {
+			pthread_setcancelstate(PTHREAD_CANCEL_DISABLE, &cs);
+			close(fd);
+			pthread_setcancelstate(cs, 0);
+			return errno;
+		}
+	} else {
+		if (errno != ENOENT && errno != ENOTDIR)
+			return errno;
+		f = fopen("/etc/shadow", "rbe");
+		if (!f) {
+			if (errno != ENOENT && errno != ENOTDIR)
+				return errno;
+			return 0;
+		}
+	}
+
+	pthread_cleanup_push(cleanup, f);
+	while (fgets(buf, size, f) && (k=strlen(buf))>0) {
+		if (skip || strncmp(name, buf, l) || buf[l]!=':') {
+			skip = buf[k-1] != '\n';
+			continue;
+		}
+		if (buf[k-1] != '\n') {
+			rv = ERANGE;
+			break;
+		}
+
+		if (__parsespent(buf, sp) < 0) continue;
+		*res = sp;
+		break;
+	}
+	pthread_cleanup_pop(1);
+	errno = rv ? rv : orig_errno;
+	return rv;
+}
diff --git a/third_party/musl/porting/linux/user/tools/install.sh b/third_party/musl/porting/linux/user/tools/install.sh
new file mode 100755
index 000000000..b6a7f7978
--- /dev/null
+++ b/third_party/musl/porting/linux/user/tools/install.sh
@@ -0,0 +1,66 @@
+#!/bin/sh
+#
+# This is an actually-safe install command which installs the new
+# file atomically in the new location, rather than overwriting
+# existing files.
+#
+
+usage() {
+printf "usage: %s [-D] [-l] [-r] [-m mode] src dest\n" "$0" 1>&2
+exit 1
+}
+
+mkdirp=
+symlink=
+symlinkflags="-s"
+mode=755
+
+while getopts Dlrm: name ; do
+case "$name" in
+D) mkdirp=yes ;;
+l) symlink=yes ;;
+r) symlink=yes; symlinkflags="$symlinkflags -r" ;;
+m) mode=$OPTARG ;;
+?) usage ;;
+esac
+done
+shift $(($OPTIND - 1))
+
+test "$#" -eq 2 || usage
+src=$1
+dst=$2
+tmp="$dst.tmp.$$"
+
+case "$dst" in
+*/) printf "%s: %s ends in /\n", "$0" "$dst" 1>&2 ; exit 1 ;;
+esac
+
+set -C
+set -e
+
+if test "$mkdirp" ; then
+umask 022
+case "$2" in
+*/*) mkdir -p "${dst%/*}" ;;
+esac
+fi
+
+trap 'rm -f "$tmp"' EXIT INT QUIT TERM HUP
+
+umask 077
+
+if test "$symlink" ; then
+ln $symlinkflags "$1" "$tmp"
+else
+cat < "$1" > "$tmp"
+chmod "$mode" "$tmp"
+fi
+
+mv -f "$tmp" "$2"
+test -d "$2" && {
+rm -f "$2/$tmp"
+printf "%s: %s is a directory\n" "$0" "$dst" 1>&2
+exit 1
+}
+
+exit 0
diff --git a/third_party/musl/kernel/include/alloca.h b/third_party/musl/porting/liteos_a/kernel/include/alloca.h
old mode 100644
new mode 100755
similarity index 100%
rename from third_party/musl/kernel/include/alloca.h
rename to third_party/musl/porting/liteos_a/kernel/include/alloca.h
diff --git a/third_party/musl/kernel/include/arpa/inet.h b/third_party/musl/porting/liteos_a/kernel/include/arpa/inet.h
old mode 100644
new mode 100755
similarity index 100%
rename from third_party/musl/kernel/include/arpa/inet.h
rename to third_party/musl/porting/liteos_a/kernel/include/arpa/inet.h
diff --git a/third_party/musl/kernel/include/assert.h b/third_party/musl/porting/liteos_a/kernel/include/assert.h
old mode 100644
new mode 100755
similarity index 100%
rename from third_party/musl/kernel/include/assert.h
rename to third_party/musl/porting/liteos_a/kernel/include/assert.h
diff --git a/third_party/musl/kernel/arch/arm/atomic_arch.h b/third_party/musl/porting/liteos_a/kernel/include/atomic_arch.h
old mode 100644
new mode 100755
similarity index 100%
rename from third_party/musl/kernel/arch/arm/atomic_arch.h
rename to third_party/musl/porting/liteos_a/kernel/include/atomic_arch.h
diff --git a/third_party/musl/kernel/obj/include/bits/alltypes.h b/third_party/musl/porting/liteos_a/kernel/include/bits/alltypes.h
old mode 100644
new mode 100755
similarity index 99%
rename from third_party/musl/kernel/obj/include/bits/alltypes.h
rename to third_party/musl/porting/liteos_a/kernel/include/bits/alltypes.h
index 166a2f8de..9a1b92a21
--- a/third_party/musl/kernel/obj/include/bits/alltypes.h
+++ b/third_party/musl/porting/liteos_a/kernel/include/bits/alltypes.h
@@ -1,4 +1,3 @@
-#include "menuconfig.h"
 #ifndef YES
 #define YES  1
 #endif
@@ -106,7 +105,7 @@ typedef struct __pthread_attr_s {
   void* stackaddr;
   unsigned int stacksize_set;
   size_t stacksize;
-#if (LOSCFG_KERNEL_SMP == YES)
+#ifdef LOSCFG_KERNEL_SMP
   cpu_set_t cpuset;
 #endif
 } pthread_attr_t;
diff --git a/third_party/musl/kernel/arch/generic/bits/dirent.h b/third_party/musl/porting/liteos_a/kernel/include/bits/dirent.h
old mode 100644
new mode 100755
similarity index 100%
rename from third_party/musl/kernel/arch/generic/bits/dirent.h
rename to third_party/musl/porting/liteos_a/kernel/include/bits/dirent.h
diff --git a/third_party/musl/kernel/arch/generic/bits/errno.h b/third_party/musl/porting/liteos_a/kernel/include/bits/errno.h
old mode 100644
new mode 100755
similarity index 100%
rename from third_party/musl/kernel/arch/generic/bits/errno.h
rename to third_party/musl/porting/liteos_a/kernel/include/bits/errno.h
diff --git a/third_party/musl/kernel/arch/arm/bits/fcntl.h b/third_party/musl/porting/liteos_a/kernel/include/bits/fcntl.h
old mode 100644
new mode 100755
similarity index 100%
rename from third_party/musl/kernel/arch/arm/bits/fcntl.h
rename to third_party/musl/porting/liteos_a/kernel/include/bits/fcntl.h
diff --git a/third_party/musl/kernel/arch/arm/bits/fenv.h b/third_party/musl/porting/liteos_a/kernel/include/bits/fenv.h
old mode 100644
new mode 100755
similarity index 100%
rename from third_party/musl/kernel/arch/arm/bits/fenv.h
rename to third_party/musl/porting/liteos_a/kernel/include/bits/fenv.h
diff --git a/third_party/musl/kernel/arch/arm/bits/float.h b/third_party/musl/porting/liteos_a/kernel/include/bits/float.h
old mode 100644
new mode 100755
similarity index 100%
rename from third_party/musl/kernel/arch/arm/bits/float.h
rename to third_party/musl/porting/liteos_a/kernel/include/bits/float.h
diff --git a/third_party/musl/kernel/arch/generic/bits/ioctl.h b/third_party/musl/porting/liteos_a/kernel/include/bits/ioctl.h
old mode 100644
new mode 100755
similarity index 100%
rename from third_party/musl/kernel/arch/generic/bits/ioctl.h
rename to third_party/musl/porting/liteos_a/kernel/include/bits/ioctl.h
diff --git a/third_party/musl/kernel/arch/arm/bits/ioctl_fix.h b/third_party/musl/porting/liteos_a/kernel/include/bits/ioctl_fix.h
old mode 100644
new mode 100755
similarity index 100%
rename from third_party/musl/kernel/arch/arm/bits/ioctl_fix.h
rename to third_party/musl/porting/liteos_a/kernel/include/bits/ioctl_fix.h
diff --git a/third_party/musl/kernel/arch/generic/bits/ipc.h b/third_party/musl/porting/liteos_a/kernel/include/bits/ipc.h
old mode 100644
new mode 100755
similarity index 100%
rename from third_party/musl/kernel/arch/generic/bits/ipc.h
rename to third_party/musl/porting/liteos_a/kernel/include/bits/ipc.h
diff --git a/third_party/musl/kernel/arch/arm/bits/ipcstat.h b/third_party/musl/porting/liteos_a/kernel/include/bits/ipcstat.h
old mode 100644
new mode 100755
similarity index 100%
rename from third_party/musl/kernel/arch/arm/bits/ipcstat.h
rename to third_party/musl/porting/liteos_a/kernel/include/bits/ipcstat.h
diff --git a/third_party/musl/kernel/arch/generic/bits/limits.h b/third_party/musl/porting/liteos_a/kernel/include/bits/limits.h
old mode 100644
new mode 100755
similarity index 100%
rename from third_party/musl/kernel/arch/generic/bits/limits.h
rename to third_party/musl/porting/liteos_a/kernel/include/bits/limits.h
diff --git a/third_party/musl/kernel/arch/generic/bits/mman.h b/third_party/musl/porting/liteos_a/kernel/include/bits/mman.h
old mode 100644
new mode 100755
similarity index 100%
rename from third_party/musl/kernel/arch/generic/bits/mman.h
rename to third_party/musl/porting/liteos_a/kernel/include/bits/mman.h
diff --git a/third_party/musl/kernel/arch/generic/bits/poll.h b/third_party/musl/porting/liteos_a/kernel/include/bits/poll.h
old mode 100644
new mode 100755
similarity index 100%
rename from third_party/musl/kernel/arch/generic/bits/poll.h
rename to third_party/musl/porting/liteos_a/kernel/include/bits/poll.h
diff --git a/third_party/musl/kernel/arch/arm/bits/posix.h b/third_party/musl/porting/liteos_a/kernel/include/bits/posix.h
old mode 100644
new mode 100755
similarity index 100%
rename from third_party/musl/kernel/arch/arm/bits/posix.h
rename to third_party/musl/porting/liteos_a/kernel/include/bits/posix.h
diff --git a/third_party/musl/kernel/arch/generic/bits/resource.h b/third_party/musl/porting/liteos_a/kernel/include/bits/resource.h
old mode 100644
new mode 100755
similarity index 100%
rename from third_party/musl/kernel/arch/generic/bits/resource.h
rename to third_party/musl/porting/liteos_a/kernel/include/bits/resource.h
diff --git a/third_party/musl/kernel/arch/arm/bits/shm.h b/third_party/musl/porting/liteos_a/kernel/include/bits/shm.h
old mode 100644
new mode 100755
similarity index 100%
rename from third_party/musl/kernel/arch/arm/bits/shm.h
rename to third_party/musl/porting/liteos_a/kernel/include/bits/shm.h
diff --git a/third_party/musl/kernel/arch/arm/bits/signal.h b/third_party/musl/porting/liteos_a/kernel/include/bits/signal.h
similarity index 100%
rename from third_party/musl/kernel/arch/arm/bits/signal.h
rename to third_party/musl/porting/liteos_a/kernel/include/bits/signal.h
diff --git a/third_party/musl/kernel/arch/generic/bits/socket.h b/third_party/musl/porting/liteos_a/kernel/include/bits/socket.h
old mode 100644
new mode 100755
similarity index 100%
rename from third_party/musl/kernel/arch/generic/bits/socket.h
rename to third_party/musl/porting/liteos_a/kernel/include/bits/socket.h
diff --git a/third_party/musl/kernel/arch/arm/bits/stat.h b/third_party/musl/porting/liteos_a/kernel/include/bits/stat.h
old mode 100644
new mode 100755
similarity index 100%
rename from third_party/musl/kernel/arch/arm/bits/stat.h
rename to third_party/musl/porting/liteos_a/kernel/include/bits/stat.h
diff --git a/third_party/musl/kernel/arch/generic/bits/statfs.h b/third_party/musl/porting/liteos_a/kernel/include/bits/statfs.h
old mode 100644
new mode 100755
similarity index 100%
rename from third_party/musl/kernel/arch/generic/bits/statfs.h
rename to third_party/musl/porting/liteos_a/kernel/include/bits/statfs.h
diff --git a/third_party/musl/kernel/arch/arm/bits/stdint.h b/third_party/musl/porting/liteos_a/kernel/include/bits/stdint.h
old mode 100644
new mode 100755
similarity index 100%
rename from third_party/musl/kernel/arch/arm/bits/stdint.h
rename to third_party/musl/porting/liteos_a/kernel/include/bits/stdint.h
diff --git a/third_party/musl/kernel/obj/include/bits/syscall.h b/third_party/musl/porting/liteos_a/kernel/include/bits/syscall.h
similarity index 100%
rename from third_party/musl/kernel/obj/include/bits/syscall.h
rename to third_party/musl/porting/liteos_a/kernel/include/bits/syscall.h
diff --git a/third_party/musl/kernel/arch/generic/bits/termios.h b/third_party/musl/porting/liteos_a/kernel/include/bits/termios.h
old mode 100644
new mode 100755
similarity index 100%
rename from third_party/musl/kernel/arch/generic/bits/termios.h
rename to third_party/musl/porting/liteos_a/kernel/include/bits/termios.h
diff --git a/third_party/musl/kernel/include/byteswap.h b/third_party/musl/porting/liteos_a/kernel/include/byteswap.h
old mode 100644
new mode 100755
similarity index 100%
rename from third_party/musl/kernel/include/byteswap.h
rename to third_party/musl/porting/liteos_a/kernel/include/byteswap.h
diff --git a/third_party/musl/kernel/include/complex.h b/third_party/musl/porting/liteos_a/kernel/include/complex.h
old mode 100644
new mode 100755
similarity index 100%
rename from third_party/musl/kernel/include/complex.h
rename to third_party/musl/porting/liteos_a/kernel/include/complex.h
diff --git a/third_party/musl/kernel/include/ctype.h b/third_party/musl/porting/liteos_a/kernel/include/ctype.h
old mode 100644
new mode 100755
similarity index 100%
rename from third_party/musl/kernel/include/ctype.h
rename to third_party/musl/porting/liteos_a/kernel/include/ctype.h
diff --git a/third_party/musl/kernel/include/dirent.h b/third_party/musl/porting/liteos_a/kernel/include/dirent.h
old mode 100644
new mode 100755
similarity index 100%
rename from third_party/musl/kernel/include/dirent.h
rename to third_party/musl/porting/liteos_a/kernel/include/dirent.h
diff --git a/third_party/musl/kernel/include/endian.h b/third_party/musl/porting/liteos_a/kernel/include/endian.h
old mode 100644
new mode 100755
similarity index 100%
rename from third_party/musl/kernel/include/endian.h
rename to third_party/musl/porting/liteos_a/kernel/include/endian.h
diff --git a/third_party/musl/kernel/include/errno.h b/third_party/musl/porting/liteos_a/kernel/include/errno.h
old mode 100644
new mode 100755
similarity index 100%
rename from third_party/musl/kernel/include/errno.h
rename to third_party/musl/porting/liteos_a/kernel/include/errno.h
diff --git a/third_party/musl/kernel/include/fcntl.h b/third_party/musl/porting/liteos_a/kernel/include/fcntl.h
old mode 100644
new mode 100755
similarity index 100%
rename from third_party/musl/kernel/include/fcntl.h
rename to third_party/musl/porting/liteos_a/kernel/include/fcntl.h
diff --git a/third_party/musl/kernel/include/features.h b/third_party/musl/porting/liteos_a/kernel/include/features.h
old mode 100644
new mode 100755
similarity index 100%
rename from third_party/musl/kernel/include/features.h
rename to third_party/musl/porting/liteos_a/kernel/include/features.h
diff --git a/third_party/musl/kernel/include/fenv.h b/third_party/musl/porting/liteos_a/kernel/include/fenv.h
old mode 100644
new mode 100755
similarity index 100%
rename from third_party/musl/kernel/include/fenv.h
rename to third_party/musl/porting/liteos_a/kernel/include/fenv.h
diff --git a/third_party/musl/kernel/include/float.h b/third_party/musl/porting/liteos_a/kernel/include/float.h
old mode 100644
new mode 100755
similarity index 100%
rename from third_party/musl/kernel/include/float.h
rename to third_party/musl/porting/liteos_a/kernel/include/float.h
diff --git a/third_party/musl/kernel/arch/generic/fp_arch.h b/third_party/musl/porting/liteos_a/kernel/include/fp_arch.h
old mode 100644
new mode 100755
similarity index 100%
rename from third_party/musl/kernel/arch/generic/fp_arch.h
rename to third_party/musl/porting/liteos_a/kernel/include/fp_arch.h
diff --git a/third_party/musl/kernel/include/ifaddrs.h b/third_party/musl/porting/liteos_a/kernel/include/ifaddrs.h
old mode 100644
new mode 100755
similarity index 100%
rename from third_party/musl/kernel/include/ifaddrs.h
rename to third_party/musl/porting/liteos_a/kernel/include/ifaddrs.h
diff --git a/third_party/musl/kernel/include/inttypes.h b/third_party/musl/porting/liteos_a/kernel/include/inttypes.h
old mode 100644
new mode 100755
similarity index 100%
rename from third_party/musl/kernel/include/inttypes.h
rename to third_party/musl/porting/liteos_a/kernel/include/inttypes.h
diff --git a/third_party/musl/kernel/include/langinfo.h b/third_party/musl/porting/liteos_a/kernel/include/langinfo.h
old mode 100644
new mode 100755
similarity index 100%
rename from third_party/musl/kernel/include/langinfo.h
rename to third_party/musl/porting/liteos_a/kernel/include/langinfo.h
diff --git a/third_party/musl/kernel/include/limits.h b/third_party/musl/porting/liteos_a/kernel/include/limits.h
similarity index 99%
rename from third_party/musl/kernel/include/limits.h
rename to third_party/musl/porting/liteos_a/kernel/include/limits.h
index c818b31c7..6e1a9db2c 100755
--- a/third_party/musl/kernel/include/limits.h
+++ b/third_party/musl/porting/liteos_a/kernel/include/limits.h
@@ -5,6 +5,8 @@
 
 #include <bits/alltypes.h> /* __LONG_MAX */
 
+#include "los_config.h"
+
 #ifndef PAGE_SIZE
 #define PAGE_SIZE 4096
 #endif
diff --git a/third_party/musl/kernel/include/locale.h b/third_party/musl/porting/liteos_a/kernel/include/locale.h
old mode 100644
new mode 100755
similarity index 100%
rename from third_party/musl/kernel/include/locale.h
rename to third_party/musl/porting/liteos_a/kernel/include/locale.h
diff --git a/third_party/musl/kernel/include/math.h b/third_party/musl/porting/liteos_a/kernel/include/math.h
old mode 100644
new mode 100755
similarity index 100%
rename from third_party/musl/kernel/include/math.h
rename to third_party/musl/porting/liteos_a/kernel/include/math.h
diff --git a/third_party/musl/kernel/include/net/ethernet.h b/third_party/musl/porting/liteos_a/kernel/include/net/ethernet.h
old mode 100644
new mode 100755
similarity index 100%
rename from third_party/musl/kernel/include/net/ethernet.h
rename to third_party/musl/porting/liteos_a/kernel/include/net/ethernet.h
diff --git a/third_party/musl/kernel/include/net/if.h b/third_party/musl/porting/liteos_a/kernel/include/net/if.h
old mode 100644
new mode 100755
similarity index 100%
rename from third_party/musl/kernel/include/net/if.h
rename to third_party/musl/porting/liteos_a/kernel/include/net/if.h
diff --git a/third_party/musl/kernel/include/net/if_arp.h b/third_party/musl/porting/liteos_a/kernel/include/net/if_arp.h
old mode 100644
new mode 100755
similarity index 100%
rename from third_party/musl/kernel/include/net/if_arp.h
rename to third_party/musl/porting/liteos_a/kernel/include/net/if_arp.h
diff --git a/third_party/musl/kernel/include/net/route.h b/third_party/musl/porting/liteos_a/kernel/include/net/route.h
old mode 100644
new mode 100755
similarity index 100%
rename from third_party/musl/kernel/include/net/route.h
rename to third_party/musl/porting/liteos_a/kernel/include/net/route.h
diff --git a/third_party/musl/kernel/include/netdb.h b/third_party/musl/porting/liteos_a/kernel/include/netdb.h
old mode 100644
new mode 100755
similarity index 100%
rename from third_party/musl/kernel/include/netdb.h
rename to third_party/musl/porting/liteos_a/kernel/include/netdb.h
diff --git a/third_party/musl/kernel/include/netinet/icmp6.h b/third_party/musl/porting/liteos_a/kernel/include/netinet/icmp6.h
old mode 100644
new mode 100755
similarity index 100%
rename from third_party/musl/kernel/include/netinet/icmp6.h
rename to third_party/musl/porting/liteos_a/kernel/include/netinet/icmp6.h
diff --git a/third_party/musl/kernel/include/netinet/if_ether.h b/third_party/musl/porting/liteos_a/kernel/include/netinet/if_ether.h
old mode 100644
new mode 100755
similarity index 100%
rename from third_party/musl/kernel/include/netinet/if_ether.h
rename to third_party/musl/porting/liteos_a/kernel/include/netinet/if_ether.h
diff --git a/third_party/musl/kernel/include/netinet/in.h b/third_party/musl/porting/liteos_a/kernel/include/netinet/in.h
old mode 100644
new mode 100755
similarity index 100%
rename from third_party/musl/kernel/include/netinet/in.h
rename to third_party/musl/porting/liteos_a/kernel/include/netinet/in.h
diff --git a/third_party/musl/kernel/include/netinet/ip.h b/third_party/musl/porting/liteos_a/kernel/include/netinet/ip.h
old mode 100644
new mode 100755
similarity index 100%
rename from third_party/musl/kernel/include/netinet/ip.h
rename to third_party/musl/porting/liteos_a/kernel/include/netinet/ip.h
diff --git a/third_party/musl/kernel/include/netinet/ip6.h b/third_party/musl/porting/liteos_a/kernel/include/netinet/ip6.h
old mode 100644
new mode 100755
similarity index 100%
rename from third_party/musl/kernel/include/netinet/ip6.h
rename to third_party/musl/porting/liteos_a/kernel/include/netinet/ip6.h
diff --git a/third_party/musl/kernel/include/netinet/ip_icmp.h b/third_party/musl/porting/liteos_a/kernel/include/netinet/ip_icmp.h
old mode 100644
new mode 100755
similarity index 100%
rename from third_party/musl/kernel/include/netinet/ip_icmp.h
rename to third_party/musl/porting/liteos_a/kernel/include/netinet/ip_icmp.h
diff --git a/third_party/musl/kernel/include/netinet/tcp.h b/third_party/musl/porting/liteos_a/kernel/include/netinet/tcp.h
old mode 100644
new mode 100755
similarity index 100%
rename from third_party/musl/kernel/include/netinet/tcp.h
rename to third_party/musl/porting/liteos_a/kernel/include/netinet/tcp.h
diff --git a/third_party/musl/kernel/include/netpacket/packet.h b/third_party/musl/porting/liteos_a/kernel/include/netpacket/packet.h
old mode 100644
new mode 100755
similarity index 100%
rename from third_party/musl/kernel/include/netpacket/packet.h
rename to third_party/musl/porting/liteos_a/kernel/include/netpacket/packet.h
diff --git a/third_party/musl/kernel/include/nl_types.h b/third_party/musl/porting/liteos_a/kernel/include/nl_types.h
old mode 100644
new mode 100755
similarity index 100%
rename from third_party/musl/kernel/include/nl_types.h
rename to third_party/musl/porting/liteos_a/kernel/include/nl_types.h
diff --git a/third_party/musl/kernel/include/poll.h b/third_party/musl/porting/liteos_a/kernel/include/poll.h
similarity index 100%
rename from third_party/musl/kernel/include/poll.h
rename to third_party/musl/porting/liteos_a/kernel/include/poll.h
diff --git a/third_party/musl/kernel/include/pthread.h b/third_party/musl/porting/liteos_a/kernel/include/pthread.h
old mode 100644
new mode 100755
similarity index 100%
rename from third_party/musl/kernel/include/pthread.h
rename to third_party/musl/porting/liteos_a/kernel/include/pthread.h
diff --git a/third_party/musl/kernel/include/sched.h b/third_party/musl/porting/liteos_a/kernel/include/sched.h
old mode 100644
new mode 100755
similarity index 100%
rename from third_party/musl/kernel/include/sched.h
rename to third_party/musl/porting/liteos_a/kernel/include/sched.h
diff --git a/third_party/musl/kernel/include/semaphore.h b/third_party/musl/porting/liteos_a/kernel/include/semaphore.h
old mode 100644
new mode 100755
similarity index 100%
rename from third_party/musl/kernel/include/semaphore.h
rename to third_party/musl/porting/liteos_a/kernel/include/semaphore.h
diff --git a/third_party/musl/kernel/include/signal.h b/third_party/musl/porting/liteos_a/kernel/include/signal.h
old mode 100644
new mode 100755
similarity index 100%
rename from third_party/musl/kernel/include/signal.h
rename to third_party/musl/porting/liteos_a/kernel/include/signal.h
diff --git a/third_party/musl/kernel/include/stdarg.h b/third_party/musl/porting/liteos_a/kernel/include/stdarg.h
old mode 100644
new mode 100755
similarity index 100%
rename from third_party/musl/kernel/include/stdarg.h
rename to third_party/musl/porting/liteos_a/kernel/include/stdarg.h
diff --git a/third_party/musl/kernel/include/stdbool.h b/third_party/musl/porting/liteos_a/kernel/include/stdbool.h
old mode 100644
new mode 100755
similarity index 100%
rename from third_party/musl/kernel/include/stdbool.h
rename to third_party/musl/porting/liteos_a/kernel/include/stdbool.h
diff --git a/third_party/musl/kernel/include/stddef.h b/third_party/musl/porting/liteos_a/kernel/include/stddef.h
old mode 100644
new mode 100755
similarity index 100%
rename from third_party/musl/kernel/include/stddef.h
rename to third_party/musl/porting/liteos_a/kernel/include/stddef.h
diff --git a/third_party/musl/kernel/include/stdint.h b/third_party/musl/porting/liteos_a/kernel/include/stdint.h
old mode 100644
new mode 100755
similarity index 100%
rename from third_party/musl/kernel/include/stdint.h
rename to third_party/musl/porting/liteos_a/kernel/include/stdint.h
diff --git a/third_party/musl/kernel/include/stdio.h b/third_party/musl/porting/liteos_a/kernel/include/stdio.h
old mode 100644
new mode 100755
similarity index 100%
rename from third_party/musl/kernel/include/stdio.h
rename to third_party/musl/porting/liteos_a/kernel/include/stdio.h
diff --git a/third_party/musl/kernel/include/stdlib.h b/third_party/musl/porting/liteos_a/kernel/include/stdlib.h
old mode 100644
new mode 100755
similarity index 100%
rename from third_party/musl/kernel/include/stdlib.h
rename to third_party/musl/porting/liteos_a/kernel/include/stdlib.h
diff --git a/third_party/musl/kernel/include/string.h b/third_party/musl/porting/liteos_a/kernel/include/string.h
old mode 100644
new mode 100755
similarity index 100%
rename from third_party/musl/kernel/include/string.h
rename to third_party/musl/porting/liteos_a/kernel/include/string.h
diff --git a/third_party/musl/kernel/include/strings.h b/third_party/musl/porting/liteos_a/kernel/include/strings.h
old mode 100644
new mode 100755
similarity index 100%
rename from third_party/musl/kernel/include/strings.h
rename to third_party/musl/porting/liteos_a/kernel/include/strings.h
diff --git a/third_party/musl/kernel/include/sys/errno.h b/third_party/musl/porting/liteos_a/kernel/include/sys/errno.h
old mode 100644
new mode 100755
similarity index 100%
rename from third_party/musl/kernel/include/sys/errno.h
rename to third_party/musl/porting/liteos_a/kernel/include/sys/errno.h
diff --git a/third_party/musl/kernel/include/sys/ioctl.h b/third_party/musl/porting/liteos_a/kernel/include/sys/ioctl.h
old mode 100644
new mode 100755
similarity index 100%
rename from third_party/musl/kernel/include/sys/ioctl.h
rename to third_party/musl/porting/liteos_a/kernel/include/sys/ioctl.h
diff --git a/third_party/musl/kernel/include/sys/ipc.h b/third_party/musl/porting/liteos_a/kernel/include/sys/ipc.h
old mode 100644
new mode 100755
similarity index 100%
rename from third_party/musl/kernel/include/sys/ipc.h
rename to third_party/musl/porting/liteos_a/kernel/include/sys/ipc.h
diff --git a/third_party/musl/kernel/include/sys/mman.h b/third_party/musl/porting/liteos_a/kernel/include/sys/mman.h
old mode 100644
new mode 100755
similarity index 100%
rename from third_party/musl/kernel/include/sys/mman.h
rename to third_party/musl/porting/liteos_a/kernel/include/sys/mman.h
diff --git a/third_party/musl/kernel/include/sys/mount.h b/third_party/musl/porting/liteos_a/kernel/include/sys/mount.h
old mode 100644
new mode 100755
similarity index 100%
rename from third_party/musl/kernel/include/sys/mount.h
rename to third_party/musl/porting/liteos_a/kernel/include/sys/mount.h
diff --git a/third_party/musl/kernel/include/sys/param.h b/third_party/musl/porting/liteos_a/kernel/include/sys/param.h
old mode 100644
new mode 100755
similarity index 100%
rename from third_party/musl/kernel/include/sys/param.h
rename to third_party/musl/porting/liteos_a/kernel/include/sys/param.h
diff --git a/third_party/musl/porting/liteos_a/kernel/include/sys/poll.h b/third_party/musl/porting/liteos_a/kernel/include/sys/poll.h
new file mode 100755
index 000000000..99170401d
--- /dev/null
+++ b/third_party/musl/porting/liteos_a/kernel/include/sys/poll.h
@@ -0,0 +1,2 @@
+#warning redirecting incorrect #include <sys/poll.h> to <poll.h>
+#include <poll.h>
diff --git a/third_party/musl/kernel/include/sys/prctl.h b/third_party/musl/porting/liteos_a/kernel/include/sys/prctl.h
old mode 100644
new mode 100755
similarity index 100%
rename from third_party/musl/kernel/include/sys/prctl.h
rename to third_party/musl/porting/liteos_a/kernel/include/sys/prctl.h
diff --git a/third_party/musl/kernel/include/sys/reboot.h b/third_party/musl/porting/liteos_a/kernel/include/sys/reboot.h
similarity index 100%
rename from third_party/musl/kernel/include/sys/reboot.h
rename to third_party/musl/porting/liteos_a/kernel/include/sys/reboot.h
diff --git a/third_party/musl/kernel/include/sys/resource.h b/third_party/musl/porting/liteos_a/kernel/include/sys/resource.h
old mode 100644
new mode 100755
similarity index 100%
rename from third_party/musl/kernel/include/sys/resource.h
rename to third_party/musl/porting/liteos_a/kernel/include/sys/resource.h
diff --git a/third_party/musl/kernel/include/sys/select.h b/third_party/musl/porting/liteos_a/kernel/include/sys/select.h
old mode 100644
new mode 100755
similarity index 93%
rename from third_party/musl/kernel/include/sys/select.h
rename to third_party/musl/porting/liteos_a/kernel/include/sys/select.h
index 28d7689c8..8880e86f7
--- a/third_party/musl/kernel/include/sys/select.h
+++ b/third_party/musl/porting/liteos_a/kernel/include/sys/select.h
@@ -15,9 +15,14 @@ extern "C" {
 
 #include <bits/alltypes.h>
 #include <signal.h>
+#ifdef LOSCFG_FS_VFS
 #include "vfs_config.h"
 
 /* FD_SETSIZE is defined in "vfs_config.h" */
+#else
+#define FD_SETSIZE 512
+#define FD_SET_TOTAL_SIZE FD_SETSIZE
+#endif
 
 typedef unsigned long fd_mask;
 
diff --git a/third_party/musl/kernel/include/sys/shm.h b/third_party/musl/porting/liteos_a/kernel/include/sys/shm.h
old mode 100644
new mode 100755
similarity index 100%
rename from third_party/musl/kernel/include/sys/shm.h
rename to third_party/musl/porting/liteos_a/kernel/include/sys/shm.h
diff --git a/third_party/musl/kernel/include/sys/socket.h b/third_party/musl/porting/liteos_a/kernel/include/sys/socket.h
old mode 100644
new mode 100755
similarity index 100%
rename from third_party/musl/kernel/include/sys/socket.h
rename to third_party/musl/porting/liteos_a/kernel/include/sys/socket.h
diff --git a/third_party/musl/kernel/include/sys/stat.h b/third_party/musl/porting/liteos_a/kernel/include/sys/stat.h
old mode 100644
new mode 100755
similarity index 100%
rename from third_party/musl/kernel/include/sys/stat.h
rename to third_party/musl/porting/liteos_a/kernel/include/sys/stat.h
diff --git a/third_party/musl/kernel/include/sys/statfs.h b/third_party/musl/porting/liteos_a/kernel/include/sys/statfs.h
old mode 100644
new mode 100755
similarity index 100%
rename from third_party/musl/kernel/include/sys/statfs.h
rename to third_party/musl/porting/liteos_a/kernel/include/sys/statfs.h
diff --git a/third_party/musl/kernel/include/sys/statvfs.h b/third_party/musl/porting/liteos_a/kernel/include/sys/statvfs.h
old mode 100644
new mode 100755
similarity index 100%
rename from third_party/musl/kernel/include/sys/statvfs.h
rename to third_party/musl/porting/liteos_a/kernel/include/sys/statvfs.h
diff --git a/third_party/musl/kernel/include/sys/syscall.h b/third_party/musl/porting/liteos_a/kernel/include/sys/syscall.h
old mode 100644
new mode 100755
similarity index 100%
rename from third_party/musl/kernel/include/sys/syscall.h
rename to third_party/musl/porting/liteos_a/kernel/include/sys/syscall.h
diff --git a/third_party/musl/kernel/include/sys/termios.h b/third_party/musl/porting/liteos_a/kernel/include/sys/termios.h
old mode 100644
new mode 100755
similarity index 100%
rename from third_party/musl/kernel/include/sys/termios.h
rename to third_party/musl/porting/liteos_a/kernel/include/sys/termios.h
diff --git a/third_party/musl/kernel/include/sys/time.h b/third_party/musl/porting/liteos_a/kernel/include/sys/time.h
old mode 100644
new mode 100755
similarity index 100%
rename from third_party/musl/kernel/include/sys/time.h
rename to third_party/musl/porting/liteos_a/kernel/include/sys/time.h
diff --git a/third_party/musl/kernel/include/sys/times.h b/third_party/musl/porting/liteos_a/kernel/include/sys/times.h
old mode 100644
new mode 100755
similarity index 100%
rename from third_party/musl/kernel/include/sys/times.h
rename to third_party/musl/porting/liteos_a/kernel/include/sys/times.h
diff --git a/third_party/musl/kernel/include/sys/types.h b/third_party/musl/porting/liteos_a/kernel/include/sys/types.h
old mode 100644
new mode 100755
similarity index 100%
rename from third_party/musl/kernel/include/sys/types.h
rename to third_party/musl/porting/liteos_a/kernel/include/sys/types.h
diff --git a/third_party/musl/kernel/include/sys/uio.h b/third_party/musl/porting/liteos_a/kernel/include/sys/uio.h
old mode 100644
new mode 100755
similarity index 100%
rename from third_party/musl/kernel/include/sys/uio.h
rename to third_party/musl/porting/liteos_a/kernel/include/sys/uio.h
diff --git a/third_party/musl/kernel/include/sys/utsname.h b/third_party/musl/porting/liteos_a/kernel/include/sys/utsname.h
old mode 100644
new mode 100755
similarity index 100%
rename from third_party/musl/kernel/include/sys/utsname.h
rename to third_party/musl/porting/liteos_a/kernel/include/sys/utsname.h
diff --git a/third_party/musl/kernel/include/sys/vfs.h b/third_party/musl/porting/liteos_a/kernel/include/sys/vfs.h
old mode 100644
new mode 100755
similarity index 100%
rename from third_party/musl/kernel/include/sys/vfs.h
rename to third_party/musl/porting/liteos_a/kernel/include/sys/vfs.h
diff --git a/third_party/musl/kernel/include/sys/wait.h b/third_party/musl/porting/liteos_a/kernel/include/sys/wait.h
old mode 100644
new mode 100755
similarity index 100%
rename from third_party/musl/kernel/include/sys/wait.h
rename to third_party/musl/porting/liteos_a/kernel/include/sys/wait.h
diff --git a/third_party/musl/kernel/include/syscall.h b/third_party/musl/porting/liteos_a/kernel/include/syscall.h
old mode 100644
new mode 100755
similarity index 100%
rename from third_party/musl/kernel/include/syscall.h
rename to third_party/musl/porting/liteos_a/kernel/include/syscall.h
diff --git a/third_party/musl/porting/liteos_a/kernel/include/sysinfo.h b/third_party/musl/porting/liteos_a/kernel/include/sysinfo.h
new file mode 100755
index 000000000..691e2a223
--- /dev/null
+++ b/third_party/musl/porting/liteos_a/kernel/include/sysinfo.h
@@ -0,0 +1,30 @@
+#ifndef _SYS_SYSINFO_H
+#define _SYS_SYSINFO_H
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+struct sysinfo {
+	unsigned long uptime;
+	unsigned long loads[3];
+	unsigned long totalram;
+	unsigned long freeram;
+	unsigned long sharedram;
+	unsigned long bufferram;
+	unsigned long totalswap;
+	unsigned long freeswap;
+	unsigned short procs, pad;
+	unsigned long totalhigh;
+	unsigned long freehigh;
+	unsigned mem_unit;
+	char __reserved[256];
+};
+
+int sysinfo (struct sysinfo *);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
diff --git a/third_party/musl/kernel/include/termios.h b/third_party/musl/porting/liteos_a/kernel/include/termios.h
old mode 100644
new mode 100755
similarity index 100%
rename from third_party/musl/kernel/include/termios.h
rename to third_party/musl/porting/liteos_a/kernel/include/termios.h
diff --git a/third_party/musl/kernel/include/time.h b/third_party/musl/porting/liteos_a/kernel/include/time.h
old mode 100644
new mode 100755
similarity index 100%
rename from third_party/musl/kernel/include/time.h
rename to third_party/musl/porting/liteos_a/kernel/include/time.h
diff --git a/third_party/musl/kernel/include/unistd.h b/third_party/musl/porting/liteos_a/kernel/include/unistd.h
old mode 100644
new mode 100755
similarity index 100%
rename from third_party/musl/kernel/include/unistd.h
rename to third_party/musl/porting/liteos_a/kernel/include/unistd.h
diff --git a/third_party/musl/kernel/include/utime.h b/third_party/musl/porting/liteos_a/kernel/include/utime.h
old mode 100644
new mode 100755
similarity index 100%
rename from third_party/musl/kernel/include/utime.h
rename to third_party/musl/porting/liteos_a/kernel/include/utime.h
diff --git a/third_party/musl/kernel/include/wchar.h b/third_party/musl/porting/liteos_a/kernel/include/wchar.h
old mode 100644
new mode 100755
similarity index 100%
rename from third_party/musl/kernel/include/wchar.h
rename to third_party/musl/porting/liteos_a/kernel/include/wchar.h
diff --git a/third_party/musl/kernel/include/wctype.h b/third_party/musl/porting/liteos_a/kernel/include/wctype.h
old mode 100644
new mode 100755
similarity index 100%
rename from third_party/musl/kernel/include/wctype.h
rename to third_party/musl/porting/liteos_a/kernel/include/wctype.h
diff --git a/third_party/musl/kernel/src/ctype/__ctype_get_mb_cur_max.c b/third_party/musl/porting/liteos_a/kernel/src/ctype/__ctype_get_mb_cur_max.c
old mode 100644
new mode 100755
similarity index 100%
rename from third_party/musl/kernel/src/ctype/__ctype_get_mb_cur_max.c
rename to third_party/musl/porting/liteos_a/kernel/src/ctype/__ctype_get_mb_cur_max.c
diff --git a/third_party/musl/kernel/src/ctype/isalpha.c b/third_party/musl/porting/liteos_a/kernel/src/ctype/isalpha.c
old mode 100644
new mode 100755
similarity index 100%
rename from third_party/musl/kernel/src/ctype/isalpha.c
rename to third_party/musl/porting/liteos_a/kernel/src/ctype/isalpha.c
diff --git a/third_party/musl/kernel/src/ctype/isdigit.c b/third_party/musl/porting/liteos_a/kernel/src/ctype/isdigit.c
old mode 100644
new mode 100755
similarity index 100%
rename from third_party/musl/kernel/src/ctype/isdigit.c
rename to third_party/musl/porting/liteos_a/kernel/src/ctype/isdigit.c
diff --git a/third_party/musl/kernel/src/ctype/islower.c b/third_party/musl/porting/liteos_a/kernel/src/ctype/islower.c
old mode 100644
new mode 100755
similarity index 100%
rename from third_party/musl/kernel/src/ctype/islower.c
rename to third_party/musl/porting/liteos_a/kernel/src/ctype/islower.c
diff --git a/third_party/musl/kernel/src/ctype/isspace.c b/third_party/musl/porting/liteos_a/kernel/src/ctype/isspace.c
old mode 100644
new mode 100755
similarity index 100%
rename from third_party/musl/kernel/src/ctype/isspace.c
rename to third_party/musl/porting/liteos_a/kernel/src/ctype/isspace.c
diff --git a/third_party/musl/kernel/src/ctype/isupper.c b/third_party/musl/porting/liteos_a/kernel/src/ctype/isupper.c
old mode 100644
new mode 100755
similarity index 100%
rename from third_party/musl/kernel/src/ctype/isupper.c
rename to third_party/musl/porting/liteos_a/kernel/src/ctype/isupper.c
diff --git a/third_party/musl/kernel/src/ctype/isxdigit.c b/third_party/musl/porting/liteos_a/kernel/src/ctype/isxdigit.c
old mode 100644
new mode 100755
similarity index 100%
rename from third_party/musl/kernel/src/ctype/isxdigit.c
rename to third_party/musl/porting/liteos_a/kernel/src/ctype/isxdigit.c
diff --git a/third_party/musl/kernel/src/ctype/tolower.c b/third_party/musl/porting/liteos_a/kernel/src/ctype/tolower.c
old mode 100644
new mode 100755
similarity index 100%
rename from third_party/musl/kernel/src/ctype/tolower.c
rename to third_party/musl/porting/liteos_a/kernel/src/ctype/tolower.c
diff --git a/third_party/musl/kernel/src/ctype/toupper.c b/third_party/musl/porting/liteos_a/kernel/src/ctype/toupper.c
old mode 100644
new mode 100755
similarity index 100%
rename from third_party/musl/kernel/src/ctype/toupper.c
rename to third_party/musl/porting/liteos_a/kernel/src/ctype/toupper.c
diff --git a/third_party/musl/kernel/src/dirent/__dirent.h b/third_party/musl/porting/liteos_a/kernel/src/dirent/__dirent.h
old mode 100644
new mode 100755
similarity index 100%
rename from third_party/musl/kernel/src/dirent/__dirent.h
rename to third_party/musl/porting/liteos_a/kernel/src/dirent/__dirent.h
diff --git a/third_party/musl/porting/liteos_a/kernel/src/env/getenv.c b/third_party/musl/porting/liteos_a/kernel/src/env/getenv.c
new file mode 100755
index 000000000..81499d095
--- /dev/null
+++ b/third_party/musl/porting/liteos_a/kernel/src/env/getenv.c
@@ -0,0 +1,56 @@
+/*
+ * Copyright (c) 2013-2019 Huawei Technologies Co., Ltd. All rights reserved.
+ * Copyright (c) 2020-2021 Huawei Device Co., Ltd. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without modification,
+ * are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice, this list of
+ *    conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright notice, this list
+ *    of conditions and the following disclaimer in the documentation and/or other materials
+ *    provided with the distribution.
+ *
+ * 3. Neither the name of the copyright holder nor the names of its contributors may be used
+ *    to endorse or promote products derived from this software without specific prior written
+ *    permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+ * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+ * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
+ * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
+ * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
+ * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#include "stdlib.h"
+#include "string.h"
+#include "los_exc.h"
+
+/*
+ * getenv --
+ *  Returns ptr to value associated with name, if any, else NULL.
+ */
+char *
+getenv(const char *name)
+{
+#ifdef LOSCFG_LLTREPORT
+    if (strncmp(name, "GCOV_PREFIX", sizeof("GCOV_PREFIX")) == 0) {
+#ifdef LOSCFG_LLTSER
+        extern const char *gcov_dir;
+        return (char *)gcov_dir;
+#else
+        return "/bin/vs/sd";
+#endif
+    }
+    if (strncmp(name, "GCOV_PREFIX_STRIP", sizeof("GCOV_PREFIX_STRIP")) == 0)
+        return "6";
+#endif
+    return (NULL);
+}
diff --git a/third_party/musl/kernel/src/errno/__strerror.h b/third_party/musl/porting/liteos_a/kernel/src/errno/__strerror.h
old mode 100644
new mode 100755
similarity index 100%
rename from third_party/musl/kernel/src/errno/__strerror.h
rename to third_party/musl/porting/liteos_a/kernel/src/errno/__strerror.h
diff --git a/third_party/musl/porting/liteos_a/kernel/src/errno/errno.c b/third_party/musl/porting/liteos_a/kernel/src/errno/errno.c
new file mode 100755
index 000000000..03cb60595
--- /dev/null
+++ b/third_party/musl/porting/liteos_a/kernel/src/errno/errno.c
@@ -0,0 +1,89 @@
+/*
+ * Copyright (c) 2013-2019 Huawei Technologies Co., Ltd. All rights reserved.
+ * Copyright (c) 2020-2021 Huawei Device Co., Ltd. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without modification,
+ * are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice, this list of
+ *    conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright notice, this list
+ *    of conditions and the following disclaimer in the documentation and/or other materials
+ *    provided with the distribution.
+ *
+ * 3. Neither the name of the copyright holder nor the names of its contributors may be used
+ *    to endorse or promote products derived from this software without specific prior written
+ *    permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+ * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+ * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
+ * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
+ * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
+ * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#include "errno.h"
+#include "los_errno.h"
+#include "los_task_pri.h"
+
+/* the specific errno get or set in interrupt service routine */
+static int errno_isr;
+
+void set_errno(int err_code) {
+  LosTaskCB *runTask = NULL;
+
+  /* errno can not be set to 0 as posix standard */
+  if (err_code == 0)
+    return;
+
+  if (OS_INT_INACTIVE) {
+    runTask = OsCurrTaskGet();
+    runTask->errorNo = err_code;
+  }
+  else {
+    errno_isr = err_code;
+  }
+}
+
+int get_errno(void) {
+  LosTaskCB *runTask = NULL;
+
+  if (OS_INT_INACTIVE) {
+    runTask = OsCurrTaskGet();
+    return runTask->errorNo;
+  }
+  else {
+    return errno_isr;
+  }
+}
+
+int *__errno_location(void) {
+  LosTaskCB *runTask = NULL;
+
+  if (OS_INT_INACTIVE) {
+    runTask = OsCurrTaskGet();
+    return &runTask->errorNo;
+  }
+  else {
+    return &errno_isr;
+  }
+}
+
+volatile int *__errno(void) {
+  LosTaskCB *runTask = NULL;
+
+  if (OS_INT_INACTIVE) {
+    runTask = OsCurrTaskGet();
+    return (volatile int *)(&runTask->errorNo);
+  }
+  else {
+    return (volatile int *)(&errno_isr);
+  }
+}
diff --git a/third_party/musl/kernel/src/errno/strerror.c b/third_party/musl/porting/liteos_a/kernel/src/errno/strerror.c
old mode 100644
new mode 100755
similarity index 100%
rename from third_party/musl/kernel/src/errno/strerror.c
rename to third_party/musl/porting/liteos_a/kernel/src/errno/strerror.c
diff --git a/third_party/musl/porting/liteos_a/kernel/src/exit/abort.c b/third_party/musl/porting/liteos_a/kernel/src/exit/abort.c
new file mode 100755
index 000000000..5a3a5d632
--- /dev/null
+++ b/third_party/musl/porting/liteos_a/kernel/src/exit/abort.c
@@ -0,0 +1,39 @@
+/*
+ * Copyright (c) 2013-2019 Huawei Technologies Co., Ltd. All rights reserved.
+ * Copyright (c) 2020-2021 Huawei Device Co., Ltd. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without modification,
+ * are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice, this list of
+ *    conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright notice, this list
+ *    of conditions and the following disclaimer in the documentation and/or other materials
+ *    provided with the distribution.
+ *
+ * 3. Neither the name of the copyright holder nor the names of its contributors may be used
+ *    to endorse or promote products derived from this software without specific prior written
+ *    permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+ * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+ * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
+ * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
+ * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
+ * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#include "stdlib.h"
+#include "string.h"
+#include "los_exc.h"
+
+void abort(void) {
+  LOS_Panic("System was being aborted\n");
+  while (1);
+}
\ No newline at end of file
diff --git a/third_party/musl/porting/liteos_a/kernel/src/exit/assert.c b/third_party/musl/porting/liteos_a/kernel/src/exit/assert.c
new file mode 100755
index 000000000..51938edda
--- /dev/null
+++ b/third_party/musl/porting/liteos_a/kernel/src/exit/assert.c
@@ -0,0 +1,61 @@
+/*
+ * Copyright (c) 2013-2019 Huawei Technologies Co., Ltd. All rights reserved.
+ * Copyright (c) 2020-2021 Huawei Device Co., Ltd. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without modification,
+ * are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice, this list of
+ *    conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright notice, this list
+ *    of conditions and the following disclaimer in the documentation and/or other materials
+ *    provided with the distribution.
+ *
+ * 3. Neither the name of the copyright holder nor the names of its contributors may be used
+ *    to endorse or promote products derived from this software without specific prior written
+ *    permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+ * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+ * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
+ * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
+ * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
+ * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#include "assert.h"
+#include "los_hwi.h"
+#include "los_printf.h"
+#include "los_exc.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif /* __cplusplus */
+
+void __assert(const char* file, int line, const char* expr) {
+  PRINT_ERR("__assert error: %s, %d, %s\n", file, line, expr);
+  LOS_Panic("__assert error:\n");
+  while (1);
+}
+
+void __assert2(const char* file, int line, const char* func, const char* expr) {
+  PRINT_ERR("%s:%d: %s: assertion \"%s\" failed", file, line, func, expr);
+  LOS_Panic("__assert error:\n");
+  while (1);
+}
+
+void __assert_fail(const char* expr, const char* file, int line, const char* func) {
+  PRINT_ERR("%s:%d: %s: assertion \"%s\" failed", file, line, func, expr);
+  LOS_Panic("__assert error:\n");
+  while (1);
+}
+
+#ifdef __cplusplus
+}
+#endif /* __cplusplus */
\ No newline at end of file
diff --git a/third_party/musl/porting/liteos_a/kernel/src/exit/exit.c b/third_party/musl/porting/liteos_a/kernel/src/exit/exit.c
new file mode 100755
index 000000000..4fd2028ca
--- /dev/null
+++ b/third_party/musl/porting/liteos_a/kernel/src/exit/exit.c
@@ -0,0 +1,45 @@
+/*
+ * Copyright (c) 2013-2019 Huawei Technologies Co., Ltd. All rights reserved.
+ * Copyright (c) 2020-2021 Huawei Device Co., Ltd. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without modification,
+ * are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice, this list of
+ *    conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright notice, this list
+ *    of conditions and the following disclaimer in the documentation and/or other materials
+ *    provided with the distribution.
+ *
+ * 3. Neither the name of the copyright holder nor the names of its contributors may be used
+ *    to endorse or promote products derived from this software without specific prior written
+ *    permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+ * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+ * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
+ * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
+ * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
+ * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#include <errno.h>
+#include "los_printf.h"
+
+void _exit(int status) {
+  PRINT_ERR("%s NOT SUPPORT\n", __FUNCTION__);
+  errno = ENOSYS;
+  while (1);
+}
+
+void exit(int status) {
+  PRINT_ERR("%s NOT SUPPORT\n", __FUNCTION__);
+  errno = ENOSYS;
+  while (1);
+}
diff --git a/third_party/musl/kernel/src/fenv/fenv.c b/third_party/musl/porting/liteos_a/kernel/src/fenv/fenv.c
old mode 100644
new mode 100755
similarity index 100%
rename from third_party/musl/kernel/src/fenv/fenv.c
rename to third_party/musl/porting/liteos_a/kernel/src/fenv/fenv.c
diff --git a/third_party/musl/kernel/src/include/arpa/inet.h b/third_party/musl/porting/liteos_a/kernel/src/include/arpa/inet.h
old mode 100644
new mode 100755
similarity index 100%
rename from third_party/musl/kernel/src/include/arpa/inet.h
rename to third_party/musl/porting/liteos_a/kernel/src/include/arpa/inet.h
diff --git a/third_party/musl/kernel/src/include/features.h b/third_party/musl/porting/liteos_a/kernel/src/include/features.h
old mode 100644
new mode 100755
similarity index 100%
rename from third_party/musl/kernel/src/include/features.h
rename to third_party/musl/porting/liteos_a/kernel/src/include/features.h
diff --git a/third_party/musl/kernel/src/include/langinfo.h b/third_party/musl/porting/liteos_a/kernel/src/include/langinfo.h
old mode 100644
new mode 100755
similarity index 100%
rename from third_party/musl/kernel/src/include/langinfo.h
rename to third_party/musl/porting/liteos_a/kernel/src/include/langinfo.h
diff --git a/third_party/musl/kernel/src/include/stdio.h b/third_party/musl/porting/liteos_a/kernel/src/include/stdio.h
old mode 100644
new mode 100755
similarity index 100%
rename from third_party/musl/kernel/src/include/stdio.h
rename to third_party/musl/porting/liteos_a/kernel/src/include/stdio.h
diff --git a/third_party/musl/kernel/src/include/string.h b/third_party/musl/porting/liteos_a/kernel/src/include/string.h
old mode 100644
new mode 100755
similarity index 100%
rename from third_party/musl/kernel/src/include/string.h
rename to third_party/musl/porting/liteos_a/kernel/src/include/string.h
diff --git a/third_party/musl/kernel/src/include/sys/mman.h b/third_party/musl/porting/liteos_a/kernel/src/include/sys/mman.h
old mode 100644
new mode 100755
similarity index 100%
rename from third_party/musl/kernel/src/include/sys/mman.h
rename to third_party/musl/porting/liteos_a/kernel/src/include/sys/mman.h
diff --git a/third_party/musl/kernel/src/include/time.h b/third_party/musl/porting/liteos_a/kernel/src/include/time.h
old mode 100644
new mode 100755
similarity index 100%
rename from third_party/musl/kernel/src/include/time.h
rename to third_party/musl/porting/liteos_a/kernel/src/include/time.h
diff --git a/third_party/musl/kernel/src/include/unistd.h b/third_party/musl/porting/liteos_a/kernel/src/include/unistd.h
old mode 100644
new mode 100755
similarity index 100%
rename from third_party/musl/kernel/src/include/unistd.h
rename to third_party/musl/porting/liteos_a/kernel/src/include/unistd.h
diff --git a/third_party/musl/kernel/src/internal/atomic.h b/third_party/musl/porting/liteos_a/kernel/src/internal/atomic.h
old mode 100644
new mode 100755
similarity index 100%
rename from third_party/musl/kernel/src/internal/atomic.h
rename to third_party/musl/porting/liteos_a/kernel/src/internal/atomic.h
diff --git a/third_party/musl/kernel/src/internal/floatscan.c b/third_party/musl/porting/liteos_a/kernel/src/internal/floatscan.c
old mode 100644
new mode 100755
similarity index 100%
rename from third_party/musl/kernel/src/internal/floatscan.c
rename to third_party/musl/porting/liteos_a/kernel/src/internal/floatscan.c
diff --git a/third_party/musl/kernel/src/internal/floatscan.h b/third_party/musl/porting/liteos_a/kernel/src/internal/floatscan.h
old mode 100644
new mode 100755
similarity index 100%
rename from third_party/musl/kernel/src/internal/floatscan.h
rename to third_party/musl/porting/liteos_a/kernel/src/internal/floatscan.h
diff --git a/third_party/musl/kernel/src/internal/intscan.c b/third_party/musl/porting/liteos_a/kernel/src/internal/intscan.c
old mode 100644
new mode 100755
similarity index 100%
rename from third_party/musl/kernel/src/internal/intscan.c
rename to third_party/musl/porting/liteos_a/kernel/src/internal/intscan.c
diff --git a/third_party/musl/kernel/src/internal/intscan.h b/third_party/musl/porting/liteos_a/kernel/src/internal/intscan.h
old mode 100644
new mode 100755
similarity index 100%
rename from third_party/musl/kernel/src/internal/intscan.h
rename to third_party/musl/porting/liteos_a/kernel/src/internal/intscan.h
diff --git a/third_party/musl/kernel/src/internal/libc.h b/third_party/musl/porting/liteos_a/kernel/src/internal/libc.h
old mode 100644
new mode 100755
similarity index 100%
rename from third_party/musl/kernel/src/internal/libc.h
rename to third_party/musl/porting/liteos_a/kernel/src/internal/libc.h
diff --git a/third_party/musl/kernel/src/internal/libm.h b/third_party/musl/porting/liteos_a/kernel/src/internal/libm.h
old mode 100644
new mode 100755
similarity index 100%
rename from third_party/musl/kernel/src/internal/libm.h
rename to third_party/musl/porting/liteos_a/kernel/src/internal/libm.h
diff --git a/third_party/musl/kernel/src/internal/locale_impl.h b/third_party/musl/porting/liteos_a/kernel/src/internal/locale_impl.h
old mode 100644
new mode 100755
similarity index 100%
rename from third_party/musl/kernel/src/internal/locale_impl.h
rename to third_party/musl/porting/liteos_a/kernel/src/internal/locale_impl.h
diff --git a/third_party/musl/kernel/src/internal/pthread_impl.h b/third_party/musl/porting/liteos_a/kernel/src/internal/pthread_impl.h
old mode 100644
new mode 100755
similarity index 100%
rename from third_party/musl/kernel/src/internal/pthread_impl.h
rename to third_party/musl/porting/liteos_a/kernel/src/internal/pthread_impl.h
diff --git a/third_party/musl/kernel/src/internal/shgetc.c b/third_party/musl/porting/liteos_a/kernel/src/internal/shgetc.c
old mode 100644
new mode 100755
similarity index 100%
rename from third_party/musl/kernel/src/internal/shgetc.c
rename to third_party/musl/porting/liteos_a/kernel/src/internal/shgetc.c
diff --git a/third_party/musl/kernel/src/internal/shgetc.h b/third_party/musl/porting/liteos_a/kernel/src/internal/shgetc.h
old mode 100644
new mode 100755
similarity index 100%
rename from third_party/musl/kernel/src/internal/shgetc.h
rename to third_party/musl/porting/liteos_a/kernel/src/internal/shgetc.h
diff --git a/third_party/musl/kernel/src/internal/stdio_impl.h b/third_party/musl/porting/liteos_a/kernel/src/internal/stdio_impl.h
old mode 100644
new mode 100755
similarity index 100%
rename from third_party/musl/kernel/src/internal/stdio_impl.h
rename to third_party/musl/porting/liteos_a/kernel/src/internal/stdio_impl.h
diff --git a/third_party/musl/kernel/src/linux/stime.c b/third_party/musl/porting/liteos_a/kernel/src/linux/stime.c
old mode 100644
new mode 100755
similarity index 100%
rename from third_party/musl/kernel/src/linux/stime.c
rename to third_party/musl/porting/liteos_a/kernel/src/linux/stime.c
diff --git a/third_party/musl/kernel/src/locale/__lctrans.c b/third_party/musl/porting/liteos_a/kernel/src/locale/__lctrans.c
old mode 100644
new mode 100755
similarity index 100%
rename from third_party/musl/kernel/src/locale/__lctrans.c
rename to third_party/musl/porting/liteos_a/kernel/src/locale/__lctrans.c
diff --git a/third_party/musl/kernel/src/locale/__mo_lookup.c b/third_party/musl/porting/liteos_a/kernel/src/locale/__mo_lookup.c
old mode 100644
new mode 100755
similarity index 100%
rename from third_party/musl/kernel/src/locale/__mo_lookup.c
rename to third_party/musl/porting/liteos_a/kernel/src/locale/__mo_lookup.c
diff --git a/third_party/musl/kernel/src/locale/c_locale.c b/third_party/musl/porting/liteos_a/kernel/src/locale/c_locale.c
old mode 100644
new mode 100755
similarity index 100%
rename from third_party/musl/kernel/src/locale/c_locale.c
rename to third_party/musl/porting/liteos_a/kernel/src/locale/c_locale.c
diff --git a/third_party/musl/kernel/src/locale/langinfo.c b/third_party/musl/porting/liteos_a/kernel/src/locale/langinfo.c
old mode 100644
new mode 100755
similarity index 100%
rename from third_party/musl/kernel/src/locale/langinfo.c
rename to third_party/musl/porting/liteos_a/kernel/src/locale/langinfo.c
diff --git a/third_party/musl/kernel/src/locale/locale_map.c b/third_party/musl/porting/liteos_a/kernel/src/locale/locale_map.c
old mode 100644
new mode 100755
similarity index 100%
rename from third_party/musl/kernel/src/locale/locale_map.c
rename to third_party/musl/porting/liteos_a/kernel/src/locale/locale_map.c
diff --git a/third_party/musl/kernel/src/malloc/malloc.c b/third_party/musl/porting/liteos_a/kernel/src/malloc/malloc.c
similarity index 96%
rename from third_party/musl/kernel/src/malloc/malloc.c
rename to third_party/musl/porting/liteos_a/kernel/src/malloc/malloc.c
index 4611a3140..ccac6fcce 100755
--- a/third_party/musl/kernel/src/malloc/malloc.c
+++ b/third_party/musl/porting/liteos_a/kernel/src/malloc/malloc.c
@@ -1,6 +1,6 @@
 /*
- * Copyright (c) 2013-2019, Huawei Technologies Co., Ltd. All rights reserved.
- * Copyright (c) 2020, Huawei Device Co., Ltd. All rights reserved.
+ * Copyright (c) 2013-2019 Huawei Technologies Co., Ltd. All rights reserved.
+ * Copyright (c) 2020-2021 Huawei Device Co., Ltd. All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without modification,
  * are permitted provided that the following conditions are met:
diff --git a/third_party/musl/kernel/src/math/__cos.c b/third_party/musl/porting/liteos_a/kernel/src/math/__cos.c
old mode 100644
new mode 100755
similarity index 100%
rename from third_party/musl/kernel/src/math/__cos.c
rename to third_party/musl/porting/liteos_a/kernel/src/math/__cos.c
diff --git a/third_party/musl/kernel/src/math/__cosdf.c b/third_party/musl/porting/liteos_a/kernel/src/math/__cosdf.c
old mode 100644
new mode 100755
similarity index 100%
rename from third_party/musl/kernel/src/math/__cosdf.c
rename to third_party/musl/porting/liteos_a/kernel/src/math/__cosdf.c
diff --git a/third_party/musl/kernel/src/math/__cosl.c b/third_party/musl/porting/liteos_a/kernel/src/math/__cosl.c
old mode 100644
new mode 100755
similarity index 100%
rename from third_party/musl/kernel/src/math/__cosl.c
rename to third_party/musl/porting/liteos_a/kernel/src/math/__cosl.c
diff --git a/third_party/musl/kernel/src/math/__expo2.c b/third_party/musl/porting/liteos_a/kernel/src/math/__expo2.c
old mode 100644
new mode 100755
similarity index 100%
rename from third_party/musl/kernel/src/math/__expo2.c
rename to third_party/musl/porting/liteos_a/kernel/src/math/__expo2.c
diff --git a/third_party/musl/kernel/src/math/__expo2f.c b/third_party/musl/porting/liteos_a/kernel/src/math/__expo2f.c
old mode 100644
new mode 100755
similarity index 100%
rename from third_party/musl/kernel/src/math/__expo2f.c
rename to third_party/musl/porting/liteos_a/kernel/src/math/__expo2f.c
diff --git a/third_party/musl/kernel/src/math/__fpclassify.c b/third_party/musl/porting/liteos_a/kernel/src/math/__fpclassify.c
old mode 100644
new mode 100755
similarity index 100%
rename from third_party/musl/kernel/src/math/__fpclassify.c
rename to third_party/musl/porting/liteos_a/kernel/src/math/__fpclassify.c
diff --git a/third_party/musl/kernel/src/math/__fpclassifyf.c b/third_party/musl/porting/liteos_a/kernel/src/math/__fpclassifyf.c
old mode 100644
new mode 100755
similarity index 100%
rename from third_party/musl/kernel/src/math/__fpclassifyf.c
rename to third_party/musl/porting/liteos_a/kernel/src/math/__fpclassifyf.c
diff --git a/third_party/musl/kernel/src/math/__fpclassifyl.c b/third_party/musl/porting/liteos_a/kernel/src/math/__fpclassifyl.c
old mode 100644
new mode 100755
similarity index 100%
rename from third_party/musl/kernel/src/math/__fpclassifyl.c
rename to third_party/musl/porting/liteos_a/kernel/src/math/__fpclassifyl.c
diff --git a/third_party/musl/kernel/src/math/__invtrigl.c b/third_party/musl/porting/liteos_a/kernel/src/math/__invtrigl.c
old mode 100644
new mode 100755
similarity index 100%
rename from third_party/musl/kernel/src/math/__invtrigl.c
rename to third_party/musl/porting/liteos_a/kernel/src/math/__invtrigl.c
diff --git a/third_party/musl/kernel/src/math/__invtrigl.h b/third_party/musl/porting/liteos_a/kernel/src/math/__invtrigl.h
old mode 100644
new mode 100755
similarity index 100%
rename from third_party/musl/kernel/src/math/__invtrigl.h
rename to third_party/musl/porting/liteos_a/kernel/src/math/__invtrigl.h
diff --git a/third_party/musl/kernel/src/math/__math_divzero.c b/third_party/musl/porting/liteos_a/kernel/src/math/__math_divzero.c
old mode 100644
new mode 100755
similarity index 100%
rename from third_party/musl/kernel/src/math/__math_divzero.c
rename to third_party/musl/porting/liteos_a/kernel/src/math/__math_divzero.c
diff --git a/third_party/musl/kernel/src/math/__math_divzerof.c b/third_party/musl/porting/liteos_a/kernel/src/math/__math_divzerof.c
old mode 100644
new mode 100755
similarity index 100%
rename from third_party/musl/kernel/src/math/__math_divzerof.c
rename to third_party/musl/porting/liteos_a/kernel/src/math/__math_divzerof.c
diff --git a/third_party/musl/kernel/src/math/__math_invalid.c b/third_party/musl/porting/liteos_a/kernel/src/math/__math_invalid.c
old mode 100644
new mode 100755
similarity index 100%
rename from third_party/musl/kernel/src/math/__math_invalid.c
rename to third_party/musl/porting/liteos_a/kernel/src/math/__math_invalid.c
diff --git a/third_party/musl/kernel/src/math/__math_invalidf.c b/third_party/musl/porting/liteos_a/kernel/src/math/__math_invalidf.c
old mode 100644
new mode 100755
similarity index 100%
rename from third_party/musl/kernel/src/math/__math_invalidf.c
rename to third_party/musl/porting/liteos_a/kernel/src/math/__math_invalidf.c
diff --git a/third_party/musl/kernel/src/math/__math_oflow.c b/third_party/musl/porting/liteos_a/kernel/src/math/__math_oflow.c
old mode 100644
new mode 100755
similarity index 100%
rename from third_party/musl/kernel/src/math/__math_oflow.c
rename to third_party/musl/porting/liteos_a/kernel/src/math/__math_oflow.c
diff --git a/third_party/musl/kernel/src/math/__math_oflowf.c b/third_party/musl/porting/liteos_a/kernel/src/math/__math_oflowf.c
old mode 100644
new mode 100755
similarity index 100%
rename from third_party/musl/kernel/src/math/__math_oflowf.c
rename to third_party/musl/porting/liteos_a/kernel/src/math/__math_oflowf.c
diff --git a/third_party/musl/kernel/src/math/__math_uflow.c b/third_party/musl/porting/liteos_a/kernel/src/math/__math_uflow.c
old mode 100644
new mode 100755
similarity index 100%
rename from third_party/musl/kernel/src/math/__math_uflow.c
rename to third_party/musl/porting/liteos_a/kernel/src/math/__math_uflow.c
diff --git a/third_party/musl/kernel/src/math/__math_uflowf.c b/third_party/musl/porting/liteos_a/kernel/src/math/__math_uflowf.c
old mode 100644
new mode 100755
similarity index 100%
rename from third_party/musl/kernel/src/math/__math_uflowf.c
rename to third_party/musl/porting/liteos_a/kernel/src/math/__math_uflowf.c
diff --git a/third_party/musl/kernel/src/math/__math_xflow.c b/third_party/musl/porting/liteos_a/kernel/src/math/__math_xflow.c
old mode 100644
new mode 100755
similarity index 100%
rename from third_party/musl/kernel/src/math/__math_xflow.c
rename to third_party/musl/porting/liteos_a/kernel/src/math/__math_xflow.c
diff --git a/third_party/musl/kernel/src/math/__math_xflowf.c b/third_party/musl/porting/liteos_a/kernel/src/math/__math_xflowf.c
old mode 100644
new mode 100755
similarity index 100%
rename from third_party/musl/kernel/src/math/__math_xflowf.c
rename to third_party/musl/porting/liteos_a/kernel/src/math/__math_xflowf.c
diff --git a/third_party/musl/kernel/src/math/__polevll.c b/third_party/musl/porting/liteos_a/kernel/src/math/__polevll.c
old mode 100644
new mode 100755
similarity index 100%
rename from third_party/musl/kernel/src/math/__polevll.c
rename to third_party/musl/porting/liteos_a/kernel/src/math/__polevll.c
diff --git a/third_party/musl/kernel/src/math/__rem_pio2.c b/third_party/musl/porting/liteos_a/kernel/src/math/__rem_pio2.c
old mode 100644
new mode 100755
similarity index 100%
rename from third_party/musl/kernel/src/math/__rem_pio2.c
rename to third_party/musl/porting/liteos_a/kernel/src/math/__rem_pio2.c
diff --git a/third_party/musl/kernel/src/math/__rem_pio2_large.c b/third_party/musl/porting/liteos_a/kernel/src/math/__rem_pio2_large.c
old mode 100644
new mode 100755
similarity index 100%
rename from third_party/musl/kernel/src/math/__rem_pio2_large.c
rename to third_party/musl/porting/liteos_a/kernel/src/math/__rem_pio2_large.c
diff --git a/third_party/musl/kernel/src/math/__rem_pio2f.c b/third_party/musl/porting/liteos_a/kernel/src/math/__rem_pio2f.c
old mode 100644
new mode 100755
similarity index 100%
rename from third_party/musl/kernel/src/math/__rem_pio2f.c
rename to third_party/musl/porting/liteos_a/kernel/src/math/__rem_pio2f.c
diff --git a/third_party/musl/kernel/src/math/__rem_pio2l.c b/third_party/musl/porting/liteos_a/kernel/src/math/__rem_pio2l.c
old mode 100644
new mode 100755
similarity index 100%
rename from third_party/musl/kernel/src/math/__rem_pio2l.c
rename to third_party/musl/porting/liteos_a/kernel/src/math/__rem_pio2l.c
diff --git a/third_party/musl/kernel/src/math/__signbit.c b/third_party/musl/porting/liteos_a/kernel/src/math/__signbit.c
old mode 100644
new mode 100755
similarity index 100%
rename from third_party/musl/kernel/src/math/__signbit.c
rename to third_party/musl/porting/liteos_a/kernel/src/math/__signbit.c
diff --git a/third_party/musl/kernel/src/math/__signbitf.c b/third_party/musl/porting/liteos_a/kernel/src/math/__signbitf.c
old mode 100644
new mode 100755
similarity index 100%
rename from third_party/musl/kernel/src/math/__signbitf.c
rename to third_party/musl/porting/liteos_a/kernel/src/math/__signbitf.c
diff --git a/third_party/musl/kernel/src/math/__signbitl.c b/third_party/musl/porting/liteos_a/kernel/src/math/__signbitl.c
old mode 100644
new mode 100755
similarity index 100%
rename from third_party/musl/kernel/src/math/__signbitl.c
rename to third_party/musl/porting/liteos_a/kernel/src/math/__signbitl.c
diff --git a/third_party/musl/kernel/src/math/__sin.c b/third_party/musl/porting/liteos_a/kernel/src/math/__sin.c
old mode 100644
new mode 100755
similarity index 100%
rename from third_party/musl/kernel/src/math/__sin.c
rename to third_party/musl/porting/liteos_a/kernel/src/math/__sin.c
diff --git a/third_party/musl/kernel/src/math/__sindf.c b/third_party/musl/porting/liteos_a/kernel/src/math/__sindf.c
old mode 100644
new mode 100755
similarity index 100%
rename from third_party/musl/kernel/src/math/__sindf.c
rename to third_party/musl/porting/liteos_a/kernel/src/math/__sindf.c
diff --git a/third_party/musl/kernel/src/math/__sinl.c b/third_party/musl/porting/liteos_a/kernel/src/math/__sinl.c
old mode 100644
new mode 100755
similarity index 100%
rename from third_party/musl/kernel/src/math/__sinl.c
rename to third_party/musl/porting/liteos_a/kernel/src/math/__sinl.c
diff --git a/third_party/musl/kernel/src/math/__tan.c b/third_party/musl/porting/liteos_a/kernel/src/math/__tan.c
old mode 100644
new mode 100755
similarity index 100%
rename from third_party/musl/kernel/src/math/__tan.c
rename to third_party/musl/porting/liteos_a/kernel/src/math/__tan.c
diff --git a/third_party/musl/kernel/src/math/__tandf.c b/third_party/musl/porting/liteos_a/kernel/src/math/__tandf.c
old mode 100644
new mode 100755
similarity index 100%
rename from third_party/musl/kernel/src/math/__tandf.c
rename to third_party/musl/porting/liteos_a/kernel/src/math/__tandf.c
diff --git a/third_party/musl/kernel/src/math/__tanl.c b/third_party/musl/porting/liteos_a/kernel/src/math/__tanl.c
old mode 100644
new mode 100755
similarity index 100%
rename from third_party/musl/kernel/src/math/__tanl.c
rename to third_party/musl/porting/liteos_a/kernel/src/math/__tanl.c
diff --git a/third_party/musl/kernel/src/math/acos.c b/third_party/musl/porting/liteos_a/kernel/src/math/acos.c
old mode 100644
new mode 100755
similarity index 100%
rename from third_party/musl/kernel/src/math/acos.c
rename to third_party/musl/porting/liteos_a/kernel/src/math/acos.c
diff --git a/third_party/musl/kernel/src/math/acosf.c b/third_party/musl/porting/liteos_a/kernel/src/math/acosf.c
old mode 100644
new mode 100755
similarity index 100%
rename from third_party/musl/kernel/src/math/acosf.c
rename to third_party/musl/porting/liteos_a/kernel/src/math/acosf.c
diff --git a/third_party/musl/kernel/src/math/acosh.c b/third_party/musl/porting/liteos_a/kernel/src/math/acosh.c
old mode 100644
new mode 100755
similarity index 100%
rename from third_party/musl/kernel/src/math/acosh.c
rename to third_party/musl/porting/liteos_a/kernel/src/math/acosh.c
diff --git a/third_party/musl/kernel/src/math/acoshf.c b/third_party/musl/porting/liteos_a/kernel/src/math/acoshf.c
old mode 100644
new mode 100755
similarity index 100%
rename from third_party/musl/kernel/src/math/acoshf.c
rename to third_party/musl/porting/liteos_a/kernel/src/math/acoshf.c
diff --git a/third_party/musl/kernel/src/math/acoshl.c b/third_party/musl/porting/liteos_a/kernel/src/math/acoshl.c
old mode 100644
new mode 100755
similarity index 100%
rename from third_party/musl/kernel/src/math/acoshl.c
rename to third_party/musl/porting/liteos_a/kernel/src/math/acoshl.c
diff --git a/third_party/musl/kernel/src/math/acosl.c b/third_party/musl/porting/liteos_a/kernel/src/math/acosl.c
old mode 100644
new mode 100755
similarity index 100%
rename from third_party/musl/kernel/src/math/acosl.c
rename to third_party/musl/porting/liteos_a/kernel/src/math/acosl.c
diff --git a/third_party/musl/kernel/src/math/arm/fabs.c b/third_party/musl/porting/liteos_a/kernel/src/math/arm/fabs.c
old mode 100644
new mode 100755
similarity index 100%
rename from third_party/musl/kernel/src/math/arm/fabs.c
rename to third_party/musl/porting/liteos_a/kernel/src/math/arm/fabs.c
diff --git a/third_party/musl/kernel/src/math/arm/fabsf.c b/third_party/musl/porting/liteos_a/kernel/src/math/arm/fabsf.c
old mode 100644
new mode 100755
similarity index 100%
rename from third_party/musl/kernel/src/math/arm/fabsf.c
rename to third_party/musl/porting/liteos_a/kernel/src/math/arm/fabsf.c
diff --git a/third_party/musl/kernel/src/math/arm/fma.c b/third_party/musl/porting/liteos_a/kernel/src/math/arm/fma.c
old mode 100644
new mode 100755
similarity index 100%
rename from third_party/musl/kernel/src/math/arm/fma.c
rename to third_party/musl/porting/liteos_a/kernel/src/math/arm/fma.c
diff --git a/third_party/musl/kernel/src/math/arm/fmaf.c b/third_party/musl/porting/liteos_a/kernel/src/math/arm/fmaf.c
old mode 100644
new mode 100755
similarity index 100%
rename from third_party/musl/kernel/src/math/arm/fmaf.c
rename to third_party/musl/porting/liteos_a/kernel/src/math/arm/fmaf.c
diff --git a/third_party/musl/kernel/src/math/arm/sqrt.c b/third_party/musl/porting/liteos_a/kernel/src/math/arm/sqrt.c
old mode 100644
new mode 100755
similarity index 100%
rename from third_party/musl/kernel/src/math/arm/sqrt.c
rename to third_party/musl/porting/liteos_a/kernel/src/math/arm/sqrt.c
diff --git a/third_party/musl/kernel/src/math/arm/sqrtf.c b/third_party/musl/porting/liteos_a/kernel/src/math/arm/sqrtf.c
old mode 100644
new mode 100755
similarity index 100%
rename from third_party/musl/kernel/src/math/arm/sqrtf.c
rename to third_party/musl/porting/liteos_a/kernel/src/math/arm/sqrtf.c
diff --git a/third_party/musl/kernel/src/math/asin.c b/third_party/musl/porting/liteos_a/kernel/src/math/asin.c
old mode 100644
new mode 100755
similarity index 100%
rename from third_party/musl/kernel/src/math/asin.c
rename to third_party/musl/porting/liteos_a/kernel/src/math/asin.c
diff --git a/third_party/musl/kernel/src/math/asinf.c b/third_party/musl/porting/liteos_a/kernel/src/math/asinf.c
old mode 100644
new mode 100755
similarity index 100%
rename from third_party/musl/kernel/src/math/asinf.c
rename to third_party/musl/porting/liteos_a/kernel/src/math/asinf.c
diff --git a/third_party/musl/kernel/src/math/asinh.c b/third_party/musl/porting/liteos_a/kernel/src/math/asinh.c
old mode 100644
new mode 100755
similarity index 100%
rename from third_party/musl/kernel/src/math/asinh.c
rename to third_party/musl/porting/liteos_a/kernel/src/math/asinh.c
diff --git a/third_party/musl/kernel/src/math/asinhf.c b/third_party/musl/porting/liteos_a/kernel/src/math/asinhf.c
old mode 100644
new mode 100755
similarity index 100%
rename from third_party/musl/kernel/src/math/asinhf.c
rename to third_party/musl/porting/liteos_a/kernel/src/math/asinhf.c
diff --git a/third_party/musl/kernel/src/math/asinhl.c b/third_party/musl/porting/liteos_a/kernel/src/math/asinhl.c
old mode 100644
new mode 100755
similarity index 100%
rename from third_party/musl/kernel/src/math/asinhl.c
rename to third_party/musl/porting/liteos_a/kernel/src/math/asinhl.c
diff --git a/third_party/musl/kernel/src/math/asinl.c b/third_party/musl/porting/liteos_a/kernel/src/math/asinl.c
old mode 100644
new mode 100755
similarity index 100%
rename from third_party/musl/kernel/src/math/asinl.c
rename to third_party/musl/porting/liteos_a/kernel/src/math/asinl.c
diff --git a/third_party/musl/kernel/src/math/atan.c b/third_party/musl/porting/liteos_a/kernel/src/math/atan.c
old mode 100644
new mode 100755
similarity index 100%
rename from third_party/musl/kernel/src/math/atan.c
rename to third_party/musl/porting/liteos_a/kernel/src/math/atan.c
diff --git a/third_party/musl/kernel/src/math/atan2.c b/third_party/musl/porting/liteos_a/kernel/src/math/atan2.c
old mode 100644
new mode 100755
similarity index 100%
rename from third_party/musl/kernel/src/math/atan2.c
rename to third_party/musl/porting/liteos_a/kernel/src/math/atan2.c
diff --git a/third_party/musl/kernel/src/math/atan2f.c b/third_party/musl/porting/liteos_a/kernel/src/math/atan2f.c
old mode 100644
new mode 100755
similarity index 100%
rename from third_party/musl/kernel/src/math/atan2f.c
rename to third_party/musl/porting/liteos_a/kernel/src/math/atan2f.c
diff --git a/third_party/musl/kernel/src/math/atan2l.c b/third_party/musl/porting/liteos_a/kernel/src/math/atan2l.c
old mode 100644
new mode 100755
similarity index 100%
rename from third_party/musl/kernel/src/math/atan2l.c
rename to third_party/musl/porting/liteos_a/kernel/src/math/atan2l.c
diff --git a/third_party/musl/kernel/src/math/atanf.c b/third_party/musl/porting/liteos_a/kernel/src/math/atanf.c
old mode 100644
new mode 100755
similarity index 100%
rename from third_party/musl/kernel/src/math/atanf.c
rename to third_party/musl/porting/liteos_a/kernel/src/math/atanf.c
diff --git a/third_party/musl/kernel/src/math/atanh.c b/third_party/musl/porting/liteos_a/kernel/src/math/atanh.c
old mode 100644
new mode 100755
similarity index 100%
rename from third_party/musl/kernel/src/math/atanh.c
rename to third_party/musl/porting/liteos_a/kernel/src/math/atanh.c
diff --git a/third_party/musl/kernel/src/math/atanhf.c b/third_party/musl/porting/liteos_a/kernel/src/math/atanhf.c
old mode 100644
new mode 100755
similarity index 100%
rename from third_party/musl/kernel/src/math/atanhf.c
rename to third_party/musl/porting/liteos_a/kernel/src/math/atanhf.c
diff --git a/third_party/musl/kernel/src/math/atanhl.c b/third_party/musl/porting/liteos_a/kernel/src/math/atanhl.c
old mode 100644
new mode 100755
similarity index 100%
rename from third_party/musl/kernel/src/math/atanhl.c
rename to third_party/musl/porting/liteos_a/kernel/src/math/atanhl.c
diff --git a/third_party/musl/kernel/src/math/atanl.c b/third_party/musl/porting/liteos_a/kernel/src/math/atanl.c
old mode 100644
new mode 100755
similarity index 100%
rename from third_party/musl/kernel/src/math/atanl.c
rename to third_party/musl/porting/liteos_a/kernel/src/math/atanl.c
diff --git a/third_party/musl/kernel/src/math/cbrt.c b/third_party/musl/porting/liteos_a/kernel/src/math/cbrt.c
old mode 100644
new mode 100755
similarity index 100%
rename from third_party/musl/kernel/src/math/cbrt.c
rename to third_party/musl/porting/liteos_a/kernel/src/math/cbrt.c
diff --git a/third_party/musl/kernel/src/math/cbrtf.c b/third_party/musl/porting/liteos_a/kernel/src/math/cbrtf.c
old mode 100644
new mode 100755
similarity index 100%
rename from third_party/musl/kernel/src/math/cbrtf.c
rename to third_party/musl/porting/liteos_a/kernel/src/math/cbrtf.c
diff --git a/third_party/musl/kernel/src/math/cbrtl.c b/third_party/musl/porting/liteos_a/kernel/src/math/cbrtl.c
old mode 100644
new mode 100755
similarity index 100%
rename from third_party/musl/kernel/src/math/cbrtl.c
rename to third_party/musl/porting/liteos_a/kernel/src/math/cbrtl.c
diff --git a/third_party/musl/kernel/src/math/ceil.c b/third_party/musl/porting/liteos_a/kernel/src/math/ceil.c
old mode 100644
new mode 100755
similarity index 100%
rename from third_party/musl/kernel/src/math/ceil.c
rename to third_party/musl/porting/liteos_a/kernel/src/math/ceil.c
diff --git a/third_party/musl/kernel/src/math/ceilf.c b/third_party/musl/porting/liteos_a/kernel/src/math/ceilf.c
old mode 100644
new mode 100755
similarity index 100%
rename from third_party/musl/kernel/src/math/ceilf.c
rename to third_party/musl/porting/liteos_a/kernel/src/math/ceilf.c
diff --git a/third_party/musl/kernel/src/math/ceill.c b/third_party/musl/porting/liteos_a/kernel/src/math/ceill.c
old mode 100644
new mode 100755
similarity index 100%
rename from third_party/musl/kernel/src/math/ceill.c
rename to third_party/musl/porting/liteos_a/kernel/src/math/ceill.c
diff --git a/third_party/musl/kernel/src/math/copysign.c b/third_party/musl/porting/liteos_a/kernel/src/math/copysign.c
old mode 100644
new mode 100755
similarity index 100%
rename from third_party/musl/kernel/src/math/copysign.c
rename to third_party/musl/porting/liteos_a/kernel/src/math/copysign.c
diff --git a/third_party/musl/kernel/src/math/copysignf.c b/third_party/musl/porting/liteos_a/kernel/src/math/copysignf.c
old mode 100644
new mode 100755
similarity index 100%
rename from third_party/musl/kernel/src/math/copysignf.c
rename to third_party/musl/porting/liteos_a/kernel/src/math/copysignf.c
diff --git a/third_party/musl/kernel/src/math/copysignl.c b/third_party/musl/porting/liteos_a/kernel/src/math/copysignl.c
old mode 100644
new mode 100755
similarity index 100%
rename from third_party/musl/kernel/src/math/copysignl.c
rename to third_party/musl/porting/liteos_a/kernel/src/math/copysignl.c
diff --git a/third_party/musl/kernel/src/math/cos.c b/third_party/musl/porting/liteos_a/kernel/src/math/cos.c
old mode 100644
new mode 100755
similarity index 100%
rename from third_party/musl/kernel/src/math/cos.c
rename to third_party/musl/porting/liteos_a/kernel/src/math/cos.c
diff --git a/third_party/musl/kernel/src/math/cosf.c b/third_party/musl/porting/liteos_a/kernel/src/math/cosf.c
old mode 100644
new mode 100755
similarity index 100%
rename from third_party/musl/kernel/src/math/cosf.c
rename to third_party/musl/porting/liteos_a/kernel/src/math/cosf.c
diff --git a/third_party/musl/kernel/src/math/cosh.c b/third_party/musl/porting/liteos_a/kernel/src/math/cosh.c
old mode 100644
new mode 100755
similarity index 100%
rename from third_party/musl/kernel/src/math/cosh.c
rename to third_party/musl/porting/liteos_a/kernel/src/math/cosh.c
diff --git a/third_party/musl/kernel/src/math/coshf.c b/third_party/musl/porting/liteos_a/kernel/src/math/coshf.c
old mode 100644
new mode 100755
similarity index 100%
rename from third_party/musl/kernel/src/math/coshf.c
rename to third_party/musl/porting/liteos_a/kernel/src/math/coshf.c
diff --git a/third_party/musl/kernel/src/math/coshl.c b/third_party/musl/porting/liteos_a/kernel/src/math/coshl.c
old mode 100644
new mode 100755
similarity index 100%
rename from third_party/musl/kernel/src/math/coshl.c
rename to third_party/musl/porting/liteos_a/kernel/src/math/coshl.c
diff --git a/third_party/musl/kernel/src/math/cosl.c b/third_party/musl/porting/liteos_a/kernel/src/math/cosl.c
old mode 100644
new mode 100755
similarity index 100%
rename from third_party/musl/kernel/src/math/cosl.c
rename to third_party/musl/porting/liteos_a/kernel/src/math/cosl.c
diff --git a/third_party/musl/kernel/src/math/erf.c b/third_party/musl/porting/liteos_a/kernel/src/math/erf.c
old mode 100644
new mode 100755
similarity index 100%
rename from third_party/musl/kernel/src/math/erf.c
rename to third_party/musl/porting/liteos_a/kernel/src/math/erf.c
diff --git a/third_party/musl/kernel/src/math/erff.c b/third_party/musl/porting/liteos_a/kernel/src/math/erff.c
old mode 100644
new mode 100755
similarity index 100%
rename from third_party/musl/kernel/src/math/erff.c
rename to third_party/musl/porting/liteos_a/kernel/src/math/erff.c
diff --git a/third_party/musl/kernel/src/math/erfl.c b/third_party/musl/porting/liteos_a/kernel/src/math/erfl.c
old mode 100644
new mode 100755
similarity index 100%
rename from third_party/musl/kernel/src/math/erfl.c
rename to third_party/musl/porting/liteos_a/kernel/src/math/erfl.c
diff --git a/third_party/musl/kernel/src/math/exp.c b/third_party/musl/porting/liteos_a/kernel/src/math/exp.c
old mode 100644
new mode 100755
similarity index 100%
rename from third_party/musl/kernel/src/math/exp.c
rename to third_party/musl/porting/liteos_a/kernel/src/math/exp.c
diff --git a/third_party/musl/kernel/src/math/exp10.c b/third_party/musl/porting/liteos_a/kernel/src/math/exp10.c
old mode 100644
new mode 100755
similarity index 100%
rename from third_party/musl/kernel/src/math/exp10.c
rename to third_party/musl/porting/liteos_a/kernel/src/math/exp10.c
diff --git a/third_party/musl/kernel/src/math/exp10f.c b/third_party/musl/porting/liteos_a/kernel/src/math/exp10f.c
old mode 100644
new mode 100755
similarity index 100%
rename from third_party/musl/kernel/src/math/exp10f.c
rename to third_party/musl/porting/liteos_a/kernel/src/math/exp10f.c
diff --git a/third_party/musl/kernel/src/math/exp10l.c b/third_party/musl/porting/liteos_a/kernel/src/math/exp10l.c
old mode 100644
new mode 100755
similarity index 100%
rename from third_party/musl/kernel/src/math/exp10l.c
rename to third_party/musl/porting/liteos_a/kernel/src/math/exp10l.c
diff --git a/third_party/musl/kernel/src/math/exp2.c b/third_party/musl/porting/liteos_a/kernel/src/math/exp2.c
old mode 100644
new mode 100755
similarity index 100%
rename from third_party/musl/kernel/src/math/exp2.c
rename to third_party/musl/porting/liteos_a/kernel/src/math/exp2.c
diff --git a/third_party/musl/kernel/src/math/exp2f.c b/third_party/musl/porting/liteos_a/kernel/src/math/exp2f.c
old mode 100644
new mode 100755
similarity index 100%
rename from third_party/musl/kernel/src/math/exp2f.c
rename to third_party/musl/porting/liteos_a/kernel/src/math/exp2f.c
diff --git a/third_party/musl/kernel/src/math/exp2f_data.c b/third_party/musl/porting/liteos_a/kernel/src/math/exp2f_data.c
old mode 100644
new mode 100755
similarity index 100%
rename from third_party/musl/kernel/src/math/exp2f_data.c
rename to third_party/musl/porting/liteos_a/kernel/src/math/exp2f_data.c
diff --git a/third_party/musl/kernel/src/math/exp2f_data.h b/third_party/musl/porting/liteos_a/kernel/src/math/exp2f_data.h
old mode 100644
new mode 100755
similarity index 100%
rename from third_party/musl/kernel/src/math/exp2f_data.h
rename to third_party/musl/porting/liteos_a/kernel/src/math/exp2f_data.h
diff --git a/third_party/musl/kernel/src/math/exp2l.c b/third_party/musl/porting/liteos_a/kernel/src/math/exp2l.c
old mode 100644
new mode 100755
similarity index 100%
rename from third_party/musl/kernel/src/math/exp2l.c
rename to third_party/musl/porting/liteos_a/kernel/src/math/exp2l.c
diff --git a/third_party/musl/kernel/src/math/exp_data.c b/third_party/musl/porting/liteos_a/kernel/src/math/exp_data.c
old mode 100644
new mode 100755
similarity index 100%
rename from third_party/musl/kernel/src/math/exp_data.c
rename to third_party/musl/porting/liteos_a/kernel/src/math/exp_data.c
diff --git a/third_party/musl/kernel/src/math/exp_data.h b/third_party/musl/porting/liteos_a/kernel/src/math/exp_data.h
old mode 100644
new mode 100755
similarity index 100%
rename from third_party/musl/kernel/src/math/exp_data.h
rename to third_party/musl/porting/liteos_a/kernel/src/math/exp_data.h
diff --git a/third_party/musl/kernel/src/math/expf.c b/third_party/musl/porting/liteos_a/kernel/src/math/expf.c
old mode 100644
new mode 100755
similarity index 100%
rename from third_party/musl/kernel/src/math/expf.c
rename to third_party/musl/porting/liteos_a/kernel/src/math/expf.c
diff --git a/third_party/musl/kernel/src/math/expl.c b/third_party/musl/porting/liteos_a/kernel/src/math/expl.c
old mode 100644
new mode 100755
similarity index 100%
rename from third_party/musl/kernel/src/math/expl.c
rename to third_party/musl/porting/liteos_a/kernel/src/math/expl.c
diff --git a/third_party/musl/kernel/src/math/expm1.c b/third_party/musl/porting/liteos_a/kernel/src/math/expm1.c
old mode 100644
new mode 100755
similarity index 100%
rename from third_party/musl/kernel/src/math/expm1.c
rename to third_party/musl/porting/liteos_a/kernel/src/math/expm1.c
diff --git a/third_party/musl/kernel/src/math/expm1f.c b/third_party/musl/porting/liteos_a/kernel/src/math/expm1f.c
old mode 100644
new mode 100755
similarity index 100%
rename from third_party/musl/kernel/src/math/expm1f.c
rename to third_party/musl/porting/liteos_a/kernel/src/math/expm1f.c
diff --git a/third_party/musl/kernel/src/math/expm1l.c b/third_party/musl/porting/liteos_a/kernel/src/math/expm1l.c
old mode 100644
new mode 100755
similarity index 100%
rename from third_party/musl/kernel/src/math/expm1l.c
rename to third_party/musl/porting/liteos_a/kernel/src/math/expm1l.c
diff --git a/third_party/musl/kernel/src/math/fabs.c b/third_party/musl/porting/liteos_a/kernel/src/math/fabs.c
old mode 100644
new mode 100755
similarity index 100%
rename from third_party/musl/kernel/src/math/fabs.c
rename to third_party/musl/porting/liteos_a/kernel/src/math/fabs.c
diff --git a/third_party/musl/kernel/src/math/fabsf.c b/third_party/musl/porting/liteos_a/kernel/src/math/fabsf.c
old mode 100644
new mode 100755
similarity index 100%
rename from third_party/musl/kernel/src/math/fabsf.c
rename to third_party/musl/porting/liteos_a/kernel/src/math/fabsf.c
diff --git a/third_party/musl/kernel/src/math/fabsl.c b/third_party/musl/porting/liteos_a/kernel/src/math/fabsl.c
old mode 100644
new mode 100755
similarity index 100%
rename from third_party/musl/kernel/src/math/fabsl.c
rename to third_party/musl/porting/liteos_a/kernel/src/math/fabsl.c
diff --git a/third_party/musl/kernel/src/math/fdim.c b/third_party/musl/porting/liteos_a/kernel/src/math/fdim.c
old mode 100644
new mode 100755
similarity index 100%
rename from third_party/musl/kernel/src/math/fdim.c
rename to third_party/musl/porting/liteos_a/kernel/src/math/fdim.c
diff --git a/third_party/musl/kernel/src/math/fdimf.c b/third_party/musl/porting/liteos_a/kernel/src/math/fdimf.c
old mode 100644
new mode 100755
similarity index 100%
rename from third_party/musl/kernel/src/math/fdimf.c
rename to third_party/musl/porting/liteos_a/kernel/src/math/fdimf.c
diff --git a/third_party/musl/kernel/src/math/fdiml.c b/third_party/musl/porting/liteos_a/kernel/src/math/fdiml.c
old mode 100644
new mode 100755
similarity index 100%
rename from third_party/musl/kernel/src/math/fdiml.c
rename to third_party/musl/porting/liteos_a/kernel/src/math/fdiml.c
diff --git a/third_party/musl/kernel/src/math/finite.c b/third_party/musl/porting/liteos_a/kernel/src/math/finite.c
old mode 100644
new mode 100755
similarity index 100%
rename from third_party/musl/kernel/src/math/finite.c
rename to third_party/musl/porting/liteos_a/kernel/src/math/finite.c
diff --git a/third_party/musl/kernel/src/math/finitef.c b/third_party/musl/porting/liteos_a/kernel/src/math/finitef.c
old mode 100644
new mode 100755
similarity index 100%
rename from third_party/musl/kernel/src/math/finitef.c
rename to third_party/musl/porting/liteos_a/kernel/src/math/finitef.c
diff --git a/third_party/musl/kernel/src/math/floor.c b/third_party/musl/porting/liteos_a/kernel/src/math/floor.c
old mode 100644
new mode 100755
similarity index 100%
rename from third_party/musl/kernel/src/math/floor.c
rename to third_party/musl/porting/liteos_a/kernel/src/math/floor.c
diff --git a/third_party/musl/kernel/src/math/floorf.c b/third_party/musl/porting/liteos_a/kernel/src/math/floorf.c
old mode 100644
new mode 100755
similarity index 100%
rename from third_party/musl/kernel/src/math/floorf.c
rename to third_party/musl/porting/liteos_a/kernel/src/math/floorf.c
diff --git a/third_party/musl/kernel/src/math/floorl.c b/third_party/musl/porting/liteos_a/kernel/src/math/floorl.c
old mode 100644
new mode 100755
similarity index 100%
rename from third_party/musl/kernel/src/math/floorl.c
rename to third_party/musl/porting/liteos_a/kernel/src/math/floorl.c
diff --git a/third_party/musl/kernel/src/math/fma.c b/third_party/musl/porting/liteos_a/kernel/src/math/fma.c
old mode 100644
new mode 100755
similarity index 100%
rename from third_party/musl/kernel/src/math/fma.c
rename to third_party/musl/porting/liteos_a/kernel/src/math/fma.c
diff --git a/third_party/musl/kernel/src/math/fmaf.c b/third_party/musl/porting/liteos_a/kernel/src/math/fmaf.c
old mode 100644
new mode 100755
similarity index 100%
rename from third_party/musl/kernel/src/math/fmaf.c
rename to third_party/musl/porting/liteos_a/kernel/src/math/fmaf.c
diff --git a/third_party/musl/kernel/src/math/fmal.c b/third_party/musl/porting/liteos_a/kernel/src/math/fmal.c
old mode 100644
new mode 100755
similarity index 100%
rename from third_party/musl/kernel/src/math/fmal.c
rename to third_party/musl/porting/liteos_a/kernel/src/math/fmal.c
diff --git a/third_party/musl/kernel/src/math/fmax.c b/third_party/musl/porting/liteos_a/kernel/src/math/fmax.c
old mode 100644
new mode 100755
similarity index 100%
rename from third_party/musl/kernel/src/math/fmax.c
rename to third_party/musl/porting/liteos_a/kernel/src/math/fmax.c
diff --git a/third_party/musl/kernel/src/math/fmaxf.c b/third_party/musl/porting/liteos_a/kernel/src/math/fmaxf.c
old mode 100644
new mode 100755
similarity index 100%
rename from third_party/musl/kernel/src/math/fmaxf.c
rename to third_party/musl/porting/liteos_a/kernel/src/math/fmaxf.c
diff --git a/third_party/musl/kernel/src/math/fmaxl.c b/third_party/musl/porting/liteos_a/kernel/src/math/fmaxl.c
old mode 100644
new mode 100755
similarity index 100%
rename from third_party/musl/kernel/src/math/fmaxl.c
rename to third_party/musl/porting/liteos_a/kernel/src/math/fmaxl.c
diff --git a/third_party/musl/kernel/src/math/fmin.c b/third_party/musl/porting/liteos_a/kernel/src/math/fmin.c
old mode 100644
new mode 100755
similarity index 100%
rename from third_party/musl/kernel/src/math/fmin.c
rename to third_party/musl/porting/liteos_a/kernel/src/math/fmin.c
diff --git a/third_party/musl/kernel/src/math/fminf.c b/third_party/musl/porting/liteos_a/kernel/src/math/fminf.c
old mode 100644
new mode 100755
similarity index 100%
rename from third_party/musl/kernel/src/math/fminf.c
rename to third_party/musl/porting/liteos_a/kernel/src/math/fminf.c
diff --git a/third_party/musl/kernel/src/math/fminl.c b/third_party/musl/porting/liteos_a/kernel/src/math/fminl.c
old mode 100644
new mode 100755
similarity index 100%
rename from third_party/musl/kernel/src/math/fminl.c
rename to third_party/musl/porting/liteos_a/kernel/src/math/fminl.c
diff --git a/third_party/musl/kernel/src/math/fmod.c b/third_party/musl/porting/liteos_a/kernel/src/math/fmod.c
old mode 100644
new mode 100755
similarity index 100%
rename from third_party/musl/kernel/src/math/fmod.c
rename to third_party/musl/porting/liteos_a/kernel/src/math/fmod.c
diff --git a/third_party/musl/kernel/src/math/fmodf.c b/third_party/musl/porting/liteos_a/kernel/src/math/fmodf.c
old mode 100644
new mode 100755
similarity index 100%
rename from third_party/musl/kernel/src/math/fmodf.c
rename to third_party/musl/porting/liteos_a/kernel/src/math/fmodf.c
diff --git a/third_party/musl/kernel/src/math/fmodl.c b/third_party/musl/porting/liteos_a/kernel/src/math/fmodl.c
old mode 100644
new mode 100755
similarity index 100%
rename from third_party/musl/kernel/src/math/fmodl.c
rename to third_party/musl/porting/liteos_a/kernel/src/math/fmodl.c
diff --git a/third_party/musl/kernel/src/math/frexp.c b/third_party/musl/porting/liteos_a/kernel/src/math/frexp.c
old mode 100644
new mode 100755
similarity index 100%
rename from third_party/musl/kernel/src/math/frexp.c
rename to third_party/musl/porting/liteos_a/kernel/src/math/frexp.c
diff --git a/third_party/musl/kernel/src/math/frexpf.c b/third_party/musl/porting/liteos_a/kernel/src/math/frexpf.c
old mode 100644
new mode 100755
similarity index 100%
rename from third_party/musl/kernel/src/math/frexpf.c
rename to third_party/musl/porting/liteos_a/kernel/src/math/frexpf.c
diff --git a/third_party/musl/kernel/src/math/frexpl.c b/third_party/musl/porting/liteos_a/kernel/src/math/frexpl.c
old mode 100644
new mode 100755
similarity index 100%
rename from third_party/musl/kernel/src/math/frexpl.c
rename to third_party/musl/porting/liteos_a/kernel/src/math/frexpl.c
diff --git a/third_party/musl/kernel/src/math/hypot.c b/third_party/musl/porting/liteos_a/kernel/src/math/hypot.c
old mode 100644
new mode 100755
similarity index 100%
rename from third_party/musl/kernel/src/math/hypot.c
rename to third_party/musl/porting/liteos_a/kernel/src/math/hypot.c
diff --git a/third_party/musl/kernel/src/math/hypotf.c b/third_party/musl/porting/liteos_a/kernel/src/math/hypotf.c
old mode 100644
new mode 100755
similarity index 100%
rename from third_party/musl/kernel/src/math/hypotf.c
rename to third_party/musl/porting/liteos_a/kernel/src/math/hypotf.c
diff --git a/third_party/musl/kernel/src/math/hypotl.c b/third_party/musl/porting/liteos_a/kernel/src/math/hypotl.c
old mode 100644
new mode 100755
similarity index 100%
rename from third_party/musl/kernel/src/math/hypotl.c
rename to third_party/musl/porting/liteos_a/kernel/src/math/hypotl.c
diff --git a/third_party/musl/kernel/src/math/ilogb.c b/third_party/musl/porting/liteos_a/kernel/src/math/ilogb.c
old mode 100644
new mode 100755
similarity index 100%
rename from third_party/musl/kernel/src/math/ilogb.c
rename to third_party/musl/porting/liteos_a/kernel/src/math/ilogb.c
diff --git a/third_party/musl/kernel/src/math/ilogbf.c b/third_party/musl/porting/liteos_a/kernel/src/math/ilogbf.c
old mode 100644
new mode 100755
similarity index 100%
rename from third_party/musl/kernel/src/math/ilogbf.c
rename to third_party/musl/porting/liteos_a/kernel/src/math/ilogbf.c
diff --git a/third_party/musl/kernel/src/math/ilogbl.c b/third_party/musl/porting/liteos_a/kernel/src/math/ilogbl.c
old mode 100644
new mode 100755
similarity index 100%
rename from third_party/musl/kernel/src/math/ilogbl.c
rename to third_party/musl/porting/liteos_a/kernel/src/math/ilogbl.c
diff --git a/third_party/musl/kernel/src/math/j0.c b/third_party/musl/porting/liteos_a/kernel/src/math/j0.c
old mode 100644
new mode 100755
similarity index 100%
rename from third_party/musl/kernel/src/math/j0.c
rename to third_party/musl/porting/liteos_a/kernel/src/math/j0.c
diff --git a/third_party/musl/kernel/src/math/j0f.c b/third_party/musl/porting/liteos_a/kernel/src/math/j0f.c
old mode 100644
new mode 100755
similarity index 100%
rename from third_party/musl/kernel/src/math/j0f.c
rename to third_party/musl/porting/liteos_a/kernel/src/math/j0f.c
diff --git a/third_party/musl/kernel/src/math/j1.c b/third_party/musl/porting/liteos_a/kernel/src/math/j1.c
old mode 100644
new mode 100755
similarity index 100%
rename from third_party/musl/kernel/src/math/j1.c
rename to third_party/musl/porting/liteos_a/kernel/src/math/j1.c
diff --git a/third_party/musl/kernel/src/math/j1f.c b/third_party/musl/porting/liteos_a/kernel/src/math/j1f.c
old mode 100644
new mode 100755
similarity index 100%
rename from third_party/musl/kernel/src/math/j1f.c
rename to third_party/musl/porting/liteos_a/kernel/src/math/j1f.c
diff --git a/third_party/musl/kernel/src/math/jn.c b/third_party/musl/porting/liteos_a/kernel/src/math/jn.c
old mode 100644
new mode 100755
similarity index 100%
rename from third_party/musl/kernel/src/math/jn.c
rename to third_party/musl/porting/liteos_a/kernel/src/math/jn.c
diff --git a/third_party/musl/kernel/src/math/jnf.c b/third_party/musl/porting/liteos_a/kernel/src/math/jnf.c
old mode 100644
new mode 100755
similarity index 100%
rename from third_party/musl/kernel/src/math/jnf.c
rename to third_party/musl/porting/liteos_a/kernel/src/math/jnf.c
diff --git a/third_party/musl/kernel/src/math/ldexp.c b/third_party/musl/porting/liteos_a/kernel/src/math/ldexp.c
old mode 100644
new mode 100755
similarity index 100%
rename from third_party/musl/kernel/src/math/ldexp.c
rename to third_party/musl/porting/liteos_a/kernel/src/math/ldexp.c
diff --git a/third_party/musl/kernel/src/math/ldexpf.c b/third_party/musl/porting/liteos_a/kernel/src/math/ldexpf.c
old mode 100644
new mode 100755
similarity index 100%
rename from third_party/musl/kernel/src/math/ldexpf.c
rename to third_party/musl/porting/liteos_a/kernel/src/math/ldexpf.c
diff --git a/third_party/musl/kernel/src/math/ldexpl.c b/third_party/musl/porting/liteos_a/kernel/src/math/ldexpl.c
old mode 100644
new mode 100755
similarity index 100%
rename from third_party/musl/kernel/src/math/ldexpl.c
rename to third_party/musl/porting/liteos_a/kernel/src/math/ldexpl.c
diff --git a/third_party/musl/kernel/src/math/lgamma.c b/third_party/musl/porting/liteos_a/kernel/src/math/lgamma.c
old mode 100644
new mode 100755
similarity index 100%
rename from third_party/musl/kernel/src/math/lgamma.c
rename to third_party/musl/porting/liteos_a/kernel/src/math/lgamma.c
diff --git a/third_party/musl/kernel/src/math/lgamma_r.c b/third_party/musl/porting/liteos_a/kernel/src/math/lgamma_r.c
old mode 100644
new mode 100755
similarity index 100%
rename from third_party/musl/kernel/src/math/lgamma_r.c
rename to third_party/musl/porting/liteos_a/kernel/src/math/lgamma_r.c
diff --git a/third_party/musl/kernel/src/math/lgammaf.c b/third_party/musl/porting/liteos_a/kernel/src/math/lgammaf.c
old mode 100644
new mode 100755
similarity index 100%
rename from third_party/musl/kernel/src/math/lgammaf.c
rename to third_party/musl/porting/liteos_a/kernel/src/math/lgammaf.c
diff --git a/third_party/musl/kernel/src/math/lgammaf_r.c b/third_party/musl/porting/liteos_a/kernel/src/math/lgammaf_r.c
old mode 100644
new mode 100755
similarity index 100%
rename from third_party/musl/kernel/src/math/lgammaf_r.c
rename to third_party/musl/porting/liteos_a/kernel/src/math/lgammaf_r.c
diff --git a/third_party/musl/kernel/src/math/lgammal.c b/third_party/musl/porting/liteos_a/kernel/src/math/lgammal.c
old mode 100644
new mode 100755
similarity index 100%
rename from third_party/musl/kernel/src/math/lgammal.c
rename to third_party/musl/porting/liteos_a/kernel/src/math/lgammal.c
diff --git a/third_party/musl/kernel/src/math/llrint.c b/third_party/musl/porting/liteos_a/kernel/src/math/llrint.c
old mode 100644
new mode 100755
similarity index 100%
rename from third_party/musl/kernel/src/math/llrint.c
rename to third_party/musl/porting/liteos_a/kernel/src/math/llrint.c
diff --git a/third_party/musl/kernel/src/math/llrintf.c b/third_party/musl/porting/liteos_a/kernel/src/math/llrintf.c
old mode 100644
new mode 100755
similarity index 100%
rename from third_party/musl/kernel/src/math/llrintf.c
rename to third_party/musl/porting/liteos_a/kernel/src/math/llrintf.c
diff --git a/third_party/musl/kernel/src/math/llrintl.c b/third_party/musl/porting/liteos_a/kernel/src/math/llrintl.c
old mode 100644
new mode 100755
similarity index 100%
rename from third_party/musl/kernel/src/math/llrintl.c
rename to third_party/musl/porting/liteos_a/kernel/src/math/llrintl.c
diff --git a/third_party/musl/kernel/src/math/llround.c b/third_party/musl/porting/liteos_a/kernel/src/math/llround.c
old mode 100644
new mode 100755
similarity index 100%
rename from third_party/musl/kernel/src/math/llround.c
rename to third_party/musl/porting/liteos_a/kernel/src/math/llround.c
diff --git a/third_party/musl/kernel/src/math/llroundf.c b/third_party/musl/porting/liteos_a/kernel/src/math/llroundf.c
old mode 100644
new mode 100755
similarity index 100%
rename from third_party/musl/kernel/src/math/llroundf.c
rename to third_party/musl/porting/liteos_a/kernel/src/math/llroundf.c
diff --git a/third_party/musl/kernel/src/math/llroundl.c b/third_party/musl/porting/liteos_a/kernel/src/math/llroundl.c
old mode 100644
new mode 100755
similarity index 100%
rename from third_party/musl/kernel/src/math/llroundl.c
rename to third_party/musl/porting/liteos_a/kernel/src/math/llroundl.c
diff --git a/third_party/musl/kernel/src/math/log.c b/third_party/musl/porting/liteos_a/kernel/src/math/log.c
old mode 100644
new mode 100755
similarity index 100%
rename from third_party/musl/kernel/src/math/log.c
rename to third_party/musl/porting/liteos_a/kernel/src/math/log.c
diff --git a/third_party/musl/kernel/src/math/log10.c b/third_party/musl/porting/liteos_a/kernel/src/math/log10.c
old mode 100644
new mode 100755
similarity index 100%
rename from third_party/musl/kernel/src/math/log10.c
rename to third_party/musl/porting/liteos_a/kernel/src/math/log10.c
diff --git a/third_party/musl/kernel/src/math/log10f.c b/third_party/musl/porting/liteos_a/kernel/src/math/log10f.c
old mode 100644
new mode 100755
similarity index 100%
rename from third_party/musl/kernel/src/math/log10f.c
rename to third_party/musl/porting/liteos_a/kernel/src/math/log10f.c
diff --git a/third_party/musl/kernel/src/math/log10l.c b/third_party/musl/porting/liteos_a/kernel/src/math/log10l.c
old mode 100644
new mode 100755
similarity index 100%
rename from third_party/musl/kernel/src/math/log10l.c
rename to third_party/musl/porting/liteos_a/kernel/src/math/log10l.c
diff --git a/third_party/musl/kernel/src/math/log1p.c b/third_party/musl/porting/liteos_a/kernel/src/math/log1p.c
old mode 100644
new mode 100755
similarity index 100%
rename from third_party/musl/kernel/src/math/log1p.c
rename to third_party/musl/porting/liteos_a/kernel/src/math/log1p.c
diff --git a/third_party/musl/kernel/src/math/log1pf.c b/third_party/musl/porting/liteos_a/kernel/src/math/log1pf.c
old mode 100644
new mode 100755
similarity index 100%
rename from third_party/musl/kernel/src/math/log1pf.c
rename to third_party/musl/porting/liteos_a/kernel/src/math/log1pf.c
diff --git a/third_party/musl/kernel/src/math/log1pl.c b/third_party/musl/porting/liteos_a/kernel/src/math/log1pl.c
old mode 100644
new mode 100755
similarity index 100%
rename from third_party/musl/kernel/src/math/log1pl.c
rename to third_party/musl/porting/liteos_a/kernel/src/math/log1pl.c
diff --git a/third_party/musl/kernel/src/math/log2.c b/third_party/musl/porting/liteos_a/kernel/src/math/log2.c
old mode 100644
new mode 100755
similarity index 100%
rename from third_party/musl/kernel/src/math/log2.c
rename to third_party/musl/porting/liteos_a/kernel/src/math/log2.c
diff --git a/third_party/musl/kernel/src/math/log2_data.c b/third_party/musl/porting/liteos_a/kernel/src/math/log2_data.c
old mode 100644
new mode 100755
similarity index 100%
rename from third_party/musl/kernel/src/math/log2_data.c
rename to third_party/musl/porting/liteos_a/kernel/src/math/log2_data.c
diff --git a/third_party/musl/kernel/src/math/log2_data.h b/third_party/musl/porting/liteos_a/kernel/src/math/log2_data.h
old mode 100644
new mode 100755
similarity index 100%
rename from third_party/musl/kernel/src/math/log2_data.h
rename to third_party/musl/porting/liteos_a/kernel/src/math/log2_data.h
diff --git a/third_party/musl/kernel/src/math/log2f.c b/third_party/musl/porting/liteos_a/kernel/src/math/log2f.c
old mode 100644
new mode 100755
similarity index 100%
rename from third_party/musl/kernel/src/math/log2f.c
rename to third_party/musl/porting/liteos_a/kernel/src/math/log2f.c
diff --git a/third_party/musl/kernel/src/math/log2f_data.c b/third_party/musl/porting/liteos_a/kernel/src/math/log2f_data.c
old mode 100644
new mode 100755
similarity index 100%
rename from third_party/musl/kernel/src/math/log2f_data.c
rename to third_party/musl/porting/liteos_a/kernel/src/math/log2f_data.c
diff --git a/third_party/musl/kernel/src/math/log2f_data.h b/third_party/musl/porting/liteos_a/kernel/src/math/log2f_data.h
old mode 100644
new mode 100755
similarity index 100%
rename from third_party/musl/kernel/src/math/log2f_data.h
rename to third_party/musl/porting/liteos_a/kernel/src/math/log2f_data.h
diff --git a/third_party/musl/kernel/src/math/log2l.c b/third_party/musl/porting/liteos_a/kernel/src/math/log2l.c
old mode 100644
new mode 100755
similarity index 100%
rename from third_party/musl/kernel/src/math/log2l.c
rename to third_party/musl/porting/liteos_a/kernel/src/math/log2l.c
diff --git a/third_party/musl/kernel/src/math/log_data.c b/third_party/musl/porting/liteos_a/kernel/src/math/log_data.c
old mode 100644
new mode 100755
similarity index 100%
rename from third_party/musl/kernel/src/math/log_data.c
rename to third_party/musl/porting/liteos_a/kernel/src/math/log_data.c
diff --git a/third_party/musl/kernel/src/math/log_data.h b/third_party/musl/porting/liteos_a/kernel/src/math/log_data.h
old mode 100644
new mode 100755
similarity index 100%
rename from third_party/musl/kernel/src/math/log_data.h
rename to third_party/musl/porting/liteos_a/kernel/src/math/log_data.h
diff --git a/third_party/musl/kernel/src/math/logb.c b/third_party/musl/porting/liteos_a/kernel/src/math/logb.c
old mode 100644
new mode 100755
similarity index 100%
rename from third_party/musl/kernel/src/math/logb.c
rename to third_party/musl/porting/liteos_a/kernel/src/math/logb.c
diff --git a/third_party/musl/kernel/src/math/logbf.c b/third_party/musl/porting/liteos_a/kernel/src/math/logbf.c
old mode 100644
new mode 100755
similarity index 100%
rename from third_party/musl/kernel/src/math/logbf.c
rename to third_party/musl/porting/liteos_a/kernel/src/math/logbf.c
diff --git a/third_party/musl/kernel/src/math/logbl.c b/third_party/musl/porting/liteos_a/kernel/src/math/logbl.c
old mode 100644
new mode 100755
similarity index 100%
rename from third_party/musl/kernel/src/math/logbl.c
rename to third_party/musl/porting/liteos_a/kernel/src/math/logbl.c
diff --git a/third_party/musl/kernel/src/math/logf.c b/third_party/musl/porting/liteos_a/kernel/src/math/logf.c
old mode 100644
new mode 100755
similarity index 100%
rename from third_party/musl/kernel/src/math/logf.c
rename to third_party/musl/porting/liteos_a/kernel/src/math/logf.c
diff --git a/third_party/musl/kernel/src/math/logf_data.c b/third_party/musl/porting/liteos_a/kernel/src/math/logf_data.c
old mode 100644
new mode 100755
similarity index 100%
rename from third_party/musl/kernel/src/math/logf_data.c
rename to third_party/musl/porting/liteos_a/kernel/src/math/logf_data.c
diff --git a/third_party/musl/kernel/src/math/logf_data.h b/third_party/musl/porting/liteos_a/kernel/src/math/logf_data.h
old mode 100644
new mode 100755
similarity index 100%
rename from third_party/musl/kernel/src/math/logf_data.h
rename to third_party/musl/porting/liteos_a/kernel/src/math/logf_data.h
diff --git a/third_party/musl/kernel/src/math/logl.c b/third_party/musl/porting/liteos_a/kernel/src/math/logl.c
old mode 100644
new mode 100755
similarity index 100%
rename from third_party/musl/kernel/src/math/logl.c
rename to third_party/musl/porting/liteos_a/kernel/src/math/logl.c
diff --git a/third_party/musl/kernel/src/math/lrint.c b/third_party/musl/porting/liteos_a/kernel/src/math/lrint.c
old mode 100644
new mode 100755
similarity index 100%
rename from third_party/musl/kernel/src/math/lrint.c
rename to third_party/musl/porting/liteos_a/kernel/src/math/lrint.c
diff --git a/third_party/musl/kernel/src/math/lrintf.c b/third_party/musl/porting/liteos_a/kernel/src/math/lrintf.c
old mode 100644
new mode 100755
similarity index 100%
rename from third_party/musl/kernel/src/math/lrintf.c
rename to third_party/musl/porting/liteos_a/kernel/src/math/lrintf.c
diff --git a/third_party/musl/kernel/src/math/lrintl.c b/third_party/musl/porting/liteos_a/kernel/src/math/lrintl.c
old mode 100644
new mode 100755
similarity index 100%
rename from third_party/musl/kernel/src/math/lrintl.c
rename to third_party/musl/porting/liteos_a/kernel/src/math/lrintl.c
diff --git a/third_party/musl/kernel/src/math/lround.c b/third_party/musl/porting/liteos_a/kernel/src/math/lround.c
old mode 100644
new mode 100755
similarity index 100%
rename from third_party/musl/kernel/src/math/lround.c
rename to third_party/musl/porting/liteos_a/kernel/src/math/lround.c
diff --git a/third_party/musl/kernel/src/math/lroundf.c b/third_party/musl/porting/liteos_a/kernel/src/math/lroundf.c
old mode 100644
new mode 100755
similarity index 100%
rename from third_party/musl/kernel/src/math/lroundf.c
rename to third_party/musl/porting/liteos_a/kernel/src/math/lroundf.c
diff --git a/third_party/musl/kernel/src/math/lroundl.c b/third_party/musl/porting/liteos_a/kernel/src/math/lroundl.c
old mode 100644
new mode 100755
similarity index 100%
rename from third_party/musl/kernel/src/math/lroundl.c
rename to third_party/musl/porting/liteos_a/kernel/src/math/lroundl.c
diff --git a/third_party/musl/kernel/src/math/modf.c b/third_party/musl/porting/liteos_a/kernel/src/math/modf.c
old mode 100644
new mode 100755
similarity index 100%
rename from third_party/musl/kernel/src/math/modf.c
rename to third_party/musl/porting/liteos_a/kernel/src/math/modf.c
diff --git a/third_party/musl/kernel/src/math/modff.c b/third_party/musl/porting/liteos_a/kernel/src/math/modff.c
old mode 100644
new mode 100755
similarity index 100%
rename from third_party/musl/kernel/src/math/modff.c
rename to third_party/musl/porting/liteos_a/kernel/src/math/modff.c
diff --git a/third_party/musl/kernel/src/math/modfl.c b/third_party/musl/porting/liteos_a/kernel/src/math/modfl.c
old mode 100644
new mode 100755
similarity index 100%
rename from third_party/musl/kernel/src/math/modfl.c
rename to third_party/musl/porting/liteos_a/kernel/src/math/modfl.c
diff --git a/third_party/musl/kernel/src/math/nan.c b/third_party/musl/porting/liteos_a/kernel/src/math/nan.c
old mode 100644
new mode 100755
similarity index 100%
rename from third_party/musl/kernel/src/math/nan.c
rename to third_party/musl/porting/liteos_a/kernel/src/math/nan.c
diff --git a/third_party/musl/kernel/src/math/nanf.c b/third_party/musl/porting/liteos_a/kernel/src/math/nanf.c
old mode 100644
new mode 100755
similarity index 100%
rename from third_party/musl/kernel/src/math/nanf.c
rename to third_party/musl/porting/liteos_a/kernel/src/math/nanf.c
diff --git a/third_party/musl/kernel/src/math/nanl.c b/third_party/musl/porting/liteos_a/kernel/src/math/nanl.c
old mode 100644
new mode 100755
similarity index 100%
rename from third_party/musl/kernel/src/math/nanl.c
rename to third_party/musl/porting/liteos_a/kernel/src/math/nanl.c
diff --git a/third_party/musl/kernel/src/math/nearbyint.c b/third_party/musl/porting/liteos_a/kernel/src/math/nearbyint.c
old mode 100644
new mode 100755
similarity index 100%
rename from third_party/musl/kernel/src/math/nearbyint.c
rename to third_party/musl/porting/liteos_a/kernel/src/math/nearbyint.c
diff --git a/third_party/musl/kernel/src/math/nearbyintf.c b/third_party/musl/porting/liteos_a/kernel/src/math/nearbyintf.c
old mode 100644
new mode 100755
similarity index 100%
rename from third_party/musl/kernel/src/math/nearbyintf.c
rename to third_party/musl/porting/liteos_a/kernel/src/math/nearbyintf.c
diff --git a/third_party/musl/kernel/src/math/nearbyintl.c b/third_party/musl/porting/liteos_a/kernel/src/math/nearbyintl.c
old mode 100644
new mode 100755
similarity index 100%
rename from third_party/musl/kernel/src/math/nearbyintl.c
rename to third_party/musl/porting/liteos_a/kernel/src/math/nearbyintl.c
diff --git a/third_party/musl/kernel/src/math/nextafter.c b/third_party/musl/porting/liteos_a/kernel/src/math/nextafter.c
old mode 100644
new mode 100755
similarity index 100%
rename from third_party/musl/kernel/src/math/nextafter.c
rename to third_party/musl/porting/liteos_a/kernel/src/math/nextafter.c
diff --git a/third_party/musl/kernel/src/math/nextafterf.c b/third_party/musl/porting/liteos_a/kernel/src/math/nextafterf.c
old mode 100644
new mode 100755
similarity index 100%
rename from third_party/musl/kernel/src/math/nextafterf.c
rename to third_party/musl/porting/liteos_a/kernel/src/math/nextafterf.c
diff --git a/third_party/musl/kernel/src/math/nextafterl.c b/third_party/musl/porting/liteos_a/kernel/src/math/nextafterl.c
old mode 100644
new mode 100755
similarity index 100%
rename from third_party/musl/kernel/src/math/nextafterl.c
rename to third_party/musl/porting/liteos_a/kernel/src/math/nextafterl.c
diff --git a/third_party/musl/kernel/src/math/nexttoward.c b/third_party/musl/porting/liteos_a/kernel/src/math/nexttoward.c
old mode 100644
new mode 100755
similarity index 100%
rename from third_party/musl/kernel/src/math/nexttoward.c
rename to third_party/musl/porting/liteos_a/kernel/src/math/nexttoward.c
diff --git a/third_party/musl/kernel/src/math/nexttowardf.c b/third_party/musl/porting/liteos_a/kernel/src/math/nexttowardf.c
old mode 100644
new mode 100755
similarity index 100%
rename from third_party/musl/kernel/src/math/nexttowardf.c
rename to third_party/musl/porting/liteos_a/kernel/src/math/nexttowardf.c
diff --git a/third_party/musl/kernel/src/math/nexttowardl.c b/third_party/musl/porting/liteos_a/kernel/src/math/nexttowardl.c
old mode 100644
new mode 100755
similarity index 100%
rename from third_party/musl/kernel/src/math/nexttowardl.c
rename to third_party/musl/porting/liteos_a/kernel/src/math/nexttowardl.c
diff --git a/third_party/musl/kernel/src/math/pow.c b/third_party/musl/porting/liteos_a/kernel/src/math/pow.c
old mode 100644
new mode 100755
similarity index 100%
rename from third_party/musl/kernel/src/math/pow.c
rename to third_party/musl/porting/liteos_a/kernel/src/math/pow.c
diff --git a/third_party/musl/kernel/src/math/pow_data.c b/third_party/musl/porting/liteos_a/kernel/src/math/pow_data.c
old mode 100644
new mode 100755
similarity index 100%
rename from third_party/musl/kernel/src/math/pow_data.c
rename to third_party/musl/porting/liteos_a/kernel/src/math/pow_data.c
diff --git a/third_party/musl/kernel/src/math/pow_data.h b/third_party/musl/porting/liteos_a/kernel/src/math/pow_data.h
old mode 100644
new mode 100755
similarity index 100%
rename from third_party/musl/kernel/src/math/pow_data.h
rename to third_party/musl/porting/liteos_a/kernel/src/math/pow_data.h
diff --git a/third_party/musl/kernel/src/math/powf.c b/third_party/musl/porting/liteos_a/kernel/src/math/powf.c
old mode 100644
new mode 100755
similarity index 100%
rename from third_party/musl/kernel/src/math/powf.c
rename to third_party/musl/porting/liteos_a/kernel/src/math/powf.c
diff --git a/third_party/musl/kernel/src/math/powf_data.c b/third_party/musl/porting/liteos_a/kernel/src/math/powf_data.c
old mode 100644
new mode 100755
similarity index 100%
rename from third_party/musl/kernel/src/math/powf_data.c
rename to third_party/musl/porting/liteos_a/kernel/src/math/powf_data.c
diff --git a/third_party/musl/kernel/src/math/powf_data.h b/third_party/musl/porting/liteos_a/kernel/src/math/powf_data.h
old mode 100644
new mode 100755
similarity index 100%
rename from third_party/musl/kernel/src/math/powf_data.h
rename to third_party/musl/porting/liteos_a/kernel/src/math/powf_data.h
diff --git a/third_party/musl/kernel/src/math/powl.c b/third_party/musl/porting/liteos_a/kernel/src/math/powl.c
old mode 100644
new mode 100755
similarity index 100%
rename from third_party/musl/kernel/src/math/powl.c
rename to third_party/musl/porting/liteos_a/kernel/src/math/powl.c
diff --git a/third_party/musl/kernel/src/math/remainder.c b/third_party/musl/porting/liteos_a/kernel/src/math/remainder.c
old mode 100644
new mode 100755
similarity index 100%
rename from third_party/musl/kernel/src/math/remainder.c
rename to third_party/musl/porting/liteos_a/kernel/src/math/remainder.c
diff --git a/third_party/musl/kernel/src/math/remainderf.c b/third_party/musl/porting/liteos_a/kernel/src/math/remainderf.c
old mode 100644
new mode 100755
similarity index 100%
rename from third_party/musl/kernel/src/math/remainderf.c
rename to third_party/musl/porting/liteos_a/kernel/src/math/remainderf.c
diff --git a/third_party/musl/kernel/src/math/remainderl.c b/third_party/musl/porting/liteos_a/kernel/src/math/remainderl.c
old mode 100644
new mode 100755
similarity index 100%
rename from third_party/musl/kernel/src/math/remainderl.c
rename to third_party/musl/porting/liteos_a/kernel/src/math/remainderl.c
diff --git a/third_party/musl/kernel/src/math/remquo.c b/third_party/musl/porting/liteos_a/kernel/src/math/remquo.c
old mode 100644
new mode 100755
similarity index 100%
rename from third_party/musl/kernel/src/math/remquo.c
rename to third_party/musl/porting/liteos_a/kernel/src/math/remquo.c
diff --git a/third_party/musl/kernel/src/math/remquof.c b/third_party/musl/porting/liteos_a/kernel/src/math/remquof.c
old mode 100644
new mode 100755
similarity index 100%
rename from third_party/musl/kernel/src/math/remquof.c
rename to third_party/musl/porting/liteos_a/kernel/src/math/remquof.c
diff --git a/third_party/musl/kernel/src/math/remquol.c b/third_party/musl/porting/liteos_a/kernel/src/math/remquol.c
old mode 100644
new mode 100755
similarity index 100%
rename from third_party/musl/kernel/src/math/remquol.c
rename to third_party/musl/porting/liteos_a/kernel/src/math/remquol.c
diff --git a/third_party/musl/kernel/src/math/rint.c b/third_party/musl/porting/liteos_a/kernel/src/math/rint.c
old mode 100644
new mode 100755
similarity index 100%
rename from third_party/musl/kernel/src/math/rint.c
rename to third_party/musl/porting/liteos_a/kernel/src/math/rint.c
diff --git a/third_party/musl/kernel/src/math/rintf.c b/third_party/musl/porting/liteos_a/kernel/src/math/rintf.c
old mode 100644
new mode 100755
similarity index 100%
rename from third_party/musl/kernel/src/math/rintf.c
rename to third_party/musl/porting/liteos_a/kernel/src/math/rintf.c
diff --git a/third_party/musl/kernel/src/math/rintl.c b/third_party/musl/porting/liteos_a/kernel/src/math/rintl.c
old mode 100644
new mode 100755
similarity index 100%
rename from third_party/musl/kernel/src/math/rintl.c
rename to third_party/musl/porting/liteos_a/kernel/src/math/rintl.c
diff --git a/third_party/musl/kernel/src/math/round.c b/third_party/musl/porting/liteos_a/kernel/src/math/round.c
old mode 100644
new mode 100755
similarity index 100%
rename from third_party/musl/kernel/src/math/round.c
rename to third_party/musl/porting/liteos_a/kernel/src/math/round.c
diff --git a/third_party/musl/kernel/src/math/roundf.c b/third_party/musl/porting/liteos_a/kernel/src/math/roundf.c
old mode 100644
new mode 100755
similarity index 100%
rename from third_party/musl/kernel/src/math/roundf.c
rename to third_party/musl/porting/liteos_a/kernel/src/math/roundf.c
diff --git a/third_party/musl/kernel/src/math/roundl.c b/third_party/musl/porting/liteos_a/kernel/src/math/roundl.c
old mode 100644
new mode 100755
similarity index 100%
rename from third_party/musl/kernel/src/math/roundl.c
rename to third_party/musl/porting/liteos_a/kernel/src/math/roundl.c
diff --git a/third_party/musl/kernel/src/math/scalb.c b/third_party/musl/porting/liteos_a/kernel/src/math/scalb.c
old mode 100644
new mode 100755
similarity index 100%
rename from third_party/musl/kernel/src/math/scalb.c
rename to third_party/musl/porting/liteos_a/kernel/src/math/scalb.c
diff --git a/third_party/musl/kernel/src/math/scalbf.c b/third_party/musl/porting/liteos_a/kernel/src/math/scalbf.c
old mode 100644
new mode 100755
similarity index 100%
rename from third_party/musl/kernel/src/math/scalbf.c
rename to third_party/musl/porting/liteos_a/kernel/src/math/scalbf.c
diff --git a/third_party/musl/kernel/src/math/scalbln.c b/third_party/musl/porting/liteos_a/kernel/src/math/scalbln.c
old mode 100644
new mode 100755
similarity index 100%
rename from third_party/musl/kernel/src/math/scalbln.c
rename to third_party/musl/porting/liteos_a/kernel/src/math/scalbln.c
diff --git a/third_party/musl/kernel/src/math/scalblnf.c b/third_party/musl/porting/liteos_a/kernel/src/math/scalblnf.c
old mode 100644
new mode 100755
similarity index 100%
rename from third_party/musl/kernel/src/math/scalblnf.c
rename to third_party/musl/porting/liteos_a/kernel/src/math/scalblnf.c
diff --git a/third_party/musl/kernel/src/math/scalblnl.c b/third_party/musl/porting/liteos_a/kernel/src/math/scalblnl.c
old mode 100644
new mode 100755
similarity index 100%
rename from third_party/musl/kernel/src/math/scalblnl.c
rename to third_party/musl/porting/liteos_a/kernel/src/math/scalblnl.c
diff --git a/third_party/musl/kernel/src/math/scalbn.c b/third_party/musl/porting/liteos_a/kernel/src/math/scalbn.c
old mode 100644
new mode 100755
similarity index 100%
rename from third_party/musl/kernel/src/math/scalbn.c
rename to third_party/musl/porting/liteos_a/kernel/src/math/scalbn.c
diff --git a/third_party/musl/kernel/src/math/scalbnf.c b/third_party/musl/porting/liteos_a/kernel/src/math/scalbnf.c
old mode 100644
new mode 100755
similarity index 100%
rename from third_party/musl/kernel/src/math/scalbnf.c
rename to third_party/musl/porting/liteos_a/kernel/src/math/scalbnf.c
diff --git a/third_party/musl/kernel/src/math/scalbnl.c b/third_party/musl/porting/liteos_a/kernel/src/math/scalbnl.c
old mode 100644
new mode 100755
similarity index 100%
rename from third_party/musl/kernel/src/math/scalbnl.c
rename to third_party/musl/porting/liteos_a/kernel/src/math/scalbnl.c
diff --git a/third_party/musl/kernel/src/math/signgam.c b/third_party/musl/porting/liteos_a/kernel/src/math/signgam.c
old mode 100644
new mode 100755
similarity index 100%
rename from third_party/musl/kernel/src/math/signgam.c
rename to third_party/musl/porting/liteos_a/kernel/src/math/signgam.c
diff --git a/third_party/musl/kernel/src/math/significand.c b/third_party/musl/porting/liteos_a/kernel/src/math/significand.c
old mode 100644
new mode 100755
similarity index 100%
rename from third_party/musl/kernel/src/math/significand.c
rename to third_party/musl/porting/liteos_a/kernel/src/math/significand.c
diff --git a/third_party/musl/kernel/src/math/significandf.c b/third_party/musl/porting/liteos_a/kernel/src/math/significandf.c
old mode 100644
new mode 100755
similarity index 100%
rename from third_party/musl/kernel/src/math/significandf.c
rename to third_party/musl/porting/liteos_a/kernel/src/math/significandf.c
diff --git a/third_party/musl/kernel/src/math/sin.c b/third_party/musl/porting/liteos_a/kernel/src/math/sin.c
old mode 100644
new mode 100755
similarity index 100%
rename from third_party/musl/kernel/src/math/sin.c
rename to third_party/musl/porting/liteos_a/kernel/src/math/sin.c
diff --git a/third_party/musl/kernel/src/math/sincos.c b/third_party/musl/porting/liteos_a/kernel/src/math/sincos.c
old mode 100644
new mode 100755
similarity index 100%
rename from third_party/musl/kernel/src/math/sincos.c
rename to third_party/musl/porting/liteos_a/kernel/src/math/sincos.c
diff --git a/third_party/musl/kernel/src/math/sincosf.c b/third_party/musl/porting/liteos_a/kernel/src/math/sincosf.c
old mode 100644
new mode 100755
similarity index 100%
rename from third_party/musl/kernel/src/math/sincosf.c
rename to third_party/musl/porting/liteos_a/kernel/src/math/sincosf.c
diff --git a/third_party/musl/kernel/src/math/sincosl.c b/third_party/musl/porting/liteos_a/kernel/src/math/sincosl.c
old mode 100644
new mode 100755
similarity index 100%
rename from third_party/musl/kernel/src/math/sincosl.c
rename to third_party/musl/porting/liteos_a/kernel/src/math/sincosl.c
diff --git a/third_party/musl/kernel/src/math/sinf.c b/third_party/musl/porting/liteos_a/kernel/src/math/sinf.c
old mode 100644
new mode 100755
similarity index 100%
rename from third_party/musl/kernel/src/math/sinf.c
rename to third_party/musl/porting/liteos_a/kernel/src/math/sinf.c
diff --git a/third_party/musl/kernel/src/math/sinh.c b/third_party/musl/porting/liteos_a/kernel/src/math/sinh.c
old mode 100644
new mode 100755
similarity index 100%
rename from third_party/musl/kernel/src/math/sinh.c
rename to third_party/musl/porting/liteos_a/kernel/src/math/sinh.c
diff --git a/third_party/musl/kernel/src/math/sinhf.c b/third_party/musl/porting/liteos_a/kernel/src/math/sinhf.c
old mode 100644
new mode 100755
similarity index 100%
rename from third_party/musl/kernel/src/math/sinhf.c
rename to third_party/musl/porting/liteos_a/kernel/src/math/sinhf.c
diff --git a/third_party/musl/kernel/src/math/sinhl.c b/third_party/musl/porting/liteos_a/kernel/src/math/sinhl.c
old mode 100644
new mode 100755
similarity index 100%
rename from third_party/musl/kernel/src/math/sinhl.c
rename to third_party/musl/porting/liteos_a/kernel/src/math/sinhl.c
diff --git a/third_party/musl/kernel/src/math/sinl.c b/third_party/musl/porting/liteos_a/kernel/src/math/sinl.c
old mode 100644
new mode 100755
similarity index 100%
rename from third_party/musl/kernel/src/math/sinl.c
rename to third_party/musl/porting/liteos_a/kernel/src/math/sinl.c
diff --git a/third_party/musl/kernel/src/math/sqrt.c b/third_party/musl/porting/liteos_a/kernel/src/math/sqrt.c
old mode 100644
new mode 100755
similarity index 100%
rename from third_party/musl/kernel/src/math/sqrt.c
rename to third_party/musl/porting/liteos_a/kernel/src/math/sqrt.c
diff --git a/third_party/musl/kernel/src/math/sqrtf.c b/third_party/musl/porting/liteos_a/kernel/src/math/sqrtf.c
old mode 100644
new mode 100755
similarity index 100%
rename from third_party/musl/kernel/src/math/sqrtf.c
rename to third_party/musl/porting/liteos_a/kernel/src/math/sqrtf.c
diff --git a/third_party/musl/kernel/src/math/sqrtl.c b/third_party/musl/porting/liteos_a/kernel/src/math/sqrtl.c
old mode 100644
new mode 100755
similarity index 100%
rename from third_party/musl/kernel/src/math/sqrtl.c
rename to third_party/musl/porting/liteos_a/kernel/src/math/sqrtl.c
diff --git a/third_party/musl/kernel/src/math/tan.c b/third_party/musl/porting/liteos_a/kernel/src/math/tan.c
old mode 100644
new mode 100755
similarity index 100%
rename from third_party/musl/kernel/src/math/tan.c
rename to third_party/musl/porting/liteos_a/kernel/src/math/tan.c
diff --git a/third_party/musl/kernel/src/math/tanf.c b/third_party/musl/porting/liteos_a/kernel/src/math/tanf.c
old mode 100644
new mode 100755
similarity index 100%
rename from third_party/musl/kernel/src/math/tanf.c
rename to third_party/musl/porting/liteos_a/kernel/src/math/tanf.c
diff --git a/third_party/musl/kernel/src/math/tanh.c b/third_party/musl/porting/liteos_a/kernel/src/math/tanh.c
old mode 100644
new mode 100755
similarity index 100%
rename from third_party/musl/kernel/src/math/tanh.c
rename to third_party/musl/porting/liteos_a/kernel/src/math/tanh.c
diff --git a/third_party/musl/kernel/src/math/tanhf.c b/third_party/musl/porting/liteos_a/kernel/src/math/tanhf.c
old mode 100644
new mode 100755
similarity index 100%
rename from third_party/musl/kernel/src/math/tanhf.c
rename to third_party/musl/porting/liteos_a/kernel/src/math/tanhf.c
diff --git a/third_party/musl/kernel/src/math/tanhl.c b/third_party/musl/porting/liteos_a/kernel/src/math/tanhl.c
old mode 100644
new mode 100755
similarity index 100%
rename from third_party/musl/kernel/src/math/tanhl.c
rename to third_party/musl/porting/liteos_a/kernel/src/math/tanhl.c
diff --git a/third_party/musl/kernel/src/math/tanl.c b/third_party/musl/porting/liteos_a/kernel/src/math/tanl.c
old mode 100644
new mode 100755
similarity index 100%
rename from third_party/musl/kernel/src/math/tanl.c
rename to third_party/musl/porting/liteos_a/kernel/src/math/tanl.c
diff --git a/third_party/musl/kernel/src/math/tgamma.c b/third_party/musl/porting/liteos_a/kernel/src/math/tgamma.c
old mode 100644
new mode 100755
similarity index 100%
rename from third_party/musl/kernel/src/math/tgamma.c
rename to third_party/musl/porting/liteos_a/kernel/src/math/tgamma.c
diff --git a/third_party/musl/kernel/src/math/tgammaf.c b/third_party/musl/porting/liteos_a/kernel/src/math/tgammaf.c
old mode 100644
new mode 100755
similarity index 100%
rename from third_party/musl/kernel/src/math/tgammaf.c
rename to third_party/musl/porting/liteos_a/kernel/src/math/tgammaf.c
diff --git a/third_party/musl/kernel/src/math/tgammal.c b/third_party/musl/porting/liteos_a/kernel/src/math/tgammal.c
old mode 100644
new mode 100755
similarity index 100%
rename from third_party/musl/kernel/src/math/tgammal.c
rename to third_party/musl/porting/liteos_a/kernel/src/math/tgammal.c
diff --git a/third_party/musl/kernel/src/math/trunc.c b/third_party/musl/porting/liteos_a/kernel/src/math/trunc.c
old mode 100644
new mode 100755
similarity index 100%
rename from third_party/musl/kernel/src/math/trunc.c
rename to third_party/musl/porting/liteos_a/kernel/src/math/trunc.c
diff --git a/third_party/musl/kernel/src/math/truncf.c b/third_party/musl/porting/liteos_a/kernel/src/math/truncf.c
old mode 100644
new mode 100755
similarity index 100%
rename from third_party/musl/kernel/src/math/truncf.c
rename to third_party/musl/porting/liteos_a/kernel/src/math/truncf.c
diff --git a/third_party/musl/kernel/src/math/truncl.c b/third_party/musl/porting/liteos_a/kernel/src/math/truncl.c
old mode 100644
new mode 100755
similarity index 100%
rename from third_party/musl/kernel/src/math/truncl.c
rename to third_party/musl/porting/liteos_a/kernel/src/math/truncl.c
diff --git a/third_party/musl/kernel/src/multibyte/internal.c b/third_party/musl/porting/liteos_a/kernel/src/multibyte/internal.c
old mode 100644
new mode 100755
similarity index 100%
rename from third_party/musl/kernel/src/multibyte/internal.c
rename to third_party/musl/porting/liteos_a/kernel/src/multibyte/internal.c
diff --git a/third_party/musl/kernel/src/multibyte/internal.h b/third_party/musl/porting/liteos_a/kernel/src/multibyte/internal.h
old mode 100644
new mode 100755
similarity index 100%
rename from third_party/musl/kernel/src/multibyte/internal.h
rename to third_party/musl/porting/liteos_a/kernel/src/multibyte/internal.h
diff --git a/third_party/musl/kernel/src/multibyte/mbtowc.c b/third_party/musl/porting/liteos_a/kernel/src/multibyte/mbtowc.c
old mode 100644
new mode 100755
similarity index 100%
rename from third_party/musl/kernel/src/multibyte/mbtowc.c
rename to third_party/musl/porting/liteos_a/kernel/src/multibyte/mbtowc.c
diff --git a/third_party/musl/kernel/src/multibyte/wcrtomb.c b/third_party/musl/porting/liteos_a/kernel/src/multibyte/wcrtomb.c
old mode 100644
new mode 100755
similarity index 100%
rename from third_party/musl/kernel/src/multibyte/wcrtomb.c
rename to third_party/musl/porting/liteos_a/kernel/src/multibyte/wcrtomb.c
diff --git a/third_party/musl/kernel/src/multibyte/wctomb.c b/third_party/musl/porting/liteos_a/kernel/src/multibyte/wctomb.c
old mode 100644
new mode 100755
similarity index 100%
rename from third_party/musl/kernel/src/multibyte/wctomb.c
rename to third_party/musl/porting/liteos_a/kernel/src/multibyte/wctomb.c
diff --git a/third_party/musl/kernel/src/network/htonl.c b/third_party/musl/porting/liteos_a/kernel/src/network/htonl.c
old mode 100644
new mode 100755
similarity index 100%
rename from third_party/musl/kernel/src/network/htonl.c
rename to third_party/musl/porting/liteos_a/kernel/src/network/htonl.c
diff --git a/third_party/musl/kernel/src/network/htons.c b/third_party/musl/porting/liteos_a/kernel/src/network/htons.c
old mode 100644
new mode 100755
similarity index 100%
rename from third_party/musl/kernel/src/network/htons.c
rename to third_party/musl/porting/liteos_a/kernel/src/network/htons.c
diff --git a/third_party/musl/kernel/src/network/ntohl.c b/third_party/musl/porting/liteos_a/kernel/src/network/ntohl.c
old mode 100644
new mode 100755
similarity index 100%
rename from third_party/musl/kernel/src/network/ntohl.c
rename to third_party/musl/porting/liteos_a/kernel/src/network/ntohl.c
diff --git a/third_party/musl/kernel/src/network/ntohs.c b/third_party/musl/porting/liteos_a/kernel/src/network/ntohs.c
old mode 100644
new mode 100755
similarity index 100%
rename from third_party/musl/kernel/src/network/ntohs.c
rename to third_party/musl/porting/liteos_a/kernel/src/network/ntohs.c
diff --git a/third_party/musl/porting/liteos_a/kernel/src/prng/rand.c b/third_party/musl/porting/liteos_a/kernel/src/prng/rand.c
new file mode 100755
index 000000000..65ad23843
--- /dev/null
+++ b/third_party/musl/porting/liteos_a/kernel/src/prng/rand.c
@@ -0,0 +1,43 @@
+/*
+ * Copyright (c) 2013-2019 Huawei Technologies Co., Ltd. All rights reserved.
+ * Copyright (c) 2020-2021 Huawei Device Co., Ltd. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without modification,
+ * are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice, this list of
+ *    conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright notice, this list
+ *    of conditions and the following disclaimer in the documentation and/or other materials
+ *    provided with the distribution.
+ *
+ * 3. Neither the name of the copyright holder nor the names of its contributors may be used
+ *    to endorse or promote products derived from this software without specific prior written
+ *    permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+ * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+ * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
+ * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
+ * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
+ * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#include <stdlib.h>
+#include <stdint.h>
+
+void srand(unsigned s)
+{
+    return srandom(s);
+}
+
+int rand(void)
+{
+   return random();
+}
diff --git a/third_party/musl/kernel/src/prng/random.c b/third_party/musl/porting/liteos_a/kernel/src/prng/random.c
old mode 100644
new mode 100755
similarity index 100%
rename from third_party/musl/kernel/src/prng/random.c
rename to third_party/musl/porting/liteos_a/kernel/src/prng/random.c
diff --git a/third_party/musl/porting/liteos_a/kernel/src/sched/sched_yield.c b/third_party/musl/porting/liteos_a/kernel/src/sched/sched_yield.c
new file mode 100755
index 000000000..c511cfdfa
--- /dev/null
+++ b/third_party/musl/porting/liteos_a/kernel/src/sched/sched_yield.c
@@ -0,0 +1,39 @@
+/*
+ * Copyright (c) 2013-2019 Huawei Technologies Co., Ltd. All rights reserved.
+ * Copyright (c) 2020-2021 Huawei Device Co., Ltd. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without modification,
+ * are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice, this list of
+ *    conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright notice, this list
+ *    of conditions and the following disclaimer in the documentation and/or other materials
+ *    provided with the distribution.
+ *
+ * 3. Neither the name of the copyright holder nor the names of its contributors may be used
+ *    to endorse or promote products derived from this software without specific prior written
+ *    permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+ * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+ * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
+ * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
+ * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
+ * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#include <sched.h>
+#include "los_process.h"
+
+int sched_yield()
+{
+    (void)LOS_TaskYield();
+    return 0;
+}
diff --git a/third_party/musl/kernel/src/stdio/__fdopen.c b/third_party/musl/porting/liteos_a/kernel/src/stdio/__fdopen.c
old mode 100644
new mode 100755
similarity index 100%
rename from third_party/musl/kernel/src/stdio/__fdopen.c
rename to third_party/musl/porting/liteos_a/kernel/src/stdio/__fdopen.c
diff --git a/third_party/musl/kernel/src/stdio/__fmodeflags.c b/third_party/musl/porting/liteos_a/kernel/src/stdio/__fmodeflags.c
old mode 100644
new mode 100755
similarity index 100%
rename from third_party/musl/kernel/src/stdio/__fmodeflags.c
rename to third_party/musl/porting/liteos_a/kernel/src/stdio/__fmodeflags.c
diff --git a/third_party/musl/kernel/src/stdio/__lockfile.c b/third_party/musl/porting/liteos_a/kernel/src/stdio/__lockfile.c
old mode 100644
new mode 100755
similarity index 100%
rename from third_party/musl/kernel/src/stdio/__lockfile.c
rename to third_party/musl/porting/liteos_a/kernel/src/stdio/__lockfile.c
diff --git a/third_party/musl/kernel/src/stdio/__overflow.c b/third_party/musl/porting/liteos_a/kernel/src/stdio/__overflow.c
old mode 100644
new mode 100755
similarity index 100%
rename from third_party/musl/kernel/src/stdio/__overflow.c
rename to third_party/musl/porting/liteos_a/kernel/src/stdio/__overflow.c
diff --git a/third_party/musl/kernel/src/stdio/__stdio_close.c b/third_party/musl/porting/liteos_a/kernel/src/stdio/__stdio_close.c
old mode 100644
new mode 100755
similarity index 100%
rename from third_party/musl/kernel/src/stdio/__stdio_close.c
rename to third_party/musl/porting/liteos_a/kernel/src/stdio/__stdio_close.c
diff --git a/third_party/musl/kernel/src/stdio/__stdio_read.c b/third_party/musl/porting/liteos_a/kernel/src/stdio/__stdio_read.c
old mode 100644
new mode 100755
similarity index 100%
rename from third_party/musl/kernel/src/stdio/__stdio_read.c
rename to third_party/musl/porting/liteos_a/kernel/src/stdio/__stdio_read.c
diff --git a/third_party/musl/kernel/src/stdio/__stdio_seek.c b/third_party/musl/porting/liteos_a/kernel/src/stdio/__stdio_seek.c
similarity index 98%
rename from third_party/musl/kernel/src/stdio/__stdio_seek.c
rename to third_party/musl/porting/liteos_a/kernel/src/stdio/__stdio_seek.c
index 7dc176179..9e93feb04 100755
--- a/third_party/musl/kernel/src/stdio/__stdio_seek.c
+++ b/third_party/musl/porting/liteos_a/kernel/src/stdio/__stdio_seek.c
@@ -2,6 +2,7 @@
 #include <unistd.h>
 #include <sys/types.h>
 #include <dirent.h>
+#ifdef LOSCFG_FS_VFS
 #include <fs/fs.h>
 
 static off64_t __stdio_lseek64(int fd, int offsetHigh, int offsetLow, off64_t *result, int whence)
@@ -53,3 +54,4 @@ off_t __stdio_seek(FILE *f, off_t off, int whence)
     off_t result = 0;
     return __stdio_lseek64(f->fd, off>>32, off, &result, whence) ? -1 : result;
 }
+#endif
diff --git a/third_party/musl/kernel/src/stdio/__stdio_write.c b/third_party/musl/porting/liteos_a/kernel/src/stdio/__stdio_write.c
old mode 100644
new mode 100755
similarity index 100%
rename from third_party/musl/kernel/src/stdio/__stdio_write.c
rename to third_party/musl/porting/liteos_a/kernel/src/stdio/__stdio_write.c
diff --git a/third_party/musl/kernel/src/stdio/__stdout_write.c b/third_party/musl/porting/liteos_a/kernel/src/stdio/__stdout_write.c
old mode 100644
new mode 100755
similarity index 100%
rename from third_party/musl/kernel/src/stdio/__stdout_write.c
rename to third_party/musl/porting/liteos_a/kernel/src/stdio/__stdout_write.c
diff --git a/third_party/musl/kernel/src/stdio/__toread.c b/third_party/musl/porting/liteos_a/kernel/src/stdio/__toread.c
old mode 100644
new mode 100755
similarity index 100%
rename from third_party/musl/kernel/src/stdio/__toread.c
rename to third_party/musl/porting/liteos_a/kernel/src/stdio/__toread.c
diff --git a/third_party/musl/kernel/src/stdio/__towrite.c b/third_party/musl/porting/liteos_a/kernel/src/stdio/__towrite.c
old mode 100644
new mode 100755
similarity index 100%
rename from third_party/musl/kernel/src/stdio/__towrite.c
rename to third_party/musl/porting/liteos_a/kernel/src/stdio/__towrite.c
diff --git a/third_party/musl/kernel/src/stdio/__uflow.c b/third_party/musl/porting/liteos_a/kernel/src/stdio/__uflow.c
old mode 100644
new mode 100755
similarity index 100%
rename from third_party/musl/kernel/src/stdio/__uflow.c
rename to third_party/musl/porting/liteos_a/kernel/src/stdio/__uflow.c
diff --git a/third_party/musl/kernel/src/stdio/fclose.c b/third_party/musl/porting/liteos_a/kernel/src/stdio/fclose.c
old mode 100644
new mode 100755
similarity index 93%
rename from third_party/musl/kernel/src/stdio/fclose.c
rename to third_party/musl/porting/liteos_a/kernel/src/stdio/fclose.c
index 9c4be28e2..c53f3cd6e
--- a/third_party/musl/kernel/src/stdio/fclose.c
+++ b/third_party/musl/porting/liteos_a/kernel/src/stdio/fclose.c
@@ -1,11 +1,8 @@
 #include "stdio_impl.h"
 #include <stdlib.h>
-#include "menuconfig.h"
 #ifdef LOSCFG_LLTSER
 #include "gcov_ser.h"
 #endif
-#include "fs/fs.h"
-#include "fs/file.h"
 
 static void dummy(FILE *f) { }
 weak_alias(dummy, __unlist_locked_file);
diff --git a/third_party/musl/kernel/src/stdio/feof.c b/third_party/musl/porting/liteos_a/kernel/src/stdio/feof.c
old mode 100644
new mode 100755
similarity index 100%
rename from third_party/musl/kernel/src/stdio/feof.c
rename to third_party/musl/porting/liteos_a/kernel/src/stdio/feof.c
diff --git a/third_party/musl/kernel/src/stdio/fflush.c b/third_party/musl/porting/liteos_a/kernel/src/stdio/fflush.c
old mode 100644
new mode 100755
similarity index 100%
rename from third_party/musl/kernel/src/stdio/fflush.c
rename to third_party/musl/porting/liteos_a/kernel/src/stdio/fflush.c
diff --git a/third_party/musl/kernel/src/stdio/fgetc.c b/third_party/musl/porting/liteos_a/kernel/src/stdio/fgetc.c
old mode 100644
new mode 100755
similarity index 100%
rename from third_party/musl/kernel/src/stdio/fgetc.c
rename to third_party/musl/porting/liteos_a/kernel/src/stdio/fgetc.c
diff --git a/third_party/musl/kernel/src/stdio/fopen.c b/third_party/musl/porting/liteos_a/kernel/src/stdio/fopen.c
old mode 100644
new mode 100755
similarity index 92%
rename from third_party/musl/kernel/src/stdio/fopen.c
rename to third_party/musl/porting/liteos_a/kernel/src/stdio/fopen.c
index 0b4739871..37d91130f
--- a/third_party/musl/kernel/src/stdio/fopen.c
+++ b/third_party/musl/porting/liteos_a/kernel/src/stdio/fopen.c
@@ -4,12 +4,9 @@
 #include <string.h>
 #include <errno.h>
 #include <limits.h>
-#include "menuconfig.h"
 #ifdef LOSCFG_LLTSER
 #include "gcov_ser.h"
 #endif
-#include "fs/fs.h"
-#include "fs/file.h"
 
 FILE *fopen(const char *restrict filename, const char *restrict mode)
 {
diff --git a/third_party/musl/kernel/src/stdio/fprintf.c b/third_party/musl/porting/liteos_a/kernel/src/stdio/fprintf.c
old mode 100644
new mode 100755
similarity index 100%
rename from third_party/musl/kernel/src/stdio/fprintf.c
rename to third_party/musl/porting/liteos_a/kernel/src/stdio/fprintf.c
diff --git a/third_party/musl/kernel/src/stdio/fputc.c b/third_party/musl/porting/liteos_a/kernel/src/stdio/fputc.c
old mode 100644
new mode 100755
similarity index 100%
rename from third_party/musl/kernel/src/stdio/fputc.c
rename to third_party/musl/porting/liteos_a/kernel/src/stdio/fputc.c
diff --git a/third_party/musl/kernel/src/stdio/fputs.c b/third_party/musl/porting/liteos_a/kernel/src/stdio/fputs.c
old mode 100644
new mode 100755
similarity index 100%
rename from third_party/musl/kernel/src/stdio/fputs.c
rename to third_party/musl/porting/liteos_a/kernel/src/stdio/fputs.c
diff --git a/third_party/musl/kernel/src/stdio/fread.c b/third_party/musl/porting/liteos_a/kernel/src/stdio/fread.c
old mode 100644
new mode 100755
similarity index 92%
rename from third_party/musl/kernel/src/stdio/fread.c
rename to third_party/musl/porting/liteos_a/kernel/src/stdio/fread.c
index a257f72bf..5d3b869ef
--- a/third_party/musl/kernel/src/stdio/fread.c
+++ b/third_party/musl/porting/liteos_a/kernel/src/stdio/fread.c
@@ -1,11 +1,8 @@
 #include "stdio_impl.h"
 #include <string.h>
-#include "menuconfig.h"
 #ifdef LOSCFG_LLTSER
 #include "gcov_ser.h"
 #endif
-#include "fs/fs.h"
-#include "fs/file.h"
 
 #define MIN(a,b) ((a)<(b) ? (a) : (b))
 
diff --git a/third_party/musl/kernel/src/stdio/fseek.c b/third_party/musl/porting/liteos_a/kernel/src/stdio/fseek.c
old mode 100644
new mode 100755
similarity index 100%
rename from third_party/musl/kernel/src/stdio/fseek.c
rename to third_party/musl/porting/liteos_a/kernel/src/stdio/fseek.c
diff --git a/third_party/musl/kernel/src/stdio/ftell.c b/third_party/musl/porting/liteos_a/kernel/src/stdio/ftell.c
old mode 100644
new mode 100755
similarity index 100%
rename from third_party/musl/kernel/src/stdio/ftell.c
rename to third_party/musl/porting/liteos_a/kernel/src/stdio/ftell.c
diff --git a/third_party/musl/kernel/src/stdio/fwrite.c b/third_party/musl/porting/liteos_a/kernel/src/stdio/fwrite.c
old mode 100644
new mode 100755
similarity index 97%
rename from third_party/musl/kernel/src/stdio/fwrite.c
rename to third_party/musl/porting/liteos_a/kernel/src/stdio/fwrite.c
index c90d39d45..a7cd0aa2c
--- a/third_party/musl/kernel/src/stdio/fwrite.c
+++ b/third_party/musl/porting/liteos_a/kernel/src/stdio/fwrite.c
@@ -1,6 +1,5 @@
 #include "stdio_impl.h"
 #include <string.h>
-#include "menuconfig.h"
 #ifdef LOSCFG_LLTSER
 #include "gcov_ser.h"
 #endif
diff --git a/third_party/musl/kernel/src/stdio/getc.h b/third_party/musl/porting/liteos_a/kernel/src/stdio/getc.h
old mode 100644
new mode 100755
similarity index 100%
rename from third_party/musl/kernel/src/stdio/getc.h
rename to third_party/musl/porting/liteos_a/kernel/src/stdio/getc.h
diff --git a/third_party/musl/kernel/src/stdio/ofl.c b/third_party/musl/porting/liteos_a/kernel/src/stdio/ofl.c
old mode 100644
new mode 100755
similarity index 100%
rename from third_party/musl/kernel/src/stdio/ofl.c
rename to third_party/musl/porting/liteos_a/kernel/src/stdio/ofl.c
diff --git a/third_party/musl/kernel/src/stdio/ofl_add.c b/third_party/musl/porting/liteos_a/kernel/src/stdio/ofl_add.c
old mode 100644
new mode 100755
similarity index 100%
rename from third_party/musl/kernel/src/stdio/ofl_add.c
rename to third_party/musl/porting/liteos_a/kernel/src/stdio/ofl_add.c
diff --git a/third_party/musl/kernel/src/stdio/perror.c b/third_party/musl/porting/liteos_a/kernel/src/stdio/perror.c
old mode 100644
new mode 100755
similarity index 100%
rename from third_party/musl/kernel/src/stdio/perror.c
rename to third_party/musl/porting/liteos_a/kernel/src/stdio/perror.c
diff --git a/third_party/musl/kernel/src/stdio/printf.c b/third_party/musl/porting/liteos_a/kernel/src/stdio/printf.c
old mode 100644
new mode 100755
similarity index 100%
rename from third_party/musl/kernel/src/stdio/printf.c
rename to third_party/musl/porting/liteos_a/kernel/src/stdio/printf.c
diff --git a/third_party/musl/kernel/src/stdio/putc.h b/third_party/musl/porting/liteos_a/kernel/src/stdio/putc.h
old mode 100644
new mode 100755
similarity index 100%
rename from third_party/musl/kernel/src/stdio/putc.h
rename to third_party/musl/porting/liteos_a/kernel/src/stdio/putc.h
diff --git a/third_party/musl/kernel/src/stdio/puts.c b/third_party/musl/porting/liteos_a/kernel/src/stdio/puts.c
old mode 100644
new mode 100755
similarity index 100%
rename from third_party/musl/kernel/src/stdio/puts.c
rename to third_party/musl/porting/liteos_a/kernel/src/stdio/puts.c
diff --git a/third_party/musl/kernel/src/stdio/remove.c b/third_party/musl/porting/liteos_a/kernel/src/stdio/remove.c
old mode 100644
new mode 100755
similarity index 73%
rename from third_party/musl/kernel/src/stdio/remove.c
rename to third_party/musl/porting/liteos_a/kernel/src/stdio/remove.c
index 71a3113c2..84549a560
--- a/third_party/musl/kernel/src/stdio/remove.c
+++ b/third_party/musl/porting/liteos_a/kernel/src/stdio/remove.c
@@ -2,9 +2,6 @@
 #include <errno.h>
 #include <fcntl.h>
 #include <unistd.h>
-#include "menuconfig.h"
-#include "fs/fs.h"
-#include "fs/file.h"
 
 int remove(const char *path)
 {
diff --git a/third_party/musl/kernel/src/stdio/setvbuf.c b/third_party/musl/porting/liteos_a/kernel/src/stdio/setvbuf.c
old mode 100644
new mode 100755
similarity index 100%
rename from third_party/musl/kernel/src/stdio/setvbuf.c
rename to third_party/musl/porting/liteos_a/kernel/src/stdio/setvbuf.c
diff --git a/third_party/musl/kernel/src/stdio/snprintf.c b/third_party/musl/porting/liteos_a/kernel/src/stdio/snprintf.c
old mode 100644
new mode 100755
similarity index 100%
rename from third_party/musl/kernel/src/stdio/snprintf.c
rename to third_party/musl/porting/liteos_a/kernel/src/stdio/snprintf.c
diff --git a/third_party/musl/kernel/src/stdio/sprintf.c b/third_party/musl/porting/liteos_a/kernel/src/stdio/sprintf.c
old mode 100644
new mode 100755
similarity index 100%
rename from third_party/musl/kernel/src/stdio/sprintf.c
rename to third_party/musl/porting/liteos_a/kernel/src/stdio/sprintf.c
diff --git a/third_party/musl/kernel/src/stdio/stderr.c b/third_party/musl/porting/liteos_a/kernel/src/stdio/stderr.c
old mode 100644
new mode 100755
similarity index 100%
rename from third_party/musl/kernel/src/stdio/stderr.c
rename to third_party/musl/porting/liteos_a/kernel/src/stdio/stderr.c
diff --git a/third_party/musl/kernel/src/stdio/stdout.c b/third_party/musl/porting/liteos_a/kernel/src/stdio/stdout.c
old mode 100644
new mode 100755
similarity index 100%
rename from third_party/musl/kernel/src/stdio/stdout.c
rename to third_party/musl/porting/liteos_a/kernel/src/stdio/stdout.c
diff --git a/third_party/musl/kernel/src/stdio/ungetc.c b/third_party/musl/porting/liteos_a/kernel/src/stdio/ungetc.c
old mode 100644
new mode 100755
similarity index 100%
rename from third_party/musl/kernel/src/stdio/ungetc.c
rename to third_party/musl/porting/liteos_a/kernel/src/stdio/ungetc.c
diff --git a/third_party/musl/kernel/src/stdio/vfprintf.c b/third_party/musl/porting/liteos_a/kernel/src/stdio/vfprintf.c
old mode 100644
new mode 100755
similarity index 98%
rename from third_party/musl/kernel/src/stdio/vfprintf.c
rename to third_party/musl/porting/liteos_a/kernel/src/stdio/vfprintf.c
index bb8c00bad..a5bcee8a1
--- a/third_party/musl/kernel/src/stdio/vfprintf.c
+++ b/third_party/musl/porting/liteos_a/kernel/src/stdio/vfprintf.c
@@ -29,6 +29,10 @@
 
 #define FLAGMASK (ALT_FORM|ZERO_PAD|LEFT_ADJ|PAD_POS|MARK_POS|GROUPED)
 
+/* Redefine the CHAR type that defined in los_typedef.h and introduced
+ * in by limit.h to avoid conflicts with the following enum definition. */
+#define CHAR _CHAR
+
 /* State machine to accept length modifiers + conversion specifiers.
  * Result is 0 on failure, or an argument type to pop on success. */
 
@@ -444,6 +448,7 @@ static int printf_core(FILE *f, const char *fmt, va_list *ap, union arg *nl_arg,
 	int t, pl;
 	wchar_t wc[2], *ws;
 	char mb[4];
+#ifdef LOSCFG_FS_VFS
 	struct winsize wsz;
 
 	if (f && (f->write == __stdout_write) && !ioctl(f->fd, TIOCGWINSZ, &wsz)) {
@@ -452,6 +457,7 @@ static int printf_core(FILE *f, const char *fmt, va_list *ap, union arg *nl_arg,
 		f->wpos = f->wbase = f->buf;
 		f->wend = f->buf + f->buf_size;
 	}
+#endif
 	for (;;) {
 		/* This error is only specified for snprintf, but since it's
 		 * unspecified for other forms, do the same. Stop immediately
diff --git a/third_party/musl/kernel/src/stdio/vprintf.c b/third_party/musl/porting/liteos_a/kernel/src/stdio/vprintf.c
old mode 100644
new mode 100755
similarity index 100%
rename from third_party/musl/kernel/src/stdio/vprintf.c
rename to third_party/musl/porting/liteos_a/kernel/src/stdio/vprintf.c
diff --git a/third_party/musl/kernel/src/stdio/vsnprintf.c b/third_party/musl/porting/liteos_a/kernel/src/stdio/vsnprintf.c
old mode 100644
new mode 100755
similarity index 100%
rename from third_party/musl/kernel/src/stdio/vsnprintf.c
rename to third_party/musl/porting/liteos_a/kernel/src/stdio/vsnprintf.c
diff --git a/third_party/musl/kernel/src/stdio/vsprintf.c b/third_party/musl/porting/liteos_a/kernel/src/stdio/vsprintf.c
old mode 100644
new mode 100755
similarity index 100%
rename from third_party/musl/kernel/src/stdio/vsprintf.c
rename to third_party/musl/porting/liteos_a/kernel/src/stdio/vsprintf.c
diff --git a/third_party/musl/kernel/src/stdlib/abs.c b/third_party/musl/porting/liteos_a/kernel/src/stdlib/abs.c
old mode 100644
new mode 100755
similarity index 100%
rename from third_party/musl/kernel/src/stdlib/abs.c
rename to third_party/musl/porting/liteos_a/kernel/src/stdlib/abs.c
diff --git a/third_party/musl/kernel/src/stdlib/atoi.c b/third_party/musl/porting/liteos_a/kernel/src/stdlib/atoi.c
old mode 100644
new mode 100755
similarity index 100%
rename from third_party/musl/kernel/src/stdlib/atoi.c
rename to third_party/musl/porting/liteos_a/kernel/src/stdlib/atoi.c
diff --git a/third_party/musl/kernel/src/stdlib/strtod.c b/third_party/musl/porting/liteos_a/kernel/src/stdlib/strtod.c
old mode 100644
new mode 100755
similarity index 100%
rename from third_party/musl/kernel/src/stdlib/strtod.c
rename to third_party/musl/porting/liteos_a/kernel/src/stdlib/strtod.c
diff --git a/third_party/musl/kernel/src/stdlib/strtol.c b/third_party/musl/porting/liteos_a/kernel/src/stdlib/strtol.c
old mode 100644
new mode 100755
similarity index 100%
rename from third_party/musl/kernel/src/stdlib/strtol.c
rename to third_party/musl/porting/liteos_a/kernel/src/stdlib/strtol.c
diff --git a/third_party/musl/kernel/src/string/bzero.c b/third_party/musl/porting/liteos_a/kernel/src/string/bzero.c
old mode 100644
new mode 100755
similarity index 100%
rename from third_party/musl/kernel/src/string/bzero.c
rename to third_party/musl/porting/liteos_a/kernel/src/string/bzero.c
diff --git a/third_party/musl/kernel/src/string/memchr.c b/third_party/musl/porting/liteos_a/kernel/src/string/memchr.c
old mode 100644
new mode 100755
similarity index 100%
rename from third_party/musl/kernel/src/string/memchr.c
rename to third_party/musl/porting/liteos_a/kernel/src/string/memchr.c
diff --git a/third_party/musl/kernel/src/string/memcmp.c b/third_party/musl/porting/liteos_a/kernel/src/string/memcmp.c
old mode 100644
new mode 100755
similarity index 100%
rename from third_party/musl/kernel/src/string/memcmp.c
rename to third_party/musl/porting/liteos_a/kernel/src/string/memcmp.c
diff --git a/third_party/musl/kernel/src/string/memcpy.c b/third_party/musl/porting/liteos_a/kernel/src/string/memcpy.c
old mode 100644
new mode 100755
similarity index 100%
rename from third_party/musl/kernel/src/string/memcpy.c
rename to third_party/musl/porting/liteos_a/kernel/src/string/memcpy.c
diff --git a/third_party/musl/kernel/src/string/memmove.c b/third_party/musl/porting/liteos_a/kernel/src/string/memmove.c
old mode 100644
new mode 100755
similarity index 100%
rename from third_party/musl/kernel/src/string/memmove.c
rename to third_party/musl/porting/liteos_a/kernel/src/string/memmove.c
diff --git a/third_party/musl/kernel/src/string/memrchr.c b/third_party/musl/porting/liteos_a/kernel/src/string/memrchr.c
old mode 100644
new mode 100755
similarity index 100%
rename from third_party/musl/kernel/src/string/memrchr.c
rename to third_party/musl/porting/liteos_a/kernel/src/string/memrchr.c
diff --git a/third_party/musl/kernel/src/string/memset.c b/third_party/musl/porting/liteos_a/kernel/src/string/memset.c
old mode 100644
new mode 100755
similarity index 100%
rename from third_party/musl/kernel/src/string/memset.c
rename to third_party/musl/porting/liteos_a/kernel/src/string/memset.c
diff --git a/third_party/musl/kernel/src/string/stpcpy.c b/third_party/musl/porting/liteos_a/kernel/src/string/stpcpy.c
old mode 100644
new mode 100755
similarity index 100%
rename from third_party/musl/kernel/src/string/stpcpy.c
rename to third_party/musl/porting/liteos_a/kernel/src/string/stpcpy.c
diff --git a/third_party/musl/kernel/src/string/stpncpy.c b/third_party/musl/porting/liteos_a/kernel/src/string/stpncpy.c
old mode 100644
new mode 100755
similarity index 100%
rename from third_party/musl/kernel/src/string/stpncpy.c
rename to third_party/musl/porting/liteos_a/kernel/src/string/stpncpy.c
diff --git a/third_party/musl/kernel/src/string/strcasecmp.c b/third_party/musl/porting/liteos_a/kernel/src/string/strcasecmp.c
old mode 100644
new mode 100755
similarity index 100%
rename from third_party/musl/kernel/src/string/strcasecmp.c
rename to third_party/musl/porting/liteos_a/kernel/src/string/strcasecmp.c
diff --git a/third_party/musl/kernel/src/string/strcasestr.c b/third_party/musl/porting/liteos_a/kernel/src/string/strcasestr.c
old mode 100644
new mode 100755
similarity index 100%
rename from third_party/musl/kernel/src/string/strcasestr.c
rename to third_party/musl/porting/liteos_a/kernel/src/string/strcasestr.c
diff --git a/third_party/musl/kernel/src/string/strcat.c b/third_party/musl/porting/liteos_a/kernel/src/string/strcat.c
old mode 100644
new mode 100755
similarity index 100%
rename from third_party/musl/kernel/src/string/strcat.c
rename to third_party/musl/porting/liteos_a/kernel/src/string/strcat.c
diff --git a/third_party/musl/kernel/src/string/strchr.c b/third_party/musl/porting/liteos_a/kernel/src/string/strchr.c
old mode 100644
new mode 100755
similarity index 100%
rename from third_party/musl/kernel/src/string/strchr.c
rename to third_party/musl/porting/liteos_a/kernel/src/string/strchr.c
diff --git a/third_party/musl/kernel/src/string/strchrnul.c b/third_party/musl/porting/liteos_a/kernel/src/string/strchrnul.c
old mode 100644
new mode 100755
similarity index 100%
rename from third_party/musl/kernel/src/string/strchrnul.c
rename to third_party/musl/porting/liteos_a/kernel/src/string/strchrnul.c
diff --git a/third_party/musl/kernel/src/string/strcmp.c b/third_party/musl/porting/liteos_a/kernel/src/string/strcmp.c
old mode 100644
new mode 100755
similarity index 100%
rename from third_party/musl/kernel/src/string/strcmp.c
rename to third_party/musl/porting/liteos_a/kernel/src/string/strcmp.c
diff --git a/third_party/musl/kernel/src/string/strcpy.c b/third_party/musl/porting/liteos_a/kernel/src/string/strcpy.c
old mode 100644
new mode 100755
similarity index 100%
rename from third_party/musl/kernel/src/string/strcpy.c
rename to third_party/musl/porting/liteos_a/kernel/src/string/strcpy.c
diff --git a/third_party/musl/kernel/src/string/strcspn.c b/third_party/musl/porting/liteos_a/kernel/src/string/strcspn.c
old mode 100644
new mode 100755
similarity index 100%
rename from third_party/musl/kernel/src/string/strcspn.c
rename to third_party/musl/porting/liteos_a/kernel/src/string/strcspn.c
diff --git a/third_party/musl/kernel/src/string/strdup.c b/third_party/musl/porting/liteos_a/kernel/src/string/strdup.c
old mode 100644
new mode 100755
similarity index 100%
rename from third_party/musl/kernel/src/string/strdup.c
rename to third_party/musl/porting/liteos_a/kernel/src/string/strdup.c
diff --git a/third_party/musl/kernel/src/string/strerror_r.c b/third_party/musl/porting/liteos_a/kernel/src/string/strerror_r.c
old mode 100644
new mode 100755
similarity index 100%
rename from third_party/musl/kernel/src/string/strerror_r.c
rename to third_party/musl/porting/liteos_a/kernel/src/string/strerror_r.c
diff --git a/third_party/musl/kernel/src/string/strlcat.c b/third_party/musl/porting/liteos_a/kernel/src/string/strlcat.c
old mode 100644
new mode 100755
similarity index 100%
rename from third_party/musl/kernel/src/string/strlcat.c
rename to third_party/musl/porting/liteos_a/kernel/src/string/strlcat.c
diff --git a/third_party/musl/kernel/src/string/strlcpy.c b/third_party/musl/porting/liteos_a/kernel/src/string/strlcpy.c
old mode 100644
new mode 100755
similarity index 100%
rename from third_party/musl/kernel/src/string/strlcpy.c
rename to third_party/musl/porting/liteos_a/kernel/src/string/strlcpy.c
diff --git a/third_party/musl/kernel/src/string/strlen.c b/third_party/musl/porting/liteos_a/kernel/src/string/strlen.c
old mode 100644
new mode 100755
similarity index 100%
rename from third_party/musl/kernel/src/string/strlen.c
rename to third_party/musl/porting/liteos_a/kernel/src/string/strlen.c
diff --git a/third_party/musl/kernel/src/string/strncasecmp.c b/third_party/musl/porting/liteos_a/kernel/src/string/strncasecmp.c
old mode 100644
new mode 100755
similarity index 100%
rename from third_party/musl/kernel/src/string/strncasecmp.c
rename to third_party/musl/porting/liteos_a/kernel/src/string/strncasecmp.c
diff --git a/third_party/musl/kernel/src/string/strncat.c b/third_party/musl/porting/liteos_a/kernel/src/string/strncat.c
old mode 100644
new mode 100755
similarity index 100%
rename from third_party/musl/kernel/src/string/strncat.c
rename to third_party/musl/porting/liteos_a/kernel/src/string/strncat.c
diff --git a/third_party/musl/kernel/src/string/strncmp.c b/third_party/musl/porting/liteos_a/kernel/src/string/strncmp.c
old mode 100644
new mode 100755
similarity index 100%
rename from third_party/musl/kernel/src/string/strncmp.c
rename to third_party/musl/porting/liteos_a/kernel/src/string/strncmp.c
diff --git a/third_party/musl/kernel/src/string/strncpy.c b/third_party/musl/porting/liteos_a/kernel/src/string/strncpy.c
old mode 100644
new mode 100755
similarity index 100%
rename from third_party/musl/kernel/src/string/strncpy.c
rename to third_party/musl/porting/liteos_a/kernel/src/string/strncpy.c
diff --git a/third_party/musl/kernel/src/string/strndup.c b/third_party/musl/porting/liteos_a/kernel/src/string/strndup.c
old mode 100644
new mode 100755
similarity index 100%
rename from third_party/musl/kernel/src/string/strndup.c
rename to third_party/musl/porting/liteos_a/kernel/src/string/strndup.c
diff --git a/third_party/musl/kernel/src/string/strnlen.c b/third_party/musl/porting/liteos_a/kernel/src/string/strnlen.c
old mode 100644
new mode 100755
similarity index 100%
rename from third_party/musl/kernel/src/string/strnlen.c
rename to third_party/musl/porting/liteos_a/kernel/src/string/strnlen.c
diff --git a/third_party/musl/kernel/src/string/strpbrk.c b/third_party/musl/porting/liteos_a/kernel/src/string/strpbrk.c
old mode 100644
new mode 100755
similarity index 100%
rename from third_party/musl/kernel/src/string/strpbrk.c
rename to third_party/musl/porting/liteos_a/kernel/src/string/strpbrk.c
diff --git a/third_party/musl/kernel/src/string/strrchr.c b/third_party/musl/porting/liteos_a/kernel/src/string/strrchr.c
old mode 100644
new mode 100755
similarity index 100%
rename from third_party/musl/kernel/src/string/strrchr.c
rename to third_party/musl/porting/liteos_a/kernel/src/string/strrchr.c
diff --git a/third_party/musl/kernel/src/string/strsep.c b/third_party/musl/porting/liteos_a/kernel/src/string/strsep.c
old mode 100644
new mode 100755
similarity index 100%
rename from third_party/musl/kernel/src/string/strsep.c
rename to third_party/musl/porting/liteos_a/kernel/src/string/strsep.c
diff --git a/third_party/musl/kernel/src/string/strspn.c b/third_party/musl/porting/liteos_a/kernel/src/string/strspn.c
old mode 100644
new mode 100755
similarity index 100%
rename from third_party/musl/kernel/src/string/strspn.c
rename to third_party/musl/porting/liteos_a/kernel/src/string/strspn.c
diff --git a/third_party/musl/kernel/src/string/strstr.c b/third_party/musl/porting/liteos_a/kernel/src/string/strstr.c
old mode 100644
new mode 100755
similarity index 100%
rename from third_party/musl/kernel/src/string/strstr.c
rename to third_party/musl/porting/liteos_a/kernel/src/string/strstr.c
diff --git a/third_party/musl/kernel/src/string/strtok.c b/third_party/musl/porting/liteos_a/kernel/src/string/strtok.c
old mode 100644
new mode 100755
similarity index 100%
rename from third_party/musl/kernel/src/string/strtok.c
rename to third_party/musl/porting/liteos_a/kernel/src/string/strtok.c
diff --git a/third_party/musl/kernel/src/string/strtok_r.c b/third_party/musl/porting/liteos_a/kernel/src/string/strtok_r.c
old mode 100644
new mode 100755
similarity index 100%
rename from third_party/musl/kernel/src/string/strtok_r.c
rename to third_party/musl/porting/liteos_a/kernel/src/string/strtok_r.c
diff --git a/third_party/musl/kernel/src/time/__month_to_secs.c b/third_party/musl/porting/liteos_a/kernel/src/time/__month_to_secs.c
old mode 100644
new mode 100755
similarity index 100%
rename from third_party/musl/kernel/src/time/__month_to_secs.c
rename to third_party/musl/porting/liteos_a/kernel/src/time/__month_to_secs.c
diff --git a/third_party/musl/kernel/src/time/__secs_to_tm.c b/third_party/musl/porting/liteos_a/kernel/src/time/__secs_to_tm.c
old mode 100644
new mode 100755
similarity index 100%
rename from third_party/musl/kernel/src/time/__secs_to_tm.c
rename to third_party/musl/porting/liteos_a/kernel/src/time/__secs_to_tm.c
diff --git a/third_party/musl/kernel/src/time/__tm_to_secs.c b/third_party/musl/porting/liteos_a/kernel/src/time/__tm_to_secs.c
old mode 100644
new mode 100755
similarity index 100%
rename from third_party/musl/kernel/src/time/__tm_to_secs.c
rename to third_party/musl/porting/liteos_a/kernel/src/time/__tm_to_secs.c
diff --git a/third_party/musl/kernel/src/time/__tz.c b/third_party/musl/porting/liteos_a/kernel/src/time/__tz.c
old mode 100644
new mode 100755
similarity index 100%
rename from third_party/musl/kernel/src/time/__tz.c
rename to third_party/musl/porting/liteos_a/kernel/src/time/__tz.c
diff --git a/third_party/musl/kernel/src/time/__year_to_secs.c b/third_party/musl/porting/liteos_a/kernel/src/time/__year_to_secs.c
old mode 100644
new mode 100755
similarity index 100%
rename from third_party/musl/kernel/src/time/__year_to_secs.c
rename to third_party/musl/porting/liteos_a/kernel/src/time/__year_to_secs.c
diff --git a/third_party/musl/kernel/src/time/asctime.c b/third_party/musl/porting/liteos_a/kernel/src/time/asctime.c
old mode 100644
new mode 100755
similarity index 100%
rename from third_party/musl/kernel/src/time/asctime.c
rename to third_party/musl/porting/liteos_a/kernel/src/time/asctime.c
diff --git a/third_party/musl/kernel/src/time/asctime_r.c b/third_party/musl/porting/liteos_a/kernel/src/time/asctime_r.c
old mode 100644
new mode 100755
similarity index 100%
rename from third_party/musl/kernel/src/time/asctime_r.c
rename to third_party/musl/porting/liteos_a/kernel/src/time/asctime_r.c
diff --git a/third_party/musl/kernel/src/time/ctime.c b/third_party/musl/porting/liteos_a/kernel/src/time/ctime.c
old mode 100644
new mode 100755
similarity index 100%
rename from third_party/musl/kernel/src/time/ctime.c
rename to third_party/musl/porting/liteos_a/kernel/src/time/ctime.c
diff --git a/third_party/musl/kernel/src/time/ctime_r.c b/third_party/musl/porting/liteos_a/kernel/src/time/ctime_r.c
old mode 100644
new mode 100755
similarity index 100%
rename from third_party/musl/kernel/src/time/ctime_r.c
rename to third_party/musl/porting/liteos_a/kernel/src/time/ctime_r.c
diff --git a/third_party/musl/kernel/src/time/gmtime.c b/third_party/musl/porting/liteos_a/kernel/src/time/gmtime.c
old mode 100644
new mode 100755
similarity index 100%
rename from third_party/musl/kernel/src/time/gmtime.c
rename to third_party/musl/porting/liteos_a/kernel/src/time/gmtime.c
diff --git a/third_party/musl/kernel/src/time/gmtime_r.c b/third_party/musl/porting/liteos_a/kernel/src/time/gmtime_r.c
old mode 100644
new mode 100755
similarity index 100%
rename from third_party/musl/kernel/src/time/gmtime_r.c
rename to third_party/musl/porting/liteos_a/kernel/src/time/gmtime_r.c
diff --git a/third_party/musl/kernel/src/time/localtime.c b/third_party/musl/porting/liteos_a/kernel/src/time/localtime.c
old mode 100644
new mode 100755
similarity index 100%
rename from third_party/musl/kernel/src/time/localtime.c
rename to third_party/musl/porting/liteos_a/kernel/src/time/localtime.c
diff --git a/third_party/musl/kernel/src/time/localtime_r.c b/third_party/musl/porting/liteos_a/kernel/src/time/localtime_r.c
old mode 100644
new mode 100755
similarity index 100%
rename from third_party/musl/kernel/src/time/localtime_r.c
rename to third_party/musl/porting/liteos_a/kernel/src/time/localtime_r.c
diff --git a/third_party/musl/kernel/src/time/mktime.c b/third_party/musl/porting/liteos_a/kernel/src/time/mktime.c
old mode 100644
new mode 100755
similarity index 100%
rename from third_party/musl/kernel/src/time/mktime.c
rename to third_party/musl/porting/liteos_a/kernel/src/time/mktime.c
diff --git a/third_party/musl/kernel/src/time/strftime.c b/third_party/musl/porting/liteos_a/kernel/src/time/strftime.c
old mode 100644
new mode 100755
similarity index 100%
rename from third_party/musl/kernel/src/time/strftime.c
rename to third_party/musl/porting/liteos_a/kernel/src/time/strftime.c
diff --git a/third_party/musl/kernel/src/time/strptime.c b/third_party/musl/porting/liteos_a/kernel/src/time/strptime.c
old mode 100644
new mode 100755
similarity index 100%
rename from third_party/musl/kernel/src/time/strptime.c
rename to third_party/musl/porting/liteos_a/kernel/src/time/strptime.c
diff --git a/third_party/musl/porting/liteos_a/kernel/src/time/time.c b/third_party/musl/porting/liteos_a/kernel/src/time/time.c
new file mode 100755
index 000000000..dcf19c7d5
--- /dev/null
+++ b/third_party/musl/porting/liteos_a/kernel/src/time/time.c
@@ -0,0 +1,51 @@
+/*
+ * Copyright (c) 2013-2019 Huawei Technologies Co., Ltd. All rights reserved.
+ * Copyright (c) 2020-2021 Huawei Device Co., Ltd. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without modification,
+ * are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice, this list of
+ *    conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright notice, this list
+ *    of conditions and the following disclaimer in the documentation and/or other materials
+ *    provided with the distribution.
+ *
+ * 3. Neither the name of the copyright holder nor the names of its contributors may be used
+ *    to endorse or promote products derived from this software without specific prior written
+ *    permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+ * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+ * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
+ * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
+ * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
+ * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#include "los_typedef.h"
+#include <time.h>
+#include <sys/time.h>
+
+time_t time(time_t *t)
+{
+    struct timeval tp;
+    int ret;
+
+    /* Get the current time from the system */
+    ret = gettimeofday(&tp, (struct timezone *)NULL);
+    if (ret == LOS_OK) {
+        /* Return the seconds since the epoch */
+        if (t) {
+            *t = tp.tv_sec;
+        }
+        return tp.tv_sec;
+    }
+    return (time_t)OS_ERROR;
+}
diff --git a/third_party/musl/kernel/src/time/time_impl.h b/third_party/musl/porting/liteos_a/kernel/src/time/time_impl.h
old mode 100644
new mode 100755
similarity index 100%
rename from third_party/musl/kernel/src/time/time_impl.h
rename to third_party/musl/porting/liteos_a/kernel/src/time/time_impl.h
diff --git a/third_party/musl/porting/liteos_a/user/arch/arm/bits/syscall.h.in b/third_party/musl/porting/liteos_a/user/arch/arm/bits/syscall.h.in
new file mode 100755
index 000000000..33b4676a0
--- /dev/null
+++ b/third_party/musl/porting/liteos_a/user/arch/arm/bits/syscall.h.in
@@ -0,0 +1,400 @@
+#define __NR_restart_syscall	0
+#define __NR_exit	1
+#define __NR_fork	2
+#define __NR_read	3
+#define __NR_write	4
+#define __NR_open	5
+#define __NR_close	6
+#define __NR_creat	8
+#define __NR_link	9
+#define __NR_unlink	10
+#define __NR_execve	11
+#define __NR_chdir	12
+#define __NR_mknod	14
+#define __NR_chmod	15
+#define __NR_lchown	16
+#define __NR_lseek	19
+#define __NR_getpid	20
+#define __NR_mount	21
+#define __NR_umount	22
+#define __NR_setuid	23
+#define __NR_getuid	24
+#define __NR_ptrace	26
+#define __NR_pause	29
+#define __NR_access	33
+#define __NR_nice	34
+#define __NR_sync	36
+#define __NR_kill	37
+#define __NR_rename	38
+#define __NR_mkdir	39
+#define __NR_rmdir	40
+#define __NR_dup	41
+#define __NR_pipe	42
+#define __NR_times	43
+#define __NR_brk	45
+#define __NR_setgid	46
+#define __NR_getgid	47
+#define __NR_geteuid	49
+#define __NR_getegid	50
+#define __NR_acct	51
+#define __NR_umount2	52
+#define __NR_ioctl	54
+#define __NR_fcntl	55
+#define __NR_setpgid	57
+#define __NR_umask	60
+#define __NR_chroot	61
+#define __NR_ustat	62
+#define __NR_dup2	63
+#define __NR_getppid	64
+#define __NR_getpgrp	65
+#define __NR_setsid	66
+#define __NR_sigaction	67
+#define __NR_setreuid	70
+#define __NR_setregid	71
+#define __NR_sigsuspend	72
+#define __NR_sigpending	73
+#define __NR_sethostname	74
+#define __NR_setrlimit	75
+#define __NR_getrusage	77
+#define __NR_gettimeofday_time32	78
+#define __NR_settimeofday_time32	79
+#define __NR_getgroups	80
+#define __NR_setgroups	81
+#define __NR_symlink	83
+#define __NR_readlink	85
+#define __NR_uselib	86
+#define __NR_swapon	87
+#define __NR_reboot	88
+#define __NR_munmap	91
+#define __NR_truncate	92
+#define __NR_ftruncate	93
+#define __NR_fchmod	94
+#define __NR_fchown	95
+#define __NR_getpriority	96
+#define __NR_setpriority	97
+#define __NR_statfs	99
+#define __NR_fstatfs	100
+#define __NR_syslog	103
+#define __NR_setitimer	104
+#define __NR_getitimer	105
+#define __NR_stat	106
+#define __NR_lstat	107
+#define __NR_fstat	108
+#define __NR_vhangup	111
+#define __NR_wait4	114
+#define __NR_swapoff	115
+#define __NR_sysinfo	116
+#define __NR_fsync	118
+#define __NR_sigreturn	119
+#define __NR_clone	120
+#define __NR_setdomainname	121
+#define __NR_uname	122
+#define __NR_adjtimex	124
+#define __NR_mprotect	125
+#define __NR_sigprocmask	126
+#define __NR_init_module	128
+#define __NR_delete_module	129
+#define __NR_quotactl	131
+#define __NR_getpgid	132
+#define __NR_fchdir	133
+#define __NR_bdflush	134
+#define __NR_sysfs	135
+#define __NR_personality	136
+#define __NR_setfsuid	138
+#define __NR_setfsgid	139
+#define __NR__llseek	140
+#define __NR_getdents	141
+#define __NR__newselect	142
+#define __NR_flock	143
+#define __NR_msync	144
+#define __NR_readv	145
+#define __NR_writev	146
+#define __NR_getsid	147
+#define __NR_fdatasync	148
+#define __NR__sysctl	149
+#define __NR_mlock	150
+#define __NR_munlock	151
+#define __NR_mlockall	152
+#define __NR_munlockall	153
+#define __NR_sched_setparam	154
+#define __NR_sched_getparam	155
+#define __NR_sched_setscheduler	156
+#define __NR_sched_getscheduler	157
+#define __NR_sched_yield	158
+#define __NR_sched_get_priority_max	159
+#define __NR_sched_get_priority_min	160
+#define __NR_sched_rr_get_interval	161
+#define __NR_nanosleep	162
+#define __NR_mremap	163
+#define __NR_setresuid	164
+#define __NR_getresuid	165
+#define __NR_poll	168
+#define __NR_nfsservctl	169
+#define __NR_setresgid	170
+#define __NR_getresgid	171
+#define __NR_prctl	172
+#define __NR_rt_sigreturn	173
+#define __NR_rt_sigaction	174
+#define __NR_rt_sigprocmask	175
+#define __NR_rt_sigpending	176
+#define __NR_rt_sigtimedwait	177
+#define __NR_rt_sigqueueinfo	178
+#define __NR_rt_sigsuspend	179
+#define __NR_pread64	180
+#define __NR_pwrite64	181
+#define __NR_chown	182
+#define __NR_getcwd	183
+#define __NR_capget	184
+#define __NR_capset	185
+#define __NR_sigaltstack	186
+#define __NR_sendfile	187
+#define __NR_vfork	190
+#define __NR_ugetrlimit	191
+#define __NR_mmap2	192
+#define __NR_truncate64	193
+#define __NR_ftruncate64	194
+#define __NR_stat64	195
+#define __NR_lstat64	196
+#define __NR_fstat64	197
+#define __NR_lchown32	198
+#define __NR_getuid32	199
+#define __NR_getgid32	200
+#define __NR_geteuid32	201
+#define __NR_getegid32	202
+#define __NR_setreuid32	203
+#define __NR_setregid32	204
+#define __NR_getgroups32	205
+#define __NR_setgroups32	206
+#define __NR_fchown32	207
+#define __NR_setresuid32	208
+#define __NR_getresuid32	209
+#define __NR_setresgid32	210
+#define __NR_getresgid32	211
+#define __NR_chown32	212
+#define __NR_setuid32	213
+#define __NR_setgid32	214
+#define __NR_setfsuid32	215
+#define __NR_setfsgid32	216
+#define __NR_getdents64	217
+#define __NR_pivot_root	218
+#define __NR_mincore	219
+#define __NR_madvise	220
+#define __NR_fcntl64	221
+#define __NR_gettid	224
+#define __NR_readahead	225
+#define __NR_setxattr	226
+#define __NR_lsetxattr	227
+#define __NR_fsetxattr	228
+#define __NR_getxattr	229
+#define __NR_lgetxattr	230
+#define __NR_fgetxattr	231
+#define __NR_listxattr	232
+#define __NR_llistxattr	233
+#define __NR_flistxattr	234
+#define __NR_removexattr	235
+#define __NR_lremovexattr	236
+#define __NR_fremovexattr	237
+#define __NR_tkill	238
+#define __NR_sendfile64	239
+#define __NR_futex	240
+#define __NR_sched_setaffinity	241
+#define __NR_sched_getaffinity	242
+#define __NR_io_setup	243
+#define __NR_io_destroy	244
+#define __NR_io_getevents	245
+#define __NR_io_submit	246
+#define __NR_io_cancel	247
+#define __NR_exit_group	248
+#define __NR_lookup_dcookie	249
+#define __NR_epoll_create	250
+#define __NR_epoll_ctl	251
+#define __NR_epoll_wait	252
+#define __NR_remap_file_pages	253
+#define __NR_set_thread_area	254
+#define __NR_get_thread_area	255
+#define __NR_set_tid_address	256
+#define __NR_timer_create	257
+#define __NR_timer_settime32	258
+#define __NR_timer_gettime32	259
+#define __NR_timer_getoverrun	260
+#define __NR_timer_delete	261
+#define __NR_clock_settime32	262
+#define __NR_clock_gettime32	263
+#define __NR_clock_getres_time32	264
+#define __NR_clock_nanosleep_time32	265
+#define __NR_statfs64	266
+#define __NR_fstatfs64	267
+#define __NR_tgkill	268
+#define __NR_utimes	269
+#define __NR_fadvise64_64	270
+#define __NR_arm_fadvise64_64	270
+#define __NR_pciconfig_iobase	271
+#define __NR_pciconfig_read	272
+#define __NR_pciconfig_write	273
+#define __NR_mq_open	274
+#define __NR_mq_unlink	275
+#define __NR_mq_timedsend	276
+#define __NR_mq_timedreceive	277
+#define __NR_mq_notify	278
+#define __NR_mq_getsetattr	279
+#define __NR_waitid	280
+#define __NR_socket	281
+#define __NR_bind	282
+#define __NR_connect	283
+#define __NR_listen	284
+#define __NR_accept	285
+#define __NR_getsockname	286
+#define __NR_getpeername	287
+#define __NR_socketpair	288
+#define __NR_send	289
+#define __NR_sendto	290
+#define __NR_recv	291
+#define __NR_recvfrom	292
+#define __NR_shutdown	293
+#define __NR_setsockopt	294
+#define __NR_getsockopt	295
+#define __NR_sendmsg	296
+#define __NR_recvmsg	297
+#define __NR_semop	298
+#define __NR_semget	299
+#define __NR_semctl	300
+#define __NR_msgsnd	301
+#define __NR_msgrcv	302
+#define __NR_msgget	303
+#define __NR_msgctl	304
+#define __NR_shmat	305
+#define __NR_shmdt	306
+#define __NR_shmget	307
+#define __NR_shmctl	308
+#define __NR_add_key	309
+#define __NR_request_key	310
+#define __NR_keyctl	311
+#define __NR_semtimedop	312
+#define __NR_vserver	313
+#define __NR_ioprio_set	314
+#define __NR_ioprio_get	315
+#define __NR_inotify_init	316
+#define __NR_inotify_add_watch	317
+#define __NR_inotify_rm_watch	318
+#define __NR_mbind	319
+#define __NR_get_mempolicy	320
+#define __NR_set_mempolicy	321
+#define __NR_openat	322
+#define __NR_mkdirat	323
+#define __NR_mknodat	324
+#define __NR_fchownat	325
+#define __NR_futimesat	326
+#define __NR_fstatat64	327
+#define __NR_unlinkat	328
+#define __NR_renameat	329
+#define __NR_linkat	330
+#define __NR_symlinkat	331
+#define __NR_readlinkat	332
+#define __NR_fchmodat	333
+#define __NR_faccessat	334
+#define __NR_pselect6	335
+#define __NR_ppoll	336
+#define __NR_unshare	337
+#define __NR_set_robust_list	338
+#define __NR_get_robust_list	339
+#define __NR_splice	340
+#define __NR_sync_file_range2	341
+#define __NR_arm_sync_file_range	341
+#define __NR_tee	342
+#define __NR_vmsplice	343
+#define __NR_move_pages	344
+#define __NR_getcpu	345
+#define __NR_epoll_pwait	346
+#define __NR_kexec_load	347
+#define __NR_utimensat	348
+#define __NR_signalfd	349
+#define __NR_timerfd_create	350
+#define __NR_eventfd	351
+#define __NR_fallocate	352
+#define __NR_timerfd_settime32	353
+#define __NR_timerfd_gettime32	354
+#define __NR_signalfd4	355
+#define __NR_eventfd2	356
+#define __NR_epoll_create1	357
+#define __NR_dup3	358
+#define __NR_pipe2	359
+#define __NR_inotify_init1	360
+#define __NR_preadv	361
+#define __NR_pwritev	362
+#define __NR_rt_tgsigqueueinfo	363
+#define __NR_perf_event_open	364
+#define __NR_recvmmsg	365
+#define __NR_accept4	366
+#define __NR_fanotify_init	367
+#define __NR_fanotify_mark	368
+#define __NR_prlimit64	369
+#define __NR_name_to_handle_at	370
+#define __NR_open_by_handle_at	371
+#define __NR_clock_adjtime	372
+#define __NR_syncfs	373
+#define __NR_sendmmsg	374
+#define __NR_setns	375
+#define __NR_process_vm_readv	376
+#define __NR_process_vm_writev	377
+#define __NR_kcmp		378
+#define __NR_finit_module	379
+#define __NR_sched_setattr	380
+#define __NR_sched_getattr	381
+#define __NR_renameat2	382
+#define __NR_seccomp	383
+#define __NR_getrandom	384
+#define __NR_memfd_create	385
+#define __NR_bpf	386
+#define __NR_execveat	387
+#define __NR_userfaultfd	388
+#define __NR_membarrier		389
+#define __NR_mlock2		390
+#define __NR_copy_file_range	391
+#define __NR_preadv2	392
+#define __NR_pwritev2	393
+#define __NR_pkey_mprotect	394
+#define __NR_pkey_alloc	395
+#define __NR_pkey_free	396
+#define __NR_statx	397
+#define __NR_rseq	398
+#define __NR_io_pgetevents	399
+#define __NR_migrate_pages	400
+#define __NR_kexec_file_load	401
+#define __NR_pidfd_send_signal	424
+#define __NR_io_uring_setup	425
+#define __NR_io_uring_enter	426
+#define __NR_io_uring_register	427
+#define __NR_open_tree		428
+#define __NR_move_mount		429
+#define __NR_fsopen		430
+#define __NR_fsconfig		431
+#define __NR_fsmount		432
+#define __NR_fspick		433
+#define __NR_pidfd_open		434
+#define __NR_clone3		435
+
+/* OHOS customized syscalls, not compatible with ARM EABI */
+#define __NR_OHOS_BEGIN         500
+#define __NR_pthread_set_detach (__NR_OHOS_BEGIN + 0)
+#define __NR_pthread_join       (__NR_OHOS_BEGIN + 1)
+#define __NR_pthread_deatch     (__NR_OHOS_BEGIN + 2)
+#define __NR_creat_user_thread  (__NR_OHOS_BEGIN + 3)
+#define __NR_processcreat       (__NR_OHOS_BEGIN + 4)
+#define __NR_processtart        (__NR_OHOS_BEGIN + 5)
+#define __NR_printf             (__NR_OHOS_BEGIN + 6)
+#define __NR_dumpmemory         (__NR_OHOS_BEGIN + 13)
+#define __NR_mkfifo             (__NR_OHOS_BEGIN + 14)
+#define __NR_mqclose            (__NR_OHOS_BEGIN + 15)
+#define __NR_realpath           (__NR_OHOS_BEGIN + 16)
+#define __NR_format             (__NR_OHOS_BEGIN + 17)
+#define __NR_shellexec          (__NR_OHOS_BEGIN + 18)
+#define __NR_ohoscapget         (__NR_OHOS_BEGIN + 19)
+#define __NR_ohoscapset         (__NR_OHOS_BEGIN + 20)
+#define __NR_syscallend         (__NR_OHOS_BEGIN + 21)
+
+#define __ARM_NR_breakpoint	0x0f0001
+#define __ARM_NR_cacheflush	0x0f0002
+#define __ARM_NR_usr26		0x0f0003
+#define __ARM_NR_usr32		0x0f0004
+#define __ARM_NR_set_tls	0x0f0005
+#define __ARM_NR_get_tls	0x0f0006
diff --git a/third_party/musl/porting/liteos_a/user/arch/arm/crt_arch.h b/third_party/musl/porting/liteos_a/user/arch/arm/crt_arch.h
new file mode 100755
index 000000000..219464e07
--- /dev/null
+++ b/third_party/musl/porting/liteos_a/user/arch/arm/crt_arch.h
@@ -0,0 +1,18 @@
+__asm__(
+".text \n"
+".global " START " \n"
+".type " START ",%function \n"
+START ": \n"
+"	mov fp, #0 \n"
+"	mov lr, #0 \n"
+"	ldr a2, 1f \n"
+"	add a2, pc, a2 \n"
+"	mov a3, sp \n"
+"2:	and ip, a3, #-16 \n"
+"	mov sp, ip \n"
+"	bl " START "_c \n"
+".weak _DYNAMIC \n"
+".hidden _DYNAMIC \n"
+".align 2 \n"
+"1:	.word _DYNAMIC-2b \n"
+);
diff --git a/third_party/musl/porting/liteos_a/user/arch/arm/pthread_arch.h b/third_party/musl/porting/liteos_a/user/arch/arm/pthread_arch.h
new file mode 100755
index 000000000..14119c953
--- /dev/null
+++ b/third_party/musl/porting/liteos_a/user/arch/arm/pthread_arch.h
@@ -0,0 +1,37 @@
+#if 0
+#if ((__ARM_ARCH_6K__ || __ARM_ARCH_6KZ__ || __ARM_ARCH_6ZK__) && !__thumb__) \
+ || __ARM_ARCH_7A__ || __ARM_ARCH_7R__ || __ARM_ARCH >= 7
+
+static inline pthread_t __pthread_self()
+{
+	char *p;
+	__asm__ ( "mrc p15,0,%0,c13,c0,3" : "=r"(p) );
+	return (void *)(p-sizeof(struct pthread));
+}
+
+#else
+
+#if __ARM_ARCH_4__ || __ARM_ARCH_4T__ || __ARM_ARCH == 4
+#define BLX "mov lr,pc\n\tbx"
+#else
+#define BLX "blx"
+#endif
+
+static inline pthread_t __pthread_self()
+{
+	extern hidden uintptr_t __a_gettp_ptr;
+	register uintptr_t p __asm__("r0");
+	__asm__ ( BLX " %1" : "=r"(p) : "r"(__a_gettp_ptr) : "cc", "lr" );
+	return (void *)(p-sizeof(struct pthread));
+}
+
+#endif
+#else
+extern pthread_t __pthread_self();
+#endif
+
+#define TLS_ABOVE_TP
+#define GAP_ABOVE_TP 8
+#define TP_ADJ(p) ((char *)(p) + sizeof(struct pthread))
+
+#define MC_PC arm_pc
diff --git a/third_party/musl/porting/liteos_a/user/arch/arm/reloc.h b/third_party/musl/porting/liteos_a/user/arch/arm/reloc.h
new file mode 100755
index 000000000..843dd6211
--- /dev/null
+++ b/third_party/musl/porting/liteos_a/user/arch/arm/reloc.h
@@ -0,0 +1,32 @@
+#if __BYTE_ORDER == __BIG_ENDIAN
+#define ENDIAN_SUFFIX "eb"
+#else
+#define ENDIAN_SUFFIX ""
+#endif
+
+#if __ARM_PCS_VFP
+#define FP_SUFFIX "hf"
+#else
+#define FP_SUFFIX ""
+#endif
+
+#define LDSO_ARCH "arm" ENDIAN_SUFFIX FP_SUFFIX
+
+#define NO_LEGACY_INITFINI
+
+#define TPOFF_K 0
+
+#define REL_SYMBOLIC    R_ARM_ABS32
+#define REL_GOT         R_ARM_GLOB_DAT
+#define REL_PLT         R_ARM_JUMP_SLOT
+#define REL_RELATIVE    R_ARM_RELATIVE
+#define REL_COPY        R_ARM_COPY
+#define REL_DTPMOD      R_ARM_TLS_DTPMOD32
+#define REL_DTPOFF      R_ARM_TLS_DTPOFF32
+#define REL_TPOFF       R_ARM_TLS_TPOFF32
+#define REL_TLSDESC     R_ARM_TLS_DESC
+
+#define TLSDESC_BACKWARDS
+
+#define CRTJMP(pc,sp) __asm__ __volatile__( \
+	"mov r0,%1 ; bx %0" : : "r"(pc), "r"(sp) : "memory", "r0" )
diff --git a/third_party/musl/porting/liteos_a/user/arch/arm/syscall_arch.h b/third_party/musl/porting/liteos_a/user/arch/arm/syscall_arch.h
new file mode 100755
index 000000000..9b5a52491
--- /dev/null
+++ b/third_party/musl/porting/liteos_a/user/arch/arm/syscall_arch.h
@@ -0,0 +1,109 @@
+#define __SYSCALL_LL_E(x) \
+((union { long long ll; long l[2]; }){ .ll = x }).l[0], \
+((union { long long ll; long l[2]; }){ .ll = x }).l[1]
+#define __SYSCALL_LL_O(x) 0, __SYSCALL_LL_E((x))
+
+#ifdef __thumb__
+
+/* Avoid use of r7 in asm constraints when producing thumb code,
+ * since it's reserved as frame pointer and might not be supported. */
+#define __ASM____R7__
+#define __asm_syscall(...) do { \
+	__asm__ __volatile__ ( "mov %1,r7 ; mov r7,%2 ; svc 0 ; mov r7,%1" \
+	: "=r"(r0), "=&r"((int){0}) : __VA_ARGS__ : "memory"); \
+	return r0; \
+	} while (0)
+
+#else
+
+#define __ASM____R7__ __asm__("r7")
+#define __asm_syscall(...) do { \
+	__asm__ __volatile__ ( "svc 0" \
+	: "=r"(r0) : __VA_ARGS__ : "memory"); \
+	return r0; \
+	} while (0)
+#endif
+
+/* For thumb2, we can allow 8-bit immediate syscall numbers, saving a
+ * register in the above dance around r7. Does not work for thumb1 where
+ * only movs, not mov, supports immediates, and we can't use movs because
+ * it doesn't support high regs. */
+#ifdef __thumb2__
+#define R7_OPERAND "rI"(r7)
+#else
+#define R7_OPERAND "r"(r7)
+#endif
+
+static inline long __syscall0(long n)
+{
+	register long r7 __ASM____R7__ = n;
+	register long r0 __asm__("r0");
+	__asm_syscall(R7_OPERAND);
+}
+
+static inline long __syscall1(long n, long a)
+{
+	register long r7 __ASM____R7__ = n;
+	register long r0 __asm__("r0") = a;
+	__asm_syscall(R7_OPERAND, "0"(r0));
+}
+
+static inline long __syscall2(long n, long a, long b)
+{
+	register long r7 __ASM____R7__ = n;
+	register long r0 __asm__("r0") = a;
+	register long r1 __asm__("r1") = b;
+	__asm_syscall(R7_OPERAND, "0"(r0), "r"(r1));
+}
+
+static inline long __syscall3(long n, long a, long b, long c)
+{
+	register long r7 __ASM____R7__ = n;
+	register long r0 __asm__("r0") = a;
+	register long r1 __asm__("r1") = b;
+	register long r2 __asm__("r2") = c;
+	__asm_syscall(R7_OPERAND, "0"(r0), "r"(r1), "r"(r2));
+}
+
+static inline long __syscall4(long n, long a, long b, long c, long d)
+{
+	register long r7 __ASM____R7__ = n;
+	register long r0 __asm__("r0") = a;
+	register long r1 __asm__("r1") = b;
+	register long r2 __asm__("r2") = c;
+	register long r3 __asm__("r3") = d;
+	__asm_syscall(R7_OPERAND, "0"(r0), "r"(r1), "r"(r2), "r"(r3));
+}
+
+static inline long __syscall5(long n, long a, long b, long c, long d, long e)
+{
+	register long r7 __ASM____R7__ = n;
+	register long r0 __asm__("r0") = a;
+	register long r1 __asm__("r1") = b;
+	register long r2 __asm__("r2") = c;
+	register long r3 __asm__("r3") = d;
+	register long r4 __asm__("r4") = e;
+	__asm_syscall(R7_OPERAND, "0"(r0), "r"(r1), "r"(r2), "r"(r3), "r"(r4));
+}
+
+static inline long __syscall6(long n, long a, long b, long c, long d, long e, long f)
+{
+	register long r7 __ASM____R7__ = n;
+	register long r0 __asm__("r0") = a;
+	register long r1 __asm__("r1") = b;
+	register long r2 __asm__("r2") = c;
+	register long r3 __asm__("r3") = d;
+	register long r4 __asm__("r4") = e;
+	register long r5 __asm__("r5") = f;
+	__asm_syscall(R7_OPERAND, "0"(r0), "r"(r1), "r"(r2), "r"(r3), "r"(r4), "r"(r5));
+}
+
+#define VDSO_USEFUL
+#define VDSO_CGT32_SYM "VdsoClockGettime"
+#define VDSO_CGT32_VER "OHOS"
+#define VDSO_CGT_SYM "VdsoClockGettime"
+#define VDSO_CGT_VER "OHOS"
+
+#define SYSCALL_FADVISE_6_ARG
+
+#define SYSCALL_IPC_BROKEN_MODE
diff --git a/third_party/musl/kernel_m/include/limits.h b/third_party/musl/porting/liteos_a/user/include/limits.h
similarity index 96%
rename from third_party/musl/kernel_m/include/limits.h
rename to third_party/musl/porting/liteos_a/user/include/limits.h
index 20fda4a1b..44da653b3 100755
--- a/third_party/musl/kernel_m/include/limits.h
+++ b/third_party/musl/porting/liteos_a/user/include/limits.h
@@ -1,10 +1,6 @@
 #ifndef _LIMITS_H
 #define _LIMITS_H
 
-#ifdef __ICCARM__ /* for iar */
-#include_next <limits.h>
-#else
-
 #include <features.h>
 
 #include <bits/alltypes.h> /* __LONG_MAX */
@@ -48,9 +44,9 @@
 #ifndef NAME_MAX
 #define NAME_MAX 255
 #endif
-#define PATH_MAX 4096
+#define PATH_MAX 256
 #define NGROUPS_MAX 32
-#define ARG_MAX 131072
+#define ARG_MAX 4096
 #define IOV_MAX 1024
 #define SYMLOOP_MAX 40
 #define WORD_BIT 32
@@ -73,7 +69,7 @@
 #define SEM_VALUE_MAX 0x7fffffff
 #define SEM_NSEMS_MAX 256
 #define DELAYTIMER_MAX 0x7fffffff
-#define MQ_PRIO_MAX 32768
+#define MQ_PRIO_MAX 1
 #define LOGIN_NAME_MAX 256
 
 /* Arbitrary numbers... */
@@ -167,5 +163,4 @@
 #define _XOPEN_NAME_MAX         255
 #define _XOPEN_PATH_MAX         1024
 
-#endif /* __ICCARM__ */
 #endif
diff --git a/third_party/musl/include/sys/capability.h b/third_party/musl/porting/liteos_a/user/include/sys/capability.h
similarity index 95%
rename from third_party/musl/include/sys/capability.h
rename to third_party/musl/porting/liteos_a/user/include/sys/capability.h
index 23e9bb07b..b7dd8f727 100755
--- a/third_party/musl/include/sys/capability.h
+++ b/third_party/musl/porting/liteos_a/user/include/sys/capability.h
@@ -1,6 +1,6 @@
 /*
- * Copyright (c) 2013-2019, Huawei Technologies Co., Ltd. All rights reserved.
- * Copyright (c) 2020, Huawei Device Co., Ltd. All rights reserved.
+ * Copyright (c) 2013-2019 Huawei Technologies Co., Ltd. All rights reserved.
+ * Copyright (c) 2020-2021 Huawei Device Co., Ltd. All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without modification,
  * are permitted provided that the following conditions are met:
diff --git a/third_party/musl/porting/liteos_a/user/include/unistd.h b/third_party/musl/porting/liteos_a/user/include/unistd.h
new file mode 100755
index 000000000..b4ff3db86
--- /dev/null
+++ b/third_party/musl/porting/liteos_a/user/include/unistd.h
@@ -0,0 +1,493 @@
+#ifndef	_UNISTD_H
+#define	_UNISTD_H
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#include <features.h>
+
+#define STDIN_FILENO  0
+#define STDOUT_FILENO 1
+#define STDERR_FILENO 2
+
+#define SEEK_SET 0
+#define SEEK_CUR 1
+#define SEEK_END 2
+
+#ifdef __cplusplus
+#define NULL 0L
+#else
+#define NULL ((void*)0)
+#endif
+
+#define __NEED_size_t
+#define __NEED_ssize_t
+#define __NEED_uid_t
+#define __NEED_gid_t
+#define __NEED_off_t
+#define __NEED_pid_t
+#define __NEED_intptr_t
+#define __NEED_useconds_t
+
+#include <bits/alltypes.h>
+
+int pipe(int [2]);
+int pipe2(int [2], int);
+int close(int);
+int posix_close(int, int);
+int dup(int);
+int dup2(int, int);
+int dup3(int, int, int);
+off_t lseek(int, off_t, int);
+int fsync(int);
+int fdatasync(int);
+
+ssize_t read(int, void *, size_t);
+ssize_t write(int, const void *, size_t);
+ssize_t pread(int, void *, size_t, off_t);
+ssize_t pwrite(int, const void *, size_t, off_t);
+
+int chown(const char *, uid_t, gid_t);
+int fchown(int, uid_t, gid_t);
+int lchown(const char *, uid_t, gid_t);
+int fchownat(int, const char *, uid_t, gid_t, int);
+
+int link(const char *, const char *);
+int linkat(int, const char *, int, const char *, int);
+int symlink(const char *, const char *);
+int symlinkat(const char *, int, const char *);
+ssize_t readlink(const char *__restrict, char *__restrict, size_t);
+ssize_t readlinkat(int, const char *__restrict, char *__restrict, size_t);
+int unlink(const char *);
+int unlinkat(int, const char *, int);
+int rmdir(const char *);
+int truncate(const char *, off_t);
+int ftruncate(int, off_t);
+
+#define F_OK 0
+#define R_OK 4
+#define W_OK 2
+#define X_OK 1
+
+int access(const char *, int);
+int faccessat(int, const char *, int, int);
+
+
+/* Format options */
+#define FMT_FAT      0x01
+#define FMT_FAT32    0x02
+#define FMT_ANY      0x07
+#define FMT_ERASE    0x08
+
+/** 
+  * @brief format FAT device (SD card, U disk, and MMC card), this function is OHOS-specific
+  * @param dev device name.
+  * @param sectors sectors per cluster, can be 0 OR power of 2. The sector size for standard FAT volumes is 512 bytes.
+  *    -- sector number is 0 OR >128: automatically choose the appropriate cluster size.
+  *    -- sector number is 1 ~ 128: cluster size = sectors per cluster * 512B.
+  * @param option file system type.
+  *    -- FMT_FAT
+  *    -- FMT_FAT32
+  *    -- FMT_ANY
+  *    -- FMT_ERASE (USB not supported)
+  * @return format result
+  * @retval -1 format error
+  * @retval 0 format successful
+  */
+int format(const char *dev, int sectors, int option);
+
+int chdir(const char *);
+int fchdir(int);
+char *getcwd(char *, size_t);
+
+unsigned alarm(unsigned);
+unsigned sleep(unsigned);
+int pause(void);
+
+pid_t fork(void);
+int execve(const char *, char *const [], char *const []);
+int execv(const char *, char *const []);
+int execle(const char *, const char *, ...);
+int execl(const char *, const char *, ...);
+int execvp(const char *, char *const []);
+int execlp(const char *, const char *, ...);
+int fexecve(int, char *const [], char *const []);
+_Noreturn void _exit(int);
+
+pid_t getpid(void);
+pid_t getppid(void);
+pid_t getpgrp(void);
+pid_t getpgid(pid_t);
+int setpgid(pid_t, pid_t);
+pid_t setsid(void);
+pid_t getsid(pid_t);
+char *ttyname(int);
+int ttyname_r(int, char *, size_t);
+int isatty(int);
+pid_t tcgetpgrp(int);
+int tcsetpgrp(int, pid_t);
+
+uid_t getuid(void);
+uid_t geteuid(void);
+gid_t getgid(void);
+gid_t getegid(void);
+int getgroups(int, gid_t []);
+int setuid(uid_t);
+int seteuid(uid_t);
+int setgid(gid_t);
+int setegid(gid_t);
+
+char *getlogin(void);
+int getlogin_r(char *, size_t);
+int gethostname(char *, size_t);
+char *ctermid(char *);
+
+int getopt(int, char * const [], const char *);
+extern char *optarg;
+extern int optind, opterr, optopt;
+
+long pathconf(const char *, int);
+long fpathconf(int, int);
+long sysconf(int);
+size_t confstr(int, char *, size_t);
+
+#if defined(_XOPEN_SOURCE) || defined(_GNU_SOURCE) || defined(_BSD_SOURCE)
+#define F_ULOCK 0
+#define F_LOCK  1
+#define F_TLOCK 2
+#define F_TEST  3
+int setreuid(uid_t, uid_t);
+int setregid(gid_t, gid_t);
+int lockf(int, int, off_t);
+long gethostid(void);
+int nice(int);
+void sync(void);
+pid_t setpgrp(void);
+char *crypt(const char *, const char *);
+void encrypt(char *, int);
+void swab(const void *__restrict, void *__restrict, ssize_t);
+#endif
+
+#if defined(_GNU_SOURCE) || defined(_BSD_SOURCE) \
+ || (defined(_XOPEN_SOURCE) && _XOPEN_SOURCE+0 < 700)
+int usleep(unsigned);
+unsigned ualarm(unsigned, unsigned);
+#endif
+
+#if defined(_GNU_SOURCE) || defined(_BSD_SOURCE)
+#define L_SET 0
+#define L_INCR 1
+#define L_XTND 2
+int brk(void *);
+void *sbrk(intptr_t);
+pid_t vfork(void);
+int vhangup(void);
+int chroot(const char *);
+int getpagesize(void);
+int getdtablesize(void);
+int sethostname(const char *, size_t);
+int getdomainname(char *, size_t);
+int setdomainname(const char *, size_t);
+int setgroups(size_t, const gid_t *);
+char *getpass(const char *);
+int daemon(int, int);
+void setusershell(void);
+void endusershell(void);
+char *getusershell(void);
+int acct(const char *);
+long syscall(long, ...);
+int execvpe(const char *, char *const [], char *const []);
+int issetugid(void);
+int getentropy(void *, size_t);
+extern int optreset;
+#endif
+
+#ifdef _GNU_SOURCE
+extern char **environ;
+int setresuid(uid_t, uid_t, uid_t);
+int setresgid(gid_t, gid_t, gid_t);
+int getresuid(uid_t *, uid_t *, uid_t *);
+int getresgid(gid_t *, gid_t *, gid_t *);
+char *get_current_dir_name(void);
+int syncfs(int);
+int euidaccess(const char *, int);
+int eaccess(const char *, int);
+ssize_t copy_file_range(int, off_t *, int, off_t *, size_t, unsigned);
+#endif
+
+#if defined(_LARGEFILE64_SOURCE) || defined(_GNU_SOURCE)
+#define lseek64 lseek
+#define pread64 pread
+#define pwrite64 pwrite
+#define truncate64 truncate
+#define ftruncate64 ftruncate
+#define lockf64 lockf
+#define off64_t off_t
+#endif
+
+#define POSIX_CLOSE_RESTART     0
+
+#define _XOPEN_VERSION          700
+#define _XOPEN_UNIX             1
+#define _XOPEN_ENH_I18N         1
+
+#define _POSIX_VERSION          200809L
+#define _POSIX2_VERSION         _POSIX_VERSION
+
+#define _POSIX_ADVISORY_INFO    _POSIX_VERSION
+#define _POSIX_CHOWN_RESTRICTED 1
+#define _POSIX_IPV6             _POSIX_VERSION
+#define _POSIX_JOB_CONTROL      1
+#define _POSIX_MAPPED_FILES     _POSIX_VERSION
+#define _POSIX_MEMLOCK          _POSIX_VERSION
+#define _POSIX_MEMLOCK_RANGE    _POSIX_VERSION
+#define _POSIX_MEMORY_PROTECTION _POSIX_VERSION
+#define _POSIX_MESSAGE_PASSING  _POSIX_VERSION
+#define _POSIX_FSYNC            _POSIX_VERSION
+#define _POSIX_NO_TRUNC         1
+#define _POSIX_RAW_SOCKETS      _POSIX_VERSION
+#define _POSIX_REALTIME_SIGNALS _POSIX_VERSION
+#define _POSIX_REGEXP           1
+#define _POSIX_SAVED_IDS        1
+#define _POSIX_SHELL            1
+#define _POSIX_SPAWN            _POSIX_VERSION
+#define _POSIX_VDISABLE         0
+
+#define _POSIX_THREADS          _POSIX_VERSION
+#define _POSIX_THREAD_PROCESS_SHARED _POSIX_VERSION
+#define _POSIX_THREAD_SAFE_FUNCTIONS _POSIX_VERSION
+#define _POSIX_THREAD_ATTR_STACKADDR _POSIX_VERSION
+#define _POSIX_THREAD_ATTR_STACKSIZE _POSIX_VERSION
+#define _POSIX_THREAD_PRIORITY_SCHEDULING _POSIX_VERSION
+#define _POSIX_THREAD_CPUTIME   _POSIX_VERSION
+#define _POSIX_TIMERS           _POSIX_VERSION
+#define _POSIX_TIMEOUTS         _POSIX_VERSION
+#define _POSIX_MONOTONIC_CLOCK  _POSIX_VERSION
+#define _POSIX_CPUTIME          _POSIX_VERSION
+#define _POSIX_CLOCK_SELECTION  _POSIX_VERSION
+#define _POSIX_BARRIERS         _POSIX_VERSION
+#define _POSIX_SPIN_LOCKS       _POSIX_VERSION
+#define _POSIX_READER_WRITER_LOCKS _POSIX_VERSION
+#define _POSIX_ASYNCHRONOUS_IO  _POSIX_VERSION
+#define _POSIX_SEMAPHORES       _POSIX_VERSION
+#define _POSIX_SHARED_MEMORY_OBJECTS _POSIX_VERSION
+
+#define _POSIX2_C_BIND          _POSIX_VERSION
+
+#include <bits/posix.h>
+
+
+
+#define _PC_LINK_MAX	0
+#define _PC_MAX_CANON	1
+#define _PC_MAX_INPUT	2
+#define _PC_NAME_MAX	3
+#define _PC_PATH_MAX	4
+#define _PC_PIPE_BUF	5
+#define _PC_CHOWN_RESTRICTED	6
+#define _PC_NO_TRUNC	7
+#define _PC_VDISABLE	8
+#define _PC_SYNC_IO	9
+#define _PC_ASYNC_IO	10
+#define _PC_PRIO_IO	11
+#define _PC_SOCK_MAXBUF	12
+#define _PC_FILESIZEBITS	13
+#define _PC_REC_INCR_XFER_SIZE	14
+#define _PC_REC_MAX_XFER_SIZE	15
+#define _PC_REC_MIN_XFER_SIZE	16
+#define _PC_REC_XFER_ALIGN	17
+#define _PC_ALLOC_SIZE_MIN	18
+#define _PC_SYMLINK_MAX	19
+#define _PC_2_SYMLINKS	20
+
+#define _SC_ARG_MAX	0
+#define _SC_CHILD_MAX	1
+#define _SC_CLK_TCK	2
+#define _SC_NGROUPS_MAX	3
+#define _SC_OPEN_MAX	4
+#define _SC_STREAM_MAX	5
+#define _SC_TZNAME_MAX	6
+#define _SC_JOB_CONTROL	7
+#define _SC_SAVED_IDS	8
+#define _SC_REALTIME_SIGNALS	9
+#define _SC_PRIORITY_SCHEDULING	10
+#define _SC_TIMERS	11
+#define _SC_ASYNCHRONOUS_IO	12
+#define _SC_PRIORITIZED_IO	13
+#define _SC_SYNCHRONIZED_IO	14
+#define _SC_FSYNC	15
+#define _SC_MAPPED_FILES	16
+#define _SC_MEMLOCK	17
+#define _SC_MEMLOCK_RANGE	18
+#define _SC_MEMORY_PROTECTION	19
+#define _SC_MESSAGE_PASSING	20
+#define _SC_SEMAPHORES	21
+#define _SC_SHARED_MEMORY_OBJECTS	22
+#define _SC_AIO_LISTIO_MAX	23
+#define _SC_AIO_MAX	24
+#define _SC_AIO_PRIO_DELTA_MAX	25
+#define _SC_DELAYTIMER_MAX	26
+#define _SC_MQ_OPEN_MAX	27
+#define _SC_MQ_PRIO_MAX	28
+#define _SC_VERSION	29
+#define _SC_PAGE_SIZE	30
+#define _SC_PAGESIZE	30 /* !! */
+#define _SC_RTSIG_MAX	31
+#define _SC_SEM_NSEMS_MAX	32
+#define _SC_SEM_VALUE_MAX	33
+#define _SC_SIGQUEUE_MAX	34
+#define _SC_TIMER_MAX	35
+#define _SC_BC_BASE_MAX	36
+#define _SC_BC_DIM_MAX	37
+#define _SC_BC_SCALE_MAX	38
+#define _SC_BC_STRING_MAX	39
+#define _SC_COLL_WEIGHTS_MAX	40
+#define _SC_EXPR_NEST_MAX	42
+#define _SC_LINE_MAX	43
+#define _SC_RE_DUP_MAX	44
+#define _SC_2_VERSION	46
+#define _SC_2_C_BIND	47
+#define _SC_2_C_DEV	48
+#define _SC_2_FORT_DEV	49
+#define _SC_2_FORT_RUN	50
+#define _SC_2_SW_DEV	51
+#define _SC_2_LOCALEDEF	52
+#define _SC_UIO_MAXIOV	60 /* !! */
+#define _SC_IOV_MAX	60
+#define _SC_THREADS	67
+#define _SC_THREAD_SAFE_FUNCTIONS	68
+#define _SC_GETGR_R_SIZE_MAX	69
+#define _SC_GETPW_R_SIZE_MAX	70
+#define _SC_LOGIN_NAME_MAX	71
+#define _SC_TTY_NAME_MAX	72
+#define _SC_THREAD_DESTRUCTOR_ITERATIONS	73
+#define _SC_THREAD_KEYS_MAX	74
+#define _SC_THREAD_STACK_MIN	75
+#define _SC_THREAD_THREADS_MAX	76
+#define _SC_THREAD_ATTR_STACKADDR	77
+#define _SC_THREAD_ATTR_STACKSIZE	78
+#define _SC_THREAD_PRIORITY_SCHEDULING	79
+#define _SC_THREAD_PRIO_INHERIT	80
+#define _SC_THREAD_PRIO_PROTECT	81
+#define _SC_THREAD_PROCESS_SHARED	82
+#define _SC_NPROCESSORS_CONF	83
+#define _SC_NPROCESSORS_ONLN	84
+#define _SC_PHYS_PAGES	85
+#define _SC_AVPHYS_PAGES	86
+#define _SC_ATEXIT_MAX	87
+#define _SC_PASS_MAX	88
+#define _SC_XOPEN_VERSION	89
+#define _SC_XOPEN_XCU_VERSION	90
+#define _SC_XOPEN_UNIX	91
+#define _SC_XOPEN_CRYPT	92
+#define _SC_XOPEN_ENH_I18N	93
+#define _SC_XOPEN_SHM	94
+#define _SC_2_CHAR_TERM	95
+#define _SC_2_UPE	97
+#define _SC_XOPEN_XPG2	98
+#define _SC_XOPEN_XPG3	99
+#define _SC_XOPEN_XPG4	100
+#define _SC_NZERO	109
+#define _SC_XBS5_ILP32_OFF32	125
+#define _SC_XBS5_ILP32_OFFBIG	126
+#define _SC_XBS5_LP64_OFF64	127
+#define _SC_XBS5_LPBIG_OFFBIG	128
+#define _SC_XOPEN_LEGACY	129
+#define _SC_XOPEN_REALTIME	130
+#define _SC_XOPEN_REALTIME_THREADS	131
+#define _SC_ADVISORY_INFO	132
+#define _SC_BARRIERS	133
+#define _SC_CLOCK_SELECTION	137
+#define _SC_CPUTIME	138
+#define _SC_THREAD_CPUTIME	139
+#define _SC_MONOTONIC_CLOCK	149
+#define _SC_READER_WRITER_LOCKS	153
+#define _SC_SPIN_LOCKS	154
+#define _SC_REGEXP	155
+#define _SC_SHELL	157
+#define _SC_SPAWN	159
+#define _SC_SPORADIC_SERVER	160
+#define _SC_THREAD_SPORADIC_SERVER	161
+#define _SC_TIMEOUTS	164
+#define _SC_TYPED_MEMORY_OBJECTS	165
+#define _SC_2_PBS	168
+#define _SC_2_PBS_ACCOUNTING	169
+#define _SC_2_PBS_LOCATE	170
+#define _SC_2_PBS_MESSAGE	171
+#define _SC_2_PBS_TRACK	172
+#define _SC_SYMLOOP_MAX	173
+#define _SC_STREAMS	174
+#define _SC_2_PBS_CHECKPOINT	175
+#define _SC_V6_ILP32_OFF32	176
+#define _SC_V6_ILP32_OFFBIG	177
+#define _SC_V6_LP64_OFF64	178
+#define _SC_V6_LPBIG_OFFBIG	179
+#define _SC_HOST_NAME_MAX	180
+#define _SC_TRACE	181
+#define _SC_TRACE_EVENT_FILTER	182
+#define _SC_TRACE_INHERIT	183
+#define _SC_TRACE_LOG	184
+
+#define _SC_IPV6	235
+#define _SC_RAW_SOCKETS	236
+#define _SC_V7_ILP32_OFF32	237
+#define _SC_V7_ILP32_OFFBIG	238
+#define _SC_V7_LP64_OFF64	239
+#define _SC_V7_LPBIG_OFFBIG	240
+#define _SC_SS_REPL_MAX	241
+#define _SC_TRACE_EVENT_NAME_MAX	242
+#define _SC_TRACE_NAME_MAX	243
+#define _SC_TRACE_SYS_MAX	244
+#define _SC_TRACE_USER_EVENT_MAX	245
+#define _SC_XOPEN_STREAMS	246
+#define _SC_THREAD_ROBUST_PRIO_INHERIT	247
+#define _SC_THREAD_ROBUST_PRIO_PROTECT	248
+
+#define _CS_PATH	0
+#define _CS_POSIX_V6_WIDTH_RESTRICTED_ENVS	1
+#define _CS_GNU_LIBC_VERSION	2
+#define _CS_GNU_LIBPTHREAD_VERSION	3
+#define _CS_POSIX_V5_WIDTH_RESTRICTED_ENVS	4
+#define _CS_POSIX_V7_WIDTH_RESTRICTED_ENVS	5
+
+#define _CS_POSIX_V6_ILP32_OFF32_CFLAGS	1116
+#define _CS_POSIX_V6_ILP32_OFF32_LDFLAGS	1117
+#define _CS_POSIX_V6_ILP32_OFF32_LIBS	1118
+#define _CS_POSIX_V6_ILP32_OFF32_LINTFLAGS	1119
+#define _CS_POSIX_V6_ILP32_OFFBIG_CFLAGS	1120
+#define _CS_POSIX_V6_ILP32_OFFBIG_LDFLAGS	1121
+#define _CS_POSIX_V6_ILP32_OFFBIG_LIBS	1122
+#define _CS_POSIX_V6_ILP32_OFFBIG_LINTFLAGS	1123
+#define _CS_POSIX_V6_LP64_OFF64_CFLAGS	1124
+#define _CS_POSIX_V6_LP64_OFF64_LDFLAGS	1125
+#define _CS_POSIX_V6_LP64_OFF64_LIBS	1126
+#define _CS_POSIX_V6_LP64_OFF64_LINTFLAGS	1127
+#define _CS_POSIX_V6_LPBIG_OFFBIG_CFLAGS	1128
+#define _CS_POSIX_V6_LPBIG_OFFBIG_LDFLAGS	1129
+#define _CS_POSIX_V6_LPBIG_OFFBIG_LIBS	1130
+#define _CS_POSIX_V6_LPBIG_OFFBIG_LINTFLAGS	1131
+#define _CS_POSIX_V7_ILP32_OFF32_CFLAGS	1132
+#define _CS_POSIX_V7_ILP32_OFF32_LDFLAGS	1133
+#define _CS_POSIX_V7_ILP32_OFF32_LIBS	1134
+#define _CS_POSIX_V7_ILP32_OFF32_LINTFLAGS	1135
+#define _CS_POSIX_V7_ILP32_OFFBIG_CFLAGS	1136
+#define _CS_POSIX_V7_ILP32_OFFBIG_LDFLAGS	1137
+#define _CS_POSIX_V7_ILP32_OFFBIG_LIBS	1138
+#define _CS_POSIX_V7_ILP32_OFFBIG_LINTFLAGS	1139
+#define _CS_POSIX_V7_LP64_OFF64_CFLAGS	1140
+#define _CS_POSIX_V7_LP64_OFF64_LDFLAGS	1141
+#define _CS_POSIX_V7_LP64_OFF64_LIBS	1142
+#define _CS_POSIX_V7_LP64_OFF64_LINTFLAGS	1143
+#define _CS_POSIX_V7_LPBIG_OFFBIG_CFLAGS	1144
+#define _CS_POSIX_V7_LPBIG_OFFBIG_LDFLAGS	1145
+#define _CS_POSIX_V7_LPBIG_OFFBIG_LIBS	1146
+#define _CS_POSIX_V7_LPBIG_OFFBIG_LINTFLAGS	1147
+#define _CS_V6_ENV	1148
+#define _CS_V7_ENV	1149
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
diff --git a/third_party/musl/porting/liteos_a/user/ldso/dynlink.c b/third_party/musl/porting/liteos_a/user/ldso/dynlink.c
new file mode 100755
index 000000000..40e05220a
--- /dev/null
+++ b/third_party/musl/porting/liteos_a/user/ldso/dynlink.c
@@ -0,0 +1,2345 @@
+#define _GNU_SOURCE
+#define SYSCALL_NO_TLS 1
+#include <stdio.h>
+#include <stdlib.h>
+#include <stdarg.h>
+#include <stddef.h>
+#include <string.h>
+#include <unistd.h>
+#include <stdint.h>
+#include <elf.h>
+#include <sys/mman.h>
+#include <limits.h>
+#include <fcntl.h>
+#include <sys/stat.h>
+#include <errno.h>
+#include <link.h>
+#include <setjmp.h>
+#include <pthread.h>
+#include <ctype.h>
+#include <dlfcn.h>
+#include <semaphore.h>
+#include <sys/membarrier.h>
+#include "pthread_impl.h"
+#include "libc.h"
+#include "dynlink.h"
+#include "malloc_impl.h"
+
+static void error(const char *, ...);
+
+#define MAXP2(a,b) (-(-(a)&-(b)))
+#define ALIGN(x,y) ((x)+(y)-1 & -(y))
+
+#define container_of(p,t,m) ((t*)((char *)(p)-offsetof(t,m)))
+#define countof(a) ((sizeof (a))/(sizeof (a)[0]))
+
+struct debug {
+	int ver;
+	void *head;
+	void (*bp)(void);
+	int state;
+	void *base;
+};
+
+struct td_index {
+	size_t args[2];
+	struct td_index *next;
+};
+
+struct dso {
+#if DL_FDPIC
+	struct fdpic_loadmap *loadmap;
+#else
+	unsigned char *base;
+#endif
+	char *name;
+	size_t *dynv;
+	struct dso *next, *prev;
+
+	Phdr *phdr;
+	int phnum;
+	size_t phentsize;
+	Sym *syms;
+	Elf_Symndx *hashtab;
+	uint32_t *ghashtab;
+	int16_t *versym;
+	char *strings;
+	struct dso *syms_next, *lazy_next;
+	size_t *lazy, lazy_cnt;
+	unsigned char *map;
+	size_t map_len;
+	char relocated;
+	char constructed;
+	char kernel_mapped;
+	char mark;
+	char bfs_built;
+	char runtime_loaded;
+	struct dso **deps, *needed_by;
+	size_t ndeps_direct;
+	size_t next_dep;
+	int ctor_visitor;
+	char *rpath_orig, *rpath;
+	struct tls_module tls;
+	size_t tls_id;
+	size_t relro_start, relro_end;
+	uintptr_t *new_dtv;
+	unsigned char *new_tls;
+	struct td_index *td_index;
+	struct dso *fini_next;
+	char *shortname;
+#if DL_FDPIC
+	unsigned char *base;
+#else
+	struct fdpic_loadmap *loadmap;
+#endif
+	struct funcdesc {
+		void *addr;
+		size_t *got;
+	} *funcdescs;
+	size_t *got;
+	char buf[];
+};
+
+struct symdef {
+	Sym *sym;
+	struct dso *dso;
+};
+
+typedef void (*stage3_func)(size_t *, size_t *);
+
+static struct builtin_tls {
+	char c;
+	struct pthread pt;
+	void *space[16];
+} builtin_tls[1];
+#define MIN_TLS_ALIGN offsetof(struct builtin_tls, pt)
+
+#define ADDEND_LIMIT 4096
+static size_t *saved_addends, *apply_addends_to;
+
+static struct dso ldso;
+static struct dso *head, *tail, *fini_head, *syms_tail, *lazy_head;
+static char *env_path, *sys_path;
+static unsigned long long gencnt;
+static int runtime;
+static int ldd_mode;
+static int ldso_fail;
+static int noload;
+static int shutting_down;
+static jmp_buf *rtld_fail;
+static pthread_rwlock_t lock;
+static struct debug debug;
+static struct tls_module *tls_tail;
+static size_t tls_cnt, tls_offset, tls_align = MIN_TLS_ALIGN;
+static size_t static_tls_cnt;
+static pthread_mutex_t init_fini_lock;
+static pthread_cond_t ctor_cond;
+static struct dso *builtin_deps[2];
+static struct dso *const no_deps[1];
+static struct dso *builtin_ctor_queue[4];
+static struct dso **main_ctor_queue;
+static struct fdpic_loadmap *app_loadmap;
+static struct fdpic_dummy_loadmap app_dummy_loadmap;
+
+struct debug *_dl_debug_addr = &debug;
+
+extern hidden int __malloc_replaced;
+
+hidden void (*const __init_array_start)(void)=0, (*const __fini_array_start)(void)=0;
+
+extern hidden void (*const __init_array_end)(void), (*const __fini_array_end)(void);
+
+weak_alias(__init_array_start, __init_array_end);
+weak_alias(__fini_array_start, __fini_array_end);
+
+static int dl_strcmp(const char *l, const char *r)
+{
+	for (; *l==*r && *l; l++, r++);
+	return *(unsigned char *)l - *(unsigned char *)r;
+}
+#define strcmp(l,r) dl_strcmp(l,r)
+
+/* Compute load address for a virtual address in a given dso. */
+#if DL_FDPIC
+static void *laddr(const struct dso *p, size_t v)
+{
+	size_t j=0;
+	if (!p->loadmap) return p->base + v;
+	for (j=0; v-p->loadmap->segs[j].p_vaddr >= p->loadmap->segs[j].p_memsz; j++);
+	return (void *)(v - p->loadmap->segs[j].p_vaddr + p->loadmap->segs[j].addr);
+}
+static void *laddr_pg(const struct dso *p, size_t v)
+{
+	size_t j=0;
+	size_t pgsz = PAGE_SIZE;
+	if (!p->loadmap) return p->base + v;
+	for (j=0; ; j++) {
+		size_t a = p->loadmap->segs[j].p_vaddr;
+		size_t b = a + p->loadmap->segs[j].p_memsz;
+		a &= -pgsz;
+		b += pgsz-1;
+		b &= -pgsz;
+		if (v-a<b-a) break;
+	}
+	return (void *)(v - p->loadmap->segs[j].p_vaddr + p->loadmap->segs[j].addr);
+}
+static void (*fdbarrier(void *p))()
+{
+	void (*fd)();
+	__asm__("" : "=r"(fd) : "0"(p));
+	return fd;
+}
+#define fpaddr(p, v) fdbarrier((&(struct funcdesc){ \
+	laddr(p, v), (p)->got }))
+#else
+#define laddr(p, v) (void *)((p)->base + (v))
+#define laddr_pg(p, v) laddr(p, v)
+#define fpaddr(p, v) ((void (*)())laddr(p, v))
+#endif
+
+static void decode_vec(size_t *v, size_t *a, size_t cnt)
+{
+	size_t i;
+	for (i=0; i<cnt; i++) a[i] = 0;
+	for (; v[0]; v+=2) if (v[0]-1<cnt-1) {
+		a[0] |= 1UL<<v[0];
+		a[v[0]] = v[1];
+	}
+}
+
+static int search_vec(size_t *v, size_t *r, size_t key)
+{
+	for (; v[0]!=key; v+=2)
+		if (!v[0]) return 0;
+	*r = v[1];
+	return 1;
+}
+
+static uint32_t sysv_hash(const char *s0)
+{
+	const unsigned char *s = (void *)s0;
+	uint_fast32_t h = 0;
+	while (*s) {
+		h = 16*h + *s++;
+		h ^= h>>24 & 0xf0;
+	}
+	return h & 0xfffffff;
+}
+
+static uint32_t gnu_hash(const char *s0)
+{
+	const unsigned char *s = (void *)s0;
+	uint_fast32_t h = 5381;
+	for (; *s; s++)
+		h += h*32 + *s;
+	return h;
+}
+
+static Sym *sysv_lookup(const char *s, uint32_t h, struct dso *dso)
+{
+	size_t i;
+	Sym *syms = dso->syms;
+	Elf_Symndx *hashtab = dso->hashtab;
+	char *strings = dso->strings;
+	for (i=hashtab[2+h%hashtab[0]]; i; i=hashtab[2+hashtab[0]+i]) {
+		if ((!dso->versym || dso->versym[i] >= 0)
+		    && (!strcmp(s, strings+syms[i].st_name)))
+			return syms+i;
+	}
+	return 0;
+}
+
+static Sym *gnu_lookup(uint32_t h1, uint32_t *hashtab, struct dso *dso, const char *s)
+{
+	uint32_t nbuckets = hashtab[0];
+	uint32_t *buckets = hashtab + 4 + hashtab[2]*(sizeof(size_t)/4);
+	uint32_t i = buckets[h1 % nbuckets];
+
+	if (!i) return 0;
+
+	uint32_t *hashval = buckets + nbuckets + (i - hashtab[1]);
+
+	for (h1 |= 1; ; i++) {
+		uint32_t h2 = *hashval++;
+		if ((h1 == (h2|1)) && (!dso->versym || dso->versym[i] >= 0)
+		    && !strcmp(s, dso->strings + dso->syms[i].st_name))
+			return dso->syms+i;
+		if (h2 & 1) break;
+	}
+
+	return 0;
+}
+
+static Sym *gnu_lookup_filtered(uint32_t h1, uint32_t *hashtab, struct dso *dso, const char *s, uint32_t fofs, size_t fmask)
+{
+	const size_t *bloomwords = (const void *)(hashtab+4);
+	size_t f = bloomwords[fofs & (hashtab[2]-1)];
+	if (!(f & fmask)) return 0;
+
+	f >>= (h1 >> hashtab[3]) % (8 * sizeof f);
+	if (!(f & 1)) return 0;
+
+	return gnu_lookup(h1, hashtab, dso, s);
+}
+
+#define OK_TYPES (1<<STT_NOTYPE | 1<<STT_OBJECT | 1<<STT_FUNC | 1<<STT_COMMON | 1<<STT_TLS)
+#define OK_BINDS (1<<STB_GLOBAL | 1<<STB_WEAK | 1<<STB_GNU_UNIQUE)
+
+#ifndef ARCH_SYM_REJECT_UND
+#define ARCH_SYM_REJECT_UND(s) 0
+#endif
+
+#if defined(__GNUC__)
+__attribute__((always_inline))
+#endif
+static inline struct symdef find_sym2(struct dso *dso, const char *s, int need_def, int use_deps)
+{
+	uint32_t h = 0, gh = gnu_hash(s), gho = gh / (8*sizeof(size_t)), *ght;
+	size_t ghm = 1ul << gh % (8*sizeof(size_t));
+	struct symdef def = {0};
+	struct dso **deps = use_deps ? dso->deps : 0;
+	for (; dso; dso=use_deps ? *deps++ : dso->syms_next) {
+		Sym *sym;
+		if ((ght = dso->ghashtab)) {
+			sym = gnu_lookup_filtered(gh, ght, dso, s, gho, ghm);
+		} else {
+			if (!h) h = sysv_hash(s);
+			sym = sysv_lookup(s, h, dso);
+		}
+		if (!sym) continue;
+		if (!sym->st_shndx)
+			if (need_def || (sym->st_info&0xf) == STT_TLS
+			    || ARCH_SYM_REJECT_UND(sym))
+				continue;
+		if (!sym->st_value)
+			if ((sym->st_info&0xf) != STT_TLS)
+				continue;
+		if (!(1<<(sym->st_info&0xf) & OK_TYPES)) continue;
+		if (!(1<<(sym->st_info>>4) & OK_BINDS)) continue;
+		def.sym = sym;
+		def.dso = dso;
+		break;
+	}
+	return def;
+}
+
+static struct symdef find_sym(struct dso *dso, const char *s, int need_def)
+{
+	return find_sym2(dso, s, need_def, 0);
+}
+
+static void do_relocs(struct dso *dso, size_t *rel, size_t rel_size, size_t stride)
+{
+	unsigned char *base = dso->base;
+	Sym *syms = dso->syms;
+	char *strings = dso->strings;
+	Sym *sym;
+	const char *name;
+	void *ctx;
+	int type;
+	int sym_index;
+	struct symdef def;
+	size_t *reloc_addr;
+	size_t sym_val;
+	size_t tls_val;
+	size_t addend;
+	int skip_relative = 0, reuse_addends = 0, save_slot = 0;
+
+	if (dso == &ldso) {
+		/* Only ldso's REL table needs addend saving/reuse. */
+		if (rel == apply_addends_to)
+			reuse_addends = 1;
+		skip_relative = 1;
+	}
+
+	for (; rel_size; rel+=stride, rel_size-=stride*sizeof(size_t)) {
+		if (skip_relative && IS_RELATIVE(rel[1], dso->syms)) continue;
+		type = R_TYPE(rel[1]);
+		if (type == REL_NONE) continue;
+		reloc_addr = laddr(dso, rel[0]);
+
+		if (stride > 2) {
+			addend = rel[2];
+		} else if (type==REL_GOT || type==REL_PLT|| type==REL_COPY) {
+			addend = 0;
+		} else if (reuse_addends) {
+			/* Save original addend in stage 2 where the dso
+			 * chain consists of just ldso; otherwise read back
+			 * saved addend since the inline one was clobbered. */
+			if (head==&ldso)
+				saved_addends[save_slot] = *reloc_addr;
+			addend = saved_addends[save_slot++];
+		} else {
+			addend = *reloc_addr;
+		}
+
+		sym_index = R_SYM(rel[1]);
+		if (sym_index) {
+			sym = syms + sym_index;
+			name = strings + sym->st_name;
+			ctx = type==REL_COPY ? head->syms_next : head;
+			def = (sym->st_info>>4) == STB_LOCAL
+				? (struct symdef){ .dso = dso, .sym = sym }
+				: find_sym(ctx, name, type==REL_PLT);
+			if (!def.sym && (sym->st_shndx != SHN_UNDEF
+			    || sym->st_info>>4 != STB_WEAK)) {
+				if (dso->lazy && (type==REL_PLT || type==REL_GOT)) {
+					dso->lazy[3*dso->lazy_cnt+0] = rel[0];
+					dso->lazy[3*dso->lazy_cnt+1] = rel[1];
+					dso->lazy[3*dso->lazy_cnt+2] = addend;
+					dso->lazy_cnt++;
+					continue;
+				}
+				error("Error relocating %s: %s: symbol not found",
+					dso->name, name);
+				if (runtime) longjmp(*rtld_fail, 1);
+				continue;
+			}
+		} else {
+			sym = 0;
+			def.sym = 0;
+			def.dso = dso;
+		}
+
+		sym_val = def.sym ? (size_t)laddr(def.dso, def.sym->st_value) : 0;
+		tls_val = def.sym ? def.sym->st_value : 0;
+
+		if ((type == REL_TPOFF || type == REL_TPOFF_NEG)
+		    && def.dso->tls_id > static_tls_cnt) {
+			error("Error relocating %s: %s: initial-exec TLS "
+				"resolves to dynamic definition in %s",
+				dso->name, name, def.dso->name);
+			longjmp(*rtld_fail, 1);
+		}
+
+		switch(type) {
+		case REL_NONE:
+			break;
+		case REL_OFFSET:
+			addend -= (size_t)reloc_addr;
+		case REL_SYMBOLIC:
+		case REL_GOT:
+		case REL_PLT:
+			*reloc_addr = sym_val + addend;
+			break;
+		case REL_USYMBOLIC:
+			memcpy(reloc_addr, &(size_t){sym_val + addend}, sizeof(size_t));
+			break;
+		case REL_RELATIVE:
+			*reloc_addr = (size_t)base + addend;
+			break;
+		case REL_SYM_OR_REL:
+			if (sym) *reloc_addr = sym_val + addend;
+			else *reloc_addr = (size_t)base + addend;
+			break;
+		case REL_COPY:
+			memcpy(reloc_addr, (void *)sym_val, sym->st_size);
+			break;
+		case REL_OFFSET32:
+			*(uint32_t *)reloc_addr = sym_val + addend
+				- (size_t)reloc_addr;
+			break;
+		case REL_FUNCDESC:
+			*reloc_addr = def.sym ? (size_t)(def.dso->funcdescs
+				+ (def.sym - def.dso->syms)) : 0;
+			break;
+		case REL_FUNCDESC_VAL:
+			if ((sym->st_info&0xf) == STT_SECTION) *reloc_addr += sym_val;
+			else *reloc_addr = sym_val;
+			reloc_addr[1] = def.sym ? (size_t)def.dso->got : 0;
+			break;
+		case REL_DTPMOD:
+			*reloc_addr = def.dso->tls_id;
+			break;
+		case REL_DTPOFF:
+			*reloc_addr = tls_val + addend - DTP_OFFSET;
+			break;
+#ifdef TLS_ABOVE_TP
+		case REL_TPOFF:
+			*reloc_addr = tls_val + def.dso->tls.offset + TPOFF_K + addend;
+			break;
+#else
+		case REL_TPOFF:
+			*reloc_addr = tls_val - def.dso->tls.offset + addend;
+			break;
+		case REL_TPOFF_NEG:
+			*reloc_addr = def.dso->tls.offset - tls_val + addend;
+			break;
+#endif
+		case REL_TLSDESC:
+			if (stride<3) addend = reloc_addr[1];
+			if (def.dso->tls_id > static_tls_cnt) {
+				struct td_index *new = malloc(sizeof *new);
+				if (!new) {
+					error(
+					"Error relocating %s: cannot allocate TLSDESC for %s",
+					dso->name, sym ? name : "(local)" );
+					longjmp(*rtld_fail, 1);
+				}
+				new->next = dso->td_index;
+				dso->td_index = new;
+				new->args[0] = def.dso->tls_id;
+				new->args[1] = tls_val + addend - DTP_OFFSET;
+				reloc_addr[0] = (size_t)__tlsdesc_dynamic;
+				reloc_addr[1] = (size_t)new;
+			} else {
+				reloc_addr[0] = (size_t)__tlsdesc_static;
+#ifdef TLS_ABOVE_TP
+				reloc_addr[1] = tls_val + def.dso->tls.offset
+					+ TPOFF_K + addend;
+#else
+				reloc_addr[1] = tls_val - def.dso->tls.offset
+					+ addend;
+#endif
+			}
+#ifdef TLSDESC_BACKWARDS
+			/* Some archs (32-bit ARM at least) invert the order of
+			 * the descriptor members. Fix them up here. */
+			size_t tmp = reloc_addr[0];
+			reloc_addr[0] = reloc_addr[1];
+			reloc_addr[1] = tmp;
+#endif
+			break;
+		default:
+			error("Error relocating %s: unsupported relocation type %d",
+				dso->name, type);
+			if (runtime) longjmp(*rtld_fail, 1);
+			continue;
+		}
+	}
+}
+
+static void redo_lazy_relocs()
+{
+	struct dso *p = lazy_head, *next;
+	lazy_head = 0;
+	for (; p; p=next) {
+		next = p->lazy_next;
+		size_t size = p->lazy_cnt*3*sizeof(size_t);
+		p->lazy_cnt = 0;
+		do_relocs(p, p->lazy, size, 3);
+		if (p->lazy_cnt) {
+			p->lazy_next = lazy_head;
+			lazy_head = p;
+		} else {
+			free(p->lazy);
+			p->lazy = 0;
+			p->lazy_next = 0;
+		}
+	}
+}
+
+/* A huge hack: to make up for the wastefulness of shared libraries
+ * needing at least a page of dirty memory even if they have no global
+ * data, we reclaim the gaps at the beginning and end of writable maps
+ * and "donate" them to the heap. */
+
+static void reclaim(struct dso *dso, size_t start, size_t end)
+{
+	if (start >= dso->relro_start && start < dso->relro_end) start = dso->relro_end;
+	if (end   >= dso->relro_start && end   < dso->relro_end) end = dso->relro_start;
+	if (start >= end) return;
+	char *base = laddr_pg(dso, start);
+	__malloc_donate(base, base+(end-start));
+}
+
+static void reclaim_gaps(struct dso *dso)
+{
+	Phdr *ph = dso->phdr;
+	size_t phcnt = dso->phnum;
+
+	for (; phcnt--; ph=(void *)((char *)ph+dso->phentsize)) {
+		if (ph->p_type!=PT_LOAD) continue;
+		if ((ph->p_flags&(PF_R|PF_W))!=(PF_R|PF_W)) continue;
+		reclaim(dso, ph->p_vaddr & -PAGE_SIZE, ph->p_vaddr);
+		reclaim(dso, ph->p_vaddr+ph->p_memsz,
+			ph->p_vaddr+ph->p_memsz+PAGE_SIZE-1 & -PAGE_SIZE);
+	}
+}
+
+static void *mmap_fixed(void *p, size_t n, int prot, int flags, int fd, off_t off)
+{
+	static int no_map_fixed;
+	char *q;
+	if (!no_map_fixed) {
+		q = mmap(p, n, prot, flags|MAP_FIXED, fd, off);
+		if (!DL_NOMMU_SUPPORT || q != MAP_FAILED || errno != EINVAL)
+			return q;
+		no_map_fixed = 1;
+	}
+	/* Fallbacks for MAP_FIXED failure on NOMMU kernels. */
+	if (flags & MAP_ANONYMOUS) {
+		memset(p, 0, n);
+		return p;
+	}
+	ssize_t r;
+	if (lseek(fd, off, SEEK_SET) < 0) return MAP_FAILED;
+	for (q=p; n; q+=r, off+=r, n-=r) {
+		r = read(fd, q, n);
+		if (r < 0 && errno != EINTR) return MAP_FAILED;
+		if (!r) {
+			memset(q, 0, n);
+			break;
+		}
+	}
+	return p;
+}
+
+static void unmap_library(struct dso *dso)
+{
+	if (dso->loadmap) {
+		size_t i;
+		for (i=0; i<dso->loadmap->nsegs; i++) {
+			if (!dso->loadmap->segs[i].p_memsz)
+				continue;
+			munmap((void *)dso->loadmap->segs[i].addr,
+				dso->loadmap->segs[i].p_memsz);
+		}
+		free(dso->loadmap);
+	} else if (dso->map && dso->map_len) {
+		munmap(dso->map, dso->map_len);
+	}
+}
+
+static void *map_library(int fd, struct dso *dso)
+{
+	Ehdr buf[(896+sizeof(Ehdr))/sizeof(Ehdr)];
+	void *allocated_buf=0;
+	size_t phsize;
+	size_t addr_min=SIZE_MAX, addr_max=0, map_len;
+	size_t this_min, this_max;
+	size_t nsegs = 0;
+	off_t off_start;
+	Ehdr *eh;
+	Phdr *ph, *ph0;
+	unsigned prot;
+	unsigned char *map=MAP_FAILED, *base;
+	size_t dyn=0;
+	size_t tls_image=0;
+	size_t i;
+
+	ssize_t l = read(fd, buf, sizeof buf);
+	eh = buf;
+	if (l<0) return 0;
+	if (l<sizeof *eh || (eh->e_type != ET_DYN && eh->e_type != ET_EXEC))
+		goto noexec;
+	phsize = eh->e_phentsize * eh->e_phnum;
+	if (phsize > sizeof buf - sizeof *eh) {
+		allocated_buf = malloc(phsize);
+		if (!allocated_buf) return 0;
+		l = pread(fd, allocated_buf, phsize, eh->e_phoff);
+		if (l < 0) goto error;
+		if (l != phsize) goto noexec;
+		ph = ph0 = allocated_buf;
+	} else if (eh->e_phoff + phsize > l) {
+		l = pread(fd, buf+1, phsize, eh->e_phoff);
+		if (l < 0) goto error;
+		if (l != phsize) goto noexec;
+		ph = ph0 = (void *)(buf + 1);
+	} else {
+		ph = ph0 = (void *)((char *)buf + eh->e_phoff);
+	}
+	for (i=eh->e_phnum; i; i--, ph=(void *)((char *)ph+eh->e_phentsize)) {
+		if (ph->p_type == PT_DYNAMIC) {
+			dyn = ph->p_vaddr;
+		} else if (ph->p_type == PT_TLS) {
+			tls_image = ph->p_vaddr;
+			dso->tls.align = ph->p_align;
+			dso->tls.len = ph->p_filesz;
+			dso->tls.size = ph->p_memsz;
+		} else if (ph->p_type == PT_GNU_RELRO) {
+			dso->relro_start = ph->p_vaddr & -PAGE_SIZE;
+			dso->relro_end = (ph->p_vaddr + ph->p_memsz) & -PAGE_SIZE;
+		} else if (ph->p_type == PT_GNU_STACK) {
+			if (!runtime && ph->p_memsz > __default_stacksize) {
+				__default_stacksize =
+					ph->p_memsz < DEFAULT_STACK_MAX ?
+					ph->p_memsz : DEFAULT_STACK_MAX;
+			}
+		}
+		if (ph->p_type != PT_LOAD) continue;
+		nsegs++;
+		if (ph->p_vaddr < addr_min) {
+			addr_min = ph->p_vaddr;
+			off_start = ph->p_offset;
+			prot = (((ph->p_flags&PF_R) ? PROT_READ : 0) |
+				((ph->p_flags&PF_W) ? PROT_WRITE: 0) |
+				((ph->p_flags&PF_X) ? PROT_EXEC : 0));
+		}
+		if (ph->p_vaddr+ph->p_memsz > addr_max) {
+			addr_max = ph->p_vaddr+ph->p_memsz;
+		}
+	}
+	if (!dyn) goto noexec;
+	if (DL_FDPIC && !(eh->e_flags & FDPIC_CONSTDISP_FLAG)) {
+		dso->loadmap = calloc(1, sizeof *dso->loadmap
+			+ nsegs * sizeof *dso->loadmap->segs);
+		if (!dso->loadmap) goto error;
+		dso->loadmap->nsegs = nsegs;
+		for (ph=ph0, i=0; i<nsegs; ph=(void *)((char *)ph+eh->e_phentsize)) {
+			if (ph->p_type != PT_LOAD) continue;
+			prot = (((ph->p_flags&PF_R) ? PROT_READ : 0) |
+				((ph->p_flags&PF_W) ? PROT_WRITE: 0) |
+				((ph->p_flags&PF_X) ? PROT_EXEC : 0));
+			map = mmap(0, ph->p_memsz + (ph->p_vaddr & PAGE_SIZE-1),
+				prot, MAP_PRIVATE,
+				fd, ph->p_offset & -PAGE_SIZE);
+			if (map == MAP_FAILED) {
+				unmap_library(dso);
+				goto error;
+			}
+			dso->loadmap->segs[i].addr = (size_t)map +
+				(ph->p_vaddr & PAGE_SIZE-1);
+			dso->loadmap->segs[i].p_vaddr = ph->p_vaddr;
+			dso->loadmap->segs[i].p_memsz = ph->p_memsz;
+			i++;
+			if (prot & PROT_WRITE) {
+				size_t brk = (ph->p_vaddr & PAGE_SIZE-1)
+					+ ph->p_filesz;
+				size_t pgbrk = brk + PAGE_SIZE-1 & -PAGE_SIZE;
+				size_t pgend = brk + ph->p_memsz - ph->p_filesz
+					+ PAGE_SIZE-1 & -PAGE_SIZE;
+				if (pgend > pgbrk && mmap_fixed(map+pgbrk,
+					pgend-pgbrk, prot,
+					MAP_PRIVATE|MAP_FIXED|MAP_ANONYMOUS,
+					-1, off_start) == MAP_FAILED)
+					goto error;
+				memset(map + brk, 0, pgbrk-brk);
+			}
+		}
+		map = (void *)dso->loadmap->segs[0].addr;
+		map_len = 0;
+		goto done_mapping;
+	}
+	addr_max += PAGE_SIZE-1;
+	addr_max &= -PAGE_SIZE;
+	addr_min &= -PAGE_SIZE;
+	off_start &= -PAGE_SIZE;
+	map_len = addr_max - addr_min + off_start;
+	/* The first time, we map too much, possibly even more than
+	 * the length of the file. This is okay because we will not
+	 * use the invalid part; we just need to reserve the right
+	 * amount of virtual address space to map over later. */
+	map = DL_NOMMU_SUPPORT
+		? mmap((void *)addr_min, map_len, PROT_READ|PROT_WRITE|PROT_EXEC,
+			MAP_PRIVATE|MAP_ANONYMOUS, -1, 0)
+		: mmap((void *)addr_min, map_len, prot,
+			MAP_PRIVATE, fd, off_start);
+	if (map==MAP_FAILED) goto error;
+	dso->map = map;
+	dso->map_len = map_len;
+	/* If the loaded file is not relocatable and the requested address is
+	 * not available, then the load operation must fail. */
+	if (eh->e_type != ET_DYN && addr_min && map!=(void *)addr_min) {
+		errno = EBUSY;
+		goto error;
+	}
+	base = map - addr_min;
+	dso->phdr = 0;
+	dso->phnum = 0;
+	for (ph=ph0, i=eh->e_phnum; i; i--, ph=(void *)((char *)ph+eh->e_phentsize)) {
+		if (ph->p_type != PT_LOAD) continue;
+		/* Check if the programs headers are in this load segment, and
+		 * if so, record the address for use by dl_iterate_phdr. */
+		if (!dso->phdr && eh->e_phoff >= ph->p_offset
+		    && eh->e_phoff+phsize <= ph->p_offset+ph->p_filesz) {
+			dso->phdr = (void *)(base + ph->p_vaddr
+				+ (eh->e_phoff-ph->p_offset));
+			dso->phnum = eh->e_phnum;
+			dso->phentsize = eh->e_phentsize;
+		}
+		this_min = ph->p_vaddr & -PAGE_SIZE;
+		this_max = ph->p_vaddr+ph->p_memsz+PAGE_SIZE-1 & -PAGE_SIZE;
+		off_start = ph->p_offset & -PAGE_SIZE;
+		prot = (((ph->p_flags&PF_R) ? PROT_READ : 0) |
+			((ph->p_flags&PF_W) ? PROT_WRITE: 0) |
+			((ph->p_flags&PF_X) ? PROT_EXEC : 0));
+		if ((ph->p_flags & PF_R) && (ph->p_flags & PF_X) && (!(ph->p_flags & PF_W))) {
+			Phdr *next_ph = ph;
+			for (int j = i - 1; j > 0; j--) {
+				next_ph = (void *)((char *)next_ph+eh->e_phentsize);
+				if (next_ph->p_type != PT_LOAD) {
+					continue;
+				}
+				size_t p_vaddr = (next_ph->p_vaddr & -(PAGE_SIZE));
+				if (p_vaddr > this_max) {
+					mprotect(base + this_max, p_vaddr - this_max , PROT_READ);
+				}
+				break;
+			}
+		}
+		/* Reuse the existing mapping for the lowest-address LOAD */
+		if ((ph->p_vaddr & -PAGE_SIZE) != addr_min || DL_NOMMU_SUPPORT)
+			if (mmap_fixed(base+this_min, this_max-this_min, prot, MAP_PRIVATE|MAP_FIXED, fd, off_start) == MAP_FAILED)
+				goto error;
+		if (ph->p_memsz > ph->p_filesz && (ph->p_flags&PF_W)) {
+			size_t brk = (size_t)base+ph->p_vaddr+ph->p_filesz;
+			size_t pgbrk = brk+PAGE_SIZE-1 & -PAGE_SIZE;
+			memset((void *)brk, 0, pgbrk-brk & PAGE_SIZE-1);
+			if (pgbrk-(size_t)base < this_max && mmap_fixed((void *)pgbrk, (size_t)base+this_max-pgbrk, prot, MAP_PRIVATE|MAP_FIXED|MAP_ANONYMOUS, -1, 0) == MAP_FAILED)
+				goto error;
+		}
+	}
+	for (i=0; ((size_t *)(base+dyn))[i]; i+=2)
+		if (((size_t *)(base+dyn))[i]==DT_TEXTREL) {
+			if (mprotect(map, map_len, PROT_READ|PROT_WRITE|PROT_EXEC)
+			    && errno != ENOSYS)
+				goto error;
+			break;
+		}
+done_mapping:
+	dso->base = base;
+	dso->dynv = laddr(dso, dyn);
+	if (dso->tls.size) dso->tls.image = laddr(dso, tls_image);
+	free(allocated_buf);
+	return map;
+noexec:
+	errno = ENOEXEC;
+error:
+	if (map!=MAP_FAILED) unmap_library(dso);
+	free(allocated_buf);
+	return 0;
+}
+
+static int path_open(const char *name, const char *s, char *buf, size_t buf_size)
+{
+	size_t l;
+	int fd;
+	for (;;) {
+		s += strspn(s, ":\n");
+		l = strcspn(s, ":\n");
+		if (l-1 >= INT_MAX) return -1;
+		if (snprintf(buf, buf_size, "%.*s/%s", (int)l, s, name) < buf_size) {
+			if ((fd = open(buf, O_RDONLY))>=0) return fd; // open(buf, O_RDONLY|O_CLOEXEC)
+			switch (errno) {
+			case ENOENT:
+			case ENOTDIR:
+			case EACCES:
+			case ENAMETOOLONG:
+				break;
+			default:
+				/* Any negative value but -1 will inhibit
+				 * futher path search. */
+				return -2;
+			}
+		}
+		s += l;
+	}
+}
+
+static int fixup_rpath(struct dso *p, char *buf, size_t buf_size)
+{
+	size_t n, l;
+	const char *s, *t, *origin;
+	char *d;
+	if (p->rpath || !p->rpath_orig) return 0;
+	if (!strchr(p->rpath_orig, '$')) {
+		p->rpath = p->rpath_orig;
+		return 0;
+	}
+	n = 0;
+	s = p->rpath_orig;
+	while ((t=strchr(s, '$'))) {
+		if (strncmp(t, "$ORIGIN", 7) && strncmp(t, "${ORIGIN}", 9))
+			return 0;
+		s = t+1;
+		n++;
+	}
+	if (n > SSIZE_MAX/PATH_MAX) return 0;
+
+	if (p->kernel_mapped) {
+		/* $ORIGIN searches cannot be performed for the main program
+		 * when it is suid/sgid/AT_SECURE. This is because the
+		 * pathname is under the control of the caller of execve.
+		 * For libraries, however, $ORIGIN can be processed safely
+		 * since the library's pathname came from a trusted source
+		 * (either system paths or a call to dlopen). */
+		if (libc.secure)
+			return 0;
+		l = readlink("/proc/self/exe", buf, buf_size);
+		if (l == -1) switch (errno) {
+		case ENOENT:
+		case ENOTDIR:
+		case EACCES:
+			break;
+		default:
+			return -1;
+		}
+		if (l >= buf_size)
+			return 0;
+		buf[l] = 0;
+		origin = buf;
+	} else {
+		origin = p->name;
+	}
+	t = strrchr(origin, '/');
+	if (t) {
+		l = t-origin;
+	} else {
+		/* Normally p->name will always be an absolute or relative
+		 * pathname containing at least one '/' character, but in the
+		 * case where ldso was invoked as a command to execute a
+		 * program in the working directory, app.name may not. Fix. */
+		origin = ".";
+		l = 1;
+	}
+	/* Disallow non-absolute origins for suid/sgid/AT_SECURE. */
+	if (libc.secure && *origin != '/')
+		return 0;
+	p->rpath = malloc(strlen(p->rpath_orig) + n*l + 1);
+	if (!p->rpath) return -1;
+
+	d = p->rpath;
+	s = p->rpath_orig;
+	while ((t=strchr(s, '$'))) {
+		memcpy(d, s, t-s);
+		d += t-s;
+		memcpy(d, origin, l);
+		d += l;
+		/* It was determined previously that the '$' is followed
+		 * either by "ORIGIN" or "{ORIGIN}". */
+		s = t + 7 + 2*(t[1]=='{');
+	}
+	strcpy(d, s);
+	return 0;
+}
+
+static void decode_dyn(struct dso *p)
+{
+	size_t dyn[DYN_CNT];
+	decode_vec(p->dynv, dyn, DYN_CNT);
+	p->syms = laddr(p, dyn[DT_SYMTAB]);
+	p->strings = laddr(p, dyn[DT_STRTAB]);
+	if (dyn[0]&(1<<DT_HASH))
+		p->hashtab = laddr(p, dyn[DT_HASH]);
+	if (dyn[0]&(1<<DT_RPATH))
+		p->rpath_orig = p->strings + dyn[DT_RPATH];
+	if (dyn[0]&(1<<DT_RUNPATH))
+		p->rpath_orig = p->strings + dyn[DT_RUNPATH];
+	if (dyn[0]&(1<<DT_PLTGOT))
+		p->got = laddr(p, dyn[DT_PLTGOT]);
+	if (search_vec(p->dynv, dyn, DT_GNU_HASH))
+		p->ghashtab = laddr(p, *dyn);
+	if (search_vec(p->dynv, dyn, DT_VERSYM))
+		p->versym = laddr(p, *dyn);
+}
+
+static size_t count_syms(struct dso *p)
+{
+	if (p->hashtab) return p->hashtab[1];
+
+	size_t nsym, i;
+	uint32_t *buckets = p->ghashtab + 4 + (p->ghashtab[2]*sizeof(size_t)/4);
+	uint32_t *hashval;
+	for (i = nsym = 0; i < p->ghashtab[0]; i++) {
+		if (buckets[i] > nsym)
+			nsym = buckets[i];
+	}
+	if (nsym) {
+		hashval = buckets + p->ghashtab[0] + (nsym - p->ghashtab[1]);
+		do nsym++;
+		while (!(*hashval++ & 1));
+	}
+	return nsym;
+}
+
+static void *dl_mmap(size_t n)
+{
+	void *p;
+	int prot = PROT_READ|PROT_WRITE, flags = MAP_ANONYMOUS|MAP_PRIVATE;
+#ifdef SYS_mmap2
+	p = (void *)__syscall(SYS_mmap2, 0, n, prot, flags, -1, 0);
+#else
+	p = (void *)__syscall(SYS_mmap, 0, n, prot, flags, -1, 0);
+#endif
+	return (unsigned long)p > -4096UL ? 0 : p;
+}
+
+static void makefuncdescs(struct dso *p)
+{
+	static int self_done;
+	size_t nsym = count_syms(p);
+	size_t i, size = nsym * sizeof(*p->funcdescs);
+
+	if (!self_done) {
+		p->funcdescs = dl_mmap(size);
+		self_done = 1;
+	} else {
+		p->funcdescs = malloc(size);
+	}
+	if (!p->funcdescs) {
+		if (!runtime) a_crash();
+		error("Error allocating function descriptors for %s", p->name);
+		longjmp(*rtld_fail, 1);
+	}
+	for (i=0; i<nsym; i++) {
+		if ((p->syms[i].st_info&0xf)==STT_FUNC && p->syms[i].st_shndx) {
+			p->funcdescs[i].addr = laddr(p, p->syms[i].st_value);
+			p->funcdescs[i].got = p->got;
+		} else {
+			p->funcdescs[i].addr = 0;
+			p->funcdescs[i].got = 0;
+		}
+	}
+}
+
+static struct dso *load_library(const char *name, struct dso *needed_by)
+{
+	char buf[2*NAME_MAX+2];
+	char fullpath[2*NAME_MAX+2];
+	const char *pathname;
+	unsigned char *map;
+	struct dso *p, temp_dso = {0};
+	int fd;
+	struct stat st;
+	size_t alloc_size;
+	int n_th = 0;
+	int is_self = 0;
+
+	if (!*name) {
+		errno = EINVAL;
+		return 0;
+	}
+
+	/* Catch and block attempts to reload the implementation itself */
+	if (name[0]=='l' && name[1]=='i' && name[2]=='b') {
+		static const char reserved[] =
+			"c.pthread.rt.m.dl.util.xnet.";
+		const char *rp, *next;
+		for (rp=reserved; *rp; rp=next) {
+			next = strchr(rp, '.') + 1;
+			if (strncmp(name+3, rp, next-rp) == 0)
+				break;
+		}
+		if (*rp) {
+			if (ldd_mode) {
+				/* Track which names have been resolved
+				 * and only report each one once. */
+				static unsigned reported;
+				unsigned mask = 1U<<(rp-reserved);
+				if (!(reported & mask)) {
+					reported |= mask;
+					dprintf(1, "\t%s => %s (%p)\n",
+						name, ldso.name,
+						ldso.base);
+				}
+			}
+			is_self = 1;
+		}
+	}
+	if (!strcmp(name, ldso.name)) is_self = 1;
+	if (is_self) {
+		if (!ldso.prev) {
+			tail->next = &ldso;
+			ldso.prev = tail;
+			tail = &ldso;
+		}
+		return &ldso;
+	}
+	if (strchr(name, '/')) {
+		pathname = name;
+		fd = open(name, O_RDONLY); // open(name, O_RDONLY|O_CLOEXEC);
+	} else {
+		/* Search for the name to see if it's already loaded */
+		for (p=head->next; p; p=p->next) {
+			if (p->shortname && !strcmp(p->shortname, name)) {
+				return p;
+			}
+		}
+		if (strlen(name) > NAME_MAX) return 0;
+		fd = -1;
+		if (env_path) fd = path_open(name, env_path, buf, sizeof buf);
+		for (p=needed_by; fd == -1 && p; p=p->needed_by) {
+			if (fixup_rpath(p, buf, sizeof buf) < 0)
+				fd = -2; /* Inhibit further search. */
+			if (p->rpath)
+				fd = path_open(name, p->rpath, buf, sizeof buf);
+		}
+		if (fd == -1) {
+			if (!sys_path) {
+				char *prefix = 0;
+				size_t prefix_len;
+				if (ldso.name[0]=='/') {
+					char *s, *t, *z;
+					for (s=t=z=ldso.name; *s; s++)
+						if (*s=='/') z=t, t=s;
+					prefix_len = z-ldso.name;
+					if (prefix_len < PATH_MAX)
+						prefix = ldso.name;
+				}
+				if (!prefix) {
+					prefix = "";
+					prefix_len = 0;
+				}
+				char etc_ldso_path[prefix_len + 1
+					+ sizeof "/etc/ld-musl-" LDSO_ARCH ".path"];
+				snprintf(etc_ldso_path, sizeof etc_ldso_path,
+					"%.*s/etc/ld-musl-" LDSO_ARCH ".path",
+					(int)prefix_len, prefix);
+				FILE *f = fopen(etc_ldso_path, "rbe");
+				if (f) {
+					if (getdelim(&sys_path, (size_t[1]){0}, 0, f) <= 0) {
+						free(sys_path);
+						sys_path = "";
+					}
+					fclose(f);
+				} else if (errno != ENOENT) {
+					sys_path = "";
+				}
+			}
+			if (!sys_path || sys_path[0] == 0) sys_path = "/usr/lib:/lib:/usr/local/lib";
+			fd = path_open(name, sys_path, buf, sizeof buf);
+		}
+		pathname = buf;
+	}
+	if (fd < 0) return 0;
+
+	if (pathname[0] != '/') {
+		if (!realpath(pathname, fullpath)) {
+			close(fd);
+			return 0;
+		}
+		pathname = fullpath;
+	}
+
+	for (p=head->next; p; p=p->next) {
+		if (!strcmp(p->name, pathname)) {
+			/* If this library was previously loaded with a
+			 * pathname but a search found the same inode,
+			 * setup its shortname so it can be found by name. */
+			if (!p->shortname && pathname != name)
+				p->shortname = strrchr(p->name, '/')+1;
+			close(fd);
+			return p;
+		}
+	}
+	map = noload ? 0 : map_library(fd, &temp_dso);
+	if (!map) return 0;
+
+	/* Avoid the danger of getting two versions of libc mapped into the
+	 * same process when an absolute pathname was used. The symbols
+	 * checked are chosen to catch both musl and glibc, and to avoid
+	 * false positives from interposition-hack libraries. */
+	decode_dyn(&temp_dso);
+	if (find_sym(&temp_dso, "__libc_start_main", 1).sym &&
+	    find_sym(&temp_dso, "stdin", 1).sym) {
+		unmap_library(&temp_dso);
+		return load_library("libc.so", needed_by);
+	}
+	/* Past this point, if we haven't reached runtime yet, ldso has
+	 * committed either to use the mapped library or to abort execution.
+	 * Unmapping is not possible, so we can safely reclaim gaps. */
+	if (!runtime) reclaim_gaps(&temp_dso);
+
+	/* Allocate storage for the new DSO. When there is TLS, this
+	 * storage must include a reservation for all pre-existing
+	 * threads to obtain copies of both the new TLS, and an
+	 * extended DTV capable of storing an additional slot for
+	 * the newly-loaded DSO. */
+	alloc_size = sizeof *p + strlen(pathname) + 1;
+	if (runtime && temp_dso.tls.image) {
+		size_t per_th = temp_dso.tls.size + temp_dso.tls.align
+			+ sizeof(void *) * (tls_cnt+3);
+		n_th = libc.threads_minus_1 + 1;
+		if (n_th > SSIZE_MAX / per_th) alloc_size = SIZE_MAX;
+		else alloc_size += n_th * per_th;
+	}
+	p = calloc(1, alloc_size);
+	if (!p) {
+		unmap_library(&temp_dso);
+		return 0;
+	}
+	memcpy(p, &temp_dso, sizeof temp_dso);
+	p->needed_by = needed_by;
+	p->name = p->buf;
+	p->runtime_loaded = runtime;
+	strcpy(p->name, pathname);
+	/* Add a shortname only if name arg was not an explicit pathname. */
+	if (pathname != name) p->shortname = strrchr(p->name, '/')+1;
+	if (p->tls.image) {
+		p->tls_id = ++tls_cnt;
+		tls_align = MAXP2(tls_align, p->tls.align);
+#ifdef TLS_ABOVE_TP
+		p->tls.offset = tls_offset + ( (p->tls.align-1) &
+			(-tls_offset + (uintptr_t)p->tls.image) );
+		tls_offset = p->tls.offset + p->tls.size;
+#else
+		tls_offset += p->tls.size + p->tls.align - 1;
+		tls_offset -= (tls_offset + (uintptr_t)p->tls.image)
+			& (p->tls.align-1);
+		p->tls.offset = tls_offset;
+#endif
+		p->new_dtv = (void *)(-sizeof(size_t) &
+			(uintptr_t)(p->name+strlen(p->name)+sizeof(size_t)));
+		p->new_tls = (void *)(p->new_dtv + n_th*(tls_cnt+1));
+		if (tls_tail) tls_tail->next = &p->tls;
+		else libc.tls_head = &p->tls;
+		tls_tail = &p->tls;
+	}
+
+	tail->next = p;
+	p->prev = tail;
+	tail = p;
+
+	if (DL_FDPIC) makefuncdescs(p);
+
+	if (ldd_mode) dprintf(1, "\t%s => %s (%p)\n", name, pathname, p->base);
+
+	return p;
+}
+
+static void load_direct_deps(struct dso *p)
+{
+	size_t i, cnt=0;
+
+	if (p->deps) return;
+	/* For head, all preloads are direct pseudo-dependencies.
+	 * Count and include them now to avoid realloc later. */
+	if (p==head) for (struct dso *q=p->next; q; q=q->next)
+		cnt++;
+	for (i=0; p->dynv[i]; i+=2)
+		if (p->dynv[i] == DT_NEEDED) cnt++;
+	/* Use builtin buffer for apps with no external deps, to
+	 * preserve property of no runtime failure paths. */
+	p->deps = (p==head && cnt<2) ? builtin_deps :
+		calloc(cnt+1, sizeof *p->deps);
+	if (!p->deps) {
+		error("Error loading dependencies for %s", p->name);
+		if (runtime) longjmp(*rtld_fail, 1);
+	}
+	cnt=0;
+	if (p==head) for (struct dso *q=p->next; q; q=q->next)
+		p->deps[cnt++] = q;
+	for (i=0; p->dynv[i]; i+=2) {
+		if (p->dynv[i] != DT_NEEDED) continue;
+		struct dso *dep = load_library(p->strings + p->dynv[i+1], p);
+		if (!dep) {
+			error("Error loading shared library %s: %m (needed by %s)",
+				p->strings + p->dynv[i+1], p->name);
+			if (runtime) longjmp(*rtld_fail, 1);
+			continue;
+		}
+		p->deps[cnt++] = dep;
+	}
+	p->deps[cnt] = 0;
+	p->ndeps_direct = cnt;
+}
+
+static void load_deps(struct dso *p)
+{
+	if (p->deps) return;
+	for (; p; p=p->next)
+		load_direct_deps(p);
+}
+
+static void extend_bfs_deps(struct dso *p)
+{
+	size_t i, j, cnt, ndeps_all;
+	struct dso **tmp;
+
+	/* Can't use realloc if the original p->deps was allocated at
+	 * program entry and malloc has been replaced, or if it's
+	 * the builtin non-allocated trivial main program deps array. */
+	int no_realloc = (__malloc_replaced && !p->runtime_loaded)
+		|| p->deps == builtin_deps;
+
+	if (p->bfs_built) return;
+	ndeps_all = p->ndeps_direct;
+
+	/* Mark existing (direct) deps so they won't be duplicated. */
+	for (i=0; p->deps[i]; i++)
+		p->deps[i]->mark = 1;
+
+	/* For each dependency already in the list, copy its list of direct
+	 * dependencies to the list, excluding any items already in the
+	 * list. Note that the list this loop iterates over will grow during
+	 * the loop, but since duplicates are excluded, growth is bounded. */
+	for (i=0; p->deps[i]; i++) {
+		struct dso *dep = p->deps[i];
+		for (j=cnt=0; j<dep->ndeps_direct; j++)
+			if (!dep->deps[j]->mark) cnt++;
+		tmp = no_realloc ? 
+			malloc(sizeof(*tmp) * (ndeps_all+cnt+1)) :
+			realloc(p->deps, sizeof(*tmp) * (ndeps_all+cnt+1));
+		if (!tmp) {
+			error("Error recording dependencies for %s", p->name);
+			if (runtime) longjmp(*rtld_fail, 1);
+			continue;
+		}
+		if (no_realloc) {
+			memcpy(tmp, p->deps, sizeof(*tmp) * (ndeps_all+1));
+			no_realloc = 0;
+		}
+		p->deps = tmp;
+		for (j=0; j<dep->ndeps_direct; j++) {
+			if (dep->deps[j]->mark) continue;
+			dep->deps[j]->mark = 1;
+			p->deps[ndeps_all++] = dep->deps[j];
+		}
+		p->deps[ndeps_all] = 0;
+	}
+	p->bfs_built = 1;
+	for (p=head; p; p=p->next)
+		p->mark = 0;
+}
+
+static void load_preload(char *s)
+{
+	int tmp;
+	char *z;
+	for (z=s; *z; s=z) {
+		for (   ; *s && (isspace(*s) || *s==':'); s++);
+		for (z=s; *z && !isspace(*z) && *z!=':'; z++);
+		tmp = *z;
+		*z = 0;
+		load_library(s, 0);
+		*z = tmp;
+	}
+}
+
+static void add_syms(struct dso *p)
+{
+	if (!p->syms_next && syms_tail != p) {
+		syms_tail->syms_next = p;
+		syms_tail = p;
+	}
+}
+
+static void revert_syms(struct dso *old_tail)
+{
+	struct dso *p, *next;
+	/* Chop off the tail of the list of dsos that participate in
+	 * the global symbol table, reverting them to RTLD_LOCAL. */
+	for (p=old_tail; p; p=next) {
+		next = p->syms_next;
+		p->syms_next = 0;
+	}
+	syms_tail = old_tail;
+}
+
+static void do_mips_relocs(struct dso *p, size_t *got)
+{
+	size_t i, j, rel[2];
+	unsigned char *base = p->base;
+	i=0; search_vec(p->dynv, &i, DT_MIPS_LOCAL_GOTNO);
+	if (p==&ldso) {
+		got += i;
+	} else {
+		while (i--) *got++ += (size_t)base;
+	}
+	j=0; search_vec(p->dynv, &j, DT_MIPS_GOTSYM);
+	i=0; search_vec(p->dynv, &i, DT_MIPS_SYMTABNO);
+	Sym *sym = p->syms + j;
+	rel[0] = (unsigned char *)got - base;
+	for (i-=j; i; i--, sym++, rel[0]+=sizeof(size_t)) {
+		rel[1] = R_INFO(sym-p->syms, R_MIPS_JUMP_SLOT);
+		do_relocs(p, rel, sizeof rel, 2);
+	}
+}
+
+static void reloc_all(struct dso *p)
+{
+	size_t dyn[DYN_CNT];
+	for (; p; p=p->next) {
+		if (p->relocated) continue;
+		decode_vec(p->dynv, dyn, DYN_CNT);
+		if (NEED_MIPS_GOT_RELOCS)
+			do_mips_relocs(p, laddr(p, dyn[DT_PLTGOT]));
+		do_relocs(p, laddr(p, dyn[DT_JMPREL]), dyn[DT_PLTRELSZ],
+			2+(dyn[DT_PLTREL]==DT_RELA));
+		do_relocs(p, laddr(p, dyn[DT_REL]), dyn[DT_RELSZ], 2);
+		do_relocs(p, laddr(p, dyn[DT_RELA]), dyn[DT_RELASZ], 3);
+
+		if (head != &ldso && p->relro_start != p->relro_end &&
+		    mprotect(laddr(p, p->relro_start), p->relro_end-p->relro_start, PROT_READ)
+		    && errno != ENOSYS) {
+			error("Error relocating %s: RELRO protection failed: %m",
+				p->name);
+			if (runtime) longjmp(*rtld_fail, 1);
+		}
+
+		p->relocated = 1;
+	}
+}
+
+static void kernel_mapped_dso(struct dso *p)
+{
+	size_t min_addr = -1, max_addr = 0, cnt;
+	Phdr *ph = p->phdr;
+	for (cnt = p->phnum; cnt--; ph = (void *)((char *)ph + p->phentsize)) {
+		if (ph->p_type == PT_DYNAMIC) {
+			p->dynv = laddr(p, ph->p_vaddr);
+		} else if (ph->p_type == PT_GNU_RELRO) {
+			p->relro_start = ph->p_vaddr & -PAGE_SIZE;
+			p->relro_end = (ph->p_vaddr + ph->p_memsz) & -PAGE_SIZE;
+		} else if (ph->p_type == PT_GNU_STACK) {
+			if (!runtime && ph->p_memsz > __default_stacksize) {
+				__default_stacksize =
+					ph->p_memsz < DEFAULT_STACK_MAX ?
+					ph->p_memsz : DEFAULT_STACK_MAX;
+			}
+		}
+		if (ph->p_type != PT_LOAD) continue;
+		if (ph->p_vaddr < min_addr)
+			min_addr = ph->p_vaddr;
+		if (ph->p_vaddr+ph->p_memsz > max_addr)
+			max_addr = ph->p_vaddr+ph->p_memsz;
+	}
+	min_addr &= -PAGE_SIZE;
+	max_addr = (max_addr + PAGE_SIZE-1) & -PAGE_SIZE;
+	p->map = p->base + min_addr;
+	p->map_len = max_addr - min_addr;
+	p->kernel_mapped = 1;
+}
+
+void __libc_exit_fini()
+{
+	struct dso *p;
+	size_t dyn[DYN_CNT];
+	int self = __pthread_self()->tid;
+
+	/* Take both locks before setting shutting_down, so that
+	 * either lock is sufficient to read its value. The lock
+	 * order matches that in dlopen to avoid deadlock. */
+	pthread_rwlock_wrlock(&lock);
+	pthread_mutex_lock(&init_fini_lock);
+	shutting_down = 1;
+	pthread_rwlock_unlock(&lock);
+	for (p=fini_head; p; p=p->fini_next) {
+		while (p->ctor_visitor && p->ctor_visitor!=self)
+			pthread_cond_wait(&ctor_cond, &init_fini_lock);
+		if (!p->constructed) continue;
+		decode_vec(p->dynv, dyn, DYN_CNT);
+		if (dyn[0] & (1<<DT_FINI_ARRAY)) {
+			size_t n = dyn[DT_FINI_ARRAYSZ]/sizeof(size_t);
+			size_t *fn = (size_t *)laddr(p, dyn[DT_FINI_ARRAY])+n;
+			while (n--) ((void (*)(void))*--fn)();
+		}
+#ifndef NO_LEGACY_INITFINI
+		if ((dyn[0] & (1<<DT_FINI)) && dyn[DT_FINI])
+			fpaddr(p, dyn[DT_FINI])();
+#endif
+	}
+}
+
+static struct dso **queue_ctors(struct dso *dso)
+{
+	size_t cnt, qpos, spos, i;
+	struct dso *p, **queue, **stack;
+
+	if (ldd_mode) return 0;
+
+	/* Bound on queue size is the total number of indirect deps.
+	 * If a bfs deps list was built, we can use it. Otherwise,
+	 * bound by the total number of DSOs, which is always safe and
+	 * is reasonable we use it (for main app at startup). */
+	if (dso->bfs_built) {
+		for (cnt=0; dso->deps[cnt]; cnt++)
+			dso->deps[cnt]->mark = 0;
+		cnt++; /* self, not included in deps */
+	} else {
+		for (cnt=0, p=head; p; cnt++, p=p->next)
+			p->mark = 0;
+	}
+	cnt++; /* termination slot */
+	if (dso==head && cnt <= countof(builtin_ctor_queue))
+		queue = builtin_ctor_queue;
+	else
+		queue = calloc(cnt, sizeof *queue);
+
+	if (!queue) {
+		error("Error allocating constructor queue: %m\n");
+		if (runtime) longjmp(*rtld_fail, 1);
+		return 0;
+	}
+
+	/* Opposite ends of the allocated buffer serve as an output queue
+	 * and a working stack. Setup initial stack with just the argument
+	 * dso and initial queue empty... */
+	stack = queue;
+	qpos = 0;
+	spos = cnt;
+	stack[--spos] = dso;
+	dso->next_dep = 0;
+	dso->mark = 1;
+
+	/* Then perform pseudo-DFS sort, but ignoring circular deps. */
+	while (spos<cnt) {
+		p = stack[spos++];
+		while (p->next_dep < p->ndeps_direct) {
+			if (p->deps[p->next_dep]->mark) {
+				p->next_dep++;
+			} else {
+				stack[--spos] = p;
+				p = p->deps[p->next_dep];
+				p->next_dep = 0;
+				p->mark = 1;
+			}
+		}
+		queue[qpos++] = p;
+	}
+	queue[qpos] = 0;
+	for (i=0; i<qpos; i++) queue[i]->mark = 0;
+
+	return queue;
+}
+
+static void do_init_fini(struct dso **queue)
+{
+	struct dso *p;
+	size_t dyn[DYN_CNT], i;
+	int self = __pthread_self()->tid;
+
+	pthread_mutex_lock(&init_fini_lock);
+	for (i=0; (p=queue[i]); i++) {
+		while ((p->ctor_visitor && p->ctor_visitor!=self) || shutting_down)
+			pthread_cond_wait(&ctor_cond, &init_fini_lock);
+		if (p->ctor_visitor || p->constructed)
+			continue;
+		p->ctor_visitor = self;
+		
+		decode_vec(p->dynv, dyn, DYN_CNT);
+		if (dyn[0] & ((1<<DT_FINI) | (1<<DT_FINI_ARRAY))) {
+			p->fini_next = fini_head;
+			fini_head = p;
+		}
+
+		pthread_mutex_unlock(&init_fini_lock);
+
+#ifndef NO_LEGACY_INITFINI
+		if ((dyn[0] & (1<<DT_INIT)) && dyn[DT_INIT])
+			fpaddr(p, dyn[DT_INIT])();
+#endif
+		if (dyn[0] & (1<<DT_INIT_ARRAY)) {
+			size_t n = dyn[DT_INIT_ARRAYSZ]/sizeof(size_t);
+			size_t *fn = laddr(p, dyn[DT_INIT_ARRAY]);
+			while (n--) ((void (*)(void))*fn++)();
+		}
+
+		pthread_mutex_lock(&init_fini_lock);
+		p->ctor_visitor = 0;
+		p->constructed = 1;
+		pthread_cond_broadcast(&ctor_cond);
+	}
+	pthread_mutex_unlock(&init_fini_lock);
+}
+
+void __libc_start_init(void)
+{
+	do_init_fini(main_ctor_queue);
+	if (!__malloc_replaced && main_ctor_queue != builtin_ctor_queue)
+		free(main_ctor_queue);
+	main_ctor_queue = 0;
+}
+
+static void dl_debug_state(void)
+{
+}
+
+weak_alias(dl_debug_state, _dl_debug_state);
+
+void __init_tls(size_t *auxv)
+{
+}
+
+static void update_tls_size()
+{
+	libc.tls_cnt = tls_cnt;
+	libc.tls_align = tls_align;
+	libc.tls_size = ALIGN(
+		(1+tls_cnt) * sizeof(void *) +
+		tls_offset +
+		sizeof(struct pthread) +
+		tls_align * 2,
+	tls_align);
+}
+
+static void install_new_tls(void)
+{
+	sigset_t set;
+	pthread_t self = __pthread_self(), td;
+	struct dso *dtv_provider = container_of(tls_tail, struct dso, tls);
+	uintptr_t (*newdtv)[tls_cnt+1] = (void *)dtv_provider->new_dtv;
+	struct dso *p;
+	size_t i, j;
+	size_t old_cnt = self->dtv[0];
+
+	__block_app_sigs(&set);
+	__tl_lock();
+	/* Copy existing dtv contents from all existing threads. */
+	for (i=0, td=self; !i || td!=self; i++, td=td->next) {
+		memcpy(newdtv+i, td->dtv,
+			(old_cnt+1)*sizeof(uintptr_t));
+		newdtv[i][0] = tls_cnt;
+	}
+	/* Install new dtls into the enlarged, uninstalled dtv copies. */
+	for (p=head; ; p=p->next) {
+		if (p->tls_id <= old_cnt) continue;
+		unsigned char *mem = p->new_tls;
+		for (j=0; j<i; j++) {
+			unsigned char *new = mem;
+			new += ((uintptr_t)p->tls.image - (uintptr_t)mem)
+				& (p->tls.align-1);
+			memcpy(new, p->tls.image, p->tls.len);
+			newdtv[j][p->tls_id] =
+				(uintptr_t)new + DTP_OFFSET;
+			mem += p->tls.size + p->tls.align;
+		}
+		if (p->tls_id == tls_cnt) break;
+	}
+
+	/* Broadcast barrier to ensure contents of new dtv is visible
+	 * if the new dtv pointer is. The __membarrier function has a
+	 * fallback emulation using signals for kernels that lack the
+	 * feature at the syscall level. */
+
+	__membarrier(MEMBARRIER_CMD_PRIVATE_EXPEDITED, 0);
+
+	/* Install new dtv for each thread. */
+	for (j=0, td=self; !j || td!=self; j++, td=td->next) {
+		td->dtv = td->dtv_copy = newdtv[j];
+	}
+
+	__tl_unlock();
+	__restore_sigs(&set);
+}
+
+/* Stage 1 of the dynamic linker is defined in dlstart.c. It calls the
+ * following stage 2 and stage 3 functions via primitive symbolic lookup
+ * since it does not have access to their addresses to begin with. */
+
+/* Stage 2 of the dynamic linker is called after relative relocations 
+ * have been processed. It can make function calls to static functions
+ * and access string literals and static data, but cannot use extern
+ * symbols. Its job is to perform symbolic relocations on the dynamic
+ * linker itself, but some of the relocations performed may need to be
+ * replaced later due to copy relocations in the main program. */
+
+hidden void __dls2(unsigned char *base, size_t *sp)
+{
+	size_t *auxv;
+	for (auxv=sp+1+*sp+1; *auxv; auxv++);
+	auxv++;
+	if (DL_FDPIC) {
+		void *p1 = (void *)sp[-2];
+		void *p2 = (void *)sp[-1];
+		if (!p1) {
+			size_t aux[AUX_CNT];
+			decode_vec(auxv, aux, AUX_CNT);
+			if (aux[AT_BASE]) ldso.base = (void *)aux[AT_BASE];
+			else ldso.base = (void *)(aux[AT_PHDR] & -4096);
+		}
+		app_loadmap = p2 ? p1 : 0;
+		ldso.loadmap = p2 ? p2 : p1;
+		ldso.base = laddr(&ldso, 0);
+	} else {
+		ldso.base = base;
+	}
+	Ehdr *ehdr = (void *)ldso.base;
+	ldso.name = ldso.shortname = "libc.so";
+	ldso.phnum = ehdr->e_phnum;
+	ldso.phdr = laddr(&ldso, ehdr->e_phoff);
+	ldso.phentsize = ehdr->e_phentsize;
+	kernel_mapped_dso(&ldso);
+	decode_dyn(&ldso);
+
+	if (DL_FDPIC) makefuncdescs(&ldso);
+
+	/* Prepare storage for to save clobbered REL addends so they
+	 * can be reused in stage 3. There should be very few. If
+	 * something goes wrong and there are a huge number, abort
+	 * instead of risking stack overflow. */
+	size_t dyn[DYN_CNT];
+	decode_vec(ldso.dynv, dyn, DYN_CNT);
+	size_t *rel = laddr(&ldso, dyn[DT_REL]);
+	size_t rel_size = dyn[DT_RELSZ];
+	size_t symbolic_rel_cnt = 0;
+	apply_addends_to = rel;
+	for (; rel_size; rel+=2, rel_size-=2*sizeof(size_t))
+		if (!IS_RELATIVE(rel[1], ldso.syms)) symbolic_rel_cnt++;
+	if (symbolic_rel_cnt >= ADDEND_LIMIT) a_crash();
+	size_t addends[symbolic_rel_cnt+1];
+	saved_addends = addends;
+
+	head = &ldso;
+	reloc_all(&ldso);
+
+	ldso.relocated = 0;
+
+	/* Call dynamic linker stage-2b, __dls2b, looking it up
+	 * symbolically as a barrier against moving the address
+	 * load across the above relocation processing. */
+	struct symdef dls2b_def = find_sym(&ldso, "__dls2b", 0);
+	if (DL_FDPIC) ((stage3_func)&ldso.funcdescs[dls2b_def.sym-ldso.syms])(sp, auxv);
+	else ((stage3_func)laddr(&ldso, dls2b_def.sym->st_value))(sp, auxv);
+}
+
+/* Stage 2b sets up a valid thread pointer, which requires relocations
+ * completed in stage 2, and on which stage 3 is permitted to depend.
+ * This is done as a separate stage, with symbolic lookup as a barrier,
+ * so that loads of the thread pointer and &errno can be pure/const and
+ * thereby hoistable. */
+
+void __dls2b(size_t *sp, size_t *auxv)
+{
+	/* Setup early thread pointer in builtin_tls for ldso/libc itself to
+	 * use during dynamic linking. If possible it will also serve as the
+	 * thread pointer at runtime. */
+	search_vec(auxv, &__hwcap, AT_HWCAP);
+	libc.auxv = auxv;
+	libc.tls_size = sizeof builtin_tls;
+	libc.tls_align = tls_align;
+	if (__init_tp(__copy_tls((void *)builtin_tls)) < 0) {
+		a_crash();
+	}
+
+	struct symdef dls3_def = find_sym(&ldso, "__dls3", 0);
+	if (DL_FDPIC) ((stage3_func)&ldso.funcdescs[dls3_def.sym-ldso.syms])(sp, auxv);
+	else ((stage3_func)laddr(&ldso, dls3_def.sym->st_value))(sp, auxv);
+}
+
+/* Stage 3 of the dynamic linker is called with the dynamic linker/libc
+ * fully functional. Its job is to load (if not already loaded) and
+ * process dependencies and relocations for the main application and
+ * transfer control to its entry point. */
+
+void __dls3(size_t *sp, size_t *auxv)
+{
+	static struct dso app, vdso;
+	size_t aux[AUX_CNT];
+	size_t i;
+	char *env_preload=0;
+	char *replace_argv0=0;
+	size_t vdso_base;
+	int argc = *sp;
+	char **argv = (void *)(sp+1);
+	char **argv_orig = argv;
+	char **envp = argv+argc+1;
+
+	/* Find aux vector just past environ[] and use it to initialize
+	 * global data that may be needed before we can make syscalls. */
+	__environ = envp;
+	decode_vec(auxv, aux, AUX_CNT);
+	search_vec(auxv, &__sysinfo, AT_SYSINFO);
+	__pthread_self()->sysinfo = __sysinfo;
+	libc.page_size = aux[AT_PAGESZ];
+	libc.secure = ((aux[0]&0x7800)!=0x7800 || aux[AT_UID]!=aux[AT_EUID]
+		|| aux[AT_GID]!=aux[AT_EGID] || aux[AT_SECURE]);
+
+	/* Only trust user/env if kernel says we're not suid/sgid */
+	if (!libc.secure) {
+		env_path = getenv("LD_LIBRARY_PATH");
+		env_preload = getenv("LD_PRELOAD");
+	}
+
+	/* If the main program was already loaded by the kernel,
+	 * AT_PHDR will point to some location other than the dynamic
+	 * linker's program headers. */
+	if (aux[AT_PHDR] != (size_t)ldso.phdr) {
+		size_t interp_off = 0;
+		size_t tls_image = 0;
+		/* Find load address of the main program, via AT_PHDR vs PT_PHDR. */
+		Phdr *phdr = app.phdr = (void *)aux[AT_PHDR];
+		app.phnum = aux[AT_PHNUM];
+		app.phentsize = aux[AT_PHENT];
+		for (i=aux[AT_PHNUM]; i; i--, phdr=(void *)((char *)phdr + aux[AT_PHENT])) {
+			if (phdr->p_type == PT_PHDR)
+				app.base = (void *)(aux[AT_PHDR] - phdr->p_vaddr);
+			else if (phdr->p_type == PT_INTERP)
+				interp_off = (size_t)phdr->p_vaddr;
+			else if (phdr->p_type == PT_TLS) {
+				tls_image = phdr->p_vaddr;
+				app.tls.len = phdr->p_filesz;
+				app.tls.size = phdr->p_memsz;
+				app.tls.align = phdr->p_align;
+			}
+		}
+		if (DL_FDPIC) app.loadmap = app_loadmap;
+		if (app.tls.size) app.tls.image = laddr(&app, tls_image);
+		if (interp_off) ldso.name = laddr(&app, interp_off);
+#if 0
+		if ((aux[0] & (1UL<<AT_EXECFN))
+		    && strncmp((char *)aux[AT_EXECFN], "/proc/", 6))
+			app.name = (char *)aux[AT_EXECFN];
+		else
+			app.name = argv[0];
+#else
+		if (argv[0])
+			app.name = argv[0];
+		else
+			app.name = "none";
+#endif
+		kernel_mapped_dso(&app);
+	} else {
+		int fd;
+		char *ldname = argv[0];
+		size_t l = strlen(ldname);
+		if (l >= 3 && !strcmp(ldname+l-3, "ldd")) ldd_mode = 1;
+		argv++;
+		while (argv[0] && argv[0][0]=='-' && argv[0][1]=='-') {
+			char *opt = argv[0]+2;
+			*argv++ = (void *)-1;
+			if (!*opt) {
+				break;
+			} else if (!memcmp(opt, "list", 5)) {
+				ldd_mode = 1;
+			} else if (!memcmp(opt, "library-path", 12)) {
+				if (opt[12]=='=') env_path = opt+13;
+				else if (opt[12]) *argv = 0;
+				else if (*argv) env_path = *argv++;
+			} else if (!memcmp(opt, "preload", 7)) {
+				if (opt[7]=='=') env_preload = opt+8;
+				else if (opt[7]) *argv = 0;
+				else if (*argv) env_preload = *argv++;
+			} else if (!memcmp(opt, "argv0", 5)) {
+				if (opt[5]=='=') replace_argv0 = opt+6;
+				else if (opt[5]) *argv = 0;
+				else if (*argv) replace_argv0 = *argv++;
+			} else {
+				argv[0] = 0;
+			}
+		}
+		argv[-1] = (void *)(argc - (argv-argv_orig));
+		if (!argv[0]) {
+			dprintf(2, "musl libc (" LDSO_ARCH ")\n"
+				"Version %s\n"
+				"Dynamic Program Loader\n"
+				"Usage: %s [options] [--] pathname%s\n",
+				__libc_version, ldname,
+				ldd_mode ? "" : " [args]");
+			_exit(1);
+		}
+		fd = open(argv[0], O_RDONLY);
+		if (fd < 0) {
+			dprintf(2, "%s: cannot load %s: %s\n", ldname, argv[0], strerror(errno));
+			_exit(1);
+		}
+		Ehdr *ehdr = (void *)map_library(fd, &app);
+		if (!ehdr) {
+			dprintf(2, "%s: %s: Not a valid dynamic program\n", ldname, argv[0]);
+			_exit(1);
+		}
+		ldso.name = ldname;
+		app.name = argv[0];
+		aux[AT_ENTRY] = (size_t)laddr(&app, ehdr->e_entry);
+		/* Find the name that would have been used for the dynamic
+		 * linker had ldd not taken its place. */
+		if (ldd_mode) {
+			for (i=0; i<app.phnum; i++) {
+				if (app.phdr[i].p_type == PT_INTERP)
+					ldso.name = laddr(&app, app.phdr[i].p_vaddr);
+			}
+			dprintf(1, "\t%s (%p)\n", ldso.name, ldso.base);
+		}
+	}
+	if (app.tls.size) {
+		libc.tls_head = tls_tail = &app.tls;
+		app.tls_id = tls_cnt = 1;
+#ifdef TLS_ABOVE_TP
+		app.tls.offset = GAP_ABOVE_TP;
+		app.tls.offset += (-GAP_ABOVE_TP + (uintptr_t)app.tls.image)
+			& (app.tls.align-1);
+		tls_offset = app.tls.offset + app.tls.size;
+#else
+		tls_offset = app.tls.offset = app.tls.size
+			+ ( -((uintptr_t)app.tls.image + app.tls.size)
+			& (app.tls.align-1) );
+#endif
+		tls_align = MAXP2(tls_align, app.tls.align);
+	}
+	decode_dyn(&app);
+	if (DL_FDPIC) {
+		makefuncdescs(&app);
+		if (!app.loadmap) {
+			app.loadmap = (void *)&app_dummy_loadmap;
+			app.loadmap->nsegs = 1;
+			app.loadmap->segs[0].addr = (size_t)app.map;
+			app.loadmap->segs[0].p_vaddr = (size_t)app.map
+				- (size_t)app.base;
+			app.loadmap->segs[0].p_memsz = app.map_len;
+		}
+		argv[-3] = (void *)app.loadmap;
+	}
+
+	/* Initial dso chain consists only of the app. */
+	head = tail = syms_tail = &app;
+
+	/* Donate unused parts of app and library mapping to malloc */
+	reclaim_gaps(&app);
+	reclaim_gaps(&ldso);
+
+	/* Load preload/needed libraries, add symbols to global namespace. */
+	ldso.deps = (struct dso **)no_deps;
+	if (env_preload) load_preload(env_preload);
+ 	load_deps(&app);
+	for (struct dso *p=head; p; p=p->next)
+		add_syms(p);
+
+	/* Attach to vdso, if provided by the kernel, last so that it does
+	 * not become part of the global namespace.  */
+	if (search_vec(auxv, &vdso_base, AT_SYSINFO_EHDR) && vdso_base) {
+		Ehdr *ehdr = (void *)vdso_base;
+		Phdr *phdr = vdso.phdr = (void *)(vdso_base + ehdr->e_phoff);
+		vdso.phnum = ehdr->e_phnum;
+		vdso.phentsize = ehdr->e_phentsize;
+		for (i=ehdr->e_phnum; i; i--, phdr=(void *)((char *)phdr + ehdr->e_phentsize)) {
+			if (phdr->p_type == PT_DYNAMIC)
+				vdso.dynv = (void *)(vdso_base + phdr->p_offset);
+			if (phdr->p_type == PT_LOAD)
+				vdso.base = (void *)(vdso_base - phdr->p_vaddr + phdr->p_offset);
+		}
+		vdso.name = "";
+		vdso.shortname = "OHOS-vdso.so";
+		vdso.relocated = 1;
+		vdso.deps = (struct dso **)no_deps;
+		decode_dyn(&vdso);
+		vdso.prev = tail;
+		tail->next = &vdso;
+		tail = &vdso;
+	}
+
+	for (i=0; app.dynv[i]; i+=2) {
+		if (!DT_DEBUG_INDIRECT && app.dynv[i]==DT_DEBUG)
+			app.dynv[i+1] = (size_t)&debug;
+		if (DT_DEBUG_INDIRECT && app.dynv[i]==DT_DEBUG_INDIRECT) {
+			size_t *ptr = (size_t *) app.dynv[i+1];
+			*ptr = (size_t)&debug;
+		}
+	}
+
+	/* This must be done before final relocations, since it calls
+	 * malloc, which may be provided by the application. Calling any
+	 * application code prior to the jump to its entry point is not
+	 * valid in our model and does not work with FDPIC, where there
+	 * are additional relocation-like fixups that only the entry point
+	 * code can see to perform. */
+	main_ctor_queue = queue_ctors(&app);
+
+	/* Initial TLS must also be allocated before final relocations
+	 * might result in calloc being a call to application code. */
+	update_tls_size();
+	void *initial_tls = builtin_tls;
+	if (libc.tls_size > sizeof builtin_tls || tls_align > MIN_TLS_ALIGN) {
+		initial_tls = calloc(libc.tls_size, 1);
+		if (!initial_tls) {
+			dprintf(2, "%s: Error getting %zu bytes thread-local storage: %m\n",
+				argv[0], libc.tls_size);
+			_exit(127);
+		}
+	}
+	static_tls_cnt = tls_cnt;
+
+	/* The main program must be relocated LAST since it may contain
+	 * copy relocations which depend on libraries' relocations. */
+	reloc_all(app.next);
+	reloc_all(&app);
+
+	/* Actual copying to new TLS needs to happen after relocations,
+	 * since the TLS images might have contained relocated addresses. */
+	if (initial_tls != builtin_tls) {
+		if (__init_tp(__copy_tls(initial_tls)) < 0) {
+			a_crash();
+		}
+	} else {
+		size_t tmp_tls_size = libc.tls_size;
+		pthread_t self = __pthread_self();
+		/* Temporarily set the tls size to the full size of
+		 * builtin_tls so that __copy_tls will use the same layout
+		 * as it did for before. Then check, just to be safe. */
+		libc.tls_size = sizeof builtin_tls;
+		if (__copy_tls((void*)builtin_tls) != self) a_crash();
+		libc.tls_size = tmp_tls_size;
+	}
+
+	if (ldso_fail) _exit(127);
+	if (ldd_mode) _exit(0);
+
+	/* Determine if malloc was interposed by a replacement implementation
+	 * so that calloc and the memalign family can harden against the
+	 * possibility of incomplete replacement. */
+	if (find_sym(head, "malloc", 1).dso != &ldso)
+		__malloc_replaced = 1;
+
+	/* Switch to runtime mode: any further failures in the dynamic
+	 * linker are a reportable failure rather than a fatal startup
+	 * error. */
+	runtime = 1;
+
+	debug.ver = 1;
+	debug.bp = dl_debug_state;
+	debug.head = head;
+	debug.base = ldso.base;
+	debug.state = 0;
+	_dl_debug_state();
+
+	if (replace_argv0) argv[0] = replace_argv0;
+
+	errno = 0;
+
+	CRTJMP((void *)aux[AT_ENTRY], argv-1);
+	for(;;);
+}
+
+static void prepare_lazy(struct dso *p)
+{
+	size_t dyn[DYN_CNT], n, flags1=0;
+	decode_vec(p->dynv, dyn, DYN_CNT);
+	search_vec(p->dynv, &flags1, DT_FLAGS_1);
+	if (dyn[DT_BIND_NOW] || (dyn[DT_FLAGS] & DF_BIND_NOW) || (flags1 & DF_1_NOW))
+		return;
+	n = dyn[DT_RELSZ]/2 + dyn[DT_RELASZ]/3 + dyn[DT_PLTRELSZ]/2 + 1;
+	if (NEED_MIPS_GOT_RELOCS) {
+		size_t j=0; search_vec(p->dynv, &j, DT_MIPS_GOTSYM);
+		size_t i=0; search_vec(p->dynv, &i, DT_MIPS_SYMTABNO);
+		n += i-j;
+	}
+	p->lazy = calloc(n, 3*sizeof(size_t));
+	if (!p->lazy) {
+		error("Error preparing lazy relocation for %s: %m", p->name);
+		longjmp(*rtld_fail, 1);
+	}
+	p->lazy_next = lazy_head;
+	lazy_head = p;
+}
+
+void *dlopen(const char *file, int mode)
+{
+	struct dso *volatile p, *orig_tail, *orig_syms_tail, *orig_lazy_head, *next;
+	struct tls_module *orig_tls_tail;
+	size_t orig_tls_cnt, orig_tls_offset, orig_tls_align;
+	size_t i;
+	int cs;
+	jmp_buf jb;
+	struct dso **volatile ctor_queue = 0;
+
+	if (mode & ~(RTLD_LAZY | RTLD_NOW | RTLD_NOLOAD | RTLD_GLOBAL | RTLD_LOCAL | RTLD_NODELETE)) {
+		error("invalid mode parameter for dlopen().");
+		return NULL;
+	}
+
+	if ((mode & (RTLD_LAZY | RTLD_NOW)) == 0) {
+		error("invalid mode, one of RTLD_LAZY and RTLD_NOW must be set.");
+		return NULL;
+	}
+
+	if (!file) return head;
+
+	pthread_setcancelstate(PTHREAD_CANCEL_DISABLE, &cs);
+	pthread_rwlock_wrlock(&lock);
+	__inhibit_ptc();
+
+	p = 0;
+	if (shutting_down) {
+		error("Cannot dlopen while program is exiting.");
+		goto end;
+	}
+	orig_tls_tail = tls_tail;
+	orig_tls_cnt = tls_cnt;
+	orig_tls_offset = tls_offset;
+	orig_tls_align = tls_align;
+	orig_lazy_head = lazy_head;
+	orig_syms_tail = syms_tail;
+	orig_tail = tail;
+	noload = mode & RTLD_NOLOAD;
+
+	rtld_fail = &jb;
+	if (setjmp(*rtld_fail)) {
+		/* Clean up anything new that was (partially) loaded */
+		revert_syms(orig_syms_tail);
+		for (p=orig_tail->next; p; p=next) {
+			next = p->next;
+			while (p->td_index) {
+				void *tmp = p->td_index->next;
+				free(p->td_index);
+				p->td_index = tmp;
+			}
+			free(p->funcdescs);
+			if (p->rpath != p->rpath_orig)
+				free(p->rpath);
+			free(p->deps);
+			unmap_library(p);
+			free(p);
+		}
+		free(ctor_queue);
+		ctor_queue = 0;
+		if (!orig_tls_tail) libc.tls_head = 0;
+		tls_tail = orig_tls_tail;
+		if (tls_tail) tls_tail->next = 0;
+		tls_cnt = orig_tls_cnt;
+		tls_offset = orig_tls_offset;
+		tls_align = orig_tls_align;
+		lazy_head = orig_lazy_head;
+		tail = orig_tail;
+		tail->next = 0;
+		p = 0;
+		goto end;
+	} else p = load_library(file, head);
+
+	if (!p) {
+		error(noload ?
+			"Library %s is not already loaded" :
+			"Error loading shared library %s: %m",
+			file);
+		goto end;
+	}
+
+	/* First load handling */
+	load_deps(p);
+	extend_bfs_deps(p);
+	pthread_mutex_lock(&init_fini_lock);
+	if (!p->constructed) ctor_queue = queue_ctors(p);
+	pthread_mutex_unlock(&init_fini_lock);
+	if (!p->relocated && (mode & RTLD_LAZY)) {
+		prepare_lazy(p);
+		for (i=0; p->deps[i]; i++)
+			if (!p->deps[i]->relocated)
+				prepare_lazy(p->deps[i]);
+	}
+	if (!p->relocated || (mode & RTLD_GLOBAL)) {
+		/* Make new symbols global, at least temporarily, so we can do
+		 * relocations. If not RTLD_GLOBAL, this is reverted below. */
+		add_syms(p);
+		for (i=0; p->deps[i]; i++)
+			add_syms(p->deps[i]);
+	}
+	if (!p->relocated) {
+		reloc_all(p);
+	}
+
+	/* If RTLD_GLOBAL was not specified, undo any new additions
+	 * to the global symbol table. This is a nop if the library was
+	 * previously loaded and already global. */
+	if (!(mode & RTLD_GLOBAL))
+		revert_syms(orig_syms_tail);
+
+	/* Processing of deferred lazy relocations must not happen until
+	 * the new libraries are committed; otherwise we could end up with
+	 * relocations resolved to symbol definitions that get removed. */
+	redo_lazy_relocs();
+
+	update_tls_size();
+	if (tls_cnt != orig_tls_cnt)
+		install_new_tls();
+	_dl_debug_state();
+	orig_tail = tail;
+end:
+	__release_ptc();
+	if (p) gencnt++;
+	pthread_rwlock_unlock(&lock);
+	if (ctor_queue) {
+		do_init_fini(ctor_queue);
+		free(ctor_queue);
+	}
+	pthread_setcancelstate(cs, 0);
+	return p;
+}
+
+hidden int __dl_invalid_handle(void *h)
+{
+	struct dso *p;
+	for (p=head; p; p=p->next) if (h==p) return 0;
+	error("Invalid library handle %p", (void *)h);
+	return 1;
+}
+
+static void *addr2dso(size_t a)
+{
+	struct dso *p;
+	size_t i;
+	if (DL_FDPIC) for (p=head; p; p=p->next) {
+		i = count_syms(p);
+		if (a-(size_t)p->funcdescs < i*sizeof(*p->funcdescs))
+			return p;
+	}
+	for (p=head; p; p=p->next) {
+		if (DL_FDPIC && p->loadmap) {
+			for (i=0; i<p->loadmap->nsegs; i++) {
+				if (a-p->loadmap->segs[i].p_vaddr
+				    < p->loadmap->segs[i].p_memsz)
+					return p;
+			}
+		} else {
+			Phdr *ph = p->phdr;
+			size_t phcnt = p->phnum;
+			size_t entsz = p->phentsize;
+			size_t base = (size_t)p->base;
+			for (; phcnt--; ph=(void *)((char *)ph+entsz)) {
+				if (ph->p_type != PT_LOAD) continue;
+				if (a-base-ph->p_vaddr < ph->p_memsz)
+					return p;
+			}
+			if (a-(size_t)p->map < p->map_len)
+				return 0;
+		}
+	}
+	return 0;
+}
+
+static void *do_dlsym(struct dso *p, const char *s, void *ra)
+{
+	int use_deps = 0;
+	if (p == head || p == RTLD_DEFAULT) {
+		p = head;
+	} else if (p == RTLD_NEXT) {
+		p = addr2dso((size_t)ra);
+		if (!p) p=head;
+		p = p->next;
+	} else if (__dl_invalid_handle(p)) {
+		return 0;
+	} else
+		use_deps = 1;
+	struct symdef def = find_sym2(p, s, 0, use_deps);
+	if (!def.sym) {
+		error("Symbol not found: %s", s);
+		return 0;
+	}
+	if ((def.sym->st_info&0xf) == STT_TLS)
+		return __tls_get_addr((tls_mod_off_t []){def.dso->tls_id, def.sym->st_value-DTP_OFFSET});
+	if (DL_FDPIC && (def.sym->st_info&0xf) == STT_FUNC)
+		return def.dso->funcdescs + (def.sym - def.dso->syms);
+	return laddr(def.dso, def.sym->st_value);
+}
+
+int dladdr(const void *addr_arg, Dl_info *info)
+{
+	size_t addr = (size_t)addr_arg;
+	struct dso *p;
+	Sym *sym, *bestsym;
+	uint32_t nsym;
+	char *strings;
+	size_t best = 0;
+	size_t besterr = -1;
+
+	pthread_rwlock_rdlock(&lock);
+	p = addr2dso(addr);
+	pthread_rwlock_unlock(&lock);
+
+	if (!p) return 0;
+
+	sym = p->syms;
+	strings = p->strings;
+	nsym = count_syms(p);
+
+	if (DL_FDPIC) {
+		size_t idx = (addr-(size_t)p->funcdescs)
+			/ sizeof(*p->funcdescs);
+		if (idx < nsym && (sym[idx].st_info&0xf) == STT_FUNC) {
+			best = (size_t)(p->funcdescs + idx);
+			bestsym = sym + idx;
+			besterr = 0;
+		}
+	}
+
+	if (!best) for (; nsym; nsym--, sym++) {
+		if (sym->st_value
+		 && (1<<(sym->st_info&0xf) & OK_TYPES)
+		 && (1<<(sym->st_info>>4) & OK_BINDS)) {
+			size_t symaddr = (size_t)laddr(p, sym->st_value);
+			if (symaddr > addr || symaddr <= best)
+				continue;
+			best = symaddr;
+			bestsym = sym;
+			besterr = addr - symaddr;
+			if (addr == symaddr)
+				break;
+		}
+	}
+
+	if (best && besterr > bestsym->st_size-1) {
+		best = 0;
+		bestsym = 0;
+	}
+
+	info->dli_fname = p->name;
+	info->dli_fbase = p->map;
+
+	if (!best) {
+		info->dli_sname = 0;
+		info->dli_saddr = 0;
+		return 1;
+	}
+
+	if (DL_FDPIC && (bestsym->st_info&0xf) == STT_FUNC)
+		best = (size_t)(p->funcdescs + (bestsym - p->syms));
+	info->dli_sname = strings + bestsym->st_name;
+	info->dli_saddr = (void *)best;
+
+	return 1;
+}
+
+hidden void *__dlsym(void *restrict p, const char *restrict s, void *restrict ra)
+{
+	void *res;
+	pthread_rwlock_rdlock(&lock);
+	res = do_dlsym(p, s, ra);
+	pthread_rwlock_unlock(&lock);
+	return res;
+}
+
+hidden void *__dlsym_redir_time64(void *restrict p, const char *restrict s, void *restrict ra)
+{
+#if _REDIR_TIME64
+	const char *suffix, *suffix2 = "";
+	char redir[36];
+
+	/* Map the symbol name to a time64 version of itself according to the
+	 * pattern used for naming the redirected time64 symbols. */
+	size_t l = strnlen(s, sizeof redir);
+	if (l<4 || l==sizeof redir) goto no_redir;
+	if (s[l-2]=='_' && s[l-1]=='r') {
+		l -= 2;
+		suffix2 = s+l;
+	}
+	if (l<4) goto no_redir;
+	if (!strcmp(s+l-4, "time")) suffix = "64";
+	else suffix = "_time64";
+
+	/* Use the presence of the remapped symbol name in libc to determine
+	 * whether it's one that requires time64 redirection; replace if so. */
+	snprintf(redir, sizeof redir, "__%.*s%s%s", (int)l, s, suffix, suffix2);
+	if (find_sym(&ldso, redir, 1).sym) s = redir;
+no_redir:
+#endif
+	return __dlsym(p, s, ra);
+}
+
+int dl_iterate_phdr(int(*callback)(struct dl_phdr_info *info, size_t size, void *data), void *data)
+{
+	struct dso *current;
+	struct dl_phdr_info info;
+	int ret = 0;
+	for(current = head; current;) {
+		info.dlpi_addr      = (uintptr_t)current->base;
+		info.dlpi_name      = current->name;
+		info.dlpi_phdr      = current->phdr;
+		info.dlpi_phnum     = current->phnum;
+		info.dlpi_adds      = gencnt;
+		info.dlpi_subs      = 0;
+		info.dlpi_tls_modid = current->tls_id;
+		info.dlpi_tls_data  = current->tls.image;
+
+		ret = (callback)(&info, sizeof (info), data);
+
+		if (ret != 0) break;
+
+		pthread_rwlock_rdlock(&lock);
+		current = current->next;
+		pthread_rwlock_unlock(&lock);
+	}
+	return ret;
+}
+
+static void error(const char *fmt, ...)
+{
+	va_list ap;
+	va_start(ap, fmt);
+	if (!runtime) {
+		vdprintf(2, fmt, ap);
+		dprintf(2, "\n");
+		ldso_fail = 1;
+		va_end(ap);
+		return;
+	}
+	__dl_vseterr(fmt, ap);
+	va_end(ap);
+}
diff --git a/third_party/musl/porting/liteos_a/user/src/aio/aio.c b/third_party/musl/porting/liteos_a/user/src/aio/aio.c
new file mode 100755
index 000000000..5bb5733b5
--- /dev/null
+++ b/third_party/musl/porting/liteos_a/user/src/aio/aio.c
@@ -0,0 +1,407 @@
+#include <aio.h>
+#include <pthread.h>
+#include <semaphore.h>
+#include <limits.h>
+#include <errno.h>
+#include <unistd.h>
+#include <stdlib.h>
+#include <sys/auxv.h>
+#include <unsupported_api.h>
+#include "syscall.h"
+#include "atomic.h"
+#include "pthread_impl.h"
+
+/* The following is a threads-based implementation of AIO with minimal
+ * dependence on implementation details. Most synchronization is
+ * performed with pthread primitives, but atomics and futex operations
+ * are used for notification in a couple places where the pthread
+ * primitives would be inefficient or impractical.
+ *
+ * For each fd with outstanding aio operations, an aio_queue structure
+ * is maintained. These are reference-counted and destroyed by the last
+ * aio worker thread to exit. Accessing any member of the aio_queue
+ * structure requires a lock on the aio_queue. Adding and removing aio
+ * queues themselves requires a write lock on the global map object,
+ * a 4-level table mapping file descriptor numbers to aio queues. A
+ * read lock on the map is used to obtain locks on existing queues by
+ * excluding destruction of the queue by a different thread while it is
+ * being locked.
+ *
+ * Each aio queue has a list of active threads/operations. Presently there
+ * is a one to one relationship between threads and operations. The only
+ * members of the aio_thread structure which are accessed by other threads
+ * are the linked list pointers, op (which is immutable), running (which
+ * is updated atomically), and err (which is synchronized via running),
+ * so no locking is necessary. Most of the other other members are used
+ * for sharing data between the main flow of execution and cancellation
+ * cleanup handler.
+ *
+ * Taking any aio locks requires having all signals blocked. This is
+ * necessary because aio_cancel is needed by close, and close is required
+ * to be async-signal safe. All aio worker threads run with all signals
+ * blocked permanently.
+ */
+
+struct aio_thread {
+	pthread_t td;
+	struct aiocb *cb;
+	struct aio_thread *next, *prev;
+	struct aio_queue *q;
+	volatile int running;
+	int err, op;
+	ssize_t ret;
+};
+
+struct aio_queue {
+	int fd, seekable, append, ref, init;
+	pthread_mutex_t lock;
+	pthread_cond_t cond;
+	struct aio_thread *head;
+};
+
+struct aio_args {
+	struct aiocb *cb;
+	struct aio_queue *q;
+	int op;
+	sem_t sem;
+};
+
+static pthread_rwlock_t maplock = PTHREAD_RWLOCK_INITIALIZER;
+static struct aio_queue *****map;
+static volatile int aio_fd_cnt;
+volatile int __aio_fut;
+
+static struct aio_queue *__aio_get_queue(int fd, int need)
+{
+	if (fd < 0) {
+		errno = EBADF;
+		return 0;
+	}
+	int a=fd>>24;
+	unsigned char b=fd>>16, c=fd>>8, d=fd;
+	struct aio_queue *q = 0;
+	pthread_rwlock_rdlock(&maplock);
+	if ((!map || !map[a] || !map[a][b] || !map[a][b][c] || !(q=map[a][b][c][d])) && need) {
+		pthread_rwlock_unlock(&maplock);
+		if (fcntl(fd, F_GETFD) < 0) return 0;
+		pthread_rwlock_wrlock(&maplock);
+		if (!map) map = calloc(sizeof *map, (-1U/2+1)>>24);
+		if (!map) goto out;
+		if (!map[a]) map[a] = calloc(sizeof **map, 256);
+		if (!map[a]) goto out;
+		if (!map[a][b]) map[a][b] = calloc(sizeof ***map, 256);
+		if (!map[a][b]) goto out;
+		if (!map[a][b][c]) map[a][b][c] = calloc(sizeof ****map, 256);
+		if (!map[a][b][c]) goto out;
+		if (!(q = map[a][b][c][d])) {
+			map[a][b][c][d] = q = calloc(sizeof *****map, 1);
+			if (q) {
+				q->fd = fd;
+				pthread_mutex_init(&q->lock, 0);
+				pthread_cond_init(&q->cond, 0);
+				a_inc(&aio_fd_cnt);
+			}
+		}
+	}
+	if (q) pthread_mutex_lock(&q->lock);
+out:
+	pthread_rwlock_unlock(&maplock);
+	return q;
+}
+
+static void __aio_unref_queue(struct aio_queue *q)
+{
+	if (q->ref > 1) {
+		q->ref--;
+		pthread_mutex_unlock(&q->lock);
+		return;
+	}
+
+	/* This is potentially the last reference, but a new reference
+	 * may arrive since we cannot free the queue object without first
+	 * taking the maplock, which requires releasing the queue lock. */
+	pthread_mutex_unlock(&q->lock);
+	pthread_rwlock_wrlock(&maplock);
+	pthread_mutex_lock(&q->lock);
+	if (q->ref == 1) {
+		int fd=q->fd;
+		int a=fd>>24;
+		unsigned char b=fd>>16, c=fd>>8, d=fd;
+		map[a][b][c][d] = 0;
+		a_dec(&aio_fd_cnt);
+		pthread_rwlock_unlock(&maplock);
+		pthread_mutex_unlock(&q->lock);
+		free(q);
+	} else {
+		q->ref--;
+		pthread_rwlock_unlock(&maplock);
+		pthread_mutex_unlock(&q->lock);
+	}
+}
+
+static void cleanup(void *ctx)
+{
+	struct aio_thread *at = ctx;
+	struct aio_queue *q = at->q;
+	struct aiocb *cb = at->cb;
+	struct sigevent sev = cb->aio_sigevent;
+
+	/* There are four potential types of waiters we could need to wake:
+	 *   1. Callers of aio_cancel/close.
+	 *   2. Callers of aio_suspend with a single aiocb.
+	 *   3. Callers of aio_suspend with a list.
+	 *   4. AIO worker threads waiting for sequenced operations.
+	 * Types 1-3 are notified via atomics/futexes, mainly for AS-safety
+	 * considerations. Type 4 is notified later via a cond var. */
+
+	cb->__ret = at->ret;
+	if (a_swap(&at->running, 0) < 0)
+		__wake(&at->running, -1, 1);
+	if (a_swap(&cb->__err, at->err) != EINPROGRESS)
+		__wake(&cb->__err, -1, 1);
+	if (a_swap(&__aio_fut, 0))
+		__wake(&__aio_fut, -1, 1);
+
+	pthread_mutex_lock(&q->lock);
+
+	if (at->next) at->next->prev = at->prev;
+	if (at->prev) at->prev->next = at->next;
+	else q->head = at->next;
+
+	/* Signal aio worker threads waiting for sequenced operations. */
+	pthread_cond_broadcast(&q->cond);
+
+	__aio_unref_queue(q);
+
+	if (sev.sigev_notify == SIGEV_SIGNAL) {
+		siginfo_t si = {
+			.si_signo = sev.sigev_signo,
+			.si_value = sev.sigev_value,
+			.si_code = SI_ASYNCIO,
+			.si_pid = getpid(),
+			.si_uid = getuid()
+		};
+		__syscall(SYS_rt_sigqueueinfo, si.si_pid, si.si_signo, &si);
+	}
+	if (sev.sigev_notify == SIGEV_THREAD) {
+		a_store(&__pthread_self()->cancel, 0);
+		sev.sigev_notify_function(sev.sigev_value);
+	}
+}
+
+static void *io_thread_func(void *ctx)
+{
+	struct aio_thread at, *p;
+
+	struct aio_args *args = ctx;
+	struct aiocb *cb = args->cb;
+	int fd = cb->aio_fildes;
+	int op = args->op;
+	void *buf = (void *)cb->aio_buf;
+	size_t len = cb->aio_nbytes;
+	off_t off = cb->aio_offset;
+
+	struct aio_queue *q = args->q;
+	ssize_t ret;
+
+	pthread_mutex_lock(&q->lock);
+	sem_post(&args->sem);
+
+	at.op = op;
+	at.running = 1;
+	at.ret = -1;
+	at.err = ECANCELED;
+	at.q = q;
+	at.td = __pthread_self();
+	at.cb = cb;
+	at.prev = 0;
+	if ((at.next = q->head)) at.next->prev = &at;
+	q->head = &at;
+
+	if (!q->init) {
+		int seekable = lseek(fd, 0, SEEK_CUR) >= 0;
+		q->seekable = seekable;
+		q->append = !seekable || (fcntl(fd, F_GETFL) & O_APPEND);
+		q->init = 1;
+	}
+
+	pthread_cleanup_push(cleanup, &at);
+
+	/* Wait for sequenced operations. */
+	if (op!=LIO_READ && (op!=LIO_WRITE || q->append)) {
+		for (;;) {
+			for (p=at.next; p && p->op!=LIO_WRITE; p=p->next);
+			if (!p) break;
+			pthread_cond_wait(&q->cond, &q->lock);
+		}
+	}
+
+	pthread_mutex_unlock(&q->lock);
+
+	switch (op) {
+	case LIO_WRITE:
+		ret = q->append ? write(fd, buf, len) : pwrite(fd, buf, len, off);
+		break;
+	case LIO_READ:
+		ret = !q->seekable ? read(fd, buf, len) : pread(fd, buf, len, off);
+		break;
+	case O_SYNC:
+		ret = fsync(fd);
+		break;
+	case O_DSYNC:
+		ret = fdatasync(fd);
+		break;
+	}
+	at.ret = ret;
+	at.err = ret<0 ? errno : 0;
+	
+	pthread_cleanup_pop(1);
+
+	return 0;
+}
+
+static size_t io_thread_stack_size = MINSIGSTKSZ+2048;
+static pthread_once_t init_stack_size_once;
+
+static void init_stack_size()
+{
+	unsigned long val = __getauxval(AT_MINSIGSTKSZ);
+	if (val > MINSIGSTKSZ) io_thread_stack_size = val + 512;
+}
+
+static int submit(struct aiocb *cb, int op)
+{
+	int ret = 0;
+	pthread_attr_t a;
+	sigset_t allmask, origmask;
+	pthread_t td;
+	struct aio_queue *q = __aio_get_queue(cb->aio_fildes, 1);
+	struct aio_args args = { .cb = cb, .op = op, .q = q };
+	sem_init(&args.sem, 0, 0);
+
+	if (!q) {
+		if (errno != EBADF) errno = EAGAIN;
+		cb->__ret = -1;
+		cb->__err = errno;
+		return -1;
+	}
+	q->ref++;
+	pthread_mutex_unlock(&q->lock);
+
+	if (cb->aio_sigevent.sigev_notify == SIGEV_THREAD) {
+		if (cb->aio_sigevent.sigev_notify_attributes)
+			a = *cb->aio_sigevent.sigev_notify_attributes;
+		else
+			pthread_attr_init(&a);
+	} else {
+		pthread_once(&init_stack_size_once, init_stack_size);
+		pthread_attr_init(&a);
+		pthread_attr_setstacksize(&a, io_thread_stack_size);
+		pthread_attr_setguardsize(&a, 0);
+	}
+	pthread_attr_setdetachstate(&a, PTHREAD_CREATE_DETACHED);
+	sigfillset(&allmask);
+	pthread_sigmask(SIG_BLOCK, &allmask, &origmask);
+	cb->__err = EINPROGRESS;
+	if (pthread_create(&td, &a, io_thread_func, &args)) {
+		pthread_mutex_lock(&q->lock);
+		__aio_unref_queue(q);
+		cb->__err = errno = EAGAIN;
+		cb->__ret = ret = -1;
+	}
+	pthread_sigmask(SIG_SETMASK, &origmask, 0);
+
+	if (!ret) {
+		while (sem_wait(&args.sem));
+	}
+
+	return ret;
+}
+
+int aio_read(struct aiocb *cb)
+{
+	unsupported_api(__FUNCTION__);
+	return submit(cb, LIO_READ);
+}
+
+int aio_write(struct aiocb *cb)
+{
+	unsupported_api(__FUNCTION__);
+	return submit(cb, LIO_WRITE);
+}
+
+int aio_fsync(int op, struct aiocb *cb)
+{
+	unsupported_api(__FUNCTION__);
+	if (op != O_SYNC && op != O_DSYNC) {
+		errno = EINVAL;
+		return -1;
+	}
+	return submit(cb, op);
+}
+
+ssize_t aio_return(struct aiocb *cb)
+{
+	unsupported_api(__FUNCTION__);
+	return cb->__ret;
+}
+
+int aio_error(const struct aiocb *cb)
+{
+	unsupported_api(__FUNCTION__);
+	a_barrier();
+	return cb->__err & 0x7fffffff;
+}
+
+int aio_cancel(int fd, struct aiocb *cb)
+{
+	sigset_t allmask, origmask;
+	int ret = AIO_ALLDONE;
+	struct aio_thread *p;
+	struct aio_queue *q;
+
+	unsupported_api(__FUNCTION__);
+	/* Unspecified behavior case. Report an error. */
+	if (cb && fd != cb->aio_fildes) {
+		errno = EINVAL;
+		return -1;
+	}
+
+	sigfillset(&allmask);
+	pthread_sigmask(SIG_BLOCK, &allmask, &origmask);
+
+	errno = ENOENT;
+	if (!(q = __aio_get_queue(fd, 0))) {
+		if (errno == EBADF) ret = -1;
+		goto done;
+	}
+
+	for (p = q->head; p; p = p->next) {
+		if (cb && cb != p->cb) continue;
+		/* Transition target from running to running-with-waiters */
+		if (a_cas(&p->running, 1, -1)) {
+			pthread_cancel(p->td);
+			__wait(&p->running, 0, -1, 1);
+			if (p->err == ECANCELED) ret = AIO_CANCELED;
+		}
+	}
+
+	pthread_mutex_unlock(&q->lock);
+done:
+	pthread_sigmask(SIG_SETMASK, &origmask, 0);
+	return ret;
+}
+
+int __aio_close(int fd)
+{
+	a_barrier();
+	if (aio_fd_cnt) aio_cancel(fd, 0);
+	return fd;
+}
+
+weak_alias(aio_cancel, aio_cancel64);
+weak_alias(aio_error, aio_error64);
+weak_alias(aio_fsync, aio_fsync64);
+weak_alias(aio_read, aio_read64);
+weak_alias(aio_write, aio_write64);
+weak_alias(aio_return, aio_return64);
diff --git a/third_party/musl/porting/liteos_a/user/src/aio/aio_suspend.c b/third_party/musl/porting/liteos_a/user/src/aio/aio_suspend.c
new file mode 100755
index 000000000..3fc0301fd
--- /dev/null
+++ b/third_party/musl/porting/liteos_a/user/src/aio/aio_suspend.c
@@ -0,0 +1,80 @@
+#include <aio.h>
+#include <errno.h>
+#include <time.h>
+#include <unsupported_api.h>
+#include "atomic.h"
+#include "pthread_impl.h"
+
+int aio_suspend(const struct aiocb *const cbs[], int cnt, const struct timespec *ts)
+{
+	int i, tid = 0, ret, expect = 0;
+	struct timespec at;
+	volatile int dummy_fut, *pfut;
+	int nzcnt = 0;
+	const struct aiocb *cb = 0;
+
+	unsupported_api(__FUNCTION__);
+	pthread_testcancel();
+
+	if (cnt<0) {
+		errno = EINVAL;
+		return -1;
+	}
+
+	for (i=0; i<cnt; i++) if (cbs[i]) {
+		if (aio_error(cbs[i]) != EINPROGRESS) return 0;
+		nzcnt++;
+		cb = cbs[i];
+	}
+
+	if (ts) {
+		clock_gettime(CLOCK_MONOTONIC, &at);
+		at.tv_sec += ts->tv_sec;
+		if ((at.tv_nsec += ts->tv_nsec) >= 1000000000) {
+			at.tv_nsec -= 1000000000;
+			at.tv_sec++;
+		}
+	}
+
+	for (;;) {
+		for (i=0; i<cnt; i++)
+			if (cbs[i] && aio_error(cbs[i]) != EINPROGRESS)
+				return 0;
+
+		switch (nzcnt) {
+		case 0:
+			pfut = &dummy_fut;
+			break;
+		case 1:
+			pfut = (void *)&cb->__err;
+			expect = EINPROGRESS | 0x80000000;
+			a_cas(pfut, EINPROGRESS, expect);
+			break;
+		default:
+			pfut = &__aio_fut;
+			if (!tid) tid = __pthread_self()->tid;
+			expect = a_cas(pfut, 0, tid);
+			if (!expect) expect = tid;
+			/* Need to recheck the predicate before waiting. */
+			for (i=0; i<cnt; i++)
+				if (cbs[i] && aio_error(cbs[i]) != EINPROGRESS)
+					return 0;
+			break;
+		}
+
+		ret = __timedwait_cp(pfut, expect, CLOCK_MONOTONIC, ts?&at:0, 1);
+
+		switch (ret) {
+		case ETIMEDOUT:
+			ret = EAGAIN;
+		case ECANCELED:
+		case EINTR:
+			errno = ret;
+			return -1;
+		}
+	}
+}
+
+#if !_REDIR_TIME64
+weak_alias(aio_suspend, aio_suspend64);
+#endif
diff --git a/third_party/musl/porting/liteos_a/user/src/aio/lio_listio.c b/third_party/musl/porting/liteos_a/user/src/aio/lio_listio.c
new file mode 100755
index 000000000..545e07718
--- /dev/null
+++ b/third_party/musl/porting/liteos_a/user/src/aio/lio_listio.c
@@ -0,0 +1,146 @@
+#include <aio.h>
+#include <errno.h>
+#include <unistd.h>
+#include <string.h>
+#include "pthread_impl.h"
+#include <unsupported_api.h>
+
+struct lio_state {
+	struct sigevent *sev;
+	int cnt;
+	struct aiocb *cbs[];
+};
+
+static int lio_wait(struct lio_state *st)
+{
+	int i, err, got_err = 0;
+	int cnt = st->cnt;
+	struct aiocb **cbs = st->cbs;
+
+	for (;;) {
+		for (i=0; i<cnt; i++) {
+			if (!cbs[i]) continue;
+			err = aio_error(cbs[i]);
+			if (err==EINPROGRESS)
+				break;
+			if (err) got_err=1;
+			cbs[i] = 0;
+		}
+		if (i==cnt) {
+			if (got_err) {
+				errno = EIO;
+				return -1;
+			}
+			return 0;
+		}
+		if (aio_suspend((void *)cbs, cnt, 0))
+			return -1;
+	}
+}
+
+static void notify_signal(struct sigevent *sev)
+{
+	siginfo_t si = {
+		.si_signo = sev->sigev_signo,
+		.si_value = sev->sigev_value,
+		.si_code = SI_ASYNCIO,
+		.si_pid = getpid(),
+		.si_uid = getuid()
+	};
+	__syscall(SYS_rt_sigqueueinfo, si.si_pid, si.si_signo, &si);
+}
+
+static void *wait_thread(void *p)
+{
+	struct lio_state *st = p;
+	struct sigevent *sev = st->sev;
+	lio_wait(st);
+	free(st);
+	switch (sev->sigev_notify) {
+	case SIGEV_SIGNAL:
+		notify_signal(sev);
+		break;
+	case SIGEV_THREAD:
+		sev->sigev_notify_function(sev->sigev_value);
+		break;
+	}
+	return 0;
+}
+
+int lio_listio(int mode, struct aiocb *restrict const *restrict cbs, int cnt, struct sigevent *restrict sev)
+{
+	unsupported_api(__FUNCTION__);
+
+	int i, ret;
+	struct lio_state *st=0;
+
+	if (cnt < 0) {
+		errno = EINVAL;
+		return -1;
+	}
+
+	if (mode == LIO_WAIT || (sev && sev->sigev_notify != SIGEV_NONE)) {
+		if (!(st = malloc(sizeof *st + cnt*sizeof *cbs))) {
+			errno = EAGAIN;
+			return -1;
+		}
+		st->cnt = cnt;
+		st->sev = sev;
+		memcpy(st->cbs, (void*) cbs, cnt*sizeof *cbs);
+	}
+
+	for (i=0; i<cnt; i++) {
+		if (!cbs[i]) continue;
+		switch (cbs[i]->aio_lio_opcode) {
+		case LIO_READ:
+			ret = aio_read(cbs[i]);
+			break;
+		case LIO_WRITE:
+			ret = aio_write(cbs[i]);
+			break;
+		default:
+			continue;
+		}
+		if (ret) {
+			free(st);
+			errno = EAGAIN;
+			return -1;
+		}
+	}
+
+	if (mode == LIO_WAIT) {
+		ret = lio_wait(st);
+		free(st);
+		return ret;
+	}
+
+	if (st) {
+		pthread_attr_t a;
+		sigset_t set, set_old;
+		pthread_t td;
+
+		if (sev->sigev_notify == SIGEV_THREAD) {
+			if (sev->sigev_notify_attributes)
+				a = *sev->sigev_notify_attributes;
+			else
+				pthread_attr_init(&a);
+		} else {
+			pthread_attr_init(&a);
+			pthread_attr_setstacksize(&a, PAGE_SIZE);
+			pthread_attr_setguardsize(&a, 0);
+		}
+		pthread_attr_setdetachstate(&a, PTHREAD_CREATE_DETACHED);
+		sigfillset(&set);
+		pthread_sigmask(SIG_BLOCK, &set, &set_old);
+		if (pthread_create(&td, &a, wait_thread, st)) {
+			free(st);
+			errno = EAGAIN;
+			return -1;
+		}
+		pthread_sigmask(SIG_SETMASK, &set_old, 0);
+	}
+
+	return 0;
+}
+
+weak_alias(lio_listio, lio_listio64);
diff --git a/third_party/musl/porting/liteos_a/user/src/conf/confstr.c b/third_party/musl/porting/liteos_a/user/src/conf/confstr.c
new file mode 100755
index 000000000..3fa863c73
--- /dev/null
+++ b/third_party/musl/porting/liteos_a/user/src/conf/confstr.c
@@ -0,0 +1,20 @@
+#include <unistd.h>
+#include <stdio.h>
+#include <errno.h>
+#include <unsupported_api.h>
+
+size_t confstr(int name, char *buf, size_t len)
+{
+	const char *s = "";
+
+	unsupported_api(__FUNCTION__);
+	if (!name) {
+		s = "/bin:/usr/bin";
+	} else if ((name&~4U)!=1 && name-_CS_POSIX_V6_ILP32_OFF32_CFLAGS>33U) {
+		errno = EINVAL;
+		return 0;
+	}
+	// snprintf is overkill but avoid wasting code size to implement
+	// this completely useless function and its truncation semantics
+	return snprintf(buf, len, "%s", s) + 1;
+}
diff --git a/third_party/musl/porting/liteos_a/user/src/conf/sysconf.c b/third_party/musl/porting/liteos_a/user/src/conf/sysconf.c
new file mode 100755
index 000000000..994e38e26
--- /dev/null
+++ b/third_party/musl/porting/liteos_a/user/src/conf/sysconf.c
@@ -0,0 +1,220 @@
+#include <unistd.h>
+#include <limits.h>
+#include <errno.h>
+#include <sys/resource.h>
+#include <signal.h>
+#include <sys/sysinfo.h>
+#include <unsupported_api.h>
+#include "syscall.h"
+#include "libc.h"
+
+#define JT(x) (-256|(x))
+#define VER JT(1)
+#define JT_ARG_MAX JT(2)
+#define JT_MQ_PRIO_MAX JT(3)
+#define JT_PAGE_SIZE JT(4)
+#define JT_SEM_VALUE_MAX JT(5)
+#define JT_NPROCESSORS_CONF JT(6)
+#define JT_NPROCESSORS_ONLN JT(7)
+#define JT_PHYS_PAGES JT(8)
+#define JT_AVPHYS_PAGES JT(9)
+#define JT_ZERO JT(10)
+#define JT_DELAYTIMER_MAX JT(11)
+
+#define RLIM(x) (-32768|(RLIMIT_ ## x))
+
+long sysconf(int name)
+{
+	static const short values[] = {
+		[_SC_ARG_MAX] = JT_ARG_MAX,
+		[_SC_CHILD_MAX] = RLIM(NPROC),
+		[_SC_CLK_TCK] = 100,
+		[_SC_NGROUPS_MAX] = 32,
+		[_SC_OPEN_MAX] = RLIM(NOFILE),
+		[_SC_STREAM_MAX] = -1,
+		[_SC_TZNAME_MAX] = TZNAME_MAX,
+		[_SC_JOB_CONTROL] = 1,
+		[_SC_SAVED_IDS] = 1,
+		[_SC_REALTIME_SIGNALS] = VER,
+		[_SC_PRIORITY_SCHEDULING] = -1,
+		[_SC_TIMERS] = VER,
+		[_SC_ASYNCHRONOUS_IO] = VER,
+		[_SC_PRIORITIZED_IO] = -1,
+		[_SC_SYNCHRONIZED_IO] = -1,
+		[_SC_FSYNC] = VER,
+		[_SC_MAPPED_FILES] = VER,
+		[_SC_MEMLOCK] = VER,
+		[_SC_MEMLOCK_RANGE] = VER,
+		[_SC_MEMORY_PROTECTION] = VER,
+		[_SC_MESSAGE_PASSING] = VER,
+		[_SC_SEMAPHORES] = VER,
+		[_SC_SHARED_MEMORY_OBJECTS] = VER,
+		[_SC_AIO_LISTIO_MAX] = -1,
+		[_SC_AIO_MAX] = -1,
+		[_SC_AIO_PRIO_DELTA_MAX] = JT_ZERO, /* ?? */
+		[_SC_DELAYTIMER_MAX] = JT_DELAYTIMER_MAX,
+		[_SC_MQ_OPEN_MAX] = -1,
+		[_SC_MQ_PRIO_MAX] = JT_MQ_PRIO_MAX,
+		[_SC_VERSION] = VER,
+		[_SC_PAGE_SIZE] = JT_PAGE_SIZE,
+		[_SC_RTSIG_MAX] = _NSIG - 1 - 31 - 3,
+		[_SC_SEM_NSEMS_MAX] = SEM_NSEMS_MAX,
+		[_SC_SEM_VALUE_MAX] = JT_SEM_VALUE_MAX,
+		[_SC_SIGQUEUE_MAX] = -1,
+		[_SC_TIMER_MAX] = -1,
+		[_SC_BC_BASE_MAX] = _POSIX2_BC_BASE_MAX,
+		[_SC_BC_DIM_MAX] = _POSIX2_BC_DIM_MAX,
+		[_SC_BC_SCALE_MAX] = _POSIX2_BC_SCALE_MAX,
+		[_SC_BC_STRING_MAX] = _POSIX2_BC_STRING_MAX,
+		[_SC_COLL_WEIGHTS_MAX] = COLL_WEIGHTS_MAX,
+		[_SC_EXPR_NEST_MAX] = -1,
+		[_SC_LINE_MAX] = -1,
+		[_SC_RE_DUP_MAX] = RE_DUP_MAX,
+		[_SC_2_VERSION] = VER,
+		[_SC_2_C_BIND] = VER,
+		[_SC_2_C_DEV] = -1,
+		[_SC_2_FORT_DEV] = -1,
+		[_SC_2_FORT_RUN] = -1,
+		[_SC_2_SW_DEV] = -1,
+		[_SC_2_LOCALEDEF] = -1,
+		[_SC_IOV_MAX] = IOV_MAX,
+		[_SC_THREADS] = VER,
+		[_SC_THREAD_SAFE_FUNCTIONS] = VER,
+		[_SC_GETGR_R_SIZE_MAX] = -1,
+		[_SC_GETPW_R_SIZE_MAX] = -1,
+		[_SC_LOGIN_NAME_MAX] = 256,
+		[_SC_TTY_NAME_MAX] = TTY_NAME_MAX,
+		[_SC_THREAD_DESTRUCTOR_ITERATIONS] = PTHREAD_DESTRUCTOR_ITERATIONS,
+		[_SC_THREAD_KEYS_MAX] = PTHREAD_KEYS_MAX,
+		[_SC_THREAD_STACK_MIN] = PTHREAD_STACK_MIN,
+		[_SC_THREAD_THREADS_MAX] = -1,
+		[_SC_THREAD_ATTR_STACKADDR] = VER,
+		[_SC_THREAD_ATTR_STACKSIZE] = VER,
+		[_SC_THREAD_PRIORITY_SCHEDULING] = VER,
+		[_SC_THREAD_PRIO_INHERIT] = -1,
+		[_SC_THREAD_PRIO_PROTECT] = -1,
+		[_SC_THREAD_PROCESS_SHARED] = VER,
+		[_SC_NPROCESSORS_CONF] = JT_NPROCESSORS_CONF,
+		[_SC_NPROCESSORS_ONLN] = JT_NPROCESSORS_ONLN,
+		[_SC_PHYS_PAGES] = JT_PHYS_PAGES,
+		[_SC_AVPHYS_PAGES] = JT_AVPHYS_PAGES,
+		[_SC_ATEXIT_MAX] = -1,
+		[_SC_PASS_MAX] = -1,
+		[_SC_XOPEN_VERSION] = _XOPEN_VERSION,
+		[_SC_XOPEN_XCU_VERSION] = _XOPEN_VERSION,
+		[_SC_XOPEN_UNIX] = 1,
+		[_SC_XOPEN_CRYPT] = -1,
+		[_SC_XOPEN_ENH_I18N] = 1,
+		[_SC_XOPEN_SHM] = 1,
+		[_SC_2_CHAR_TERM] = -1,
+		[_SC_2_UPE] = -1,
+		[_SC_XOPEN_XPG2] = -1,
+		[_SC_XOPEN_XPG3] = -1,
+		[_SC_XOPEN_XPG4] = -1,
+		[_SC_NZERO] = NZERO,
+		[_SC_XBS5_ILP32_OFF32] = -1,
+		[_SC_XBS5_ILP32_OFFBIG] = sizeof(long)==4 ? 1 : -1,
+		[_SC_XBS5_LP64_OFF64] = sizeof(long)==8 ? 1 : -1,
+		[_SC_XBS5_LPBIG_OFFBIG] = -1,
+		[_SC_XOPEN_LEGACY] = -1,
+		[_SC_XOPEN_REALTIME] = -1,
+		[_SC_XOPEN_REALTIME_THREADS] = -1,
+		[_SC_ADVISORY_INFO] = VER,
+		[_SC_BARRIERS] = VER,
+		[_SC_CLOCK_SELECTION] = VER,
+		[_SC_CPUTIME] = VER,
+		[_SC_THREAD_CPUTIME] = VER,
+		[_SC_MONOTONIC_CLOCK] = VER,
+		[_SC_READER_WRITER_LOCKS] = VER,
+		[_SC_SPIN_LOCKS] = VER,
+		[_SC_REGEXP] = 1,
+		[_SC_SHELL] = 1,
+		[_SC_SPAWN] = VER,
+		[_SC_SPORADIC_SERVER] = -1,
+		[_SC_THREAD_SPORADIC_SERVER] = -1,
+		[_SC_TIMEOUTS] = VER,
+		[_SC_TYPED_MEMORY_OBJECTS] = -1,
+		[_SC_2_PBS] = -1,
+		[_SC_2_PBS_ACCOUNTING] = -1,
+		[_SC_2_PBS_LOCATE] = -1,
+		[_SC_2_PBS_MESSAGE] = -1,
+		[_SC_2_PBS_TRACK] = -1,
+		[_SC_SYMLOOP_MAX] = SYMLOOP_MAX,
+		[_SC_STREAMS] = JT_ZERO,
+		[_SC_2_PBS_CHECKPOINT] = -1,
+		[_SC_V6_ILP32_OFF32] = -1,
+		[_SC_V6_ILP32_OFFBIG] = sizeof(long)==4 ? 1 : -1,
+		[_SC_V6_LP64_OFF64] = sizeof(long)==8 ? 1 : -1,
+		[_SC_V6_LPBIG_OFFBIG] = -1,
+		[_SC_HOST_NAME_MAX] = HOST_NAME_MAX,
+		[_SC_TRACE] = -1,
+		[_SC_TRACE_EVENT_FILTER] = -1,
+		[_SC_TRACE_INHERIT] = -1,
+		[_SC_TRACE_LOG] = -1,
+
+		[_SC_IPV6] = VER,
+		[_SC_RAW_SOCKETS] = VER,
+		[_SC_V7_ILP32_OFF32] = -1,
+		[_SC_V7_ILP32_OFFBIG] = sizeof(long)==4 ? 1 : -1,
+		[_SC_V7_LP64_OFF64] = sizeof(long)==8 ? 1 : -1,
+		[_SC_V7_LPBIG_OFFBIG] = -1,
+		[_SC_SS_REPL_MAX] = -1,
+		[_SC_TRACE_EVENT_NAME_MAX] = -1,
+		[_SC_TRACE_NAME_MAX] = -1,
+		[_SC_TRACE_SYS_MAX] = -1,
+		[_SC_TRACE_USER_EVENT_MAX] = -1,
+		[_SC_XOPEN_STREAMS] = JT_ZERO,
+		[_SC_THREAD_ROBUST_PRIO_INHERIT] = -1,
+		[_SC_THREAD_ROBUST_PRIO_PROTECT] = -1,
+	};
+	unsupported_api(__FUNCTION__);
+	if (name >= sizeof(values)/sizeof(values[0]) || !values[name]) {
+		errno = EINVAL;
+		return -1;
+	} else if (values[name] >= -1) {
+		return values[name];
+	} else if (values[name] < -256) {
+		struct rlimit lim;
+		getrlimit(values[name]&16383, &lim);
+		if (lim.rlim_cur == RLIM_INFINITY)
+			return -1;
+		return lim.rlim_cur > LONG_MAX ? LONG_MAX : lim.rlim_cur;
+	}
+
+	switch ((unsigned char)values[name]) {
+	case VER & 255:
+		return _POSIX_VERSION;
+	case JT_ARG_MAX & 255:
+		return ARG_MAX;
+	case JT_MQ_PRIO_MAX & 255:
+		return MQ_PRIO_MAX;
+	case JT_PAGE_SIZE & 255:
+		return PAGE_SIZE;
+	case JT_SEM_VALUE_MAX & 255:
+		return SEM_VALUE_MAX;
+	case JT_DELAYTIMER_MAX & 255:
+		return DELAYTIMER_MAX;
+	case JT_NPROCESSORS_CONF & 255:
+	case JT_NPROCESSORS_ONLN & 255: ;
+		unsigned char set[128] = {1};
+		int i, cnt;
+		__syscall(SYS_sched_getaffinity, 0, sizeof set, set);
+		for (i=cnt=0; i<sizeof set; i++)
+			for (; set[i]; set[i]&=set[i]-1, cnt++);
+		return cnt;
+	case JT_PHYS_PAGES & 255:
+	case JT_AVPHYS_PAGES & 255: ;
+		unsigned long long mem;
+		struct sysinfo si;
+		__lsysinfo(&si);
+		if (!si.mem_unit) si.mem_unit = 1;
+		if (name==_SC_PHYS_PAGES) mem = si.totalram;
+		else mem = si.freeram + si.bufferram;
+		mem *= si.mem_unit;
+		mem /= PAGE_SIZE;
+		return (mem > LONG_MAX) ? LONG_MAX : mem;
+	case JT_ZERO & 255:
+		return 0;
+	}
+	return values[name];
+}
diff --git a/third_party/musl/porting/liteos_a/user/src/crypt/encrypt.c b/third_party/musl/porting/liteos_a/user/src/crypt/encrypt.c
new file mode 100755
index 000000000..5a3f6503a
--- /dev/null
+++ b/third_party/musl/porting/liteos_a/user/src/crypt/encrypt.c
@@ -0,0 +1,55 @@
+#include <stdint.h>
+#include <stdlib.h>
+#include <unistd.h>
+#include <unsupported_api.h>
+
+#include "crypt_des.h"
+
+static struct expanded_key __encrypt_key;
+
+void setkey(const char *key)
+{
+	unsigned char bkey[8];
+	int i, j;
+
+	unsupported_api(__FUNCTION__);
+	for (i = 0; i < 8; i++) {
+		bkey[i] = 0;
+		for (j = 7; j >= 0; j--, key++)
+			bkey[i] |= (uint32_t)(*key & 1) << j;
+	}
+
+	__des_setkey(bkey, &__encrypt_key);
+}
+
+void encrypt(char *block, int edflag)
+{
+	struct expanded_key decrypt_key, *key;
+	uint32_t b[2];
+	int i, j;
+	char *p;
+
+	unsupported_api(__FUNCTION__);
+	p = block;
+	for (i = 0; i < 2; i++) {
+		b[i] = 0;
+		for (j = 31; j >= 0; j--, p++)
+			b[i] |= (uint32_t)(*p & 1) << j;
+	}
+
+	key = &__encrypt_key;
+	if (edflag) {
+		key = &decrypt_key;
+		for (i = 0; i < 16; i++) {
+			decrypt_key.l[i] = __encrypt_key.l[15-i];
+			decrypt_key.r[i] = __encrypt_key.r[15-i];
+		}
+	}
+
+	__do_des(b[0], b[1], b, b + 1, 1, 0, key);
+
+	p = block;
+	for (i = 0; i < 2; i++)
+		for (j = 31; j >= 0; j--)
+			*p++ = b[i]>>j & 1;
+}
diff --git a/third_party/musl/porting/liteos_a/user/src/ctype/wcswidth.c b/third_party/musl/porting/liteos_a/user/src/ctype/wcswidth.c
new file mode 100755
index 000000000..ed0f9f204
--- /dev/null
+++ b/third_party/musl/porting/liteos_a/user/src/ctype/wcswidth.c
@@ -0,0 +1,10 @@
+#include <wchar.h>
+#include <unsupported_api.h>
+
+int wcswidth(const wchar_t *wcs, size_t n)
+{
+	int l=0, k=0;
+	unsupported_api(__FUNCTION__);
+	for (; n-- && *wcs && (k = wcwidth(*wcs)) >= 0; l+=k, wcs++);
+	return (k < 0) ? k : l;
+}
diff --git a/third_party/musl/porting/liteos_a/user/src/dirent/__dirent.h b/third_party/musl/porting/liteos_a/user/src/dirent/__dirent.h
new file mode 100755
index 000000000..5d79b9657
--- /dev/null
+++ b/third_party/musl/porting/liteos_a/user/src/dirent/__dirent.h
@@ -0,0 +1,12 @@
+struct __dirstream
+{
+	off_t tell;
+	int fd;
+	int buf_pos;
+	int buf_end;
+	volatile int lock[1];
+	/* Any changes to this struct must preserve the property:
+	 * offsetof(struct __dirent, buf) % sizeof(off_t) == 0 */
+	// change buf len from 2048 to 4096 to support read 14 dirs at one readdir syscall
+	char buf[4096];
+};
diff --git a/third_party/musl/porting/liteos_a/user/src/env/__init_tls.c b/third_party/musl/porting/liteos_a/user/src/env/__init_tls.c
new file mode 100755
index 000000000..b02f0566d
--- /dev/null
+++ b/third_party/musl/porting/liteos_a/user/src/env/__init_tls.c
@@ -0,0 +1,186 @@
+#define SYSCALL_NO_TLS 1
+#include <elf.h>
+#include <limits.h>
+#include <sys/mman.h>
+#include <string.h>
+#include <stddef.h>
+#include "pthread_impl.h"
+#include "libc.h"
+#include "atomic.h"
+#include "syscall.h"
+#include "stdio_impl.h"
+#include "lock.h"
+
+volatile int __thread_list_lock;
+
+static void *dummy_tsd[1] = { 0 };
+weak_alias(dummy_tsd, __pthread_tsd_main);
+static FILE *volatile dummy_file = 0;
+weak_alias(dummy_file, __stdin_used);
+weak_alias(dummy_file, __stdout_used);
+weak_alias(dummy_file, __stderr_used);
+
+static void dummy_0()
+{
+}
+weak_alias(dummy_0, __membarrier_init);
+
+static void init_file_lock(FILE *f)
+{
+	if (f && f->lock<0) f->lock = 0;
+}
+
+int __init_tp(void *p)
+{
+	pthread_t td = p;
+	int r = __set_thread_area(TP_ADJ(p));
+	if (r < 0) return -1;
+	if (!r) libc.can_do_threads = 1;
+	libc.threads_minus_1 = 1;
+	libc.threaded = 0;
+	td->self = td;
+	td->detach_state = DT_JOINABLE;
+	td->tid = __syscall(SYS_gettid);
+	td->locale = &libc.global_locale;
+	td->robust_list.head = &td->robust_list.head;
+	td->sysinfo = __sysinfo;
+	td->next = td->prev = td;
+	td->tsd = (void **)__pthread_tsd_main;
+	for (FILE *f=*__ofl_lock(); f; f=f->next)
+		init_file_lock(f);
+	__ofl_unlock();
+	init_file_lock(__stdin_used);
+	init_file_lock(__stdout_used);
+	init_file_lock(__stderr_used);
+	__syscall(SYS_rt_sigprocmask, SIG_UNBLOCK, SIGPT_SET, 0, _NSIG/8);
+#if 0
+	__membarrier_init();
+#endif
+	libc.threaded = 1;
+	return 0;
+}
+
+static struct builtin_tls {
+	char c;
+	struct pthread pt;
+	void *space[16];
+} builtin_tls[1];
+#define MIN_TLS_ALIGN offsetof(struct builtin_tls, pt)
+
+static struct tls_module main_tls;
+
+void *__copy_tls(unsigned char *mem)
+{
+	pthread_t td;
+	struct tls_module *p;
+	size_t i;
+	uintptr_t *dtv;
+
+#ifdef TLS_ABOVE_TP
+	dtv = (uintptr_t*)(mem + libc.tls_size) - (libc.tls_cnt + 1);
+
+	mem += -((uintptr_t)mem + sizeof(struct pthread)) & (libc.tls_align-1);
+	td = (pthread_t)mem;
+	mem += sizeof(struct pthread);
+
+	for (i=1, p=libc.tls_head; p; i++, p=p->next) {
+		dtv[i] = (uintptr_t)(mem + p->offset) + DTP_OFFSET;
+		memcpy(mem + p->offset, p->image, p->len);
+	}
+#else
+	dtv = (uintptr_t *)mem;
+
+	mem += libc.tls_size - sizeof(struct pthread);
+	mem -= (uintptr_t)mem & (libc.tls_align-1);
+	td = (pthread_t)mem;
+
+	for (i=1, p=libc.tls_head; p; i++, p=p->next) {
+		dtv[i] = (uintptr_t)(mem - p->offset) + DTP_OFFSET;
+		memcpy(mem - p->offset, p->image, p->len);
+	}
+#endif
+	dtv[0] = libc.tls_cnt;
+	td->dtv = td->dtv_copy = dtv;
+	return td;
+}
+
+#if ULONG_MAX == 0xffffffff
+typedef Elf32_Phdr Phdr;
+#else
+typedef Elf64_Phdr Phdr;
+#endif
+
+extern weak hidden const size_t _DYNAMIC[];
+
+static void static_init_tls(size_t *aux)
+{
+	unsigned char *p;
+	size_t n;
+	Phdr *phdr, *tls_phdr=0;
+	size_t base = 0;
+	void *mem;
+
+	for (p=(void *)aux[AT_PHDR],n=aux[AT_PHNUM]; n; n--,p+=aux[AT_PHENT]) {
+		phdr = (void *)p;
+		if (phdr->p_type == PT_PHDR)
+			base = aux[AT_PHDR] - phdr->p_vaddr;
+		if (phdr->p_type == PT_DYNAMIC && _DYNAMIC)
+			base = (size_t)_DYNAMIC - phdr->p_vaddr;
+		if (phdr->p_type == PT_TLS)
+			tls_phdr = phdr;
+		if (phdr->p_type == PT_GNU_STACK &&
+		    phdr->p_memsz > __default_stacksize)
+			__default_stacksize =
+				phdr->p_memsz < DEFAULT_STACK_MAX ?
+				phdr->p_memsz : DEFAULT_STACK_MAX;
+	}
+
+	if (tls_phdr) {
+		main_tls.image = (void *)(base + tls_phdr->p_vaddr);
+		main_tls.len = tls_phdr->p_filesz;
+		main_tls.size = tls_phdr->p_memsz;
+		main_tls.align = tls_phdr->p_align;
+		libc.tls_cnt = 1;
+		libc.tls_head = &main_tls;
+	}
+
+	main_tls.size += (-main_tls.size - (uintptr_t)main_tls.image)
+		& (main_tls.align-1);
+#ifdef TLS_ABOVE_TP
+	main_tls.offset = GAP_ABOVE_TP;
+	main_tls.offset += (-GAP_ABOVE_TP + (uintptr_t)main_tls.image)
+		& (main_tls.align-1);
+#else
+	main_tls.offset = main_tls.size;
+#endif
+	if (main_tls.align < MIN_TLS_ALIGN) main_tls.align = MIN_TLS_ALIGN;
+
+	libc.tls_align = main_tls.align;
+	libc.tls_size = 2*sizeof(void *) + sizeof(struct pthread)
+#ifdef TLS_ABOVE_TP
+		+ main_tls.offset
+#endif
+		+ main_tls.size + main_tls.align
+		+ MIN_TLS_ALIGN-1 & -MIN_TLS_ALIGN;
+
+	if (libc.tls_size > sizeof builtin_tls) {
+#ifndef SYS_mmap2
+#define SYS_mmap2 SYS_mmap
+#endif
+		mem = (void *)__syscall(
+			SYS_mmap2,
+			0, libc.tls_size, PROT_READ|PROT_WRITE,
+			MAP_ANONYMOUS|MAP_PRIVATE, -1, 0);
+		/* -4095...-1 cast to void * will crash on dereference anyway,
+		 * so don't bloat the init code checking for error codes and
+		 * explicitly calling a_crash(). */
+	} else {
+		mem = builtin_tls;
+	}
+
+	/* Failure to initialize thread pointer is always fatal. */
+	if (__init_tp(__copy_tls(mem)) < 0)
+		a_crash();
+}
+
+weak_alias(static_init_tls, __init_tls);
diff --git a/third_party/musl/porting/liteos_a/user/src/env/__libc_start_main.c b/third_party/musl/porting/liteos_a/user/src/env/__libc_start_main.c
new file mode 100755
index 000000000..9f0fec0e4
--- /dev/null
+++ b/third_party/musl/porting/liteos_a/user/src/env/__libc_start_main.c
@@ -0,0 +1,97 @@
+#include <elf.h>
+#include <poll.h>
+#include <fcntl.h>
+#include <signal.h>
+#include <unistd.h>
+#include "syscall.h"
+#include "atomic.h"
+#include "libc.h"
+
+static void dummy(void) {}
+weak_alias(dummy, _init);
+
+extern weak hidden void (*const __init_array_start)(void), (*const __init_array_end)(void);
+
+static void dummy1(void *p) {}
+weak_alias(dummy1, __init_ssp);
+
+#define AUX_CNT 38
+
+#ifdef __GNUC__
+__attribute__((__noinline__))
+#endif
+void __init_libc(char **envp, char *pn)
+{
+	size_t i, *auxv, aux[AUX_CNT] = { 0 };
+	__environ = envp;
+	for (i=0; envp[i]; i++);
+	libc.auxv = auxv = (void *)(envp+i+1);
+	for (i=0; auxv[i]; i+=2) if (auxv[i]<AUX_CNT) aux[auxv[i]] = auxv[i+1];
+	__hwcap = aux[AT_HWCAP];
+	if (aux[AT_SYSINFO]) __sysinfo = aux[AT_SYSINFO];
+	libc.page_size = aux[AT_PAGESZ];
+
+	if (!pn) pn = (void*)aux[AT_EXECFN];
+	if (!pn) pn = "";
+	__progname = __progname_full = pn;
+	for (i=0; pn[i]; i++) if (pn[i]=='/') __progname = pn+i+1;
+
+	__init_tls(aux);
+	__init_ssp((void *)aux[AT_RANDOM]);
+
+	if (aux[AT_UID]==aux[AT_EUID] && aux[AT_GID]==aux[AT_EGID]
+		&& !aux[AT_SECURE]) return;
+
+	struct pollfd pfd[3] = { {.fd=0}, {.fd=1}, {.fd=2} };
+	int r =
+#ifdef SYS_poll
+	__syscall(SYS_poll, pfd, 3, 0);
+#else
+	__syscall(SYS_ppoll, pfd, 3, &(struct timespec){0}, 0, _NSIG/8);
+#endif
+	if (r<0) a_crash();
+	for (i=0; i<3; i++) if (pfd[i].revents&POLLNVAL)
+		if (__sys_open("/dev/null", O_RDWR)<0)
+			a_crash();
+	libc.secure = 1;
+}
+
+static void libc_start_init(void)
+{
+	_init();
+	uintptr_t a = (uintptr_t)&__init_array_start;
+	for (; a<(uintptr_t)&__init_array_end; a+=sizeof(void(*)()))
+		(*(void (**)(void))a)();
+}
+
+weak_alias(libc_start_init, __libc_start_init);
+
+typedef int lsm2_fn(int (*)(int,char **,char **), int, char **);
+static lsm2_fn libc_start_main_stage2;
+
+int __libc_start_main(int (*main)(int,char **,char **), int argc, char **argv)
+{
+	char **envp = argv+argc+1;
+
+	/* External linkage, and explicit noinline attribute if available,
+	 * are used to prevent the stack frame used during init from
+	 * persisting for the entire process lifetime. */
+	__init_libc(envp, argv[0]);
+
+	/* Barrier against hoisting application code or anything using ssp
+	 * or thread pointer prior to its initialization above. */
+	lsm2_fn *stage2 = libc_start_main_stage2;
+	__asm__ ( "" : "+r"(stage2) : : "memory" );
+	return stage2(main, argc, argv);
+}
+
+static int libc_start_main_stage2(int (*main)(int,char **,char **), int argc, char **argv)
+{
+	char **envp = argv+argc+1;
+	__libc_start_init();
+	__sig_init();
+
+	/* Pass control to the application */
+	exit(main(argc, argv, envp));
+	return 0;
+}
diff --git a/third_party/musl/porting/liteos_a/user/src/exit/abort.c b/third_party/musl/porting/liteos_a/user/src/exit/abort.c
new file mode 100755
index 000000000..38ce2c2d4
--- /dev/null
+++ b/third_party/musl/porting/liteos_a/user/src/exit/abort.c
@@ -0,0 +1,38 @@
+#include <stdlib.h>
+#include <signal.h>
+#include "syscall.h"
+#include "pthread_impl.h"
+#include "atomic.h"
+#include "lock.h"
+#include "ksigaction.h"
+
+hidden volatile int __abort_lock[1];
+
+_Noreturn void abort(void)
+{
+	sigset_t set, pending;
+	sigemptyset(&set);
+	sigaddset(&set, SIGABRT);
+
+	sigpending(&pending);
+	__syscall(SYS_rt_sigprocmask, SIG_UNBLOCK, &set, 0, _NSIG / 8);
+	if (!sigismember(&pending, SIGABRT)) {
+		raise(SIGABRT);
+	}
+	/* If there was a SIGABRT handler installed and it returned, or if
+	 * SIGABRT was blocked or ignored, take an AS-safe lock to prevent
+	 * sigaction from installing a new SIGABRT handler, uninstall any
+	 * handler that may be present, and re-raise the signal to generate
+	 * the default action of abnormal termination. */
+	__block_all_sigs(0);
+	LOCK(__abort_lock);
+	signal(SIGABRT, SIG_DFL);
+	__syscall(SYS_tkill, __pthread_self()->tid, SIGABRT);
+	__syscall(SYS_rt_sigprocmask, SIG_UNBLOCK,
+		&(long[_NSIG/(8*sizeof(long))]){1UL<<(SIGABRT-1)}, 0, _NSIG/8);
+
+	/* Beyond this point should be unreachable. */
+	a_crash();
+	raise(SIGKILL);
+	_Exit(127);
+}
diff --git a/third_party/musl/porting/liteos_a/user/src/fcntl/fcntl.c b/third_party/musl/porting/liteos_a/user/src/fcntl/fcntl.c
new file mode 100755
index 000000000..37391e053
--- /dev/null
+++ b/third_party/musl/porting/liteos_a/user/src/fcntl/fcntl.c
@@ -0,0 +1,47 @@
+#define _GNU_SOURCE
+#include <fcntl.h>
+#include <stdarg.h>
+#include <errno.h>
+#include "syscall.h"
+
+int fcntl(int fd, int cmd, ...)
+{
+	unsigned long arg;
+	va_list ap;
+	va_start(ap, cmd);
+	arg = va_arg(ap, unsigned long);
+	va_end(ap);
+	if (cmd == F_SETLKW) return syscall_cp(SYS_fcntl, fd, cmd, (void *)arg);
+	if (cmd == F_GETOWN) {
+		struct f_owner_ex ex;
+		int ret = __syscall(SYS_fcntl, fd, F_GETOWN_EX, &ex);
+		if (ret == -EINVAL) return __syscall(SYS_fcntl, fd, cmd, (void *)arg);
+		if (ret) return __syscall_ret(ret);
+		return ex.type == F_OWNER_PGRP ? -ex.pid : ex.pid;
+	}
+	if (cmd == F_DUPFD_CLOEXEC) {
+		int ret = __syscall(SYS_fcntl, fd, F_DUPFD_CLOEXEC, arg);
+		if (ret != -EINVAL) {
+			if (ret >= 0)
+				__syscall(SYS_fcntl, ret, F_SETFD, FD_CLOEXEC);
+			return __syscall_ret(ret);
+		}
+		ret = __syscall(SYS_fcntl, fd, F_DUPFD_CLOEXEC, 0);
+		if (ret != -EINVAL) {
+			if (ret >= 0) __syscall(SYS_close, ret);
+			return __syscall_ret(-EINVAL);
+		}
+		ret = __syscall(SYS_fcntl, fd, F_DUPFD, arg);
+		if (ret >= 0) __syscall(SYS_fcntl, ret, F_SETFD, FD_CLOEXEC);
+		return __syscall_ret(ret);
+	}
+	switch (cmd) {
+	case F_SETLK:
+	case F_GETLK:
+	case F_GETOWN_EX:
+	case F_SETOWN_EX:
+		return syscall(SYS_fcntl, fd, cmd, (void *)arg);
+	default:
+		return syscall(SYS_fcntl, fd, cmd, arg);
+	}
+}
diff --git a/third_party/musl/porting/liteos_a/user/src/fcntl/posix_fadvise.c b/third_party/musl/porting/liteos_a/user/src/fcntl/posix_fadvise.c
new file mode 100755
index 000000000..641dc56f7
--- /dev/null
+++ b/third_party/musl/porting/liteos_a/user/src/fcntl/posix_fadvise.c
@@ -0,0 +1,21 @@
+#include <fcntl.h>
+#include <unsupported_api.h>
+
+#include "syscall.h"
+
+int posix_fadvise(int fd, off_t base, off_t len, int advice)
+{
+	unsupported_api(__FUNCTION__);
+#if defined(SYSCALL_FADVISE_6_ARG)
+	/* Some archs, at least arm and powerpc, have the syscall
+	 * arguments reordered to avoid needing 7 argument registers
+	 * due to 64-bit argument alignment. */
+	return -__syscall(SYS_fadvise, fd, advice,
+		__SYSCALL_LL_E(base), __SYSCALL_LL_E(len));
+#else
+	return -__syscall(SYS_fadvise, fd, __SYSCALL_LL_O(base),
+		__SYSCALL_LL_E(len), advice);
+#endif
+}
+
+weak_alias(posix_fadvise, posix_fadvise64);
diff --git a/third_party/musl/porting/liteos_a/user/src/internal/libc.h b/third_party/musl/porting/liteos_a/user/src/internal/libc.h
new file mode 100755
index 000000000..da237ed14
--- /dev/null
+++ b/third_party/musl/porting/liteos_a/user/src/internal/libc.h
@@ -0,0 +1,59 @@
+#ifndef LIBC_H
+#define LIBC_H
+
+#include <stdlib.h>
+#include <stdio.h>
+#include <limits.h>
+
+struct __locale_map;
+
+struct __locale_struct {
+	const struct __locale_map *cat[6];
+};
+
+struct tls_module {
+	struct tls_module *next;
+	void *image;
+	size_t len, size, align, offset;
+};
+
+struct __libc {
+	int can_do_threads;
+	int threaded;
+	int secure;
+	volatile int threads_minus_1;
+	size_t *auxv;
+	struct tls_module *tls_head;
+	size_t tls_size, tls_align, tls_cnt;
+	size_t page_size;
+	struct __locale_struct global_locale;
+};
+
+#ifndef PAGE_SIZE
+#define PAGE_SIZE libc.page_size
+#endif
+
+extern hidden struct __libc __libc;
+#define libc __libc
+
+hidden void __init_libc(char **, char *);
+hidden void __init_tls(size_t *);
+hidden void __init_ssp(void *);
+hidden void __libc_start_init(void);
+hidden void __funcs_on_exit(void);
+hidden void __funcs_on_quick_exit(void);
+hidden void __libc_exit_fini(void);
+hidden void __fork_handler(int);
+hidden void __sig_init(void);
+hidden void arm_do_signal(int);
+
+extern hidden size_t __hwcap;
+extern hidden size_t __sysinfo;
+extern char *__progname, *__progname_full;
+
+extern hidden const char __libc_version[];
+
+hidden void __synccall(void (*)(void *), void *);
+hidden int __setxid(int, int, int, int);
+
+#endif
diff --git a/third_party/musl/porting/liteos_a/user/src/internal/pthread_impl.h b/third_party/musl/porting/liteos_a/user/src/internal/pthread_impl.h
new file mode 100755
index 000000000..2e2109070
--- /dev/null
+++ b/third_party/musl/porting/liteos_a/user/src/internal/pthread_impl.h
@@ -0,0 +1,197 @@
+#ifndef _PTHREAD_IMPL_H
+#define _PTHREAD_IMPL_H
+
+#include <pthread.h>
+#include <signal.h>
+#include <errno.h>
+#include <limits.h>
+#include <sys/mman.h>
+#include "libc.h"
+#include "syscall.h"
+#include "atomic.h"
+#include "futex.h"
+
+#define pthread __pthread
+
+struct pthread {
+	/* Part 1 -- these fields may be external or
+	 * internal (accessed via asm) ABI. Do not change. */
+	struct pthread *self;
+	uintptr_t *dtv;
+	struct pthread *prev, *next; /* non-ABI */
+	uintptr_t sysinfo;
+	uintptr_t canary, canary2;
+
+	/* Part 2 -- implementation details, non-ABI. */
+	int tid;
+	int errno_val;
+	volatile int detach_state;
+	volatile int cancel;
+	volatile unsigned char canceldisable, cancelasync;
+	unsigned char tsd_used:1;
+	unsigned char dlerror_flag:1;
+	unsigned char *map_base;
+	size_t map_size;
+	void *stack;
+	size_t stack_size;
+	size_t guard_size;
+	void *result;
+	struct __ptcb *cancelbuf;
+	void **tsd;
+	struct {
+		volatile void *volatile head;
+		long off;
+		volatile void *volatile pending;
+	} robust_list;
+	volatile int timer_id;
+	locale_t locale;
+	volatile int killlock[1];
+	char *dlerror_buf;
+	void *stdio_locks;
+
+	/* Part 3 -- the positions of these fields relative to
+	 * the end of the structure is external and internal ABI. */
+	uintptr_t canary_at_end;
+	uintptr_t *dtv_copy;
+};
+
+enum {
+	DT_EXITING = 0,
+	DT_JOINABLE,
+	DT_DETACHED,
+};
+
+struct __timer {
+	int timerid;
+	pthread_t thread;
+};
+
+#define __SU (sizeof(size_t)/sizeof(int))
+
+#define _a_stacksize __u.__s[0]
+#define _a_guardsize __u.__s[1]
+#define _a_stackaddr __u.__s[2]
+#define _a_detach __u.__i[3*__SU+0]
+#define _a_sched __u.__i[3*__SU+1]
+#define _a_policy __u.__i[3*__SU+2]
+#define _a_prio __u.__i[3*__SU+3]
+#define _m_type __u.__i[0]
+#define _m_lock __u.__vi[1]
+#define _m_waiters __u.__vi[2]
+#define _m_prev __u.__p[3]
+#define _m_next __u.__p[4]
+#define _m_count __u.__i[5]
+#define _c_shared __u.__p[0]
+#define _c_seq __u.__vi[2]
+#define _c_waiters __u.__vi[3]
+#define _c_clock __u.__i[4]
+#define _c_lock __u.__vi[8]
+#define _c_head __u.__p[1]
+#define _c_tail __u.__p[5]
+#define _rw_lock __u.__vi[0]
+#define _rw_waiters __u.__vi[1]
+#define _rw_shared __u.__i[2]
+#define _b_lock __u.__vi[0]
+#define _b_waiters __u.__vi[1]
+#define _b_limit __u.__i[2]
+#define _b_count __u.__vi[3]
+#define _b_waiters2 __u.__vi[4]
+#define _b_inst __u.__p[3]
+
+#include "pthread_arch.h"
+
+#ifndef CANARY
+#define CANARY canary
+#endif
+
+#ifndef DTP_OFFSET
+#define DTP_OFFSET 0
+#endif
+
+#ifndef tls_mod_off_t
+#define tls_mod_off_t size_t
+#endif
+
+#define SIGTIMER 32
+#define SIGCANCEL 33
+#define SIGSYNCCALL 34
+
+#define SIGALL_SET ((sigset_t *)(const unsigned long long [2]){ -1,-1 })
+#define SIGPT_SET \
+	((sigset_t *)(const unsigned long [_NSIG/8/sizeof(long)]){ \
+	[sizeof(long)==4] = 3UL<<(32*(sizeof(long)>4)) })
+#define SIGTIMER_SET \
+	((sigset_t *)(const unsigned long [_NSIG/8/sizeof(long)]){ \
+	 0x80000000 })
+
+void *__tls_get_addr(tls_mod_off_t *);
+hidden int __init_tp(void *);
+hidden void *__copy_tls(unsigned char *);
+hidden void __reset_tls();
+
+hidden void __membarrier_init(void);
+hidden void __dl_thread_cleanup(void);
+hidden void __testcancel();
+hidden void __do_cleanup_push(struct __ptcb *);
+hidden void __do_cleanup_pop(struct __ptcb *);
+hidden void __pthread_tsd_run_dtors();
+
+hidden void __pthread_key_delete_synccall(void (*)(void *), void *);
+hidden int __pthread_key_delete_impl(pthread_key_t);
+
+extern hidden volatile size_t __pthread_tsd_size;
+extern hidden void *__pthread_tsd_main[];
+extern hidden volatile int __aio_fut;
+extern hidden volatile int __eintr_valid_flag;
+
+hidden int __clone(int (*)(void *), void *, int, void *, ...);
+hidden int __thread_clone(int (*func)(void *), int flags, struct pthread *thread, unsigned char *sp);
+hidden int __set_thread_area(void *);
+hidden int __libc_sigaction(int, const struct sigaction *, struct sigaction *);
+hidden void __unmapself(void *, size_t);
+
+hidden int __timedwait(volatile int *, int, clockid_t, const struct timespec *, int);
+hidden int __timedwait_cp(volatile int *, int, clockid_t, const struct timespec *, int);
+hidden void __wait(volatile int *, volatile int *, int, int);
+static inline void __wake(volatile void *addr, int cnt, int priv)
+{
+	if (priv) priv = FUTEX_PRIVATE;
+	if (cnt<0) cnt = INT_MAX;
+	__syscall(SYS_futex, addr, FUTEX_WAKE|priv, cnt) != -ENOSYS ||
+	__syscall(SYS_futex, addr, FUTEX_WAKE, cnt);
+}
+static inline void __futexwait(volatile void *addr, int val, int priv)
+{
+	if (priv) priv = FUTEX_PRIVATE;
+	__syscall(SYS_futex, addr, FUTEX_WAIT|priv, val, 0xffffffffu) != -ENOSYS ||
+	__syscall(SYS_futex, addr, FUTEX_WAIT, val, 0xffffffffu);
+}
+
+hidden void __acquire_ptc(void);
+hidden void __release_ptc(void);
+hidden void __inhibit_ptc(void);
+
+hidden void __tl_lock(void);
+hidden void __tl_unlock(void);
+hidden void __tl_sync(pthread_t);
+
+extern hidden volatile int __thread_list_lock;
+
+extern hidden unsigned __default_stacksize;
+extern hidden unsigned __default_guardsize;
+
+#define DEFAULT_STACK_SIZE 131072
+#define DEFAULT_GUARD_SIZE 8192
+
+#define DEFAULT_STACK_MAX (8<<20)
+#define DEFAULT_GUARD_MAX (1<<20)
+
+#define __ATTRP_C11_THREAD ((void*)(uintptr_t)-1)
+
+#define MUSL_TYPE_THREAD    (-1)
+#define MUSL_TYPE_PROCESS   (0)
+
+#define PTHREAD_MUTEX_TYPE_MASK 3
+#define PTHREAD_PRIORITY_LOWEST 31
+
+#endif
diff --git a/third_party/musl/src/internal/unsupported_api.h b/third_party/musl/porting/liteos_a/user/src/internal/unsupported_api.h
similarity index 100%
rename from third_party/musl/src/internal/unsupported_api.h
rename to third_party/musl/porting/liteos_a/user/src/internal/unsupported_api.h
diff --git a/third_party/musl/porting/liteos_a/user/src/ipc/ftok.c b/third_party/musl/porting/liteos_a/user/src/ipc/ftok.c
new file mode 100755
index 000000000..5733836bd
--- /dev/null
+++ b/third_party/musl/porting/liteos_a/user/src/ipc/ftok.c
@@ -0,0 +1,12 @@
+#include <sys/ipc.h>
+#include <sys/stat.h>
+#include <unsupported_api.h>
+
+key_t ftok(const char *path, int id)
+{
+	struct stat st;
+	unsupported_api(__FUNCTION__);
+	if (stat(path, &st) < 0) return -1;
+
+	return ((st.st_ino & 0xffff) | ((st.st_dev & 0xff) << 16) | ((id & 0xffu) << 24));
+}
diff --git a/third_party/musl/porting/liteos_a/user/src/ipc/msgctl.c b/third_party/musl/porting/liteos_a/user/src/ipc/msgctl.c
new file mode 100755
index 000000000..48a2a0a17
--- /dev/null
+++ b/third_party/musl/porting/liteos_a/user/src/ipc/msgctl.c
@@ -0,0 +1,44 @@
+#include <sys/msg.h>
+#include <endian.h>
+#include <unsupported_api.h>
+
+#include "syscall.h"
+#include "ipc.h"
+
+#if __BYTE_ORDER != __BIG_ENDIAN
+#undef SYSCALL_IPC_BROKEN_MODE
+#endif
+
+int msgctl(int q, int cmd, struct msqid_ds *buf)
+{
+	unsupported_api(__FUNCTION__);
+#ifdef SYSCALL_IPC_BROKEN_MODE
+	struct msqid_ds tmp;
+	if (cmd == IPC_SET) {
+		tmp = *buf;
+		tmp.msg_perm.mode *= 0x10000U;
+		buf = &tmp;
+	}
+#endif
+#ifndef SYS_ipc
+	int r = __syscall(SYS_msgctl, q, IPC_CMD(cmd), buf);
+#else
+	int r = __syscall(SYS_ipc, IPCOP_msgctl, q, IPC_CMD(cmd), 0, buf, 0);
+#endif
+#ifdef SYSCALL_IPC_BROKEN_MODE
+	if (r >= 0) switch (cmd | IPC_TIME64) {
+	case IPC_STAT:
+	case MSG_STAT:
+	case MSG_STAT_ANY:
+		buf->msg_perm.mode >>= 16;
+	}
+#endif
+#if IPC_TIME64
+	if (r >= 0 && (cmd&IPC_TIME64)) {
+		IPC_HILO(buf, msg_stime);
+		IPC_HILO(buf, msg_rtime);
+		IPC_HILO(buf, msg_ctime);
+	}
+#endif
+	return __syscall_ret(r);
+}
diff --git a/third_party/musl/porting/liteos_a/user/src/ipc/msgget.c b/third_party/musl/porting/liteos_a/user/src/ipc/msgget.c
new file mode 100755
index 000000000..9ff7a053b
--- /dev/null
+++ b/third_party/musl/porting/liteos_a/user/src/ipc/msgget.c
@@ -0,0 +1,15 @@
+#include <sys/msg.h>
+#include <unsupported_api.h>
+
+#include "syscall.h"
+#include "ipc.h"
+
+int msgget(key_t k, int flag)
+{
+	unsupported_api(__FUNCTION__);
+#ifndef SYS_ipc
+	return syscall(SYS_msgget, k, flag);
+#else
+	return syscall(SYS_ipc, IPCOP_msgget, k, flag);
+#endif
+}
diff --git a/third_party/musl/porting/liteos_a/user/src/ipc/msgrcv.c b/third_party/musl/porting/liteos_a/user/src/ipc/msgrcv.c
new file mode 100755
index 000000000..c66eb52fa
--- /dev/null
+++ b/third_party/musl/porting/liteos_a/user/src/ipc/msgrcv.c
@@ -0,0 +1,15 @@
+#include <sys/msg.h>
+#include <unsupported_api.h>
+
+#include "syscall.h"
+#include "ipc.h"
+
+ssize_t msgrcv(int q, void *m, size_t len, long type, int flag)
+{
+	unsupported_api(__FUNCTION__);
+#ifndef SYS_ipc
+	return syscall_cp(SYS_msgrcv, q, m, len, type, flag);
+#else
+	return syscall_cp(SYS_ipc, IPCOP_msgrcv, q, len, flag, ((long[]){ (long)m, type }));
+#endif
+}
diff --git a/third_party/musl/porting/liteos_a/user/src/ipc/msgsnd.c b/third_party/musl/porting/liteos_a/user/src/ipc/msgsnd.c
new file mode 100755
index 000000000..4db4d4ef4
--- /dev/null
+++ b/third_party/musl/porting/liteos_a/user/src/ipc/msgsnd.c
@@ -0,0 +1,14 @@
+#include <unsupported_api.h>
+#include <sys/msg.h>
+#include "syscall.h"
+#include "ipc.h"
+
+int msgsnd(int q, const void *m, size_t len, int flag)
+{
+	unsupported_api(__FUNCTION__);
+#ifndef SYS_ipc
+	return syscall_cp(SYS_msgsnd, q, m, len, flag);
+#else
+	return syscall_cp(SYS_ipc, IPCOP_msgsnd, q, len, flag, m);
+#endif
+}
diff --git a/third_party/musl/porting/liteos_a/user/src/ipc/semctl.c b/third_party/musl/porting/liteos_a/user/src/ipc/semctl.c
new file mode 100755
index 000000000..9e9f15e3b
--- /dev/null
+++ b/third_party/musl/porting/liteos_a/user/src/ipc/semctl.c
@@ -0,0 +1,62 @@
+#include <sys/sem.h>
+#include <stdarg.h>
+#include <endian.h>
+#include <unsupported_api.h>
+
+#include "syscall.h"
+#include "ipc.h"
+
+#if __BYTE_ORDER != __BIG_ENDIAN
+#undef SYSCALL_IPC_BROKEN_MODE
+#endif
+
+union semun {
+	int val;
+	struct semid_ds *buf;
+	unsigned short *array;
+};
+
+int semctl(int id, int num, int cmd, ...)
+{
+	unsupported_api(__FUNCTION__);
+	union semun arg = {0};
+	va_list ap;
+	switch (cmd & ~IPC_TIME64) {
+	case SETVAL: case GETALL: case SETALL: case IPC_SET:
+	case IPC_INFO: case SEM_INFO:
+	case IPC_STAT & ~IPC_TIME64:
+	case SEM_STAT & ~IPC_TIME64:
+	case SEM_STAT_ANY & ~IPC_TIME64:
+		va_start(ap, cmd);
+		arg = va_arg(ap, union semun);
+		va_end(ap);
+	}
+#ifdef SYSCALL_IPC_BROKEN_MODE
+	struct semid_ds tmp;
+	if (cmd == IPC_SET) {
+		tmp = *arg.buf;
+		tmp.sem_perm.mode *= 0x10000U;
+		arg.buf = &tmp;
+	}
+#endif
+#ifndef SYS_ipc
+	int r = __syscall(SYS_semctl, id, num, IPC_CMD(cmd), arg.buf);
+#else
+	int r = __syscall(SYS_ipc, IPCOP_semctl, id, num, IPC_CMD(cmd), &arg.buf);
+#endif
+#ifdef SYSCALL_IPC_BROKEN_MODE
+	if (r >= 0) switch (cmd | IPC_TIME64) {
+	case IPC_STAT:
+	case SEM_STAT:
+	case SEM_STAT_ANY:
+		arg.buf->sem_perm.mode >>= 16;
+	}
+#endif
+#if IPC_TIME64
+	if (r >= 0 && (cmd&IPC_TIME64)) {
+		IPC_HILO(arg.buf, sem_otime);
+		IPC_HILO(arg.buf, sem_ctime);
+	}
+#endif
+	return __syscall_ret(r);
+}
diff --git a/third_party/musl/porting/liteos_a/user/src/ipc/semget.c b/third_party/musl/porting/liteos_a/user/src/ipc/semget.c
new file mode 100755
index 000000000..858d5bd61
--- /dev/null
+++ b/third_party/musl/porting/liteos_a/user/src/ipc/semget.c
@@ -0,0 +1,22 @@
+#include <sys/sem.h>
+#include <limits.h>
+#include <errno.h>
+#include <unsupported_api.h>
+
+#include "syscall.h"
+#include "ipc.h"
+
+int semget(key_t key, int n, int fl)
+{
+	/* The kernel uses the wrong type for the sem_nsems member
+	 * of struct semid_ds, and thus might not check that the
+	 * n fits in the correct (per POSIX) userspace type, so
+	 * we have to check here. */
+	unsupported_api(__FUNCTION__);
+	if (n > USHRT_MAX) return __syscall_ret(-EINVAL);
+#ifndef SYS_ipc
+	return syscall(SYS_semget, key, n, fl);
+#else
+	return syscall(SYS_ipc, IPCOP_semget, key, n, fl);
+#endif
+}
diff --git a/third_party/musl/porting/liteos_a/user/src/ipc/semop.c b/third_party/musl/porting/liteos_a/user/src/ipc/semop.c
new file mode 100755
index 000000000..1c96614fb
--- /dev/null
+++ b/third_party/musl/porting/liteos_a/user/src/ipc/semop.c
@@ -0,0 +1,15 @@
+#include <sys/sem.h>
+#include <unsupported_api.h>
+
+#include "syscall.h"
+#include "ipc.h"
+
+int semop(int id, struct sembuf *buf, size_t n)
+{
+	unsupported_api(__FUNCTION__);
+#ifndef SYS_ipc
+	return syscall(SYS_semop, id, buf, n);
+#else
+	return syscall(SYS_ipc, IPCOP_semop, id, n, 0, buf);
+#endif
+}
diff --git a/third_party/musl/porting/liteos_a/user/src/legacy/daemon.c b/third_party/musl/porting/liteos_a/user/src/legacy/daemon.c
new file mode 100755
index 000000000..57838e781
--- /dev/null
+++ b/third_party/musl/porting/liteos_a/user/src/legacy/daemon.c
@@ -0,0 +1,35 @@
+#define _GNU_SOURCE
+#include <fcntl.h>
+#include <unistd.h>
+#include <unsupported_api.h>
+
+int daemon(int nochdir, int noclose)
+{
+	unsupported_api(__FUNCTION__);
+	if (!nochdir && chdir("/"))
+		return -1;
+	if (!noclose) {
+		int fd, failed = 0;
+		if ((fd = open("/dev/null", O_RDWR)) < 0) return -1;
+		if (dup2(fd, 0) < 0 || dup2(fd, 1) < 0 || dup2(fd, 2) < 0)
+			failed++;
+		if (fd > 2) close(fd);
+		if (failed) return -1;
+	}
+
+	switch(fork()) {
+	case 0: break;
+	case -1: return -1;
+	default: _exit(0);
+	}
+
+	if (setsid() < 0) return -1;
+
+	switch(fork()) {
+	case 0: break;
+	case -1: return -1;
+	default: _exit(0);
+	}
+
+	return 0;
+}
diff --git a/third_party/musl/porting/liteos_a/user/src/legacy/getdtablesize.c b/third_party/musl/porting/liteos_a/user/src/legacy/getdtablesize.c
new file mode 100755
index 000000000..672e0556c
--- /dev/null
+++ b/third_party/musl/porting/liteos_a/user/src/legacy/getdtablesize.c
@@ -0,0 +1,13 @@
+#define _GNU_SOURCE
+#include <unistd.h>
+#include <limits.h>
+#include <sys/resource.h>
+#include <unsupported_api.h>
+
+int getdtablesize(void)
+{
+	struct rlimit rl;
+	unsupported_api(__FUNCTION__);
+	getrlimit(RLIMIT_NOFILE, &rl);
+	return rl.rlim_cur < INT_MAX ? rl.rlim_cur : INT_MAX;
+}
diff --git a/third_party/musl/porting/liteos_a/user/src/legacy/getusershell.c b/third_party/musl/porting/liteos_a/user/src/legacy/getusershell.c
new file mode 100755
index 000000000..c17ada773
--- /dev/null
+++ b/third_party/musl/porting/liteos_a/user/src/legacy/getusershell.c
@@ -0,0 +1,34 @@
+#define _GNU_SOURCE
+#include <stdio.h>
+#include <unistd.h>
+#include <unsupported_api.h>
+
+static const char defshells[] = "/bin/sh\n/bin/csh\n";
+
+static char *line;
+static size_t linesize;
+static FILE *f;
+
+void endusershell(void)
+{
+	unsupported_api(__FUNCTION__);
+	if (f) fclose(f);
+	f = 0;
+}
+
+void setusershell(void)
+{
+	if (!f) f = fopen("/etc/shells", "rbe");
+	if (!f) f = fmemopen((void *)defshells, sizeof defshells - 1, "rb");
+}
+
+char *getusershell(void)
+{
+	ssize_t l;
+	if (!f) setusershell();
+	if (!f) return 0;
+	l = getline(&line, &linesize, f);
+	if (l <= 0) return 0;
+	if (line[l-1]=='\n') line[l-1]=0;
+	return line;
+}
diff --git a/third_party/musl/porting/liteos_a/user/src/legacy/isastream.c b/third_party/musl/porting/liteos_a/user/src/legacy/isastream.c
new file mode 100755
index 000000000..9398088e5
--- /dev/null
+++ b/third_party/musl/porting/liteos_a/user/src/legacy/isastream.c
@@ -0,0 +1,8 @@
+#include <stropts.h>
+#include <fcntl.h>
+#include <unsupported_api.h>
+int isastream(int fd)
+{
+	unsupported_api(__FUNCTION__);
+	return fcntl(fd, F_GETFD) < 0 ? -1 : 0;
+}
diff --git a/third_party/musl/porting/liteos_a/user/src/legacy/ulimit.c b/third_party/musl/porting/liteos_a/user/src/legacy/ulimit.c
new file mode 100755
index 000000000..5580bf885
--- /dev/null
+++ b/third_party/musl/porting/liteos_a/user/src/legacy/ulimit.c
@@ -0,0 +1,21 @@
+#include <sys/resource.h>
+#include <ulimit.h>
+#include <stdarg.h>
+#include <unsupported_api.h>
+
+long ulimit(int cmd, ...)
+{
+	struct rlimit rl;
+	unsupported_api(__FUNCTION__);
+	getrlimit(RLIMIT_FSIZE, &rl);
+	if (cmd == UL_SETFSIZE) {
+		long val;
+		va_list ap;
+		va_start(ap, cmd);
+		val = va_arg(ap, long);
+		va_end(ap);
+		rl.rlim_cur = 512ULL * val;
+		if (setrlimit(RLIMIT_FSIZE, &rl)) return -1;
+	}
+	return rl.rlim_cur / 512;
+}
diff --git a/third_party/musl/porting/liteos_a/user/src/legacy/utmpx.c b/third_party/musl/porting/liteos_a/user/src/legacy/utmpx.c
new file mode 100755
index 000000000..a9f05a2a4
--- /dev/null
+++ b/third_party/musl/porting/liteos_a/user/src/legacy/utmpx.c
@@ -0,0 +1,61 @@
+#define _GNU_SOURCE
+#include <utmpx.h>
+#include <stddef.h>
+#include <errno.h>
+#include <unsupported_api.h>
+
+void endutxent(void)
+{
+	unsupported_api(__FUNCTION__);
+}
+
+void setutxent(void)
+{
+	unsupported_api(__FUNCTION__);
+}
+
+struct utmpx *getutxent(void)
+{
+	unsupported_api(__FUNCTION__);
+	return NULL;
+}
+
+struct utmpx *getutxid(const struct utmpx *ut)
+{
+	unsupported_api(__FUNCTION__);
+	return NULL;
+}
+
+struct utmpx *getutxline(const struct utmpx *ut)
+{
+	unsupported_api(__FUNCTION__);
+	return NULL;
+}
+
+struct utmpx *pututxline(const struct utmpx *ut)
+{
+	unsupported_api(__FUNCTION__);
+	return NULL;
+}
+
+void updwtmpx(const char *f, const struct utmpx *u)
+{
+	unsupported_api(__FUNCTION__);
+}
+
+static int __utmpxname(const char *f)
+{
+	unsupported_api(__FUNCTION__);
+	errno = ENOTSUP;
+	return -1;
+}
+
+weak_alias(endutxent, endutent);
+weak_alias(setutxent, setutent);
+weak_alias(getutxent, getutent);
+weak_alias(getutxid, getutid);
+weak_alias(getutxline, getutline);
+weak_alias(pututxline, pututline);
+weak_alias(updwtmpx, updwtmp);
+weak_alias(__utmpxname, utmpname);
+weak_alias(__utmpxname, utmpxname);
diff --git a/third_party/musl/porting/liteos_a/user/src/linux/adjtime.c b/third_party/musl/porting/liteos_a/user/src/linux/adjtime.c
new file mode 100755
index 000000000..871623a96
--- /dev/null
+++ b/third_party/musl/porting/liteos_a/user/src/linux/adjtime.c
@@ -0,0 +1,29 @@
+#define _GNU_SOURCE
+#include <sys/time.h>
+#include <sys/timex.h>
+#include <errno.h>
+#include "syscall.h"
+#include <unsupported_api.h>
+
+int adjtime(const struct timeval *in, struct timeval *out)
+{
+	struct timex tx = { 0 };
+	unsupported_api(__FUNCTION__);
+	if (in) {
+		if (in->tv_sec > 1000 || in->tv_usec > 1000000000) {
+			errno = EINVAL;
+			return -1;
+		}
+		tx.offset = in->tv_sec*1000000 + in->tv_usec;
+		tx.modes = ADJ_OFFSET_SINGLESHOT;
+	}
+	if (adjtimex(&tx) < 0) return -1;
+	if (out) {
+		out->tv_sec = tx.offset / 1000000;
+		if ((out->tv_usec = tx.offset % 1000000) < 0) {
+			out->tv_sec--;
+			out->tv_usec += 1000000;
+		}
+	}
+	return 0;
+}
diff --git a/third_party/musl/porting/liteos_a/user/src/linux/cap.c b/third_party/musl/porting/liteos_a/user/src/linux/cap.c
new file mode 100755
index 000000000..ffc669859
--- /dev/null
+++ b/third_party/musl/porting/liteos_a/user/src/linux/cap.c
@@ -0,0 +1,265 @@
+/*
+ * Copyright (c) 2013-2019 Huawei Technologies Co., Ltd. All rights reserved.
+ * Copyright (c) 2020-2021 Huawei Device Co., Ltd. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without modification,
+ * are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice, this list of
+ *    conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright notice, this list
+ *    of conditions and the following disclaimer in the documentation and/or other materials
+ *    provided with the distribution.
+ *
+ * 3. Neither the name of the copyright holder nor the names of its contributors may be used
+ *    to endorse or promote products derived from this software without specific prior written
+ *    permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+ * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+ * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
+ * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
+ * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
+ * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#include <errno.h>
+#include <unistd.h>
+#include <stdio.h>
+#include "syscall.h"
+#include "sys/capability.h"
+
+static unsigned int __linux_caps_maps[] = {
+	CAP_CHOWN, CAP_DAC_OVERRIDE, CAP_DAC_READ_SEARCH, CAP_FOWNER,
+	CAP_KILL, CAP_SETGID, CAP_SETUID, CAP_SETPCAP, CAP_NET_BIND_SERVICE,
+	CAP_NET_BROADCAST, CAP_NET_ADMIN, CAP_NET_RAW, CAP_SYS_PTRACE, CAP_SYS_ADMIN,
+	CAP_SYS_NICE, CAP_SYS_TIME, CAP_SYS_BOOT};
+
+static unsigned int __ohos_caps_maps[] = {
+	OHOS_CAP_CHOWN, OHOS_CAP_DAC_EXECUTE, OHOS_CAP_DAC_WRITE, OHOS_CAP_DAC_READ_SEARCH, OHOS_CAP_FOWNER, OHOS_CAP_KILL,
+	OHOS_CAP_SETGID, OHOS_CAP_SETUID, OHOS_CAP_NET_BIND_SERVICE, OHOS_CAP_NET_BROADCAST, OHOS_CAP_NET_ADMIN,
+	OHOS_CAP_NET_RAW, OHOS_CAP_FS_MOUNT, OHOS_CAP_FS_FORMAT, OHOS_CAP_SCHED_SETPRIORITY,
+	OHOS_CAP_SET_TIMEOFDAY, OHOS_CAP_CLOCK_SETTIME, OHOS_CAP_CAPSET, OHOS_CAP_REBOOT, OHOS_CAP_SHELL_EXEC};
+
+static unsigned int linux_caps_to_ohos(unsigned int caps)
+{
+	int num = sizeof(__linux_caps_maps) / sizeof(int);
+	int loop;
+	unsigned int result = 0;
+	for (loop = 0; loop < num; loop++) {
+		if (!((1 << __linux_caps_maps[loop]) & caps)) {
+			continue;
+		}
+
+		switch (__linux_caps_maps[loop]) {
+			case CAP_CHOWN:
+				result |= 1 << OHOS_CAP_CHOWN;
+				break;
+			case CAP_DAC_OVERRIDE:
+				result |= 1 << OHOS_CAP_DAC_EXECUTE;
+				result |= 1 << OHOS_CAP_DAC_WRITE;
+				result |= 1 << OHOS_CAP_DAC_READ_SEARCH;
+				break;
+			case CAP_DAC_READ_SEARCH:
+				result |= 1 << OHOS_CAP_DAC_READ_SEARCH;
+				break;
+			case CAP_FOWNER:
+				result |= 1 << OHOS_CAP_FOWNER;
+				break;
+			case CAP_KILL:
+				result |= 1 << OHOS_CAP_KILL;
+				break;
+			case CAP_SETGID:
+				result |= 1 << OHOS_CAP_SETGID;
+				break;
+			case CAP_SETUID:
+				result |= 1 << OHOS_CAP_SETUID;
+				break;
+			case CAP_SETPCAP:
+				result |= 1 << OHOS_CAP_CAPSET;
+				break;
+			case CAP_NET_BIND_SERVICE:
+				result |= 1 << OHOS_CAP_NET_BIND_SERVICE;
+				break;
+			case CAP_NET_BROADCAST:
+				result |= 1 << OHOS_CAP_NET_BROADCAST;
+				break;
+			case CAP_NET_ADMIN:
+				result |= 1 << OHOS_CAP_NET_ADMIN;
+				break;
+			case CAP_NET_RAW:
+				result |= 1 << OHOS_CAP_NET_RAW;
+				break;
+			case CAP_SYS_PTRACE:
+				result |= 1 << OHOS_CAP_SHELL_EXEC;
+				break;
+			case CAP_SYS_ADMIN:
+				result |= 1 << OHOS_CAP_FS_MOUNT;
+				result |= 1 << OHOS_CAP_FS_FORMAT;
+				break;
+			case CAP_SYS_NICE:
+				result |= 1 << OHOS_CAP_SCHED_SETPRIORITY;
+				break;
+			case CAP_SYS_TIME:
+				result |= 1 << OHOS_CAP_SET_TIMEOFDAY;
+				result |= 1 << OHOS_CAP_CLOCK_SETTIME;
+				break;
+			case CAP_SYS_BOOT:
+				result |= 1 << OHOS_CAP_REBOOT;
+				break;
+			default:
+				break;
+		}
+	}
+
+	return result;
+}
+
+static unsigned int ohos_caps_to_linux(unsigned int caps)
+{
+	int num = sizeof(__ohos_caps_maps) / sizeof(int);
+	int loop;
+	unsigned int result = 0;
+	for (loop = 0; loop < num; loop++) {
+		if (!((1 << __ohos_caps_maps[loop]) & caps)) {
+			continue;
+		}
+
+		switch (__ohos_caps_maps[loop]) {
+			case OHOS_CAP_CHOWN:
+				result |= 1 << CAP_CHOWN;
+				break;
+			case OHOS_CAP_DAC_EXECUTE:
+			case OHOS_CAP_DAC_WRITE:
+				result |= 1 << CAP_DAC_OVERRIDE;
+				break;
+			case OHOS_CAP_DAC_READ_SEARCH:
+				result |= 1 << CAP_DAC_READ_SEARCH;
+				break;
+			case OHOS_CAP_FOWNER:
+				result |= 1 << CAP_FOWNER;
+				break;
+			case OHOS_CAP_KILL:
+				result |= 1 << CAP_KILL;
+				break;
+			case OHOS_CAP_SETGID:
+				result |= 1 << CAP_SETGID;
+				break;
+			case OHOS_CAP_SETUID:
+				result |= 1 << CAP_SETUID;
+				break;
+			case OHOS_CAP_CAPSET:
+				result |= 1 << CAP_SETPCAP;
+				break;
+			case OHOS_CAP_NET_BIND_SERVICE:
+				result |= 1 << CAP_NET_BIND_SERVICE;
+				break;
+			case OHOS_CAP_NET_BROADCAST:
+				result |= 1 << CAP_NET_BROADCAST;
+				break;
+			case OHOS_CAP_NET_ADMIN:
+				result |= 1 << CAP_NET_ADMIN;
+				break;
+			case OHOS_CAP_NET_RAW:
+				result |= 1 << CAP_NET_RAW;
+				break;
+			case OHOS_CAP_SHELL_EXEC:
+				result |= 1 << CAP_SYS_PTRACE;
+				break;
+			case OHOS_CAP_FS_MOUNT:
+			case OHOS_CAP_FS_FORMAT:
+				result |= 1 << CAP_SYS_ADMIN;
+				break;
+			case OHOS_CAP_SCHED_SETPRIORITY:
+				result |= 1 << CAP_SYS_NICE;
+				break;
+			case OHOS_CAP_SET_TIMEOFDAY:
+			case OHOS_CAP_CLOCK_SETTIME:
+				result |= 1 << CAP_SYS_TIME;
+				break;
+			case OHOS_CAP_REBOOT:
+				result |= 1 << CAP_SYS_BOOT;
+				break;
+			default:
+				break;
+		}
+	}
+
+	return result;
+}
+
+int linux_capget(cap_user_header_t hdr_ptr, cap_user_data_t data_ptr)
+{
+	unsigned int capvalue = 0;
+
+	if (hdr_ptr == NULL || data_ptr == NULL) {
+		errno = EINVAL;
+		return -1;
+	}
+
+	switch (hdr_ptr->version) {
+		case _LINUX_CAPABILITY_VERSION_1:
+		case _LINUX_CAPABILITY_VERSION_2:
+		case _LINUX_CAPABILITY_VERSION_3:
+			break;
+		default:
+			errno = EINVAL;
+			return -1;
+	}
+
+	if (syscall(SYS_ohoscapget, hdr_ptr->pid, &capvalue)) {
+		return -1;
+	}
+
+	data_ptr[0].effective = ohos_caps_to_linux(capvalue);
+	data_ptr[0].permitted = ohos_caps_to_linux(capvalue);
+	data_ptr[0].inheritable = ohos_caps_to_linux(capvalue);
+	return 0;
+}
+
+int linux_capset(cap_user_header_t hdr_ptr, const cap_user_data_t data_ptr)
+{
+	unsigned int capvalue = 0;
+
+	if (hdr_ptr == NULL || data_ptr == NULL) {
+		errno = EINVAL;
+		return -1;
+	}
+
+	if (hdr_ptr->pid) {
+		errno = EPERM;
+		return -1;
+	}
+
+	switch (hdr_ptr->version) {
+		case _LINUX_CAPABILITY_VERSION_1:
+		case _LINUX_CAPABILITY_VERSION_2:
+		case _LINUX_CAPABILITY_VERSION_3:
+			break;
+		default:
+			errno = EINVAL;
+			return -1;
+	}
+
+	capvalue = linux_caps_to_ohos(data_ptr[0].effective);
+	return syscall(SYS_ohoscapset, capvalue);
+}
+
+weak_alias(linux_capget, capget);
+weak_alias(linux_capset, capset);
+
+int ohos_capget(pid_t pid, unsigned int *caps)
+{
+	return syscall(SYS_ohoscapget, pid, caps);
+}
+
+int ohos_capset(unsigned int caps)
+{
+	return syscall(SYS_ohoscapset, caps);
+}
diff --git a/third_party/musl/porting/liteos_a/user/src/linux/clone.c b/third_party/musl/porting/liteos_a/user/src/linux/clone.c
new file mode 100755
index 000000000..0db0250ae
--- /dev/null
+++ b/third_party/musl/porting/liteos_a/user/src/linux/clone.c
@@ -0,0 +1,23 @@
+#define _GNU_SOURCE
+#include <stdarg.h>
+#include <unistd.h>
+#include <sched.h>
+#include "pthread_impl.h"
+#include "syscall.h"
+#include <unsupported_api.h>
+
+int clone(int (*func)(void *), void *stack, int flags, void *arg, ...)
+{
+	va_list ap;
+	pid_t *ptid, *ctid;
+	void  *tls;
+
+	unsupported_api(__FUNCTION__);
+	va_start(ap, arg);
+	ptid = va_arg(ap, pid_t *);
+	tls  = va_arg(ap, void *);
+	ctid = va_arg(ap, pid_t *);
+	va_end(ap);
+
+	return __syscall_ret(__clone(func, stack, flags, arg, ptid, tls, ctid));
+}
diff --git a/third_party/musl/porting/liteos_a/user/src/linux/epoll.c b/third_party/musl/porting/liteos_a/user/src/linux/epoll.c
new file mode 100755
index 000000000..3fc76b908
--- /dev/null
+++ b/third_party/musl/porting/liteos_a/user/src/linux/epoll.c
@@ -0,0 +1,41 @@
+#include <sys/epoll.h>
+#include <signal.h>
+#include <errno.h>
+#include "syscall.h"
+#include <unsupported_api.h>
+
+int epoll_create(int size)
+{
+	unsupported_api(__FUNCTION__);
+	return epoll_create1(0);
+}
+
+int epoll_create1(int flags)
+{
+	int r = __syscall(SYS_epoll_create1, flags);
+#ifdef SYS_epoll_create
+	if (r==-ENOSYS && !flags) r = __syscall(SYS_epoll_create, 1);
+#endif
+	return __syscall_ret(r);
+}
+
+int epoll_ctl(int fd, int op, int fd2, struct epoll_event *ev)
+{
+	unsupported_api(__FUNCTION__);
+	return syscall(SYS_epoll_ctl, fd, op, fd2, ev);
+}
+
+int epoll_pwait(int fd, struct epoll_event *ev, int cnt, int to, const sigset_t *sigs)
+{
+	int r = __syscall(SYS_epoll_pwait, fd, ev, cnt, to, sigs, _NSIG/8);
+#ifdef SYS_epoll_wait
+	if (r==-ENOSYS && !sigs) r = __syscall(SYS_epoll_wait, fd, ev, cnt, to);
+#endif
+	return __syscall_ret(r);
+}
+
+int epoll_wait(int fd, struct epoll_event *ev, int cnt, int to)
+{
+	unsupported_api(__FUNCTION__);
+	return epoll_pwait(fd, ev, cnt, to, 0);
+}
diff --git a/third_party/musl/porting/liteos_a/user/src/linux/ppoll.c b/third_party/musl/porting/liteos_a/user/src/linux/ppoll.c
new file mode 100755
index 000000000..060cad70b
--- /dev/null
+++ b/third_party/musl/porting/liteos_a/user/src/linux/ppoll.c
@@ -0,0 +1,28 @@
+#define _GNU_SOURCE
+#include <poll.h>
+#include <signal.h>
+#include <errno.h>
+#include "syscall.h"
+#include <unsupported_api.h>
+
+#define IS32BIT(x) !((x)+0x80000000ULL>>32)
+#define CLAMP(x) (int)(IS32BIT(x) ? (x) : 0x7fffffffU+((0ULL+(x))>>63))
+
+int ppoll(struct pollfd *fds, nfds_t n, const struct timespec *to, const sigset_t *mask)
+{
+	time_t s = to ? to->tv_sec : 0;
+	long ns = to ? to->tv_nsec : 0;
+	unsupported_api(__FUNCTION__);
+#ifdef SYS_ppoll_time64
+	int r = -ENOSYS;
+	if (SYS_ppoll == SYS_ppoll_time64 || !IS32BIT(s))
+		r = __syscall_cp(SYS_ppoll_time64, fds, n,
+			to ? ((long long[]){s, ns}) : 0,
+			mask, _NSIG/8);
+	if (SYS_ppoll == SYS_ppoll_time64 || r != -ENOSYS)
+		return __syscall_ret(r);
+	s = CLAMP(s);
+#endif
+	return syscall_cp(SYS_ppoll, fds, n,
+		to ? ((long[]){s, ns}) : 0, mask, _NSIG/8);
+}
diff --git a/third_party/musl/porting/liteos_a/user/src/linux/utimes.c b/third_party/musl/porting/liteos_a/user/src/linux/utimes.c
new file mode 100755
index 000000000..b6f6df064
--- /dev/null
+++ b/third_party/musl/porting/liteos_a/user/src/linux/utimes.c
@@ -0,0 +1,10 @@
+#include <sys/time.h>
+#include <unsupported_api.h>
+#include "fcntl.h"
+#include "syscall.h"
+
+int utimes(const char *path, const struct timeval times[2])
+{
+	unsupported_api(__FUNCTION__);
+	return __futimesat(AT_FDCWD, path, times);
+}
diff --git a/third_party/musl/porting/liteos_a/user/src/locale/dcngettext.c b/third_party/musl/porting/liteos_a/user/src/locale/dcngettext.c
new file mode 100755
index 000000000..d36634e63
--- /dev/null
+++ b/third_party/musl/porting/liteos_a/user/src/locale/dcngettext.c
@@ -0,0 +1,276 @@
+#include <libintl.h>
+#include <stdlib.h>
+#include <string.h>
+#include <errno.h>
+#include <limits.h>
+#include <sys/stat.h>
+#include <sys/mman.h>
+#include <ctype.h>
+#include <unsupported_api.h>
+#include "locale_impl.h"
+#include "atomic.h"
+#include "pleval.h"
+#include "lock.h"
+
+struct binding {
+	struct binding *next;
+	int dirlen;
+	volatile int active;
+	char *domainname;
+	char *dirname;
+	char buf[];
+};
+
+static void *volatile bindings;
+
+static char *gettextdir(const char *domainname, size_t *dirlen)
+{
+	struct binding *p;
+	for (p=bindings; p; p=p->next) {
+		if (!strcmp(p->domainname, domainname) && p->active) {
+			*dirlen = p->dirlen;
+			return (char *)p->dirname;
+		}
+	}
+	return 0;
+}
+
+char *bindtextdomain(const char *domainname, const char *dirname)
+{
+	static volatile int lock[1];
+	struct binding *p, *q;
+
+	if (!domainname) return 0;
+	if (!dirname) return gettextdir(domainname, &(size_t){0});
+
+	size_t domlen = strnlen(domainname, NAME_MAX+1);
+	size_t dirlen = strnlen(dirname, PATH_MAX);
+	if (domlen > NAME_MAX || dirlen >= PATH_MAX) {
+		errno = EINVAL;
+		return 0;
+	}
+
+	LOCK(lock);
+
+	for (p=bindings; p; p=p->next) {
+		if (!strcmp(p->domainname, domainname) &&
+		    !strcmp(p->dirname, dirname)) {
+			break;
+		}
+	}
+
+	if (!p) {
+		p = calloc(sizeof *p + domlen + dirlen + 2, 1);
+		if (!p) {
+			UNLOCK(lock);
+			return 0;
+		}
+		p->next = bindings;
+		p->dirlen = dirlen;
+		p->domainname = p->buf;
+		p->dirname = p->buf + domlen + 1;
+		memcpy(p->domainname, domainname, domlen+1);
+		memcpy(p->dirname, dirname, dirlen+1);
+		a_cas_p(&bindings, bindings, p);
+	}
+
+	a_store(&p->active, 1);
+
+	for (q=bindings; q; q=q->next) {
+		if (!strcmp(q->domainname, domainname) && q != p)
+			a_store(&q->active, 0);
+	}
+
+	UNLOCK(lock);
+	
+	return (char *)p->dirname;
+}
+
+static const char catnames[][12] = {
+	"LC_CTYPE",
+	"LC_NUMERIC",
+	"LC_TIME",
+	"LC_COLLATE",
+	"LC_MONETARY",
+	"LC_MESSAGES",
+};
+
+static const char catlens[] = { 8, 10, 7, 10, 11, 11 };
+
+struct msgcat {
+	struct msgcat *next;
+	const void *map;
+	size_t map_size;
+	const char *plural_rule;
+	int nplurals;
+	struct binding *binding;
+	const struct __locale_map *lm;
+	int cat;
+};
+
+static char *dummy_gettextdomain()
+{
+	return "messages";
+}
+
+weak_alias(dummy_gettextdomain, __gettextdomain);
+
+char *dcngettext(const char *domainname, const char *msgid1, const char *msgid2, unsigned long int n, int category)
+{
+	static struct msgcat *volatile cats;
+	struct msgcat *p;
+	struct __locale_struct *loc = CURRENT_LOCALE;
+	const struct __locale_map *lm;
+	size_t domlen;
+	struct binding *q;
+	int old_errno = errno;
+
+	if ((unsigned)category >= LC_ALL) goto notrans;
+
+	if (!domainname) domainname = __gettextdomain();
+
+	domlen = strnlen(domainname, NAME_MAX+1);
+	if (domlen > NAME_MAX) goto notrans;
+
+	for (q=bindings; q; q=q->next)
+		if (!strcmp(q->domainname, domainname) && q->active)
+			break;
+	if (!q) goto notrans;
+
+	lm = loc->cat[category];
+	if (!lm) {
+notrans:
+		errno = old_errno;
+		return (char *) ((n == 1) ? msgid1 : msgid2);
+	}
+
+	for (p=cats; p; p=p->next)
+		if (p->binding == q && p->lm == lm && p->cat == category)
+			break;
+
+	if (!p) {
+		const char *dirname, *locname, *catname, *modname, *locp;
+		size_t dirlen, loclen, catlen, modlen, alt_modlen;
+		void *old_cats;
+		size_t map_size;
+
+		dirname = q->dirname;
+		locname = lm->name;
+		catname = catnames[category];
+
+		dirlen = q->dirlen;
+		loclen = strlen(locname);
+		catlen = catlens[category];
+
+		/* Logically split @mod suffix from locale name. */
+		modname = memchr(locname, '@', loclen);
+		if (!modname) modname = locname + loclen;
+		alt_modlen = modlen = loclen - (modname-locname);
+		loclen = modname-locname;
+
+		/* Drop .charset identifier; it is not used. */
+		const char *csp = memchr(locname, '.', loclen);
+		if (csp) loclen = csp-locname;
+
+		char name[dirlen+1 + loclen+modlen+1 + catlen+1 + domlen+3 + 1];
+		const void *map;
+
+		for (;;) {
+			snprintf(name, sizeof name, "%s/%.*s%.*s/%s/%s.mo\0",
+				dirname, (int)loclen, locname,
+				(int)alt_modlen, modname, catname, domainname);
+			if (map = __map_file(name, &map_size)) break;
+
+			/* Try dropping @mod, _YY, then both. */
+			if (alt_modlen) {
+				alt_modlen = 0;
+			} else if ((locp = memchr(locname, '_', loclen))) {
+				loclen = locp-locname;
+				alt_modlen = modlen;
+			} else {
+				break;
+			}
+		}
+		if (!map) goto notrans;
+
+		p = calloc(sizeof *p, 1);
+		if (!p) {
+			__munmap((void *)map, map_size);
+			goto notrans;
+		}
+		p->cat = category;
+		p->binding = q;
+		p->lm = lm;
+		p->map = map;
+		p->map_size = map_size;
+
+		const char *rule = "n!=1;";
+		unsigned long np = 2;
+		const char *r = __mo_lookup(p->map, p->map_size, "");
+		char *z;
+		while (r && strncmp(r, "Plural-Forms:", 13)) {
+			z = strchr(r, '\n');
+			r = z ? z+1 : 0;
+		}
+		if (r) {
+			r += 13;
+			while (isspace(*r)) r++;
+			if (!strncmp(r, "nplurals=", 9)) {
+				np = strtoul(r+9, &z, 10);
+				r = z;
+			}
+			while (*r && *r != ';') r++;
+			if (*r) {
+				r++;
+				while (isspace(*r)) r++;
+				if (!strncmp(r, "plural=", 7))
+					rule = r+7;
+			}
+		}
+		p->nplurals = np;
+		p->plural_rule = rule;
+
+		do {
+			old_cats = cats;
+			p->next = old_cats;
+		} while (a_cas_p(&cats, old_cats, p) != old_cats);
+	}
+
+	const char *trans = __mo_lookup(p->map, p->map_size, msgid1);
+	if (!trans) goto notrans;
+
+	/* Non-plural-processing gettext forms pass a null pointer as
+	 * msgid2 to request that dcngettext suppress plural processing. */
+
+	if (msgid2 && p->nplurals) {
+		unsigned long plural = __pleval(p->plural_rule, n);
+		if (plural > p->nplurals) goto notrans;
+		while (plural--) {
+			size_t rem = p->map_size - (trans - (char *)p->map);
+			size_t l = strnlen(trans, rem);
+			if (l+1 >= rem)
+				goto notrans;
+			trans += l+1;
+		}
+	}
+	errno = old_errno;
+	return (char *)trans;
+}
+
+char *dcgettext(const char *domainname, const char *msgid, int category)
+{
+	unsupported_api(__FUNCTION__);
+	return dcngettext(domainname, msgid, 0, 1, category);
+}
+
+char *dngettext(const char *domainname, const char *msgid1, const char *msgid2, unsigned long int n)
+{
+	unsupported_api(__FUNCTION__);
+	return dcngettext(domainname, msgid1, msgid2, n, LC_MESSAGES);
+}
+
+char *dgettext(const char *domainname, const char *msgid)
+{
+	unsupported_api(__FUNCTION__);
+	return dcngettext(domainname, msgid, 0, 1, LC_MESSAGES);
+}
diff --git a/third_party/musl/porting/liteos_a/user/src/locale/duplocale.c b/third_party/musl/porting/liteos_a/user/src/locale/duplocale.c
new file mode 100755
index 000000000..2ed823d19
--- /dev/null
+++ b/third_party/musl/porting/liteos_a/user/src/locale/duplocale.c
@@ -0,0 +1,17 @@
+#include <stdlib.h>
+#include <string.h>
+#include <unsupported_api.h>
+#include "locale_impl.h"
+#include "libc.h"
+
+locale_t __duplocale(locale_t old)
+{
+	locale_t new = malloc(sizeof *new);
+	unsupported_api(__FUNCTION__);
+	if (!new) return 0;
+	if (old == LC_GLOBAL_LOCALE) old = &libc.global_locale;
+	*new = *old;
+	return new;
+}
+
+weak_alias(__duplocale, duplocale);
diff --git a/third_party/musl/porting/liteos_a/user/src/locale/freelocale.c b/third_party/musl/porting/liteos_a/user/src/locale/freelocale.c
new file mode 100755
index 000000000..74ca22b72
--- /dev/null
+++ b/third_party/musl/porting/liteos_a/user/src/locale/freelocale.c
@@ -0,0 +1,11 @@
+#include <stdlib.h>
+#include <unsupported_api.h>
+#include "locale_impl.h"
+
+void freelocale(locale_t l)
+{
+	unsupported_api(__FUNCTION__);
+	if (__loc_is_allocated(l)) free(l);
+}
+
+weak_alias(freelocale, __freelocale);
diff --git a/third_party/musl/porting/liteos_a/user/src/locale/langinfo.c b/third_party/musl/porting/liteos_a/user/src/locale/langinfo.c
new file mode 100755
index 000000000..db10108ed
--- /dev/null
+++ b/third_party/musl/porting/liteos_a/user/src/locale/langinfo.c
@@ -0,0 +1,77 @@
+#include <locale.h>
+#include <langinfo.h>
+#include <unsupported_api.h>
+#include "locale_impl.h"
+
+static const char c_time[] =
+	"Sun\0" "Mon\0" "Tue\0" "Wed\0" "Thu\0" "Fri\0" "Sat\0"
+	"Sunday\0" "Monday\0" "Tuesday\0" "Wednesday\0"
+	"Thursday\0" "Friday\0" "Saturday\0"
+	"Jan\0" "Feb\0" "Mar\0" "Apr\0" "May\0" "Jun\0"
+	"Jul\0" "Aug\0" "Sep\0" "Oct\0" "Nov\0" "Dec\0"
+	"January\0"   "February\0" "March\0"    "April\0"
+	"May\0"       "June\0"     "July\0"     "August\0"
+	"September\0" "October\0"  "November\0" "December\0"
+	"AM\0" "PM\0"
+	"%a %b %e %T %Y\0"
+	"%m/%d/%y\0"
+	"%H:%M:%S\0"
+	"%I:%M:%S %p\0"
+	"\0"
+	"\0"
+	"%m/%d/%y\0"
+	"0123456789\0"
+	"%a %b %e %T %Y\0"
+	"%H:%M:%S";
+
+static const char c_messages[] = "^[yY]\0" "^[nN]\0" "yes\0" "no";
+static const char c_numeric[] = ".\0" "";
+
+char *__nl_langinfo_l(nl_item item, locale_t loc)
+{
+	int cat = item >> 16;
+	int idx = item & 65535;
+	const char *str;
+
+	unsupported_api(__FUNCTION__);
+
+	if (item == CODESET) return loc->cat[LC_CTYPE] ? "UTF-8" : "ASCII";
+
+	/* _NL_LOCALE_NAME extension */
+	if (idx == 65535 && cat < LC_ALL)
+		return loc->cat[cat] ? (char *)loc->cat[cat]->name : "C";
+	
+	switch (cat) {
+	case LC_NUMERIC:
+		if (idx > 1) return "";
+		str = c_numeric;
+		break;
+	case LC_TIME:
+		if (idx > 0x31) return "";
+		str = c_time;
+		break;
+	case LC_MONETARY:
+		if (idx > 0) return "";
+		str = "";
+		break;
+	case LC_MESSAGES:
+		if (idx > 3) return "";
+		str = c_messages;
+		break;
+	default:
+		return "";
+	}
+
+	for (; idx; idx--, str++) for (; *str; str++);
+	if (cat != LC_NUMERIC && *str) str = LCTRANS(str, cat, loc);
+	return (char *)str;
+}
+
+char *__nl_langinfo(nl_item item)
+{
+	unsupported_api(__FUNCTION__);
+	return __nl_langinfo_l(item, CURRENT_LOCALE);
+}
+
+weak_alias(__nl_langinfo, nl_langinfo);
+weak_alias(__nl_langinfo_l, nl_langinfo_l);
diff --git a/third_party/musl/porting/liteos_a/user/src/locale/strcoll.c b/third_party/musl/porting/liteos_a/user/src/locale/strcoll.c
new file mode 100755
index 000000000..355a8aa5e
--- /dev/null
+++ b/third_party/musl/porting/liteos_a/user/src/locale/strcoll.c
@@ -0,0 +1,15 @@
+#include <string.h>
+#include <locale.h>
+#include "locale_impl.h"
+
+int __strcoll_l(const char *l, const char *r, locale_t loc)
+{
+	return strcmp(l, r);
+}
+
+int strcoll(const char *l, const char *r)
+{
+	return strcmp(l, r);
+}
+
+weak_alias(__strcoll_l, strcoll_l);
diff --git a/third_party/musl/porting/liteos_a/user/src/locale/strfmon.c b/third_party/musl/porting/liteos_a/user/src/locale/strfmon.c
new file mode 100755
index 000000000..fd1550d0e
--- /dev/null
+++ b/third_party/musl/porting/liteos_a/user/src/locale/strfmon.c
@@ -0,0 +1,103 @@
+#include <stdio.h>
+#include <ctype.h>
+#include <stdarg.h>
+#include <monetary.h>
+#include <errno.h>
+#include <unsupported_api.h>
+#include "locale_impl.h"
+
+static ssize_t vstrfmon_l(char *s, size_t n, locale_t loc, const char *fmt, va_list ap)
+{
+	size_t l;
+	double x;
+	int fill, nogrp, negpar, nosym, left, intl;
+	int lp, rp, w, fw;
+	char *s0=s;
+	for (; n && *fmt; ) {
+		if (*fmt != '%') {
+		literal:
+			*s++ = *fmt++;
+			n--;
+			continue;
+		}
+		fmt++;
+		if (*fmt == '%') goto literal;
+
+		fill = ' ';
+		nogrp = 0;
+		negpar = 0;
+		nosym = 0;
+		left = 0;
+		for (; ; fmt++) {
+			switch (*fmt) {
+			case '=':
+				fill = *++fmt;
+				continue;
+			case '^':
+				nogrp = 1;
+				continue;
+			case '(':
+				negpar = 1;
+			case '+':
+				continue;
+			case '!':
+				nosym = 1;
+				continue;
+			case '-':
+				left = 1;
+				continue;
+			}
+			break;
+		}
+
+		for (fw=0; isdigit(*fmt); fmt++)
+			fw = 10*fw + (*fmt-'0');
+		lp = 0;
+		rp = 2;
+		if (*fmt=='#') for (lp=0, fmt++; isdigit(*fmt); fmt++)
+			lp = 10*lp + (*fmt-'0');
+		if (*fmt=='.') for (rp=0, fmt++; isdigit(*fmt); fmt++)
+			rp = 10*rp + (*fmt-'0');
+
+		intl = *fmt++ == 'i';
+
+		w = lp + 1 + rp;
+		if (!left && fw>w) w = fw;
+
+		x = va_arg(ap, double);
+		l = snprintf(s, n, "%*.*f", w, rp, x);
+		if (l >= n) {
+			errno = E2BIG;
+			return -1;
+		}
+		s += l;
+		n -= l;
+	}
+	return s-s0;
+}
+
+ssize_t strfmon_l(char *restrict s, size_t n, locale_t loc, const char *restrict fmt, ...)
+{
+	va_list ap;
+	ssize_t ret;
+
+	unsupported_api(__FUNCTION__);
+	va_start(ap, fmt);
+	ret = vstrfmon_l(s, n, loc, fmt, ap);
+	va_end(ap);
+
+	return ret;
+}
+
+
+ssize_t strfmon(char *restrict s, size_t n, const char *restrict fmt, ...)
+{
+	va_list ap;
+	ssize_t ret;
+
+	va_start(ap, fmt);
+	ret = vstrfmon_l(s, n, CURRENT_LOCALE, fmt, ap);
+	va_end(ap);
+
+	return ret;
+}
diff --git a/third_party/musl/porting/liteos_a/user/src/locale/textdomain.c b/third_party/musl/porting/liteos_a/user/src/locale/textdomain.c
new file mode 100755
index 000000000..27f3a3ff6
--- /dev/null
+++ b/third_party/musl/porting/liteos_a/user/src/locale/textdomain.c
@@ -0,0 +1,46 @@
+#include <libintl.h>
+#include <string.h>
+#include <stdlib.h>
+#include <errno.h>
+#include <limits.h>
+#include <unsupported_api.h>
+
+static char *current_domain;
+
+char *__gettextdomain()
+{
+	return current_domain ? current_domain : "messages";
+}
+
+char *textdomain(const char *domainname)
+{
+	unsupported_api(__FUNCTION__);
+	if (!domainname) return __gettextdomain();
+
+	size_t domlen = strlen(domainname);
+	if (domlen > NAME_MAX) {
+		errno = EINVAL;
+		return 0;
+	}
+
+	if (!current_domain) {
+		current_domain = malloc(NAME_MAX+1);
+		if (!current_domain) return 0;
+	}
+
+	memcpy(current_domain, domainname, domlen+1);
+
+	return current_domain;
+}
+
+char *gettext(const char *msgid)
+{
+	unsupported_api(__FUNCTION__);
+	return dgettext(0, msgid);
+}
+
+char *ngettext(const char *msgid1, const char *msgid2, unsigned long int n)
+{
+	unsupported_api(__FUNCTION__);
+	return dngettext(0, msgid1, msgid2, n);
+}
diff --git a/third_party/musl/porting/liteos_a/user/src/malloc/malloc.c b/third_party/musl/porting/liteos_a/user/src/malloc/malloc.c
new file mode 100755
index 000000000..df00631f9
--- /dev/null
+++ b/third_party/musl/porting/liteos_a/user/src/malloc/malloc.c
@@ -0,0 +1,548 @@
+#define _GNU_SOURCE
+#include <stdlib.h>
+#include <string.h>
+#include <limits.h>
+#include <stdint.h>
+#include <errno.h>
+#include <sys/mman.h>
+#include "libc.h"
+#include "atomic.h"
+#include "pthread_impl.h"
+#include "malloc_impl.h"
+
+#if defined(__GNUC__) && defined(__PIC__)
+#define inline inline __attribute__((always_inline))
+#endif
+
+static struct {
+	volatile uint64_t binmap;
+	struct bin bins[64];
+	volatile int free_lock[2];
+} mal;
+
+int __malloc_replaced;
+
+/* Synchronization tools */
+
+static inline void lock(volatile int *lk)
+{
+	if (libc.threads_minus_1)
+		while(a_swap(lk, 1)) __wait(lk, lk+1, 1, 1);
+}
+
+static inline void unlock(volatile int *lk)
+{
+	if (lk[0]) {
+		a_store(lk, 0);
+		if (lk[1]) __wake(lk, 1, 1);
+	}
+}
+
+static inline void lock_bin(int i)
+{
+	lock(mal.bins[i].lock);
+	if (!mal.bins[i].head)
+		mal.bins[i].head = mal.bins[i].tail = BIN_TO_CHUNK(i);
+}
+
+static inline void unlock_bin(int i)
+{
+	unlock(mal.bins[i].lock);
+}
+
+static int first_set(uint64_t x)
+{
+#if 1
+	return a_ctz_64(x);
+#else
+	static const char debruijn64[64] = {
+		0, 1, 2, 53, 3, 7, 54, 27, 4, 38, 41, 8, 34, 55, 48, 28,
+		62, 5, 39, 46, 44, 42, 22, 9, 24, 35, 59, 56, 49, 18, 29, 11,
+		63, 52, 6, 26, 37, 40, 33, 47, 61, 45, 43, 21, 23, 58, 17, 10,
+		51, 25, 36, 32, 60, 20, 57, 16, 50, 31, 19, 15, 30, 14, 13, 12
+	};
+	static const char debruijn32[32] = {
+		0, 1, 23, 2, 29, 24, 19, 3, 30, 27, 25, 11, 20, 8, 4, 13,
+		31, 22, 28, 18, 26, 10, 7, 12, 21, 17, 9, 6, 16, 5, 15, 14
+	};
+	if (sizeof(long) < 8) {
+		uint32_t y = x;
+		if (!y) {
+			y = x>>32;
+			return 32 + debruijn32[(y&-y)*0x076be629 >> 27];
+		}
+		return debruijn32[(y&-y)*0x076be629 >> 27];
+	}
+	return debruijn64[(x&-x)*0x022fdd63cc95386dull >> 58];
+#endif
+}
+
+static const unsigned char bin_tab[60] = {
+	            32,33,34,35,36,36,37,37,38,38,39,39,
+	40,40,40,40,41,41,41,41,42,42,42,42,43,43,43,43,
+	44,44,44,44,44,44,44,44,45,45,45,45,45,45,45,45,
+	46,46,46,46,46,46,46,46,47,47,47,47,47,47,47,47,
+};
+
+static int bin_index(size_t x)
+{
+	x = x / SIZE_ALIGN - 1;
+	if (x <= 32) return x;
+	if (x < 512) return bin_tab[x/8-4];
+	if (x > 0x1c00) return 63;
+	return bin_tab[x/128-4] + 16;
+}
+
+static int bin_index_up(size_t x)
+{
+	x = x / SIZE_ALIGN - 1;
+	if (x <= 32) return x;
+	x--;
+	if (x < 512) return bin_tab[x/8-4] + 1;
+	return bin_tab[x/128-4] + 17;
+}
+
+#if 0
+void __dump_heap(int x)
+{
+	struct chunk *c;
+	int i;
+	for (c = (void *)mal.heap; CHUNK_SIZE(c); c = NEXT_CHUNK(c))
+		fprintf(stderr, "base %p size %zu (%d) flags %d/%d\n",
+			c, CHUNK_SIZE(c), bin_index(CHUNK_SIZE(c)),
+			c->csize & 15,
+			NEXT_CHUNK(c)->psize & 15);
+	for (i=0; i<64; i++) {
+		if (mal.bins[i].head != BIN_TO_CHUNK(i) && mal.bins[i].head) {
+			fprintf(stderr, "bin %d: %p\n", i, mal.bins[i].head);
+			if (!(mal.binmap & 1ULL<<i))
+				fprintf(stderr, "missing from binmap!\n");
+		} else if (mal.binmap & 1ULL<<i)
+			fprintf(stderr, "binmap wrongly contains %d!\n", i);
+	}
+}
+#endif
+
+static struct chunk *expand_heap(size_t n)
+{
+	static int heap_lock[2];
+	static void *end;
+	void *p;
+	struct chunk *w;
+
+	/* The argument n already accounts for the caller's chunk
+	 * overhead needs, but if the heap can't be extended in-place,
+	 * we need room for an extra zero-sized sentinel chunk. */
+	n += SIZE_ALIGN;
+
+	lock(heap_lock);
+
+	p = __expand_heap(&n);
+	if (!p) {
+		unlock(heap_lock);
+		return 0;
+	}
+
+	/* If not just expanding existing space, we need to make a
+	 * new sentinel chunk below the allocated space. */
+	if (p != end) {
+		/* Valid/safe because of the prologue increment. */
+		n -= SIZE_ALIGN;
+		p = (char *)p + SIZE_ALIGN;
+		w = MEM_TO_CHUNK(p);
+		w->psize = 0 | C_INUSE;
+	}
+
+	/* Record new heap end and fill in footer. */
+	end = (char *)p + n;
+	w = MEM_TO_CHUNK(end);
+	w->psize = n | C_INUSE;
+	w->csize = 0 | C_INUSE;
+
+	/* Fill in header, which may be new or may be replacing a
+	 * zero-size sentinel header at the old end-of-heap. */
+	w = MEM_TO_CHUNK(p);
+	w->csize = n | C_INUSE;
+
+	unlock(heap_lock);
+
+	return w;
+}
+
+static int adjust_size(size_t *n)
+{
+	/* Result of pointer difference must fit in ptrdiff_t. */
+	if (*n-1 > PTRDIFF_MAX - SIZE_ALIGN - PAGE_SIZE) {
+		if (*n) {
+			errno = ENOMEM;
+			return -1;
+		} else {
+			*n = SIZE_ALIGN;
+			return 0;
+		}
+	}
+	*n = (*n + OVERHEAD + SIZE_ALIGN - 1) & SIZE_MASK;
+	return 0;
+}
+
+static void unbin(struct chunk *c, int i)
+{
+	if (c->prev == c->next)
+		a_and_64(&mal.binmap, ~(1ULL<<i));
+	c->prev->next = c->next;
+	c->next->prev = c->prev;
+	c->csize |= C_INUSE;
+	NEXT_CHUNK(c)->psize |= C_INUSE;
+}
+
+static int alloc_fwd(struct chunk *c)
+{
+	int i;
+	size_t k;
+	while (!((k=c->csize) & C_INUSE)) {
+		i = bin_index(k);
+		lock_bin(i);
+		if (c->csize == k) {
+			unbin(c, i);
+			unlock_bin(i);
+			return 1;
+		}
+		unlock_bin(i);
+	}
+	return 0;
+}
+
+static int alloc_rev(struct chunk *c)
+{
+	int i;
+	size_t k;
+	while (!((k=c->psize) & C_INUSE)) {
+		i = bin_index(k);
+		lock_bin(i);
+		if (c->psize == k) {
+			unbin(PREV_CHUNK(c), i);
+			unlock_bin(i);
+			return 1;
+		}
+		unlock_bin(i);
+	}
+	return 0;
+}
+
+
+/* pretrim - trims a chunk _prior_ to removing it from its bin.
+ * Must be called with i as the ideal bin for size n, j the bin
+ * for the _free_ chunk self, and bin j locked. */
+static int pretrim(struct chunk *self, size_t n, int i, int j)
+{
+	size_t n1;
+	struct chunk *next, *split;
+
+	/* We cannot pretrim if it would require re-binning. */
+	if (j < 40) return 0;
+	if (j < i+3) {
+		if (j != 63) return 0;
+		n1 = CHUNK_SIZE(self);
+		if (n1-n <= MMAP_THRESHOLD) return 0;
+	} else {
+		n1 = CHUNK_SIZE(self);
+	}
+	if (bin_index(n1-n) != j) return 0;
+
+	next = NEXT_CHUNK(self);
+	split = (void *)((char *)self + n);
+
+	split->prev = self->prev;
+	split->next = self->next;
+	split->prev->next = split;
+	split->next->prev = split;
+	split->psize = n | C_INUSE;
+	split->csize = n1-n;
+	next->psize = n1-n;
+	self->csize = n | C_INUSE;
+	return 1;
+}
+
+static void trim(struct chunk *self, size_t n)
+{
+	size_t n1 = CHUNK_SIZE(self);
+	struct chunk *next, *split;
+
+	if (n >= n1 - DONTCARE) return;
+
+	next = NEXT_CHUNK(self);
+	split = (void *)((char *)self + n);
+
+	split->psize = n | C_INUSE;
+	split->csize = n1-n | C_INUSE;
+	next->psize = n1-n | C_INUSE;
+	self->csize = n | C_INUSE;
+
+	__bin_chunk(split);
+}
+
+void *malloc(size_t n)
+{
+	struct chunk *c;
+	int i, j;
+
+	if (adjust_size(&n) < 0) return 0;
+
+	if (n > MMAP_THRESHOLD) {
+		size_t len = n + OVERHEAD + PAGE_SIZE - 1 & -PAGE_SIZE;
+		char *base = __mmap(0, len, PROT_READ|PROT_WRITE,
+			MAP_PRIVATE|MAP_ANONYMOUS, -1, 0);
+		if (base == (void *)-1) return 0;
+		c = (void *)(base + SIZE_ALIGN - OVERHEAD);
+		c->csize = len - (SIZE_ALIGN - OVERHEAD);
+		c->psize = SIZE_ALIGN - OVERHEAD;
+		return CHUNK_TO_MEM(c);
+	}
+
+	i = bin_index_up(n);
+	for (;;) {
+		uint64_t mask = mal.binmap & -(1ULL<<i);
+		if (!mask) {
+			c = expand_heap(n);
+			if (!c) return 0;
+			if (alloc_rev(c)) {
+				struct chunk *x = c;
+				c = PREV_CHUNK(c);
+				NEXT_CHUNK(x)->psize = c->csize =
+					x->csize + CHUNK_SIZE(c);
+			}
+			break;
+		}
+		j = first_set(mask);
+		lock_bin(j);
+		c = mal.bins[j].head;
+		if (c != BIN_TO_CHUNK(j)) {
+			if (!pretrim(c, n, i, j)) unbin(c, j);
+			unlock_bin(j);
+			break;
+		}
+		unlock_bin(j);
+	}
+
+	/* Now patch up in case we over-allocated */
+	trim(c, n);
+
+	return CHUNK_TO_MEM(c);
+}
+
+static size_t mal0_clear(char *p, size_t pagesz, size_t n)
+{
+#ifdef __GNUC__
+	typedef uint64_t __attribute__((__may_alias__)) T;
+#else
+	typedef unsigned char T;
+#endif
+	char *pp = p + n;
+	size_t i = (uintptr_t)pp & (pagesz - 1);
+	for (;;) {
+		pp = memset(pp - i, 0, i);
+		if (pp - p < pagesz) return pp - p;
+		for (i = pagesz; i; i -= 2*sizeof(T), pp -= 2*sizeof(T))
+		        if (((T *)pp)[-1] | ((T *)pp)[-2])
+				break;
+	}
+}
+
+void *calloc(size_t m, size_t n)
+{
+	if (n && m > (size_t)-1/n) {
+		errno = ENOMEM;
+		return 0;
+	}
+	n *= m;
+	void *p = malloc(n);
+	if (!p) return p;
+	if (!__malloc_replaced) {
+		if (IS_MMAPPED(MEM_TO_CHUNK(p)))
+			return p;
+		if (n >= PAGE_SIZE)
+			n = mal0_clear(p, PAGE_SIZE, n);
+	}
+	return memset(p, 0, n);
+}
+
+void *realloc(void *p, size_t n)
+{
+	struct chunk *self, *next;
+	size_t n0, n1;
+	void *new;
+
+	if (!p) return malloc(n);
+
+	if (adjust_size(&n) < 0) return 0;
+
+	self = MEM_TO_CHUNK(p);
+	n1 = n0 = CHUNK_SIZE(self);
+
+	if (IS_MMAPPED(self)) {
+		size_t extra = self->psize;
+		char *base = (char *)self - extra;
+		size_t oldlen = n0 + extra;
+		size_t newlen = n + extra;
+		/* Crash on realloc of freed chunk */
+		if (extra & 1) a_crash();
+		if (newlen < PAGE_SIZE && (new = malloc(n-OVERHEAD))) {
+			n0 = n;
+			goto copy_free_ret;
+		}
+		newlen = (newlen + PAGE_SIZE-1) & -PAGE_SIZE;
+		if (oldlen == newlen) return p;
+		base = __mremap(base, oldlen, newlen, MREMAP_MAYMOVE);
+		if (base == (void *)-1)
+			goto copy_realloc;
+		self = (void *)(base + extra);
+		self->csize = newlen - extra;
+		return CHUNK_TO_MEM(self);
+	}
+
+	next = NEXT_CHUNK(self);
+
+	/* Crash on corrupted footer (likely from buffer overflow) */
+	if (next->psize != self->csize) a_crash();
+
+	/* Merge adjacent chunks if we need more space. This is not
+	 * a waste of time even if we fail to get enough space, because our
+	 * subsequent call to free would otherwise have to do the merge. */
+	if (n > n1 && alloc_fwd(next)) {
+		n1 += CHUNK_SIZE(next);
+		next = NEXT_CHUNK(next);
+	}
+	/* FIXME: find what's wrong here and reenable it..? */
+	if (0 && n > n1 && alloc_rev(self)) {
+		self = PREV_CHUNK(self);
+		n1 += CHUNK_SIZE(self);
+	}
+	self->csize = n1 | C_INUSE;
+	next->psize = n1 | C_INUSE;
+
+	/* If we got enough space, split off the excess and return */
+	if (n <= n1) {
+		//memmove(CHUNK_TO_MEM(self), p, n0-OVERHEAD);
+		trim(self, n);
+		return CHUNK_TO_MEM(self);
+	}
+
+copy_realloc:
+	/* As a last resort, allocate a new chunk and copy to it. */
+	new = malloc(n-OVERHEAD);
+	if (!new) return 0;
+copy_free_ret:
+	memcpy(new, p, n0-OVERHEAD);
+	free(CHUNK_TO_MEM(self));
+	return new;
+}
+
+void __bin_chunk(struct chunk *self)
+{
+	struct chunk *next = NEXT_CHUNK(self);
+	size_t final_size, new_size, size;
+	int reclaim=0;
+	int i;
+
+	final_size = new_size = CHUNK_SIZE(self);
+
+	/* Crash on corrupted footer (likely from buffer overflow) */
+	if (next->psize != self->csize) a_crash();
+
+	for (;;) {
+		if (self->psize & next->csize & C_INUSE) {
+			self->csize = final_size | C_INUSE;
+			next->psize = final_size | C_INUSE;
+			i = bin_index(final_size);
+			lock_bin(i);
+			lock(mal.free_lock);
+			if (self->psize & next->csize & C_INUSE)
+				break;
+			unlock(mal.free_lock);
+			unlock_bin(i);
+		}
+
+		if (alloc_rev(self)) {
+			self = PREV_CHUNK(self);
+			size = CHUNK_SIZE(self);
+			final_size += size;
+			if (new_size+size > RECLAIM && (new_size+size^size) > size)
+				reclaim = 1;
+		}
+
+		if (alloc_fwd(next)) {
+			size = CHUNK_SIZE(next);
+			final_size += size;
+			if (new_size+size > RECLAIM && (new_size+size^size) > size)
+				reclaim = 1;
+			next = NEXT_CHUNK(next);
+		}
+	}
+
+	if (!(mal.binmap & 1ULL<<i))
+		a_or_64(&mal.binmap, 1ULL<<i);
+
+	self->csize = final_size;
+	next->psize = final_size;
+	unlock(mal.free_lock);
+
+	self->next = BIN_TO_CHUNK(i);
+	self->prev = mal.bins[i].tail;
+	self->next->prev = self;
+	self->prev->next = self;
+
+	/* Replace middle of large chunks with fresh zero pages */
+	if (reclaim) {
+		uintptr_t a = (uintptr_t)self + SIZE_ALIGN+PAGE_SIZE-1 & -PAGE_SIZE;
+		uintptr_t b = (uintptr_t)next - SIZE_ALIGN & -PAGE_SIZE;
+#if 0
+		__madvise((void *)a, b-a, MADV_DONTNEED);
+#else
+		__mmap((void *)a, b-a, PROT_READ|PROT_WRITE,
+			MAP_PRIVATE|MAP_ANONYMOUS|MAP_FIXED, -1, 0);
+#endif
+	}
+
+	unlock_bin(i);
+}
+
+static void unmap_chunk(struct chunk *self)
+{
+	size_t extra = self->psize;
+	char *base = (char *)self - extra;
+	size_t len = CHUNK_SIZE(self) + extra;
+	/* Crash on double free */
+	if (extra & 1) a_crash();
+	__munmap(base, len);
+}
+
+void free(void *p)
+{
+	if (!p) return;
+
+	struct chunk *self = MEM_TO_CHUNK(p);
+
+	if (IS_MMAPPED(self))
+		unmap_chunk(self);
+	else
+		__bin_chunk(self);
+}
+
+void __malloc_donate(char *start, char *end)
+{
+	size_t align_start_up = (SIZE_ALIGN-1) & (-(uintptr_t)start - OVERHEAD);
+	size_t align_end_down = (SIZE_ALIGN-1) & (uintptr_t)end;
+
+	/* Getting past this condition ensures that the padding for alignment
+	 * and header overhead will not overflow and will leave a nonzero
+	 * multiple of SIZE_ALIGN bytes between start and end. */
+	if (end - start <= OVERHEAD + align_start_up + align_end_down)
+		return;
+	start += align_start_up + OVERHEAD;
+	end   -= align_end_down;
+
+	struct chunk *c = MEM_TO_CHUNK(start), *n = MEM_TO_CHUNK(end);
+	c->psize = n->csize = C_INUSE;
+	c->csize = n->psize = C_INUSE | (end-start);
+	__bin_chunk(c);
+}
diff --git a/third_party/musl/porting/liteos_a/user/src/misc/gethostid.c b/third_party/musl/porting/liteos_a/user/src/misc/gethostid.c
new file mode 100755
index 000000000..f6c223da7
--- /dev/null
+++ b/third_party/musl/porting/liteos_a/user/src/misc/gethostid.c
@@ -0,0 +1,8 @@
+#include <unistd.h>
+#include <unsupported_api.h>
+
+long gethostid()
+{
+	unsupported_api(__FUNCTION__);
+	return 0;
+}
diff --git a/third_party/musl/porting/liteos_a/user/src/misc/getpriority.c b/third_party/musl/porting/liteos_a/user/src/misc/getpriority.c
new file mode 100755
index 000000000..42382122c
--- /dev/null
+++ b/third_party/musl/porting/liteos_a/user/src/misc/getpriority.c
@@ -0,0 +1,7 @@
+#include <sys/resource.h>
+#include "syscall.h"
+
+int getpriority(int which, id_t who)
+{
+    return syscall(SYS_getpriority, which, who);
+}
diff --git a/third_party/musl/porting/liteos_a/user/src/misc/getrlimit.c b/third_party/musl/porting/liteos_a/user/src/misc/getrlimit.c
new file mode 100755
index 000000000..69b73fcc1
--- /dev/null
+++ b/third_party/musl/porting/liteos_a/user/src/misc/getrlimit.c
@@ -0,0 +1,28 @@
+#include <sys/resource.h>
+#include <errno.h>
+#include <unsupported_api.h>
+#include "syscall.h"
+
+#define FIX(x) do{ if ((x)>=SYSCALL_RLIM_INFINITY) (x)=RLIM_INFINITY; }while(0)
+
+int getrlimit(int resource, struct rlimit *rlim)
+{
+	unsigned long k_rlim[2];
+	unsupported_api(__FUNCTION__);
+	int ret = syscall(SYS_prlimit64, 0, resource, 0, rlim);
+	if (!ret) {
+		FIX(rlim->rlim_cur);
+		FIX(rlim->rlim_max);
+	}
+	if (!ret || errno != ENOSYS)
+		return ret;
+	if (syscall(SYS_getrlimit, resource, k_rlim) < 0)
+		return -1;
+	rlim->rlim_cur = k_rlim[0] == -1UL ? RLIM_INFINITY : k_rlim[0];
+	rlim->rlim_max = k_rlim[1] == -1UL ? RLIM_INFINITY : k_rlim[1];
+	FIX(rlim->rlim_cur);
+	FIX(rlim->rlim_max);
+	return 0;
+}
+
+weak_alias(getrlimit, getrlimit64);
diff --git a/third_party/musl/porting/liteos_a/user/src/misc/lockf.c b/third_party/musl/porting/liteos_a/user/src/misc/lockf.c
new file mode 100755
index 000000000..f6d9a0bbd
--- /dev/null
+++ b/third_party/musl/porting/liteos_a/user/src/misc/lockf.c
@@ -0,0 +1,34 @@
+#include <unistd.h>
+#include <fcntl.h>
+#include <errno.h>
+#include <unsupported_api.h>
+
+int lockf(int fd, int op, off_t size)
+{
+	struct flock l = {
+		.l_type = F_WRLCK,
+		.l_whence = SEEK_CUR,
+		.l_len = size,
+	};
+	unsupported_api(__FUNCTION__);
+	switch (op) {
+	case F_TEST:
+		l.l_type = F_RDLCK;
+		if (fcntl(fd, F_GETLK, &l) < 0)
+			return -1;
+		if (l.l_type == F_UNLCK || l.l_pid == getpid())
+			return 0;
+		errno = EACCES;
+		return -1;
+	case F_ULOCK:
+		l.l_type = F_UNLCK;
+	case F_TLOCK:
+		return fcntl(fd, F_SETLK, &l);
+	case F_LOCK:
+		return fcntl(fd, F_SETLKW, &l);
+	}
+	errno = EINVAL;
+	return -1;
+}
+
+weak_alias(lockf, lockf64);
diff --git a/third_party/musl/porting/liteos_a/user/src/misc/mntent.c b/third_party/musl/porting/liteos_a/user/src/misc/mntent.c
new file mode 100755
index 000000000..2ddaaeed3
--- /dev/null
+++ b/third_party/musl/porting/liteos_a/user/src/misc/mntent.c
@@ -0,0 +1,83 @@
+#include <stdio.h>
+#include <string.h>
+#include <mntent.h>
+#include <errno.h>
+#include <unsupported_api.h>
+
+static char *internal_buf;
+static size_t internal_bufsize;
+
+#define SENTINEL (char *)&internal_buf
+
+FILE *setmntent(const char *name, const char *mode)
+{
+	unsupported_api(__FUNCTION__);
+	return fopen(name, mode);
+}
+
+int endmntent(FILE *f)
+{
+	if (f) fclose(f);
+	return 1;
+}
+
+struct mntent *getmntent_r(FILE *f, struct mntent *mnt, char *linebuf, int buflen)
+{
+	int cnt, n[8], use_internal = (linebuf == SENTINEL);
+
+	mnt->mnt_freq = 0;
+	mnt->mnt_passno = 0;
+
+	unsupported_api(__FUNCTION__);
+	do {
+		if (use_internal) {
+			getline(&internal_buf, &internal_bufsize, f);
+			linebuf = internal_buf;
+		} else {
+			fgets(linebuf, buflen, f);
+		}
+		if (feof(f) || ferror(f)) return 0;
+		if (!strchr(linebuf, '\n')) {
+			fscanf(f, "%*[^\n]%*[\n]");
+			errno = ERANGE;
+			return 0;
+		}
+		cnt = sscanf(linebuf, " %n%*s%n %n%*s%n %n%*s%n %n%*s%n %d %d",
+			n, n+1, n+2, n+3, n+4, n+5, n+6, n+7,
+			&mnt->mnt_freq, &mnt->mnt_passno);
+	} while (cnt < 2 || linebuf[n[0]] == '#');
+
+	linebuf[n[1]] = 0;
+	linebuf[n[3]] = 0;
+	linebuf[n[5]] = 0;
+	linebuf[n[7]] = 0;
+
+	mnt->mnt_fsname = linebuf+n[0];
+	mnt->mnt_dir = linebuf+n[2];
+	mnt->mnt_type = linebuf+n[4];
+	mnt->mnt_opts = linebuf+n[6];
+
+	return mnt;
+}
+
+struct mntent *getmntent(FILE *f)
+{
+	static struct mntent mnt;
+	unsupported_api(__FUNCTION__);
+	return getmntent_r(f, &mnt, SENTINEL, 0);
+}
+
+int addmntent(FILE *f, const struct mntent *mnt)
+{
+	unsupported_api(__FUNCTION__);
+	if (fseek(f, 0, SEEK_END)) return 1;
+	return fprintf(f, "%s\t%s\t%s\t%s\t%d\t%d\n",
+		mnt->mnt_fsname, mnt->mnt_dir, mnt->mnt_type, mnt->mnt_opts,
+		mnt->mnt_freq, mnt->mnt_passno) < 0;
+}
+
+char *hasmntopt(const struct mntent *mnt, const char *opt)
+{
+	unsupported_api(__FUNCTION__);
+	return strstr(mnt->mnt_opts, opt);
+}
diff --git a/third_party/musl/porting/liteos_a/user/src/misc/openpty.c b/third_party/musl/porting/liteos_a/user/src/misc/openpty.c
new file mode 100755
index 000000000..9c1ed0369
--- /dev/null
+++ b/third_party/musl/porting/liteos_a/user/src/misc/openpty.c
@@ -0,0 +1,42 @@
+#include <stdlib.h>
+#include <fcntl.h>
+#include <unistd.h>
+#include <pty.h>
+#include <stdio.h>
+#include <pthread.h>
+#include <unsupported_api.h>
+
+/* Nonstandard, but vastly superior to the standard functions */
+
+int openpty(int *pm, int *ps, char *name, const struct termios *tio, const struct winsize *ws)
+{
+	int m, s, n=0, cs;
+	char buf[20];
+
+	unsupported_api(__FUNCTION__);
+	m = open("/dev/ptmx", O_RDWR|O_NOCTTY);
+	if (m < 0) return -1;
+
+	pthread_setcancelstate(PTHREAD_CANCEL_DISABLE, &cs);
+
+	if (ioctl(m, TIOCSPTLCK, &n) || ioctl (m, TIOCGPTN, &n))
+		goto fail;
+
+	if (!name) name = buf;
+	snprintf(name, sizeof buf, "/dev/pts/%d", n);
+	if ((s = open(name, O_RDWR|O_NOCTTY)) < 0)
+		goto fail;
+
+	if (tio) tcsetattr(s, TCSANOW, tio);
+	if (ws) ioctl(s, TIOCSWINSZ, ws);
+
+	*pm = m;
+	*ps = s;
+
+	pthread_setcancelstate(cs, 0);
+	return 0;
+fail:
+	close(m);
+	pthread_setcancelstate(cs, 0);
+	return -1;
+}
diff --git a/third_party/musl/porting/liteos_a/user/src/misc/pty.c b/third_party/musl/porting/liteos_a/user/src/misc/pty.c
new file mode 100755
index 000000000..8842b0e51
--- /dev/null
+++ b/third_party/musl/porting/liteos_a/user/src/misc/pty.c
@@ -0,0 +1,38 @@
+#include <stdlib.h>
+#include <sys/ioctl.h>
+#include <stdio.h>
+#include <fcntl.h>
+#include <errno.h>
+#include <unsupported_api.h>
+#include "syscall.h"
+
+int posix_openpt(int flags)
+{
+	unsupported_api(__FUNCTION__);
+	int r = open("/dev/ptmx", flags);
+	if (r < 0 && errno == ENOSPC) errno = EAGAIN;
+	return r;
+}
+
+int grantpt(int fd)
+{
+	unsupported_api(__FUNCTION__);
+	return 0;
+}
+
+int unlockpt(int fd)
+{
+	int unlock = 0;
+	return ioctl(fd, TIOCSPTLCK, &unlock);
+}
+
+int __ptsname_r(int fd, char *buf, size_t len)
+{
+	int pty, err;
+	if (!buf) len = 0;
+	if ((err = __syscall(SYS_ioctl, fd, TIOCGPTN, &pty))) return -err;
+	if (snprintf(buf, len, "/dev/pts/%d", pty) >= len) return ERANGE;
+	return 0;
+}
+
+weak_alias(__ptsname_r, ptsname_r);
diff --git a/third_party/musl/porting/liteos_a/user/src/misc/realpath.c b/third_party/musl/porting/liteos_a/user/src/misc/realpath.c
new file mode 100755
index 000000000..58167a483
--- /dev/null
+++ b/third_party/musl/porting/liteos_a/user/src/misc/realpath.c
@@ -0,0 +1,24 @@
+#include <stdlib.h>
+#include <limits.h>
+#include <sys/stat.h>
+#include <fcntl.h>
+#include <errno.h>
+#include <unistd.h>
+#include <string.h>
+#include "syscall.h"
+
+char *realpath(const char *restrict filename, char *restrict resolved)
+{
+	int ret;
+	char tmp[PATH_MAX];
+
+	if (!filename) {
+		errno = EINVAL;
+		return 0;
+	}
+
+	ret = syscall(SYS_realpath, filename, tmp);
+	if (ret < 0) return 0;
+
+	return resolved ? strcpy(resolved, tmp) : strdup(tmp);
+}
diff --git a/third_party/musl/porting/liteos_a/user/src/misc/setrlimit.c b/third_party/musl/porting/liteos_a/user/src/misc/setrlimit.c
new file mode 100755
index 000000000..715667551
--- /dev/null
+++ b/third_party/musl/porting/liteos_a/user/src/misc/setrlimit.c
@@ -0,0 +1,52 @@
+#include <sys/resource.h>
+#include <errno.h>
+#include <unsupported_api.h>
+#include "syscall.h"
+#include "libc.h"
+
+#define MIN(a, b) ((a)<(b) ? (a) : (b))
+#define FIX(x) do{ if ((x)>=SYSCALL_RLIM_INFINITY) (x)=RLIM_INFINITY; }while(0)
+
+static int __setrlimit(int resource, const struct rlimit *rlim)
+{
+	unsigned long k_rlim[2];
+	struct rlimit tmp;
+	if (SYSCALL_RLIM_INFINITY != RLIM_INFINITY) {
+		tmp = *rlim;
+		FIX(tmp.rlim_cur);
+		FIX(tmp.rlim_max);
+		rlim = &tmp;
+	}
+	int ret = __syscall(SYS_prlimit64, 0, resource, rlim, 0);
+	if (ret != -ENOSYS) return ret;
+	k_rlim[0] = MIN(rlim->rlim_cur, MIN(-1UL, SYSCALL_RLIM_INFINITY));
+	k_rlim[1] = MIN(rlim->rlim_max, MIN(-1UL, SYSCALL_RLIM_INFINITY));
+	return __syscall(SYS_setrlimit, resource, k_rlim);
+}
+
+struct ctx {
+	const struct rlimit *rlim;
+	int res;
+	int err;
+};
+
+static void do_setrlimit(void *p)
+{
+	struct ctx *c = p;
+	if (c->err>0) return;
+	c->err = -__setrlimit(c->res, c->rlim);
+}
+
+int setrlimit(int resource, const struct rlimit *rlim)
+{
+	unsupported_api(__FUNCTION__);
+	struct ctx c = { .res = resource, .rlim = rlim, .err = -1 };
+	__synccall(do_setrlimit, &c);
+	if (c.err) {
+		if (c.err>0) errno = c.err;
+		return -1;
+	}
+	return 0;
+}
+
+weak_alias(setrlimit, setrlimit64);
diff --git a/third_party/musl/porting/liteos_a/user/src/misc/syslog.c b/third_party/musl/porting/liteos_a/user/src/misc/syslog.c
new file mode 100755
index 000000000..1c5dcbc43
--- /dev/null
+++ b/third_party/musl/porting/liteos_a/user/src/misc/syslog.c
@@ -0,0 +1,149 @@
+#include <stdarg.h>
+#include <sys/socket.h>
+#include <stdio.h>
+#include <unistd.h>
+#include <syslog.h>
+#include <time.h>
+#include <signal.h>
+#include <string.h>
+#include <pthread.h>
+#include <errno.h>
+#include <fcntl.h>
+#include <unsupported_api.h>
+#include "lock.h"
+
+static volatile int lock[1];
+static char log_ident[32];
+static int log_opt;
+static int log_facility = LOG_USER;
+static int log_mask = 0xff;
+static int log_fd = -1;
+
+int setlogmask(int maskpri)
+{
+	unsupported_api(__FUNCTION__);
+	LOCK(lock);
+	int ret = log_mask;
+	if (maskpri) log_mask = maskpri;
+	UNLOCK(lock);
+	return ret;
+}
+
+static const struct {
+	short sun_family;
+	char sun_path[9];
+} log_addr = {
+	AF_UNIX,
+	"/dev/log"
+};
+
+void closelog(void)
+{
+	int cs;
+	unsupported_api(__FUNCTION__);
+	pthread_setcancelstate(PTHREAD_CANCEL_DISABLE, &cs);
+	LOCK(lock);
+	close(log_fd);
+	log_fd = -1;
+	UNLOCK(lock);
+	pthread_setcancelstate(cs, 0);
+}
+
+static void __openlog()
+{
+	log_fd = socket(AF_UNIX, SOCK_DGRAM|SOCK_CLOEXEC, 0);
+	if (log_fd >= 0) connect(log_fd, (void *)&log_addr, sizeof log_addr);
+}
+
+void openlog(const char *ident, int opt, int facility)
+{
+	int cs;
+	unsupported_api(__FUNCTION__);
+	pthread_setcancelstate(PTHREAD_CANCEL_DISABLE, &cs);
+	LOCK(lock);
+
+	if (ident) {
+		size_t n = strnlen(ident, sizeof log_ident - 1);
+		memcpy(log_ident, ident, n);
+		log_ident[n] = 0;
+	} else {
+		log_ident[0] = 0;
+	}
+	log_opt = opt;
+	log_facility = facility;
+
+	if ((opt & LOG_NDELAY) && log_fd<0) __openlog();
+
+	UNLOCK(lock);
+	pthread_setcancelstate(cs, 0);
+}
+
+static int is_lost_conn(int e)
+{
+	return e==ECONNREFUSED || e==ECONNRESET || e==ENOTCONN || e==EPIPE;
+}
+
+static void _vsyslog(int priority, const char *message, va_list ap)
+{
+	char timebuf[16];
+	time_t now;
+	struct tm tm;
+	char buf[1024];
+	int errno_save = errno;
+	int pid;
+	int l, l2;
+	int hlen;
+	int fd;
+
+	if (log_fd < 0) __openlog();
+
+	if (!(priority & LOG_FACMASK)) priority |= log_facility;
+
+	now = time(NULL);
+	gmtime_r(&now, &tm);
+	strftime(timebuf, sizeof timebuf, "%b %e %T", &tm);
+
+	pid = (log_opt & LOG_PID) ? getpid() : 0;
+	l = snprintf(buf, sizeof buf, "<%d>%s %n%s%s%.0d%s: ",
+		priority, timebuf, &hlen, log_ident, "["+!pid, pid, "]"+!pid);
+	errno = errno_save;
+	l2 = vsnprintf(buf+l, sizeof buf - l, message, ap);
+	if (l2 >= 0) {
+		if (l2 >= sizeof buf - l) l = sizeof buf - 1;
+		else l += l2;
+		if (buf[l-1] != '\n') buf[l++] = '\n';
+		if (send(log_fd, buf, l, 0) < 0 && (!is_lost_conn(errno)
+		    || connect(log_fd, (void *)&log_addr, sizeof log_addr) < 0
+		    || send(log_fd, buf, l, 0) < 0)
+		    && (log_opt & LOG_CONS)) {
+			fd = open("/dev/console", O_WRONLY|O_NOCTTY|O_CLOEXEC);
+			if (fd >= 0) {
+				dprintf(fd, "%.*s", l-hlen, buf+hlen);
+				close(fd);
+			}
+		}
+		if (log_opt & LOG_PERROR) dprintf(2, "%.*s", l-hlen, buf+hlen);
+	}
+}
+
+static void __vsyslog(int priority, const char *message, va_list ap)
+{
+	int cs;
+	if (!(log_mask & LOG_MASK(priority&7)) || (priority&~0x3ff)) return;
+	pthread_setcancelstate(PTHREAD_CANCEL_DISABLE, &cs);
+	LOCK(lock);
+	_vsyslog(priority, message, ap);
+	UNLOCK(lock);
+	pthread_setcancelstate(cs, 0);
+}
+
+void syslog(int priority, const char *message, ...)
+{
+	unsupported_api(__FUNCTION__);
+	va_list ap;
+	va_start(ap, message);
+	__vsyslog(priority, message, ap);
+	va_end(ap);
+}
+
+weak_alias(__vsyslog, vsyslog);
diff --git a/third_party/musl/porting/liteos_a/user/src/misc/wordexp.c b/third_party/musl/porting/liteos_a/user/src/misc/wordexp.c
new file mode 100755
index 000000000..19d4fe1fd
--- /dev/null
+++ b/third_party/musl/porting/liteos_a/user/src/misc/wordexp.c
@@ -0,0 +1,189 @@
+#include <wordexp.h>
+#include <unistd.h>
+#include <stdio.h>
+#include <string.h>
+#include <limits.h>
+#include <stdint.h>
+#include <stdlib.h>
+#include <sys/wait.h>
+#include <signal.h>
+#include <errno.h>
+#include <fcntl.h>
+#include <unsupported_api.h>
+#include "pthread_impl.h"
+
+static void reap(pid_t pid)
+{
+	int status;
+	while (waitpid(pid, &status, 0) < 0 && errno == EINTR);
+}
+
+static char *getword(FILE *f)
+{
+	char *s = 0;
+	return getdelim(&s, (size_t [1]){0}, 0, f) < 0 ? 0 : s;
+}
+
+static int do_wordexp(const char *s, wordexp_t *we, int flags)
+{
+	size_t i, l;
+	int sq=0, dq=0;
+	size_t np=0;
+	char *w, **tmp;
+	char *redir = (flags & WRDE_SHOWERR) ? "" : "2>/dev/null";
+	int err = 0;
+	FILE *f;
+	size_t wc = 0;
+	char **wv = 0;
+	int p[2];
+	pid_t pid;
+	sigset_t set;
+
+	if (flags & WRDE_REUSE) wordfree(we);
+
+	if (flags & WRDE_NOCMD) for (i=0; s[i]; i++) switch (s[i]) {
+	case '\\':
+		if (!sq && !s[++i]) return WRDE_SYNTAX;
+		break;
+	case '\'':
+		if (!dq) sq^=1;
+		break;
+	case '"':
+		if (!sq) dq^=1;
+		break;
+	case '(':
+		if (np) {
+			np++;
+			break;
+		}
+	case ')':
+		if (np) {
+			np--;
+			break;
+		}
+	case '\n':
+	case '|':
+	case '&':
+	case ';':
+	case '<':
+	case '>':
+	case '{':
+	case '}':
+		if (!(sq|dq|np)) return WRDE_BADCHAR;
+		break;
+	case '$':
+		if (sq) break;
+		if (s[i+1]=='(' && s[i+2]=='(') {
+			i += 2;
+			np += 2;
+			break;
+		} else if (s[i+1] != '(') break;
+	case '`':
+		if (sq) break;
+		return WRDE_CMDSUB;
+	}
+
+	if (flags & WRDE_APPEND) {
+		wc = we->we_wordc;
+		wv = we->we_wordv;
+	}
+
+	i = wc;
+	if (flags & WRDE_DOOFFS) {
+		if (we->we_offs > SIZE_MAX/sizeof(void *)/4)
+			goto nospace;
+		i += we->we_offs;
+	} else {
+		we->we_offs = 0;
+	}
+
+	if (pipe2(p, O_CLOEXEC) < 0) goto nospace;
+	__block_all_sigs(&set);
+	pid = fork();
+	__restore_sigs(&set);
+	if (pid < 0) {
+		close(p[0]);
+		close(p[1]);
+		goto nospace;
+	}
+	if (!pid) {
+		if (p[1] == 1) fcntl(1, F_SETFD, 0);
+		else dup2(p[1], 1);
+		execl("/bin/sh", "sh", "-c",
+			"eval \"printf %s\\\\\\\\0 x $1 $2\"",
+			"sh", s, redir, (char *)0);
+		_exit(1);
+	}
+	close(p[1]);
+	
+	f = fdopen(p[0], "r");
+	if (!f) {
+		close(p[0]);
+		kill(pid, SIGKILL);
+		reap(pid);
+		goto nospace;
+	}
+
+	l = wv ? i+1 : 0;
+
+	free(getword(f));
+	if (feof(f)) {
+		fclose(f);
+		reap(pid);
+		return WRDE_SYNTAX;
+	}
+
+	while ((w = getword(f))) {
+		if (i+1 >= l) {
+			l += l/2+10;
+			tmp = realloc(wv, l*sizeof(char *));
+			if (!tmp) break;
+			wv = tmp;
+		}
+		wv[i++] = w;
+		wv[i] = 0;
+	}
+	if (!feof(f)) err = WRDE_NOSPACE;
+
+	fclose(f);
+	reap(pid);
+
+	if (!wv) wv = calloc(i+1, sizeof *wv);
+
+	we->we_wordv = wv;
+	we->we_wordc = i;
+
+	if (flags & WRDE_DOOFFS) {
+		if (wv) for (i=we->we_offs; i; i--)
+			we->we_wordv[i-1] = 0;
+		we->we_wordc -= we->we_offs;
+	}
+	return err;
+
+nospace:
+	if (!(flags & WRDE_APPEND)) {
+		we->we_wordc = 0;
+		we->we_wordv = 0;
+	}
+	return WRDE_NOSPACE;
+}
+
+int wordexp(const char *restrict s, wordexp_t *restrict we, int flags)
+{
+	int r, cs;
+	unsupported_api(__FUNCTION__);
+	pthread_setcancelstate(PTHREAD_CANCEL_DISABLE, &cs);
+	r = do_wordexp(s, we, flags);
+	pthread_setcancelstate(cs, 0);
+	return r;
+}
+
+void wordfree(wordexp_t *we)
+{
+	size_t i;
+	if (!we->we_wordv) return;
+	for (i=0; i<we->we_wordc; i++) free(we->we_wordv[we->we_offs+i]);
+	free(we->we_wordv);
+	we->we_wordv = 0;
+	we->we_wordc = 0;
+}
diff --git a/third_party/musl/porting/liteos_a/user/src/mman/mlock.c b/third_party/musl/porting/liteos_a/user/src/mman/mlock.c
new file mode 100755
index 000000000..e56c3228e
--- /dev/null
+++ b/third_party/musl/porting/liteos_a/user/src/mman/mlock.c
@@ -0,0 +1,13 @@
+#include <sys/mman.h>
+#include "syscall.h"
+#include <unsupported_api.h>
+
+int mlock(const void *addr, size_t len)
+{
+	unsupported_api(__FUNCTION__);
+#ifdef SYS_mlock
+	return syscall(SYS_mlock, addr, len);
+#else
+	return syscall(SYS_mlock2, addr, len, 0);
+#endif
+}
diff --git a/third_party/musl/porting/liteos_a/user/src/mman/mlockall.c b/third_party/musl/porting/liteos_a/user/src/mman/mlockall.c
new file mode 100755
index 000000000..bc2411e65
--- /dev/null
+++ b/third_party/musl/porting/liteos_a/user/src/mman/mlockall.c
@@ -0,0 +1,9 @@
+#include <sys/mman.h>
+#include <unsupported_api.h>
+#include "syscall.h"
+
+int mlockall(int flags)
+{
+	unsupported_api(__FUNCTION__);
+	return syscall(SYS_mlockall, flags);
+}
diff --git a/third_party/musl/porting/liteos_a/user/src/mman/msync.c b/third_party/musl/porting/liteos_a/user/src/mman/msync.c
new file mode 100755
index 000000000..61cbf5f0d
--- /dev/null
+++ b/third_party/musl/porting/liteos_a/user/src/mman/msync.c
@@ -0,0 +1,9 @@
+#include <sys/mman.h>
+#include <unsupported_api.h>
+#include "syscall.h"
+
+int msync(void *start, size_t len, int flags)
+{
+	unsupported_api(__FUNCTION__);
+	return syscall_cp(SYS_msync, start, len, flags);
+}
diff --git a/third_party/musl/porting/liteos_a/user/src/mman/munlock.c b/third_party/musl/porting/liteos_a/user/src/mman/munlock.c
new file mode 100755
index 000000000..8a6463a1e
--- /dev/null
+++ b/third_party/musl/porting/liteos_a/user/src/mman/munlock.c
@@ -0,0 +1,9 @@
+#include <sys/mman.h>
+#include <unsupported_api.h>
+#include "syscall.h"
+
+int munlock(const void *addr, size_t len)
+{
+	unsupported_api(__FUNCTION__);
+	return syscall(SYS_munlock, addr, len);
+}
diff --git a/third_party/musl/porting/liteos_a/user/src/mman/munlockall.c b/third_party/musl/porting/liteos_a/user/src/mman/munlockall.c
new file mode 100755
index 000000000..432700742
--- /dev/null
+++ b/third_party/musl/porting/liteos_a/user/src/mman/munlockall.c
@@ -0,0 +1,9 @@
+#include <sys/mman.h>
+#include <unsupported_api.h>
+#include "syscall.h"
+
+int munlockall(void)
+{
+	unsupported_api(__FUNCTION__);
+	return syscall(SYS_munlockall);
+}
diff --git a/third_party/musl/porting/liteos_a/user/src/mman/posix_madvise.c b/third_party/musl/porting/liteos_a/user/src/mman/posix_madvise.c
new file mode 100755
index 000000000..8498ec939
--- /dev/null
+++ b/third_party/musl/porting/liteos_a/user/src/mman/posix_madvise.c
@@ -0,0 +1,11 @@
+#define _GNU_SOURCE
+#include <sys/mman.h>
+#include <unsupported_api.h>
+#include "syscall.h"
+
+int posix_madvise(void *addr, size_t len, int advice)
+{
+	unsupported_api(__FUNCTION__);
+	if (advice == MADV_DONTNEED) return 0;
+	return -__syscall(SYS_madvise, addr, len, advice);
+}
diff --git a/third_party/musl/porting/liteos_a/user/src/mman/shm_open.c b/third_party/musl/porting/liteos_a/user/src/mman/shm_open.c
new file mode 100755
index 000000000..ef8a8c946
--- /dev/null
+++ b/third_party/musl/porting/liteos_a/user/src/mman/shm_open.c
@@ -0,0 +1,46 @@
+#include <sys/mman.h>
+#include <errno.h>
+#include <fcntl.h>
+#include <unistd.h>
+#include <string.h>
+#include <limits.h>
+#include <pthread.h>
+#include <unsupported_api.h>
+
+char *__shm_mapname(const char *name, char *buf)
+{
+	char *p;
+	while (*name == '/') name++;
+	if (*(p = __strchrnul(name, '/')) || p==name ||
+	    (p-name <= 2 && name[0]=='.' && p[-1]=='.')) {
+		errno = EINVAL;
+		return 0;
+	}
+	if (p-name > NAME_MAX) {
+		errno = ENAMETOOLONG;
+		return 0;
+	}
+	memcpy(buf, "/dev/shm/", 9);
+	memcpy(buf+9, name, p-name+1);
+	return buf;
+}
+
+int shm_open(const char *name, int flag, mode_t mode)
+{
+	int cs;
+	char buf[NAME_MAX+10];
+	unsupported_api(__FUNCTION__);
+	if (!(name = __shm_mapname(name, buf))) return -1;
+	pthread_setcancelstate(PTHREAD_CANCEL_DISABLE, &cs);
+	int fd = open(name, flag|O_NOFOLLOW|O_CLOEXEC|O_NONBLOCK, mode);
+	pthread_setcancelstate(cs, 0);
+	return fd;
+}
+
+int shm_unlink(const char *name)
+{
+	char buf[NAME_MAX+10];
+	unsupported_api(__FUNCTION__);
+	if (!(name = __shm_mapname(name, buf))) return -1;
+	return unlink(name);
+}
diff --git a/third_party/musl/porting/liteos_a/user/src/mq/mq_close.c b/third_party/musl/porting/liteos_a/user/src/mq/mq_close.c
new file mode 100755
index 000000000..645220cbd
--- /dev/null
+++ b/third_party/musl/porting/liteos_a/user/src/mq/mq_close.c
@@ -0,0 +1,7 @@
+#include <mqueue.h>
+#include "syscall.h"
+
+int mq_close(mqd_t mqd)
+{
+	return syscall(SYS_mqclose, mqd);
+}
diff --git a/third_party/musl/porting/liteos_a/user/src/multibyte/wcsnrtombs.c b/third_party/musl/porting/liteos_a/user/src/multibyte/wcsnrtombs.c
new file mode 100755
index 000000000..95e25e708
--- /dev/null
+++ b/third_party/musl/porting/liteos_a/user/src/multibyte/wcsnrtombs.c
@@ -0,0 +1,35 @@
+#include <wchar.h>
+#include <limits.h>
+#include <string.h>
+
+size_t wcsnrtombs(char *restrict dst, const wchar_t **restrict wcs, size_t wn, size_t n, mbstate_t *restrict st)
+{
+	const wchar_t *ws = *wcs;
+	size_t cnt = 0;
+	if (!dst) n=0;
+	while (ws && wn) {
+		char tmp[MB_LEN_MAX];
+		size_t l = wcrtomb(n<MB_LEN_MAX ? tmp : dst, *ws, 0);
+		if (l==-1) {
+			cnt = -1;
+			break;
+		}
+		if (dst) {
+			if (n<MB_LEN_MAX) {
+				if (l>n) break;
+				memcpy(dst, tmp, l);
+			}
+			dst += l;
+			n -= l;
+		}
+		if (!*ws) {
+			ws = 0;
+			break;
+		}
+		ws++;
+		wn--;
+		cnt += l;
+	}
+	if (dst) *wcs = ws;
+	return cnt;
+}
diff --git a/third_party/musl/porting/liteos_a/user/src/network/ent.c b/third_party/musl/porting/liteos_a/user/src/network/ent.c
new file mode 100755
index 000000000..e8f840ede
--- /dev/null
+++ b/third_party/musl/porting/liteos_a/user/src/network/ent.c
@@ -0,0 +1,27 @@
+#include <netdb.h>
+#include <unsupported_api.h>
+
+void sethostent(int x)
+{
+	unsupported_api(__FUNCTION__);
+}
+
+struct hostent *gethostent()
+{
+	unsupported_api(__FUNCTION__);
+	return 0;
+}
+
+struct netent *getnetent()
+{
+	unsupported_api(__FUNCTION__);
+	return 0;
+}
+
+void endhostent(void)
+{
+	unsupported_api(__FUNCTION__);
+}
+
+weak_alias(sethostent, setnetent);
+weak_alias(endhostent, endnetent);
diff --git a/third_party/musl/porting/liteos_a/user/src/network/ether.c b/third_party/musl/porting/liteos_a/user/src/network/ether.c
new file mode 100755
index 000000000..e3d295107
--- /dev/null
+++ b/third_party/musl/porting/liteos_a/user/src/network/ether.c
@@ -0,0 +1,62 @@
+#include <stdlib.h>
+#include <netinet/ether.h>
+#include <stdio.h>
+#include <unsupported_api.h>
+
+struct ether_addr *ether_aton_r (const char *x, struct ether_addr *p_a)
+{
+	struct ether_addr a;
+	char *y;
+	for (int ii = 0; ii < 6; ii++) {
+		unsigned long int n;
+		if (ii != 0) {
+			if (x[0] != ':') return 0; /* bad format */
+			else x++;
+		}
+		n = strtoul (x, &y, 16);
+		x = y;
+		if (n > 0xFF) return 0; /* bad byte */
+		a.ether_addr_octet[ii] = n;
+	}
+	if (x[0] != 0) return 0; /* bad format */
+	*p_a = a;
+	return p_a;
+}
+
+struct ether_addr *ether_aton (const char *x)
+{
+	static struct ether_addr a;
+	return ether_aton_r (x, &a);
+}
+
+char *ether_ntoa_r (const struct ether_addr *p_a, char *x) {
+	char *y;
+	y = x;
+	for (int ii = 0; ii < 6; ii++) {
+		x += sprintf (x, ii == 0 ? "%.2X" : ":%.2X", p_a->ether_addr_octet[ii]);
+	}
+	return y;
+}
+
+char *ether_ntoa (const struct ether_addr *p_a) {
+	static char x[18];
+	return ether_ntoa_r (p_a, x);
+}
+
+int ether_line(const char *l, struct ether_addr *e, char *hostname)
+{
+	unsupported_api(__FUNCTION__);
+	return -1;
+}
+
+int ether_ntohost(char *hostname, const struct ether_addr *e)
+{
+	unsupported_api(__FUNCTION__);
+	return -1;
+}
+
+int ether_hostton(const char *hostname, struct ether_addr *e)
+{
+	unsupported_api(__FUNCTION__);
+	return -1;
+}
diff --git a/third_party/musl/porting/liteos_a/user/src/network/freeaddrinfo.c b/third_party/musl/porting/liteos_a/user/src/network/freeaddrinfo.c
new file mode 100755
index 000000000..e86e3dacb
--- /dev/null
+++ b/third_party/musl/porting/liteos_a/user/src/network/freeaddrinfo.c
@@ -0,0 +1,18 @@
+#include <stdlib.h>
+#include <stddef.h>
+#include <netdb.h>
+#include "lookup.h"
+#include "lock.h"
+#include <unsupported_api.h>
+
+void freeaddrinfo(struct addrinfo *p)
+{
+	size_t cnt;
+	unsupported_api(__FUNCTION__);
+	for (cnt=1; p->ai_next; cnt++, p=p->ai_next);
+	struct aibuf *b = (void *)((char *)p - offsetof(struct aibuf, ai));
+	b -= b->slot;
+	LOCK(b->lock);
+	if (!(b->ref -= cnt)) free(b);
+	else UNLOCK(b->lock);
+}
diff --git a/third_party/musl/porting/liteos_a/user/src/network/gai_strerror.c b/third_party/musl/porting/liteos_a/user/src/network/gai_strerror.c
new file mode 100755
index 000000000..1415e9769
--- /dev/null
+++ b/third_party/musl/porting/liteos_a/user/src/network/gai_strerror.c
@@ -0,0 +1,27 @@
+#include <netdb.h>
+#include <unsupported_api.h>
+#include "locale_impl.h"
+
+static const char msgs[] =
+	"Invalid flags\0"
+	"Name does not resolve\0"
+	"Try again\0"
+	"Non-recoverable error\0"
+	"Unknown error\0"
+	"Unrecognized address family or invalid length\0"
+	"Unrecognized socket type\0"
+	"Unrecognized service\0"
+	"Unknown error\0"
+	"Out of memory\0"
+	"System error\0"
+	"Overflow\0"
+	"\0Unknown error";
+
+const char *gai_strerror(int ecode)
+{
+	const char *s;
+	unsupported_api(__FUNCTION__);
+	for (s=msgs, ecode++; ecode && *s; ecode++, s++) for (; *s; s++);
+	if (!*s) s++;
+	return LCTRANS_CUR(s);
+}
diff --git a/third_party/musl/porting/liteos_a/user/src/network/getaddrinfo.c b/third_party/musl/porting/liteos_a/user/src/network/getaddrinfo.c
new file mode 100755
index 000000000..97452d0c3
--- /dev/null
+++ b/third_party/musl/porting/liteos_a/user/src/network/getaddrinfo.c
@@ -0,0 +1,138 @@
+#include <stdlib.h>
+#include <sys/socket.h>
+#include <netinet/in.h>
+#include <netdb.h>
+#include <string.h>
+#include <pthread.h>
+#include <unistd.h>
+#include <endian.h>
+#include <errno.h>
+#include <unsupported_api.h>
+#include "lookup.h"
+
+int getaddrinfo(const char *restrict host, const char *restrict serv, const struct addrinfo *restrict hint, struct addrinfo **restrict res)
+{
+	struct service ports[MAXSERVS];
+	struct address addrs[MAXADDRS];
+	char canon[256], *outcanon;
+	int nservs, naddrs, nais, canon_len, i, j, k;
+	int family = AF_UNSPEC, flags = 0, proto = 0, socktype = 0;
+	struct aibuf *out;
+
+	unsupported_api(__FUNCTION__);
+
+	if (!host && !serv) return EAI_NONAME;
+
+	if (hint) {
+		family = hint->ai_family;
+		flags = hint->ai_flags;
+		proto = hint->ai_protocol;
+		socktype = hint->ai_socktype;
+
+		const int mask = AI_PASSIVE | AI_CANONNAME | AI_NUMERICHOST |
+			AI_V4MAPPED | AI_ALL | AI_ADDRCONFIG | AI_NUMERICSERV;
+		if ((flags & mask) != flags)
+			return EAI_BADFLAGS;
+
+		switch (family) {
+		case AF_INET:
+		case AF_INET6:
+		case AF_UNSPEC:
+			break;
+		default:
+			return EAI_FAMILY;
+		}
+	}
+
+	if (flags & AI_ADDRCONFIG) {
+		/* Define the "an address is configured" condition for address
+		 * families via ability to create a socket for the family plus
+		 * routability of the loopback address for the family. */
+		static const struct sockaddr_in lo4 = {
+			.sin_family = AF_INET, .sin_port = 65535,
+			.sin_addr.s_addr = __BYTE_ORDER == __BIG_ENDIAN
+				? 0x7f000001 : 0x0100007f
+		};
+		static const struct sockaddr_in6 lo6 = {
+			.sin6_family = AF_INET6, .sin6_port = 65535,
+			.sin6_addr = IN6ADDR_LOOPBACK_INIT
+		};
+		int tf[2] = { AF_INET, AF_INET6 };
+		const void *ta[2] = { &lo4, &lo6 };
+		socklen_t tl[2] = { sizeof lo4, sizeof lo6 };
+		for (i=0; i<2; i++) {
+			if (family==tf[1-i]) continue;
+			int s = socket(tf[i], SOCK_CLOEXEC|SOCK_DGRAM,
+				IPPROTO_UDP);
+			if (s>=0) {
+				int cs;
+				pthread_setcancelstate(
+					PTHREAD_CANCEL_DISABLE, &cs);
+				int r = connect(s, ta[i], tl[i]);
+				pthread_setcancelstate(cs, 0);
+				close(s);
+				if (!r) continue;
+			}
+			switch (errno) {
+			case EADDRNOTAVAIL:
+			case EAFNOSUPPORT:
+			case EHOSTUNREACH:
+			case ENETDOWN:
+			case ENETUNREACH:
+				break;
+			default:
+				return EAI_SYSTEM;
+			}
+			if (family == tf[i]) return EAI_NONAME;
+			family = tf[1-i];
+		}
+	}
+
+	nservs = __lookup_serv(ports, serv, proto, socktype, flags);
+	if (nservs < 0) return nservs;
+
+	naddrs = __lookup_name(addrs, canon, host, family, flags);
+	if (naddrs < 0) return naddrs;
+
+	nais = nservs * naddrs;
+	canon_len = strlen(canon);
+	out = calloc(1, nais * sizeof(*out) + canon_len + 1);
+	if (!out) return EAI_MEMORY;
+
+	if (canon_len) {
+		outcanon = (void *)&out[nais];
+		memcpy(outcanon, canon, canon_len+1);
+	} else {
+		outcanon = 0;
+	}
+
+	for (k=i=0; i<naddrs; i++) for (j=0; j<nservs; j++, k++) {
+		out[k].slot = k;
+		out[k].ai = (struct addrinfo){
+			.ai_family = addrs[i].family,
+			.ai_socktype = ports[j].socktype,
+			.ai_protocol = ports[j].proto,
+			.ai_addrlen = addrs[i].family == AF_INET
+				? sizeof(struct sockaddr_in)
+				: sizeof(struct sockaddr_in6),
+			.ai_addr = (void *)&out[k].sa,
+			.ai_canonname = outcanon };
+		if (k) out[k-1].ai.ai_next = &out[k].ai;
+		switch (addrs[i].family) {
+		case AF_INET:
+			out[k].sa.sin.sin_family = AF_INET;
+			out[k].sa.sin.sin_port = htons(ports[j].port);
+			memcpy(&out[k].sa.sin.sin_addr, &addrs[i].addr, 4);
+			break;
+		case AF_INET6:
+			out[k].sa.sin6.sin6_family = AF_INET6;
+			out[k].sa.sin6.sin6_port = htons(ports[j].port);
+			out[k].sa.sin6.sin6_scope_id = addrs[i].scopeid;
+			memcpy(&out[k].sa.sin6.sin6_addr, &addrs[i].addr, 16);
+			break;			
+		}
+	}
+	out[0].ref = nais;
+	*res = &out->ai;
+	return 0;
+}
diff --git a/third_party/musl/porting/liteos_a/user/src/network/gethostbyaddr.c b/third_party/musl/porting/liteos_a/user/src/network/gethostbyaddr.c
new file mode 100755
index 000000000..03fdaf840
--- /dev/null
+++ b/third_party/musl/porting/liteos_a/user/src/network/gethostbyaddr.c
@@ -0,0 +1,26 @@
+#define _GNU_SOURCE
+
+#include <netdb.h>
+#include <errno.h>
+#include <stdlib.h>
+#include <unsupported_api.h>
+
+struct hostent *gethostbyaddr(const void *a, socklen_t l, int af)
+{
+	static struct hostent *h;
+	size_t size = 63;
+	struct hostent *res;
+	int err;
+	unsupported_api(__FUNCTION__);
+	do {
+		free(h);
+		h = malloc(size+=size+1);
+		if (!h) {
+			h_errno = NO_RECOVERY;
+			return 0;
+		}
+		err = gethostbyaddr_r(a, l, af, h,
+			(void *)(h+1), size-sizeof *h, &res, &h_errno);
+	} while (err == ERANGE);
+	return err ? 0 : h;
+}
diff --git a/third_party/musl/porting/liteos_a/user/src/network/gethostbyaddr_r.c b/third_party/musl/porting/liteos_a/user/src/network/gethostbyaddr_r.c
new file mode 100755
index 000000000..ce4e3f677
--- /dev/null
+++ b/third_party/musl/porting/liteos_a/user/src/network/gethostbyaddr_r.c
@@ -0,0 +1,72 @@
+#define _GNU_SOURCE
+
+#include <sys/socket.h>
+#include <netdb.h>
+#include <string.h>
+#include <netinet/in.h>
+#include <errno.h>
+#include <inttypes.h>
+#include <unsupported_api.h>
+
+int gethostbyaddr_r(const void *a, socklen_t l, int af,
+	struct hostent *h, char *buf, size_t buflen,
+	struct hostent **res, int *err)
+{
+	union {
+		struct sockaddr_in sin;
+		struct sockaddr_in6 sin6;
+	} sa = { .sin.sin_family = af };
+	socklen_t sl = af==AF_INET6 ? sizeof sa.sin6 : sizeof sa.sin;
+	int i;
+
+	*res = 0;
+	unsupported_api(__FUNCTION__);
+	/* Load address argument into sockaddr structure */
+	if (af==AF_INET6 && l==16) memcpy(&sa.sin6.sin6_addr, a, 16);
+	else if (af==AF_INET && l==4) memcpy(&sa.sin.sin_addr, a, 4);
+	else {
+		*err = NO_RECOVERY;
+		return EINVAL;
+	}
+
+	/* Align buffer and check for space for pointers and ip address */
+	i = (uintptr_t)buf & sizeof(char *)-1;
+	if (!i) i = sizeof(char *);
+	if (buflen <= 5*sizeof(char *)-i + l) return ERANGE;
+	buf += sizeof(char *)-i;
+	buflen -= 5*sizeof(char *)-i + l;
+
+	h->h_addr_list = (void *)buf;
+	buf += 2*sizeof(char *);
+	h->h_aliases = (void *)buf;
+	buf += 2*sizeof(char *);
+
+	h->h_addr_list[0] = buf;
+	memcpy(h->h_addr_list[0], a, l);
+	buf += l;
+	h->h_addr_list[1] = 0;
+	h->h_aliases[0] = buf;
+	h->h_aliases[1] = 0;
+
+	switch (getnameinfo((void *)&sa, sl, buf, buflen, 0, 0, 0)) {
+	case EAI_AGAIN:
+		*err = TRY_AGAIN;
+		return EAGAIN;
+	case EAI_OVERFLOW:
+		return ERANGE;
+	default:
+	case EAI_MEMORY:
+	case EAI_SYSTEM:
+	case EAI_FAIL:
+		*err = NO_RECOVERY;
+		return errno;
+	case 0:
+		break;
+	}
+
+	h->h_addrtype = af;
+	h->h_length = l;
+	h->h_name = h->h_aliases[0];
+	*res = h;
+	return 0;
+}
diff --git a/third_party/musl/porting/liteos_a/user/src/network/gethostbyname.c b/third_party/musl/porting/liteos_a/user/src/network/gethostbyname.c
new file mode 100755
index 000000000..80b427ca9
--- /dev/null
+++ b/third_party/musl/porting/liteos_a/user/src/network/gethostbyname.c
@@ -0,0 +1,13 @@
+#define _GNU_SOURCE
+
+#include <sys/socket.h>
+#include <netdb.h>
+#include <string.h>
+#include <netinet/in.h>
+#include <unsupported_api.h>
+
+struct hostent *gethostbyname(const char *name)
+{
+	unsupported_api(__FUNCTION__);
+	return gethostbyname2(name, AF_INET);
+}
diff --git a/third_party/musl/porting/liteos_a/user/src/network/gethostbyname2.c b/third_party/musl/porting/liteos_a/user/src/network/gethostbyname2.c
new file mode 100755
index 000000000..8410dd0b9
--- /dev/null
+++ b/third_party/musl/porting/liteos_a/user/src/network/gethostbyname2.c
@@ -0,0 +1,27 @@
+#define _GNU_SOURCE
+
+#include <sys/socket.h>
+#include <netdb.h>
+#include <errno.h>
+#include <stdlib.h>
+#include <unsupported_api.h>
+
+struct hostent *gethostbyname2(const char *name, int af)
+{
+	static struct hostent *h;
+	size_t size = 63;
+	struct hostent *res;
+	int err;
+	unsupported_api(__FUNCTION__);
+	do {
+		free(h);
+		h = malloc(size+=size+1);
+		if (!h) {
+			h_errno = NO_RECOVERY;
+			return 0;
+		}
+		err = gethostbyname2_r(name, af, h,
+			(void *)(h+1), size-sizeof *h, &res, &h_errno);
+	} while (err == ERANGE);
+	return err ? 0 : h;
+}
diff --git a/third_party/musl/porting/liteos_a/user/src/network/gethostbyname2_r.c b/third_party/musl/porting/liteos_a/user/src/network/gethostbyname2_r.c
new file mode 100755
index 000000000..853ef7cbc
--- /dev/null
+++ b/third_party/musl/porting/liteos_a/user/src/network/gethostbyname2_r.c
@@ -0,0 +1,82 @@
+#define _GNU_SOURCE
+
+#include <sys/socket.h>
+#include <netdb.h>
+#include <string.h>
+#include <netinet/in.h>
+#include <errno.h>
+#include <stdint.h>
+#include "lookup.h"
+#include <unsupported_api.h>
+
+int gethostbyname2_r(const char *name, int af,
+	struct hostent *h, char *buf, size_t buflen,
+	struct hostent **res, int *err)
+{
+	struct address addrs[MAXADDRS];
+	char canon[256];
+	int i, cnt;
+	size_t align, need;
+
+	*res = 0;
+	unsupported_api(__FUNCTION__);
+	cnt = __lookup_name(addrs, canon, name, af, AI_CANONNAME);
+	if (cnt<0) switch (cnt) {
+	case EAI_NONAME:
+		*err = HOST_NOT_FOUND;
+		return ENOENT;
+	case EAI_AGAIN:
+		*err = TRY_AGAIN;
+		return EAGAIN;
+	default:
+	case EAI_FAIL:
+		*err = NO_RECOVERY;
+		return EBADMSG;
+	case EAI_MEMORY:
+	case EAI_SYSTEM:
+		*err = NO_RECOVERY;
+		return errno;
+	}
+
+	h->h_addrtype = af;
+	h->h_length = af==AF_INET6 ? 16 : 4;
+
+	/* Align buffer */
+	align = -(uintptr_t)buf & sizeof(char *)-1;
+
+	need = 4*sizeof(char *);
+	need += (cnt + 1) * (sizeof(char *) + h->h_length);
+	need += strlen(name)+1;
+	need += strlen(canon)+1;
+	need += align;
+
+	if (need > buflen) return ERANGE;
+
+	buf += align;
+	h->h_aliases = (void *)buf;
+	buf += 3*sizeof(char *);
+	h->h_addr_list = (void *)buf;
+	buf += (cnt+1)*sizeof(char *);
+
+	for (i=0; i<cnt; i++) {
+		h->h_addr_list[i] = (void *)buf;
+		buf += h->h_length;
+		memcpy(h->h_addr_list[i], addrs[i].addr, h->h_length);
+	}
+	h->h_addr_list[i] = 0;
+
+	h->h_name = h->h_aliases[0] = buf;
+	strcpy(h->h_name, canon);
+	buf += strlen(h->h_name)+1;
+
+	if (strcmp(h->h_name, name)) {
+		h->h_aliases[1] = buf;
+		strcpy(h->h_aliases[1], name);
+		buf += strlen(h->h_aliases[1])+1;
+	} else h->h_aliases[1] = 0;
+
+	h->h_aliases[2] = 0;
+
+	*res = h;
+	return 0;
+}
diff --git a/third_party/musl/porting/liteos_a/user/src/network/gethostbyname_r.c b/third_party/musl/porting/liteos_a/user/src/network/gethostbyname_r.c
new file mode 100755
index 000000000..c89d6f2ec
--- /dev/null
+++ b/third_party/musl/porting/liteos_a/user/src/network/gethostbyname_r.c
@@ -0,0 +1,13 @@
+#define _GNU_SOURCE
+
+#include <sys/socket.h>
+#include <netdb.h>
+#include <unsupported_api.h>
+
+int gethostbyname_r(const char *name,
+	struct hostent *h, char *buf, size_t buflen,
+	struct hostent **res, int *err)
+{
+	unsupported_api(__FUNCTION__);
+	return gethostbyname2_r(name, AF_INET, h, buf, buflen, res, err);
+}
diff --git a/third_party/musl/porting/liteos_a/user/src/network/getifaddrs.c b/third_party/musl/porting/liteos_a/user/src/network/getifaddrs.c
new file mode 100755
index 000000000..09088957d
--- /dev/null
+++ b/third_party/musl/porting/liteos_a/user/src/network/getifaddrs.c
@@ -0,0 +1,218 @@
+#define _GNU_SOURCE
+#include <errno.h>
+#include <string.h>
+#include <stdlib.h>
+#include <unistd.h>
+#include <ifaddrs.h>
+#include <syscall.h>
+#include <net/if.h>
+#include <netinet/in.h>
+#include <unsupported_api.h>
+#include "netlink.h"
+
+#define IFADDRS_HASH_SIZE 64
+
+/* getifaddrs() reports hardware addresses with PF_PACKET that implies
+ * struct sockaddr_ll.  But e.g. Infiniband socket address length is
+ * longer than sockaddr_ll.ssl_addr[8] can hold. Use this hack struct
+ * to extend ssl_addr - callers should be able to still use it. */
+struct sockaddr_ll_hack {
+	unsigned short sll_family, sll_protocol;
+	int sll_ifindex;
+	unsigned short sll_hatype;
+	unsigned char sll_pkttype, sll_halen;
+	unsigned char sll_addr[24];
+};
+
+union sockany {
+	struct sockaddr sa;
+	struct sockaddr_ll_hack ll;
+	struct sockaddr_in v4;
+	struct sockaddr_in6 v6;
+};
+
+struct ifaddrs_storage {
+	struct ifaddrs ifa;
+	struct ifaddrs_storage *hash_next;
+	union sockany addr, netmask, ifu;
+	unsigned int index;
+	char name[IFNAMSIZ+1];
+};
+
+struct ifaddrs_ctx {
+	struct ifaddrs_storage *first;
+	struct ifaddrs_storage *last;
+	struct ifaddrs_storage *hash[IFADDRS_HASH_SIZE];
+};
+
+void freeifaddrs(struct ifaddrs *ifp)
+{
+	struct ifaddrs *n;
+	while (ifp) {
+		n = ifp->ifa_next;
+		free(ifp);
+		ifp = n;
+	}
+}
+
+static void copy_addr(struct sockaddr **r, int af, union sockany *sa, void *addr, size_t addrlen, int ifindex)
+{
+	uint8_t *dst;
+	int len;
+
+	switch (af) {
+	case AF_INET:
+		dst = (uint8_t*) &sa->v4.sin_addr;
+		len = 4;
+		break;
+	case AF_INET6:
+		dst = (uint8_t*) &sa->v6.sin6_addr;
+		len = 16;
+		if (IN6_IS_ADDR_LINKLOCAL(addr) || IN6_IS_ADDR_MC_LINKLOCAL(addr))
+			sa->v6.sin6_scope_id = ifindex;
+		break;
+	default:
+		return;
+	}
+	if (addrlen < len) return;
+	sa->sa.sa_family = af;
+	memcpy(dst, addr, len);
+	*r = &sa->sa;
+}
+
+static void gen_netmask(struct sockaddr **r, int af, union sockany *sa, int prefixlen)
+{
+	uint8_t addr[16] = {0};
+	int i;
+
+	if (prefixlen > 8*sizeof(addr)) prefixlen = 8*sizeof(addr);
+	i = prefixlen / 8;
+	memset(addr, 0xff, i);
+	if (i < sizeof(addr)) addr[i++] = 0xff << (8 - (prefixlen % 8));
+	copy_addr(r, af, sa, addr, sizeof(addr), 0);
+}
+
+static void copy_lladdr(struct sockaddr **r, union sockany *sa, void *addr, size_t addrlen, int ifindex, unsigned short hatype)
+{
+	if (addrlen > sizeof(sa->ll.sll_addr)) return;
+	sa->ll.sll_family = AF_PACKET;
+	sa->ll.sll_ifindex = ifindex;
+	sa->ll.sll_hatype = hatype;
+	sa->ll.sll_halen = addrlen;
+	memcpy(sa->ll.sll_addr, addr, addrlen);
+	*r = &sa->sa;
+}
+
+static int netlink_msg_to_ifaddr(void *pctx, struct nlmsghdr *h)
+{
+	struct ifaddrs_ctx *ctx = pctx;
+	struct ifaddrs_storage *ifs, *ifs0;
+	struct ifinfomsg *ifi = NLMSG_DATA(h);
+	struct ifaddrmsg *ifa = NLMSG_DATA(h);
+	struct rtattr *rta;
+	int stats_len = 0;
+
+	if (h->nlmsg_type == RTM_NEWLINK) {
+		for (rta = NLMSG_RTA(h, sizeof(*ifi)); NLMSG_RTAOK(rta, h); rta = RTA_NEXT(rta)) {
+			if (rta->rta_type != IFLA_STATS) continue;
+			stats_len = RTA_DATALEN(rta);
+			break;
+		}
+	} else {
+		for (ifs0 = ctx->hash[ifa->ifa_index % IFADDRS_HASH_SIZE]; ifs0; ifs0 = ifs0->hash_next)
+			if (ifs0->index == ifa->ifa_index)
+				break;
+		if (!ifs0) return 0;
+	}
+
+	ifs = calloc(1, sizeof(struct ifaddrs_storage) + stats_len);
+	if (ifs == 0) return -1;
+
+	if (h->nlmsg_type == RTM_NEWLINK) {
+		ifs->index = ifi->ifi_index;
+		ifs->ifa.ifa_flags = ifi->ifi_flags;
+
+		for (rta = NLMSG_RTA(h, sizeof(*ifi)); NLMSG_RTAOK(rta, h); rta = RTA_NEXT(rta)) {
+			switch (rta->rta_type) {
+			case IFLA_IFNAME:
+				if (RTA_DATALEN(rta) < sizeof(ifs->name)) {
+					memcpy(ifs->name, RTA_DATA(rta), RTA_DATALEN(rta));
+					ifs->ifa.ifa_name = ifs->name;
+				}
+				break;
+			case IFLA_ADDRESS:
+				copy_lladdr(&ifs->ifa.ifa_addr, &ifs->addr, RTA_DATA(rta), RTA_DATALEN(rta), ifi->ifi_index, ifi->ifi_type);
+				break;
+			case IFLA_BROADCAST:
+				copy_lladdr(&ifs->ifa.ifa_broadaddr, &ifs->ifu, RTA_DATA(rta), RTA_DATALEN(rta), ifi->ifi_index, ifi->ifi_type);
+				break;
+			case IFLA_STATS:
+				ifs->ifa.ifa_data = (void*)(ifs+1);
+				memcpy(ifs->ifa.ifa_data, RTA_DATA(rta), RTA_DATALEN(rta));
+				break;
+			}
+		}
+		if (ifs->ifa.ifa_name) {
+			unsigned int bucket = ifs->index % IFADDRS_HASH_SIZE;
+			ifs->hash_next = ctx->hash[bucket];
+			ctx->hash[bucket] = ifs;
+		}
+	} else {
+		ifs->ifa.ifa_name = ifs0->ifa.ifa_name;
+		ifs->ifa.ifa_flags = ifs0->ifa.ifa_flags;
+		for (rta = NLMSG_RTA(h, sizeof(*ifa)); NLMSG_RTAOK(rta, h); rta = RTA_NEXT(rta)) {
+			switch (rta->rta_type) {
+			case IFA_ADDRESS:
+				/* If ifa_addr is already set we, received an IFA_LOCAL before
+				 * so treat this as destination address */
+				if (ifs->ifa.ifa_addr)
+					copy_addr(&ifs->ifa.ifa_dstaddr, ifa->ifa_family, &ifs->ifu, RTA_DATA(rta), RTA_DATALEN(rta), ifa->ifa_index);
+				else
+					copy_addr(&ifs->ifa.ifa_addr, ifa->ifa_family, &ifs->addr, RTA_DATA(rta), RTA_DATALEN(rta), ifa->ifa_index);
+				break;
+			case IFA_BROADCAST:
+				copy_addr(&ifs->ifa.ifa_broadaddr, ifa->ifa_family, &ifs->ifu, RTA_DATA(rta), RTA_DATALEN(rta), ifa->ifa_index);
+				break;
+			case IFA_LOCAL:
+				/* If ifa_addr is set and we get IFA_LOCAL, assume we have
+				 * a point-to-point network. Move address to correct field. */
+				if (ifs->ifa.ifa_addr) {
+					ifs->ifu = ifs->addr;
+					ifs->ifa.ifa_dstaddr = &ifs->ifu.sa;
+					memset(&ifs->addr, 0, sizeof(ifs->addr));
+				}
+				copy_addr(&ifs->ifa.ifa_addr, ifa->ifa_family, &ifs->addr, RTA_DATA(rta), RTA_DATALEN(rta), ifa->ifa_index);
+				break;
+			case IFA_LABEL:
+				if (RTA_DATALEN(rta) < sizeof(ifs->name)) {
+					memcpy(ifs->name, RTA_DATA(rta), RTA_DATALEN(rta));
+					ifs->ifa.ifa_name = ifs->name;
+				}
+				break;
+			}
+		}
+		if (ifs->ifa.ifa_addr)
+			gen_netmask(&ifs->ifa.ifa_netmask, ifa->ifa_family, &ifs->netmask, ifa->ifa_prefixlen);
+	}
+
+	if (ifs->ifa.ifa_name) {
+		if (!ctx->first) ctx->first = ifs;
+		if (ctx->last) ctx->last->ifa.ifa_next = &ifs->ifa;
+		ctx->last = ifs;
+	} else {
+		free(ifs);
+	}
+	return 0;
+}
+
+int getifaddrs(struct ifaddrs **ifap)
+{
+	struct ifaddrs_ctx _ctx, *ctx = &_ctx;
+	int r;
+	unsupported_api(__FUNCTION__);
+	memset(ctx, 0, sizeof *ctx);
+	r = __rtnetlink_enumerate(AF_UNSPEC, AF_UNSPEC, netlink_msg_to_ifaddr, ctx);
+	if (r == 0) *ifap = &ctx->first->ifa;
+	else freeifaddrs(&ctx->first->ifa);
+	return r;
+}
diff --git a/third_party/musl/porting/liteos_a/user/src/network/getnameinfo.c b/third_party/musl/porting/liteos_a/user/src/network/getnameinfo.c
new file mode 100755
index 000000000..9734c0c25
--- /dev/null
+++ b/third_party/musl/porting/liteos_a/user/src/network/getnameinfo.c
@@ -0,0 +1,201 @@
+#include <netdb.h>
+#include <limits.h>
+#include <string.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <sys/socket.h>
+#include <netinet/in.h>
+#include <arpa/inet.h>
+#include <net/if.h>
+#include <ctype.h>
+#include <resolv.h>
+#include <unsupported_api.h>
+#include "lookup.h"
+#include "stdio_impl.h"
+
+#define PTR_MAX (64 + sizeof ".in-addr.arpa")
+#define RR_PTR 12
+
+static char *itoa(char *p, unsigned x) {
+	p += 3*sizeof(int);
+	*--p = 0;
+	do {
+		*--p = '0' + x % 10;
+		x /= 10;
+	} while (x);
+	return p;
+}
+
+static void mkptr4(char *s, const unsigned char *ip)
+{
+	sprintf(s, "%d.%d.%d.%d.in-addr.arpa",
+		ip[3], ip[2], ip[1], ip[0]);
+}
+
+static void mkptr6(char *s, const unsigned char *ip)
+{
+	static const char xdigits[] = "0123456789abcdef";
+	int i;
+	for (i=15; i>=0; i--) {
+		*s++ = xdigits[ip[i]&15]; *s++ = '.';
+		*s++ = xdigits[ip[i]>>4]; *s++ = '.';
+	}
+	strcpy(s, "ip6.arpa");
+}
+
+static void reverse_hosts(char *buf, const unsigned char *a, unsigned scopeid, int family)
+{
+	char line[512], *p, *z;
+	unsigned char _buf[1032], atmp[16];
+	struct address iplit;
+	FILE _f, *f = __fopen_rb_ca("/etc/hosts", &_f, _buf, sizeof _buf);
+	if (!f) return;
+	if (family == AF_INET) {
+		memcpy(atmp+12, a, 4);
+		memcpy(atmp, "\0\0\0\0\0\0\0\0\0\0\xff\xff", 12);
+		a = atmp;
+	}
+	while (fgets(line, sizeof line, f)) {
+		if ((p=strchr(line, '#'))) *p++='\n', *p=0;
+
+		for (p=line; *p && !isspace(*p); p++);
+		*p++ = 0;
+		if (__lookup_ipliteral(&iplit, line, AF_UNSPEC)<=0)
+			continue;
+
+		if (iplit.family == AF_INET) {
+			memcpy(iplit.addr+12, iplit.addr, 4);
+			memcpy(iplit.addr, "\0\0\0\0\0\0\0\0\0\0\xff\xff", 12);
+			iplit.scopeid = 0;
+		}
+
+		if (memcmp(a, iplit.addr, 16) || iplit.scopeid != scopeid)
+			continue;
+			
+		for (; *p && isspace(*p); p++);
+		for (z=p; *z && !isspace(*z); z++);
+		*z = 0;
+		if (z-p < 256) {
+			memcpy(buf, p, z-p+1);
+			break;
+		}
+	}
+	__fclose_ca(f);
+}
+
+static void reverse_services(char *buf, int port, int dgram)
+{
+	unsigned long svport;
+	char line[128], *p, *z;
+	unsigned char _buf[1032];
+	FILE _f, *f = __fopen_rb_ca("/etc/services", &_f, _buf, sizeof _buf);
+	if (!f) return;
+	while (fgets(line, sizeof line, f)) {
+		if ((p=strchr(line, '#'))) *p++='\n', *p=0;
+
+		for (p=line; *p && !isspace(*p); p++);
+		if (!*p) continue;
+		*p++ = 0;
+		svport = strtoul(p, &z, 10);
+
+		if (svport != port || z==p) continue;
+		if (dgram && strncmp(z, "/udp", 4)) continue;
+		if (!dgram && strncmp(z, "/tcp", 4)) continue;
+		if (p-line > 32) continue;
+
+		memcpy(buf, line, p-line);
+		break;
+	}
+	__fclose_ca(f);
+}
+
+static int dns_parse_callback(void *c, int rr, const void *data, int len, const void *packet)
+{
+	if (rr != RR_PTR) return 0;
+	if (__dn_expand(packet, (const unsigned char *)packet + 512,
+	    data, c, 256) <= 0)
+		*(char *)c = 0;
+	return 0;
+	
+}
+
+int getnameinfo(const struct sockaddr *restrict sa, socklen_t sl,
+	char *restrict node, socklen_t nodelen,
+	char *restrict serv, socklen_t servlen,
+	int flags)
+{
+	char ptr[PTR_MAX];
+	char buf[256], num[3*sizeof(int)+1];
+	int af = sa->sa_family;
+	unsigned char *a;
+	unsigned scopeid;
+
+	unsupported_api(__FUNCTION__);
+	switch (af) {
+	case AF_INET:
+		a = (void *)&((struct sockaddr_in *)sa)->sin_addr;
+		if (sl < sizeof(struct sockaddr_in)) return EAI_FAMILY;
+		mkptr4(ptr, a);
+		scopeid = 0;
+		break;
+	case AF_INET6:
+		a = (void *)&((struct sockaddr_in6 *)sa)->sin6_addr;
+		if (sl < sizeof(struct sockaddr_in6)) return EAI_FAMILY;
+		if (memcmp(a, "\0\0\0\0\0\0\0\0\0\0\xff\xff", 12))
+			mkptr6(ptr, a);
+		else
+			mkptr4(ptr, a+12);
+		scopeid = ((struct sockaddr_in6 *)sa)->sin6_scope_id;
+		break;
+	default:
+		return EAI_FAMILY;
+	}
+
+	if (node && nodelen) {
+		buf[0] = 0;
+		if (!(flags & NI_NUMERICHOST)) {
+			reverse_hosts(buf, a, scopeid, af);
+		}
+		if (!*buf && !(flags & NI_NUMERICHOST)) {
+			unsigned char query[18+PTR_MAX], reply[512];
+			int qlen = __res_mkquery(0, ptr, 1, RR_PTR,
+				0, 0, 0, query, sizeof query);
+			int rlen = __res_send(query, qlen, reply, sizeof reply);
+			buf[0] = 0;
+			if (rlen > 0)
+				__dns_parse(reply, rlen, dns_parse_callback, buf);
+		}
+		if (!*buf) {
+			if (flags & NI_NAMEREQD) return EAI_NONAME;
+			inet_ntop(af, a, buf, sizeof buf);
+			if (scopeid) {
+				char *p = 0, tmp[IF_NAMESIZE+1];
+				if (!(flags & NI_NUMERICSCOPE) &&
+				    (IN6_IS_ADDR_LINKLOCAL(a) ||
+				     IN6_IS_ADDR_MC_LINKLOCAL(a)))
+					p = if_indextoname(scopeid, tmp+1);
+				if (!p)
+					p = itoa(num, scopeid);
+				*--p = '%';
+				strcat(buf, p);
+			}
+		}
+		if (strlen(buf) >= nodelen) return EAI_OVERFLOW;
+		strcpy(node, buf);
+	}
+
+	if (serv && servlen) {
+		char *p = buf;
+		int port = ntohs(((struct sockaddr_in *)sa)->sin_port);
+		buf[0] = 0;
+		if (!(flags & NI_NUMERICSERV))
+			reverse_services(buf, port, flags & NI_DGRAM);
+		if (!*p)
+			p = itoa(num, port);
+		if (strlen(p) >= servlen)
+			return EAI_OVERFLOW;
+		strcpy(serv, p);
+	}
+
+	return 0;
+}
diff --git a/third_party/musl/porting/liteos_a/user/src/network/getservbyname.c b/third_party/musl/porting/liteos_a/user/src/network/getservbyname.c
new file mode 100755
index 000000000..fb721bfda
--- /dev/null
+++ b/third_party/musl/porting/liteos_a/user/src/network/getservbyname.c
@@ -0,0 +1,14 @@
+#define _GNU_SOURCE
+#include <netdb.h>
+#include <unsupported_api.h>
+
+struct servent *getservbyname(const char *name, const char *prots)
+{
+	static struct servent se;
+	static char *buf[2];
+	struct servent *res;
+	unsupported_api(__FUNCTION__);
+	if (getservbyname_r(name, prots, &se, (void *)buf, sizeof buf, &res))
+		return 0;
+	return &se;
+}
diff --git a/third_party/musl/porting/liteos_a/user/src/network/getservbyname_r.c b/third_party/musl/porting/liteos_a/user/src/network/getservbyname_r.c
new file mode 100755
index 000000000..3f03930e5
--- /dev/null
+++ b/third_party/musl/porting/liteos_a/user/src/network/getservbyname_r.c
@@ -0,0 +1,57 @@
+#define _GNU_SOURCE
+#include <sys/socket.h>
+#include <netinet/in.h>
+#include <netdb.h>
+#include <inttypes.h>
+#include <errno.h>
+#include <string.h>
+#include <stdlib.h>
+#include "lookup.h"
+#include <unsupported_api.h>
+
+#define ALIGN (sizeof(struct { char a; char *b; }) - sizeof(char *))
+
+int getservbyname_r(const char *name, const char *prots,
+	struct servent *se, char *buf, size_t buflen, struct servent **res)
+{
+	struct service servs[MAXSERVS];
+	int cnt, proto, align;
+
+	*res = 0;
+	unsupported_api(__FUNCTION__);
+
+	/* Don't treat numeric port number strings as service records. */
+	char *end = "";
+	strtoul(name, &end, 10);
+	if (!*end) return ENOENT;
+
+	/* Align buffer */
+	align = -(uintptr_t)buf & ALIGN-1;
+	if (buflen < 2*sizeof(char *)+align)
+		return ERANGE;
+	buf += align;
+
+	if (!prots) proto = 0;
+	else if (!strcmp(prots, "tcp")) proto = IPPROTO_TCP;
+	else if (!strcmp(prots, "udp")) proto = IPPROTO_UDP;
+	else return EINVAL;
+
+	cnt = __lookup_serv(servs, name, proto, 0, 0);
+	if (cnt<0) switch (cnt) {
+	case EAI_MEMORY:
+	case EAI_SYSTEM:
+		return ENOMEM;
+	default:
+		return ENOENT;
+	}
+
+	se->s_name = (char *)name;
+	se->s_aliases = (void *)buf;
+	se->s_aliases[0] = se->s_name;
+	se->s_aliases[1] = 0;
+	se->s_port = htons(servs[0].port);
+	se->s_proto = servs[0].proto == IPPROTO_TCP ? "tcp" : "udp";
+
+	*res = se;
+	return 0;
+}
diff --git a/third_party/musl/porting/liteos_a/user/src/network/getservbyport.c b/third_party/musl/porting/liteos_a/user/src/network/getservbyport.c
new file mode 100755
index 000000000..9aaeab0f0
--- /dev/null
+++ b/third_party/musl/porting/liteos_a/user/src/network/getservbyport.c
@@ -0,0 +1,14 @@
+#define _GNU_SOURCE
+#include <netdb.h>
+#include <unsupported_api.h>
+
+struct servent *getservbyport(int port, const char *prots)
+{
+	static struct servent se;
+	static long buf[32/sizeof(long)];
+	struct servent *res;
+	unsupported_api(__FUNCTION__);
+	if (getservbyport_r(port, prots, &se, (void *)buf, sizeof buf, &res))
+		return 0;
+	return &se;
+}
diff --git a/third_party/musl/porting/liteos_a/user/src/network/getservbyport_r.c b/third_party/musl/porting/liteos_a/user/src/network/getservbyport_r.c
new file mode 100755
index 000000000..18cfd6a72
--- /dev/null
+++ b/third_party/musl/porting/liteos_a/user/src/network/getservbyport_r.c
@@ -0,0 +1,62 @@
+#define _GNU_SOURCE
+#include <sys/socket.h>
+#include <netinet/in.h>
+#include <netdb.h>
+#include <inttypes.h>
+#include <errno.h>
+#include <string.h>
+#include <stdlib.h>
+#include <unsupported_api.h>
+
+int getservbyport_r(int port, const char *prots,
+	struct servent *se, char *buf, size_t buflen, struct servent **res)
+{
+	int i;
+	struct sockaddr_in sin = {
+		.sin_family = AF_INET,
+		.sin_port = port,
+	};
+	unsupported_api(__FUNCTION__);
+
+	if (!prots) {
+		int r = getservbyport_r(port, "tcp", se, buf, buflen, res);
+		if (r) r = getservbyport_r(port, "udp", se, buf, buflen, res);
+		return r;
+	}
+	*res = 0;
+
+	/* Align buffer */
+	i = (uintptr_t)buf & sizeof(char *)-1;
+	if (!i) i = sizeof(char *);
+	if (buflen < 3*sizeof(char *)-i)
+		return ERANGE;
+	buf += sizeof(char *)-i;
+	buflen -= sizeof(char *)-i;
+
+	if (strcmp(prots, "tcp") && strcmp(prots, "udp")) return EINVAL;
+
+	se->s_port = port;
+	se->s_proto = (char *)prots;
+	se->s_aliases = (void *)buf;
+	buf += 2*sizeof(char *);
+	buflen -= 2*sizeof(char *);
+	se->s_aliases[1] = 0;
+	se->s_aliases[0] = se->s_name = buf;
+
+	switch (getnameinfo((void *)&sin, sizeof sin, 0, 0, buf, buflen,
+		strcmp(prots, "udp") ? 0 : NI_DGRAM)) {
+	case EAI_MEMORY:
+	case EAI_SYSTEM:
+		return ENOMEM;
+	default:
+		return ENOENT;
+	case 0:
+		break;
+	}
+
+	/* A numeric port string is not a service record. */
+	if (strtol(buf, 0, 10)==ntohs(port)) return ENOENT;
+
+	*res = se;
+	return 0;
+}
diff --git a/third_party/musl/porting/liteos_a/user/src/network/if_indextoname.c b/third_party/musl/porting/liteos_a/user/src/network/if_indextoname.c
new file mode 100755
index 000000000..d4fb019ce
--- /dev/null
+++ b/third_party/musl/porting/liteos_a/user/src/network/if_indextoname.c
@@ -0,0 +1,24 @@
+#define _GNU_SOURCE
+#include <net/if.h>
+#include <sys/socket.h>
+#include <sys/ioctl.h>
+#include <string.h>
+#include <errno.h>
+#include <unsupported_api.h>
+#include "syscall.h"
+
+char *if_indextoname(unsigned index, char *name)
+{
+	struct ifreq ifr;
+	int fd, r;
+	unsupported_api(__FUNCTION__);
+	if ((fd = socket(AF_UNIX, SOCK_DGRAM|SOCK_CLOEXEC, 0)) < 0) return 0;
+	ifr.ifr_ifindex = index;
+	r = ioctl(fd, SIOCGIFNAME, &ifr);
+	__syscall(SYS_close, fd);
+	if (r < 0) {
+		if (errno == ENODEV) errno = ENXIO;
+		return 0;
+	}
+	return strncpy(name, ifr.ifr_name, IF_NAMESIZE);
+}
diff --git a/third_party/musl/porting/liteos_a/user/src/network/if_nameindex.c b/third_party/musl/porting/liteos_a/user/src/network/if_nameindex.c
new file mode 100755
index 000000000..a9990fa39
--- /dev/null
+++ b/third_party/musl/porting/liteos_a/user/src/network/if_nameindex.c
@@ -0,0 +1,115 @@
+#define _GNU_SOURCE
+#include <net/if.h>
+#include <errno.h>
+#include <unistd.h>
+#include <stdlib.h>
+#include <string.h>
+#include <pthread.h>
+#include <unsupported_api.h>
+#include "netlink.h"
+
+#define IFADDRS_HASH_SIZE 64
+
+struct ifnamemap {
+	unsigned int hash_next;
+	unsigned int index;
+	unsigned char namelen;
+	char name[IFNAMSIZ];
+};
+
+struct ifnameindexctx {
+	unsigned int num, allocated, str_bytes;
+	struct ifnamemap *list;
+	unsigned int hash[IFADDRS_HASH_SIZE];
+};
+
+static int netlink_msg_to_nameindex(void *pctx, struct nlmsghdr *h)
+{
+	struct ifnameindexctx *ctx = pctx;
+	struct ifnamemap *map;
+	struct rtattr *rta;
+	unsigned int i;
+	int index, type, namelen, bucket;
+
+	if (h->nlmsg_type == RTM_NEWLINK) {
+		struct ifinfomsg *ifi = NLMSG_DATA(h);
+		index = ifi->ifi_index;
+		type = IFLA_IFNAME;
+		rta = NLMSG_RTA(h, sizeof(*ifi));
+	} else {
+		struct ifaddrmsg *ifa = NLMSG_DATA(h);
+		index = ifa->ifa_index;
+		type = IFA_LABEL;
+		rta = NLMSG_RTA(h, sizeof(*ifa));
+	}
+	for (; NLMSG_RTAOK(rta, h); rta = RTA_NEXT(rta)) {
+		if (rta->rta_type != type) continue;
+
+		namelen = RTA_DATALEN(rta) - 1;
+		if (namelen > IFNAMSIZ) return 0;
+
+		/* suppress duplicates */
+		bucket = index % IFADDRS_HASH_SIZE;
+		i = ctx->hash[bucket];
+		while (i) {
+			map = &ctx->list[i-1];
+			if (map->index == index &&
+			    map->namelen == namelen &&
+			    memcmp(map->name, RTA_DATA(rta), namelen) == 0)
+				return 0;
+			i = map->hash_next;
+		}
+
+		if (ctx->num >= ctx->allocated) {
+			size_t a = ctx->allocated ? ctx->allocated * 2 + 1 : 8;
+			if (a > SIZE_MAX/sizeof *map) return -1;
+			map = realloc(ctx->list, a * sizeof *map);
+			if (!map) return -1;
+			ctx->list = map;
+			ctx->allocated = a;
+		}
+		map = &ctx->list[ctx->num];
+		map->index = index;
+		map->namelen = namelen;
+		memcpy(map->name, RTA_DATA(rta), namelen);
+		ctx->str_bytes += namelen + 1;
+		ctx->num++;
+		map->hash_next = ctx->hash[bucket];
+		ctx->hash[bucket] = ctx->num;
+		return 0;
+	}
+	return 0;
+}
+
+struct if_nameindex *if_nameindex()
+{
+	struct ifnameindexctx _ctx, *ctx = &_ctx;
+	struct if_nameindex *ifs = 0, *d;
+	struct ifnamemap *s;
+	char *p;
+	int i;
+	int cs;
+
+	pthread_setcancelstate(PTHREAD_CANCEL_DISABLE, &cs);
+	memset(ctx, 0, sizeof(*ctx));
+	if (__rtnetlink_enumerate(AF_UNSPEC, AF_INET, netlink_msg_to_nameindex, ctx) < 0) goto err;
+
+	ifs = malloc(sizeof(struct if_nameindex[ctx->num+1]) + ctx->str_bytes);
+	if (!ifs) goto err;
+
+	p = (char*)(ifs + ctx->num + 1);
+	for (i = ctx->num, d = ifs, s = ctx->list; i; i--, s++, d++) {
+		d->if_index = s->index;
+		d->if_name = p;
+		memcpy(p, s->name, s->namelen);
+		p += s->namelen;
+		*p++ = 0;
+	}
+	d->if_index = 0;
+	d->if_name = 0;
+err:
+	pthread_setcancelstate(cs, 0);
+	free(ctx->list);
+	errno = ENOBUFS;
+	return ifs;
+}
diff --git a/third_party/musl/porting/liteos_a/user/src/network/if_nametoindex.c b/third_party/musl/porting/liteos_a/user/src/network/if_nametoindex.c
new file mode 100755
index 000000000..6447fe098
--- /dev/null
+++ b/third_party/musl/porting/liteos_a/user/src/network/if_nametoindex.c
@@ -0,0 +1,19 @@
+#define _GNU_SOURCE
+#include <net/if.h>
+#include <sys/socket.h>
+#include <sys/ioctl.h>
+#include <string.h>
+#include <unsupported_api.h>
+#include "syscall.h"
+
+unsigned if_nametoindex(const char *name)
+{
+	struct ifreq ifr;
+	int fd, r;
+	unsupported_api(__FUNCTION__);
+	if ((fd = socket(AF_UNIX, SOCK_DGRAM|SOCK_CLOEXEC, 0)) < 0) return 0;
+	strncpy(ifr.ifr_name, name, sizeof ifr.ifr_name);
+	r = ioctl(fd, SIOCGIFINDEX, &ifr);
+	__syscall(SYS_close, fd);
+	return r < 0 ? 0 : ifr.ifr_ifindex;
+}
diff --git a/third_party/musl/porting/liteos_a/user/src/network/inet_legacy.c b/third_party/musl/porting/liteos_a/user/src/network/inet_legacy.c
new file mode 100755
index 000000000..6d91b6e17
--- /dev/null
+++ b/third_party/musl/porting/liteos_a/user/src/network/inet_legacy.c
@@ -0,0 +1,32 @@
+#include <sys/socket.h>
+#include <netinet/in.h>
+#include <arpa/inet.h>
+
+in_addr_t inet_network(const char *p)
+{
+	return ntohl(inet_addr(p));
+}
+
+struct in_addr inet_makeaddr(in_addr_t n, in_addr_t h)
+{
+	if (n < 256) h |= n<<24;
+	else if (n < 65536) h |= n<<16;
+	else h |= n<<8;
+	return (struct in_addr){ htonl(h) };
+}
+
+in_addr_t inet_lnaof(struct in_addr in)
+{
+	uint32_t h = ntohl(in.s_addr);
+	if (h>>24 < 128) return h & 0xffffff;
+	if (h>>24 < 192) return h & 0xffff;
+	return h & 0xff;
+}
+
+in_addr_t inet_netof(struct in_addr in)
+{
+	uint32_t h = ntohl(in.s_addr);
+	if (h>>24 < 128) return h >> 24;
+	if (h>>24 < 192) return h >> 16;
+	return h >> 8;
+}
diff --git a/third_party/musl/porting/liteos_a/user/src/network/netname.c b/third_party/musl/porting/liteos_a/user/src/network/netname.c
new file mode 100755
index 000000000..1351b688d
--- /dev/null
+++ b/third_party/musl/porting/liteos_a/user/src/network/netname.c
@@ -0,0 +1,15 @@
+#include <netdb.h>
+#include <unsupported_api.h>
+
+struct netent *getnetbyaddr(uint32_t net, int type)
+{
+	unsupported_api(__FUNCTION__);
+	return 0;
+}
+
+struct netent *getnetbyname(const char *name)
+{
+	unsupported_api(__FUNCTION__);
+	return 0;
+}
+
diff --git a/third_party/musl/porting/liteos_a/user/src/network/proto.c b/third_party/musl/porting/liteos_a/user/src/network/proto.c
new file mode 100755
index 000000000..f5b7db45a
--- /dev/null
+++ b/third_party/musl/porting/liteos_a/user/src/network/proto.c
@@ -0,0 +1,86 @@
+#include <netdb.h>
+#include <string.h>
+#include <unsupported_api.h>
+
+/* do we really need all these?? */
+
+static int idx;
+static const unsigned char protos[] = {
+	"\000ip\0"
+	"\001icmp\0"
+	"\002igmp\0"
+	"\003ggp\0"
+	"\004ipencap\0"
+	"\005st\0"
+	"\006tcp\0"
+	"\010egp\0"
+	"\014pup\0"
+	"\021udp\0"
+	"\024hmp\0"
+	"\026xns-idp\0"
+	"\033rdp\0"
+	"\035iso-tp4\0"
+	"\044xtp\0"
+	"\045ddp\0"
+	"\046idpr-cmtp\0"
+	"\051ipv6\0"
+	"\053ipv6-route\0"
+	"\054ipv6-frag\0"
+	"\055idrp\0"
+	"\056rsvp\0"
+	"\057gre\0"
+	"\062esp\0"
+	"\063ah\0"
+	"\071skip\0"
+	"\072ipv6-icmp\0"
+	"\073ipv6-nonxt\0"
+	"\074ipv6-opts\0"
+	"\111rspf\0"
+	"\121vmtp\0"
+	"\131ospf\0"
+	"\136ipip\0"
+	"\142encap\0"
+	"\147pim\0"
+	"\377raw"
+};
+
+void endprotoent(void)
+{
+	unsupported_api(__FUNCTION__);
+	idx = 0;
+}
+
+void setprotoent(int stayopen)
+{
+	idx = 0;
+}
+
+struct protoent *getprotoent(void)
+{
+	static struct protoent p;
+	static const char *aliases;
+	if (idx >= sizeof protos) return NULL;
+	p.p_proto = protos[idx];
+	p.p_name = (char *)&protos[idx+1];
+	p.p_aliases = (char **)&aliases;
+	idx += strlen(p.p_name) + 2;
+	return &p;
+}
+
+struct protoent *getprotobyname(const char *name)
+{
+	struct protoent *p;
+	endprotoent();
+	do p = getprotoent();
+	while (p && strcmp(name, p->p_name));
+	return p;
+}
+
+struct protoent *getprotobynumber(int num)
+{
+	struct protoent *p;
+	endprotoent();
+	do p = getprotoent();
+	while (p && p->p_proto != num);
+	return p;
+}
diff --git a/third_party/musl/porting/liteos_a/user/src/network/recvmsg.c b/third_party/musl/porting/liteos_a/user/src/network/recvmsg.c
new file mode 100755
index 000000000..29f01cb62
--- /dev/null
+++ b/third_party/musl/porting/liteos_a/user/src/network/recvmsg.c
@@ -0,0 +1,73 @@
+#include <sys/socket.h>
+#include <limits.h>
+#include <time.h>
+#include <sys/time.h>
+#include <string.h>
+#include <errno.h>
+#include "syscall.h"
+
+hidden void __convert_scm_timestamps(struct msghdr *, socklen_t);
+
+void __convert_scm_timestamps(struct msghdr *msg, socklen_t csize)
+{
+	if (SCM_TIMESTAMP == SCM_TIMESTAMP_OLD) return;
+	if (!msg->msg_control || !msg->msg_controllen) return;
+
+	struct cmsghdr *cmsg, *last=0;
+	long tmp;
+	long long tvts[2];
+	int type = 0;
+
+	for (cmsg=CMSG_FIRSTHDR(msg); cmsg; cmsg=CMSG_NXTHDR(msg, cmsg)) {
+		if (cmsg->cmsg_level==SOL_SOCKET) switch (cmsg->cmsg_type) {
+		case SCM_TIMESTAMP_OLD:
+			if (type) break;
+			type = SCM_TIMESTAMP;
+			goto common;
+		case SCM_TIMESTAMPNS_OLD:
+			type = SCM_TIMESTAMPNS;
+		common:
+			memcpy(&tmp, CMSG_DATA(cmsg), sizeof tmp);
+			tvts[0] = tmp;
+			memcpy(&tmp, CMSG_DATA(cmsg) + sizeof tmp, sizeof tmp);
+			tvts[1] = tmp;
+			break;
+		}
+		last = cmsg;
+	}
+	if (!last || !type) return;
+	if (CMSG_SPACE(sizeof tvts) > csize-msg->msg_controllen) {
+		msg->msg_flags |= MSG_CTRUNC;
+		return;
+	}
+	msg->msg_controllen += CMSG_SPACE(sizeof tvts);
+	cmsg = CMSG_NXTHDR(msg, last);
+	cmsg->cmsg_level = SOL_SOCKET;
+	cmsg->cmsg_type = type;
+	cmsg->cmsg_len = CMSG_LEN(sizeof tvts);
+	memcpy(CMSG_DATA(cmsg), &tvts, sizeof tvts);
+}
+
+ssize_t recvmsg(int fd, struct msghdr *msg, int flags)
+{
+	ssize_t r;
+	if (!msg) {
+		errno = EFAULT;
+		return -1;
+	}
+	socklen_t orig_controllen = msg->msg_controllen;
+#if LONG_MAX > INT_MAX
+	struct msghdr h, *orig = msg;
+	if (msg) {
+		h = *msg;
+		h.__pad1 = h.__pad2 = 0;
+		msg = &h;
+	}
+#endif
+	r = socketcall_cp(recvmsg, fd, msg, flags, 0, 0, 0);
+	if (r >= 0) __convert_scm_timestamps(msg, orig_controllen);
+#if LONG_MAX > INT_MAX
+	if (orig) *orig = h;
+#endif
+	return r;
+}
diff --git a/third_party/musl/porting/liteos_a/user/src/network/serv.c b/third_party/musl/porting/liteos_a/user/src/network/serv.c
new file mode 100755
index 000000000..f7e4f209b
--- /dev/null
+++ b/third_party/musl/porting/liteos_a/user/src/network/serv.c
@@ -0,0 +1,18 @@
+#include <netdb.h>
+#include <unsupported_api.h>
+
+void endservent(void)
+{
+	unsupported_api(__FUNCTION__);
+}
+
+void setservent(int stayopen)
+{
+	unsupported_api(__FUNCTION__);
+}
+
+struct servent *getservent(void)
+{
+	unsupported_api(__FUNCTION__);
+	return 0;
+}
diff --git a/third_party/musl/porting/liteos_a/user/src/network/sockatmark.c b/third_party/musl/porting/liteos_a/user/src/network/sockatmark.c
new file mode 100755
index 000000000..8162c8c73
--- /dev/null
+++ b/third_party/musl/porting/liteos_a/user/src/network/sockatmark.c
@@ -0,0 +1,12 @@
+#include <sys/socket.h>
+#include <sys/ioctl.h>
+#include <unsupported_api.h>
+
+int sockatmark(int s)
+{
+	int ret;
+	unsupported_api(__FUNCTION__);
+	if (ioctl(s, SIOCATMARK, &ret) < 0)
+		return -1;
+	return ret;
+}
diff --git a/third_party/musl/porting/liteos_a/user/src/passwd/getgr_r.c b/third_party/musl/porting/liteos_a/user/src/passwd/getgr_r.c
new file mode 100755
index 000000000..108393e8e
--- /dev/null
+++ b/third_party/musl/porting/liteos_a/user/src/passwd/getgr_r.c
@@ -0,0 +1,51 @@
+#include "pwf.h"
+#include <pthread.h>
+#include <unsupported_api.h>
+
+#define FIX(x) (gr->gr_##x = gr->gr_##x-line+buf)
+
+static int getgr_r(const char *name, gid_t gid, struct group *gr, char *buf, size_t size, struct group **res)
+{
+	char *line = 0;
+	size_t len = 0;
+	char **mem = 0;
+	size_t nmem = 0;
+	int rv = 0;
+	size_t i;
+	int cs;
+
+	pthread_setcancelstate(PTHREAD_CANCEL_DISABLE, &cs);
+
+	rv = __getgr_a(name, gid, gr, &line, &len, &mem, &nmem, res);
+	if (*res && size < len + (nmem+1)*sizeof(char *) + 32) {
+		*res = 0;
+		rv = ERANGE;
+	}
+	if (*res) {
+		buf += (16-(uintptr_t)buf)%16;
+		gr->gr_mem = (void *)buf;
+		buf += (nmem+1)*sizeof(char *);
+		memcpy(buf, line, len);
+		FIX(name);
+		FIX(passwd);
+		for (i=0; mem[i]; i++)
+			gr->gr_mem[i] = mem[i]-line+buf;
+		gr->gr_mem[i] = 0;
+	}
+ 	free(mem);
+ 	free(line);
+	pthread_setcancelstate(cs, 0);
+	if (rv) errno = rv;
+	return rv;
+}
+
+int getgrnam_r(const char *name, struct group *gr, char *buf, size_t size, struct group **res)
+{
+	unsupported_api(__FUNCTION__);
+	return getgr_r(name, 0, gr, buf, size, res);
+}
+
+int getgrgid_r(gid_t gid, struct group *gr, char *buf, size_t size, struct group **res)
+{
+	return getgr_r(0, gid, gr, buf, size, res);
+}
diff --git a/third_party/musl/porting/liteos_a/user/src/passwd/getgrent.c b/third_party/musl/porting/liteos_a/user/src/passwd/getgrent.c
new file mode 100755
index 000000000..c84ef5e63
--- /dev/null
+++ b/third_party/musl/porting/liteos_a/user/src/passwd/getgrent.c
@@ -0,0 +1,44 @@
+#include <unsupported_api.h>
+#include "pwf.h"
+
+static FILE *f;
+static char *line, **mem;
+static struct group gr;
+
+void setgrent()
+{
+	unsupported_api(__FUNCTION__);
+	if (f) fclose(f);
+	f = 0;
+}
+
+weak_alias(setgrent, endgrent);
+
+struct group *getgrent()
+{
+	struct group *res;
+	size_t size=0, nmem=0;
+	unsupported_api(__FUNCTION__);
+	if (!f) f = fopen("/etc/group", "rbe");
+	if (!f) return 0;
+	__getgrent_a(f, &gr, &line, &size, &mem, &nmem, &res);
+	return res;
+}
+
+struct group *getgrgid(gid_t gid)
+{
+	struct group *res;
+	size_t size=0, nmem=0;
+	unsupported_api(__FUNCTION__);
+	__getgr_a(0, gid, &gr, &line, &size, &mem, &nmem, &res);
+	return res;
+}
+
+struct group *getgrnam(const char *name)
+{
+	struct group *res;
+	size_t size=0, nmem=0;
+	unsupported_api(__FUNCTION__);
+	__getgr_a(name, 0, &gr, &line, &size, &mem, &nmem, &res);
+	return res;
+}
diff --git a/third_party/musl/porting/liteos_a/user/src/passwd/getpw_r.c b/third_party/musl/porting/liteos_a/user/src/passwd/getpw_r.c
new file mode 100755
index 000000000..f09333d14
--- /dev/null
+++ b/third_party/musl/porting/liteos_a/user/src/passwd/getpw_r.c
@@ -0,0 +1,44 @@
+#include "pwf.h"
+#include <pthread.h>
+#include <unsupported_api.h>
+
+#define FIX(x) (pw->pw_##x = pw->pw_##x-line+buf)
+
+static int getpw_r(const char *name, uid_t uid, struct passwd *pw, char *buf, size_t size, struct passwd **res)
+{
+	char *line = 0;
+	size_t len = 0;
+	int rv = 0;
+	int cs;
+
+	pthread_setcancelstate(PTHREAD_CANCEL_DISABLE, &cs);
+
+	rv = __getpw_a(name, uid, pw, &line, &len, res);
+	if (*res && size < len) {
+		*res = 0;
+		rv = ERANGE;
+	}
+	if (*res) {
+		memcpy(buf, line, len);
+		FIX(name);
+		FIX(passwd);
+		FIX(gecos);
+		FIX(dir);
+		FIX(shell);
+	}
+ 	free(line);
+	pthread_setcancelstate(cs, 0);
+	if (rv) errno = rv;
+	return rv;
+}
+
+int getpwnam_r(const char *name, struct passwd *pw, char *buf, size_t size, struct passwd **res)
+{
+	unsupported_api(__FUNCTION__);
+	return getpw_r(name, 0, pw, buf, size, res);
+}
+
+int getpwuid_r(uid_t uid, struct passwd *pw, char *buf, size_t size, struct passwd **res)
+{
+	return getpw_r(0, uid, pw, buf, size, res);
+}
diff --git a/third_party/musl/porting/liteos_a/user/src/passwd/getpwent.c b/third_party/musl/porting/liteos_a/user/src/passwd/getpwent.c
new file mode 100755
index 000000000..73e7a6fff
--- /dev/null
+++ b/third_party/musl/porting/liteos_a/user/src/passwd/getpwent.c
@@ -0,0 +1,42 @@
+#include "pwf.h"
+#include <unsupported_api.h>
+
+static FILE *f;
+static char *line;
+static struct passwd pw;
+static size_t size;
+
+void setpwent()
+{
+	unsupported_api(__FUNCTION__);
+	if (f) fclose(f);
+	f = 0;
+}
+
+weak_alias(setpwent, endpwent);
+
+struct passwd *getpwent()
+{
+	struct passwd *res;
+	unsupported_api(__FUNCTION__);
+	if (!f) f = fopen("/etc/passwd", "rbe");
+	if (!f) return 0;
+	__getpwent_a(f, &pw, &line, &size, &res);
+	return res;
+}
+
+struct passwd *getpwuid(uid_t uid)
+{
+	struct passwd *res;
+	unsupported_api(__FUNCTION__);
+	__getpw_a(0, uid, &pw, &line, &size, &res);
+	return res;
+}
+
+struct passwd *getpwnam(const char *name)
+{
+	struct passwd *res;
+	unsupported_api(__FUNCTION__);
+	__getpw_a(name, 0, &pw, &line, &size, &res);
+	return res;
+}
diff --git a/third_party/musl/porting/liteos_a/user/src/process/fexecve.c b/third_party/musl/porting/liteos_a/user/src/process/fexecve.c
new file mode 100755
index 000000000..cc02ad936
--- /dev/null
+++ b/third_party/musl/porting/liteos_a/user/src/process/fexecve.c
@@ -0,0 +1,18 @@
+#define _GNU_SOURCE
+#include <unistd.h>
+#include <errno.h>
+#include <fcntl.h>
+#include "syscall.h"
+#include <unsupported_api.h>
+
+int fexecve(int fd, char *const argv[], char *const envp[])
+{
+	unsupported_api(__FUNCTION__);
+	int r = __syscall(SYS_execveat, fd, "", argv, envp, AT_EMPTY_PATH);
+	if (r != -ENOSYS) return __syscall_ret(r);
+	char buf[15 + 3*sizeof(int)];
+	__procfdname(buf, fd);
+	execve(buf, argv, envp);
+	if (errno == ENOENT) errno = EBADF;
+	return -1;
+}
diff --git a/third_party/musl/porting/liteos_a/user/src/process/fork.c b/third_party/musl/porting/liteos_a/user/src/process/fork.c
new file mode 100755
index 000000000..b5b8dca0a
--- /dev/null
+++ b/third_party/musl/porting/liteos_a/user/src/process/fork.c
@@ -0,0 +1,38 @@
+#include <unistd.h>
+#include <string.h>
+#include <signal.h>
+#include "syscall.h"
+#include "libc.h"
+#include "pthread_impl.h"
+
+static void dummy(int x)
+{
+}
+
+weak_alias(dummy, __fork_handler);
+
+pid_t fork(void)
+{
+	pid_t ret;
+	sigset_t set;
+	__fork_handler(-1);
+	__block_all_sigs(&set);
+#ifdef SYS_fork
+	ret = __syscall(SYS_fork);
+#else
+	ret = __syscall(SYS_clone, SIGCHLD, 0);
+#endif
+	if (!ret) {
+		pthread_t self = __pthread_self();
+		self->tid = __syscall(SYS_gettid);
+		self->robust_list.off = 0;
+		self->robust_list.pending = 0;
+		self->next = self->prev = self;
+		__thread_list_lock = 0;
+		libc.threads_minus_1 = 0;
+		signal(SIGSYS, arm_do_signal);
+	}
+	__restore_sigs(&set);
+	__fork_handler(!ret);
+	return __syscall_ret(ret);
+}
diff --git a/third_party/musl/porting/liteos_a/user/src/process/posix_spawn.c b/third_party/musl/porting/liteos_a/user/src/process/posix_spawn.c
new file mode 100755
index 000000000..5a5d94c69
--- /dev/null
+++ b/third_party/musl/porting/liteos_a/user/src/process/posix_spawn.c
@@ -0,0 +1,206 @@
+#define _GNU_SOURCE
+#include <spawn.h>
+#include <sched.h>
+#include <unistd.h>
+#include <signal.h>
+#include <fcntl.h>
+#include <sys/wait.h>
+#include <unsupported_api.h>
+#include "syscall.h"
+#include "pthread_impl.h"
+#include "fdop.h"
+
+struct args {
+	int p[2];
+	sigset_t oldmask;
+	const char *path;
+	const posix_spawn_file_actions_t *fa;
+	const posix_spawnattr_t *restrict attr;
+	char *const *argv, *const *envp;
+};
+
+static int __sys_dup2(int old, int new)
+{
+#ifdef SYS_dup2
+	return __syscall(SYS_dup2, old, new);
+#else
+	return __syscall(SYS_dup3, old, new, 0);
+#endif
+}
+
+static int child(void *args_vp)
+{
+	int i, ret;
+	struct sigaction sa = {0};
+	struct args *args = args_vp;
+	int p = args->p[1];
+	const posix_spawn_file_actions_t *fa = args->fa;
+	const posix_spawnattr_t *restrict attr = args->attr;
+	sigset_t hset;
+
+	close(args->p[0]);
+
+	/* All signal dispositions must be either SIG_DFL or SIG_IGN
+	 * before signals are unblocked. Otherwise a signal handler
+	 * from the parent might get run in the child while sharing
+	 * memory, with unpredictable and dangerous results. To
+	 * reduce overhead, sigaction has tracked for us which signals
+	 * potentially have a signal handler. */
+	__get_handler_set(&hset);
+	for (i=1; i<_NSIG; i++) {
+		if ((attr->__flags & POSIX_SPAWN_SETSIGDEF)
+		     && sigismember(&attr->__def, i)) {
+			sa.sa_handler = SIG_DFL;
+		} else if (sigismember(&hset, i)) {
+			if (i-32<3U) {
+				sa.sa_handler = SIG_IGN;
+			} else {
+				__libc_sigaction(i, 0, &sa);
+				if (sa.sa_handler==SIG_IGN) continue;
+				sa.sa_handler = SIG_DFL;
+			}
+		} else {
+			continue;
+		}
+		__libc_sigaction(i, &sa, 0);
+	}
+
+	if (attr->__flags & POSIX_SPAWN_SETSID)
+		if ((ret=__syscall(SYS_setsid)) < 0)
+			goto fail;
+
+	if (attr->__flags & POSIX_SPAWN_SETPGROUP)
+		if ((ret=__syscall(SYS_setpgid, 0, attr->__pgrp)))
+			goto fail;
+
+	/* Use syscalls directly because the library functions attempt
+	 * to do a multi-threaded synchronized id-change, which would
+	 * trash the parent's state. */
+	if (attr->__flags & POSIX_SPAWN_RESETIDS)
+		if ((ret=__syscall(SYS_setgid, __syscall(SYS_getgid))) ||
+		    (ret=__syscall(SYS_setuid, __syscall(SYS_getuid))) )
+			goto fail;
+
+	if (fa && fa->__actions) {
+		struct fdop *op;
+		int fd;
+		for (op = fa->__actions; op->next; op = op->next);
+		for (; op; op = op->prev) {
+			/* It's possible that a file operation would clobber
+			 * the pipe fd used for synchronizing with the
+			 * parent. To avoid that, we dup the pipe onto
+			 * an unoccupied fd. */
+			if (op->fd == p) {
+				ret = __syscall(SYS_dup, p);
+				if (ret < 0) goto fail;
+				__syscall(SYS_close, p);
+				p = ret;
+			}
+			switch(op->cmd) {
+			case FDOP_CLOSE:
+				__syscall(SYS_close, op->fd);
+				break;
+			case FDOP_DUP2:
+				fd = op->srcfd;
+				if (fd == p) {
+					ret = -EBADF;
+					goto fail;
+				}
+				if (fd != op->fd) {
+					if ((ret=__sys_dup2(fd, op->fd))<0)
+						goto fail;
+				} else {
+					ret = __syscall(SYS_fcntl, fd, F_GETFD);
+					ret = __syscall(SYS_fcntl, fd, F_SETFD,
+					                ret & ~FD_CLOEXEC);
+					if (ret<0)
+						goto fail;
+				}
+				break;
+			case FDOP_OPEN:
+				fd = __sys_open(op->path, op->oflag, op->mode);
+				if ((ret=fd) < 0) goto fail;
+				if (fd != op->fd) {
+					if ((ret=__sys_dup2(fd, op->fd))<0)
+						goto fail;
+					__syscall(SYS_close, fd);
+				}
+				break;
+			case FDOP_CHDIR:
+				ret = __syscall(SYS_chdir, op->path);
+				if (ret<0) goto fail;
+				break;
+			case FDOP_FCHDIR:
+				ret = __syscall(SYS_fchdir, op->fd);
+				if (ret<0) goto fail;
+				break;
+			}
+		}
+	}
+
+	/* Close-on-exec flag may have been lost if we moved the pipe
+	 * to a different fd. We don't use F_DUPFD_CLOEXEC above because
+	 * it would fail on older kernels and atomicity is not needed --
+	 * in this process there are no threads or signal handlers. */
+	__syscall(SYS_fcntl, p, F_SETFD, FD_CLOEXEC);
+
+	pthread_sigmask(SIG_SETMASK, (attr->__flags & POSIX_SPAWN_SETSIGMASK)
+		? &attr->__mask : &args->oldmask, 0);
+
+	int (*exec)(const char *, char *const *, char *const *) =
+		attr->__fn ? (int (*)())attr->__fn : execve;
+
+	exec(args->path, args->argv, args->envp);
+	ret = -errno;
+
+fail:
+	/* Since sizeof errno < PIPE_BUF, the write is atomic. */
+	ret = -ret;
+	if (ret) while (__syscall(SYS_write, p, &ret, sizeof ret) < 0);
+	_exit(127);
+}
+
+
+int posix_spawn(pid_t *restrict res, const char *restrict path,
+	const posix_spawn_file_actions_t *fa,
+	const posix_spawnattr_t *restrict attr,
+	char *const argv[restrict], char *const envp[restrict])
+{
+	pid_t pid;
+	char stack[1024+PATH_MAX];
+	int ec=0, cs;
+	struct args args;
+
+	unsupported_api(__FUNCTION__);
+	if (pipe2(args.p, O_CLOEXEC))
+		return errno;
+
+	pthread_setcancelstate(PTHREAD_CANCEL_DISABLE, &cs);
+
+	args.path = path;
+	args.fa = fa;
+	args.attr = attr ? attr : &(const posix_spawnattr_t){0};
+	args.argv = argv;
+	args.envp = envp;
+	pthread_sigmask(SIG_BLOCK, SIGALL_SET, &args.oldmask);
+
+	pid = __clone(child, stack+sizeof stack,
+		CLONE_VM|CLONE_VFORK|SIGCHLD, &args);
+	close(args.p[1]);
+
+	if (pid > 0) {
+		if (read(args.p[0], &ec, sizeof ec) != sizeof ec) ec = 0;
+		else waitpid(pid, &(int){0}, 0);
+	} else {
+		ec = -pid;
+	}
+
+	close(args.p[0]);
+
+	if (!ec && res) *res = pid;
+
+	pthread_sigmask(SIG_SETMASK, &args.oldmask, 0);
+	pthread_setcancelstate(cs, 0);
+
+	return ec;
+}
diff --git a/third_party/musl/porting/liteos_a/user/src/process/posix_spawn_file_actions_addclose.c b/third_party/musl/porting/liteos_a/user/src/process/posix_spawn_file_actions_addclose.c
new file mode 100755
index 000000000..7f6fc8569
--- /dev/null
+++ b/third_party/musl/porting/liteos_a/user/src/process/posix_spawn_file_actions_addclose.c
@@ -0,0 +1,18 @@
+#include <spawn.h>
+#include <stdlib.h>
+#include <errno.h>
+#include "fdop.h"
+#include <unsupported_api.h>
+
+int posix_spawn_file_actions_addclose(posix_spawn_file_actions_t *fa, int fd)
+{
+	unsupported_api(__FUNCTION__);
+	struct fdop *op = malloc(sizeof *op);
+	if (!op) return ENOMEM;
+	op->cmd = FDOP_CLOSE;
+	op->fd = fd;
+	if ((op->next = fa->__actions)) op->next->prev = op;
+	op->prev = 0;
+	fa->__actions = op;
+	return 0;
+}
diff --git a/third_party/musl/porting/liteos_a/user/src/process/posix_spawn_file_actions_adddup2.c b/third_party/musl/porting/liteos_a/user/src/process/posix_spawn_file_actions_adddup2.c
new file mode 100755
index 000000000..19e518116
--- /dev/null
+++ b/third_party/musl/porting/liteos_a/user/src/process/posix_spawn_file_actions_adddup2.c
@@ -0,0 +1,19 @@
+#include <spawn.h>
+#include <stdlib.h>
+#include <errno.h>
+#include "fdop.h"
+#include <unsupported_api.h>
+
+int posix_spawn_file_actions_adddup2(posix_spawn_file_actions_t *fa, int srcfd, int fd)
+{
+	unsupported_api(__FUNCTION__);
+	struct fdop *op = malloc(sizeof *op);
+	if (!op) return ENOMEM;
+	op->cmd = FDOP_DUP2;
+	op->srcfd = srcfd;
+	op->fd = fd;
+	if ((op->next = fa->__actions)) op->next->prev = op;
+	op->prev = 0;
+	fa->__actions = op;
+	return 0;
+}
diff --git a/third_party/musl/porting/liteos_a/user/src/process/posix_spawn_file_actions_addopen.c b/third_party/musl/porting/liteos_a/user/src/process/posix_spawn_file_actions_addopen.c
new file mode 100755
index 000000000..35c52d3c6
--- /dev/null
+++ b/third_party/musl/porting/liteos_a/user/src/process/posix_spawn_file_actions_addopen.c
@@ -0,0 +1,22 @@
+#include <spawn.h>
+#include <stdlib.h>
+#include <string.h>
+#include <errno.h>
+#include "fdop.h"
+#include <unsupported_api.h>
+
+int posix_spawn_file_actions_addopen(posix_spawn_file_actions_t *restrict fa, int fd, const char *restrict path, int flags, mode_t mode)
+{
+	unsupported_api(__FUNCTION__);
+	struct fdop *op = malloc(sizeof *op + strlen(path) + 1);
+	if (!op) return ENOMEM;
+	op->cmd = FDOP_OPEN;
+	op->fd = fd;
+	op->oflag = flags;
+	op->mode = mode;
+	strcpy(op->path, path);
+	if ((op->next = fa->__actions)) op->next->prev = op;
+	op->prev = 0;
+	fa->__actions = op;
+	return 0;
+}
diff --git a/third_party/musl/porting/liteos_a/user/src/process/posix_spawnattr_destroy.c b/third_party/musl/porting/liteos_a/user/src/process/posix_spawnattr_destroy.c
new file mode 100755
index 000000000..b66614fc4
--- /dev/null
+++ b/third_party/musl/porting/liteos_a/user/src/process/posix_spawnattr_destroy.c
@@ -0,0 +1,8 @@
+#include <spawn.h>
+#include <unsupported_api.h>
+
+int posix_spawnattr_destroy(posix_spawnattr_t *attr)
+{
+	unsupported_api(__FUNCTION__);
+	return 0;
+}
diff --git a/third_party/musl/porting/liteos_a/user/src/process/posix_spawnattr_getflags.c b/third_party/musl/porting/liteos_a/user/src/process/posix_spawnattr_getflags.c
new file mode 100755
index 000000000..d3942db77
--- /dev/null
+++ b/third_party/musl/porting/liteos_a/user/src/process/posix_spawnattr_getflags.c
@@ -0,0 +1,9 @@
+#include <spawn.h>
+#include <unsupported_api.h>
+
+int posix_spawnattr_getflags(const posix_spawnattr_t *restrict attr, short *restrict flags)
+{
+	unsupported_api(__FUNCTION__);
+	*flags = attr->__flags;
+	return 0;
+}
diff --git a/third_party/musl/porting/liteos_a/user/src/process/posix_spawnattr_getpgroup.c b/third_party/musl/porting/liteos_a/user/src/process/posix_spawnattr_getpgroup.c
new file mode 100755
index 000000000..be42a87e2
--- /dev/null
+++ b/third_party/musl/porting/liteos_a/user/src/process/posix_spawnattr_getpgroup.c
@@ -0,0 +1,9 @@
+#include <spawn.h>
+#include <unsupported_api.h>
+
+int posix_spawnattr_getpgroup(const posix_spawnattr_t *restrict attr, pid_t *restrict pgrp)
+{
+	unsupported_api(__FUNCTION__);
+	*pgrp = attr->__pgrp;
+	return 0;
+}
diff --git a/third_party/musl/porting/liteos_a/user/src/process/posix_spawnattr_getsigdefault.c b/third_party/musl/porting/liteos_a/user/src/process/posix_spawnattr_getsigdefault.c
new file mode 100755
index 000000000..6687b8640
--- /dev/null
+++ b/third_party/musl/porting/liteos_a/user/src/process/posix_spawnattr_getsigdefault.c
@@ -0,0 +1,9 @@
+#include <spawn.h>
+#include <unsupported_api.h>
+
+int posix_spawnattr_getsigdefault(const posix_spawnattr_t *restrict attr, sigset_t *restrict def)
+{
+	unsupported_api(__FUNCTION__);
+	*def = attr->__def;
+	return 0;
+}
diff --git a/third_party/musl/porting/liteos_a/user/src/process/posix_spawnattr_getsigmask.c b/third_party/musl/porting/liteos_a/user/src/process/posix_spawnattr_getsigmask.c
new file mode 100755
index 000000000..5d56dae47
--- /dev/null
+++ b/third_party/musl/porting/liteos_a/user/src/process/posix_spawnattr_getsigmask.c
@@ -0,0 +1,9 @@
+#include <spawn.h>
+#include <unsupported_api.h>
+
+int posix_spawnattr_getsigmask(const posix_spawnattr_t *restrict attr, sigset_t *restrict mask)
+{
+	unsupported_api(__FUNCTION__);
+	*mask = attr->__mask;
+	return 0;
+}
diff --git a/third_party/musl/porting/liteos_a/user/src/process/posix_spawnattr_init.c b/third_party/musl/porting/liteos_a/user/src/process/posix_spawnattr_init.c
new file mode 100755
index 000000000..cf2dc2754
--- /dev/null
+++ b/third_party/musl/porting/liteos_a/user/src/process/posix_spawnattr_init.c
@@ -0,0 +1,9 @@
+#include <spawn.h>
+#include <unsupported_api.h>
+
+int posix_spawnattr_init(posix_spawnattr_t *attr)
+{
+	unsupported_api(__FUNCTION__);
+	*attr = (posix_spawnattr_t){ 0 };
+	return 0;
+}
diff --git a/third_party/musl/porting/liteos_a/user/src/process/posix_spawnattr_sched.c b/third_party/musl/porting/liteos_a/user/src/process/posix_spawnattr_sched.c
new file mode 100755
index 000000000..f7a3cc03f
--- /dev/null
+++ b/third_party/musl/porting/liteos_a/user/src/process/posix_spawnattr_sched.c
@@ -0,0 +1,30 @@
+#include <spawn.h>
+#include <sched.h>
+#include <errno.h>
+#include <unsupported_api.h>
+
+int posix_spawnattr_getschedparam(const posix_spawnattr_t *restrict attr,
+	struct sched_param *restrict schedparam)
+{
+	unsupported_api(__FUNCTION__);
+	return ENOSYS;
+}
+
+int posix_spawnattr_setschedparam(posix_spawnattr_t *restrict attr,
+	const struct sched_param *restrict schedparam)
+{
+	unsupported_api(__FUNCTION__);
+	return ENOSYS;
+}
+
+int posix_spawnattr_getschedpolicy(const posix_spawnattr_t *restrict attr, int *restrict policy)
+{
+	unsupported_api(__FUNCTION__);
+	return ENOSYS;
+}
+
+int posix_spawnattr_setschedpolicy(posix_spawnattr_t *attr, int policy)
+{
+	unsupported_api(__FUNCTION__);
+	return ENOSYS;
+}
diff --git a/third_party/musl/porting/liteos_a/user/src/process/posix_spawnattr_setflags.c b/third_party/musl/porting/liteos_a/user/src/process/posix_spawnattr_setflags.c
new file mode 100755
index 000000000..afeb2af5f
--- /dev/null
+++ b/third_party/musl/porting/liteos_a/user/src/process/posix_spawnattr_setflags.c
@@ -0,0 +1,20 @@
+#include <spawn.h>
+#include <errno.h>
+#include <unsupported_api.h>
+
+int posix_spawnattr_setflags(posix_spawnattr_t *attr, short flags)
+{
+	unsupported_api(__FUNCTION__);
+	const unsigned all_flags =
+		POSIX_SPAWN_RESETIDS |
+		POSIX_SPAWN_SETPGROUP |
+		POSIX_SPAWN_SETSIGDEF |
+		POSIX_SPAWN_SETSIGMASK |
+		POSIX_SPAWN_SETSCHEDPARAM |
+		POSIX_SPAWN_SETSCHEDULER |
+		POSIX_SPAWN_USEVFORK |
+		POSIX_SPAWN_SETSID;
+	if (flags & ~all_flags) return EINVAL;
+	attr->__flags = flags;
+	return 0;
+}
diff --git a/third_party/musl/porting/liteos_a/user/src/process/posix_spawnattr_setpgroup.c b/third_party/musl/porting/liteos_a/user/src/process/posix_spawnattr_setpgroup.c
new file mode 100755
index 000000000..217cb9e0b
--- /dev/null
+++ b/third_party/musl/porting/liteos_a/user/src/process/posix_spawnattr_setpgroup.c
@@ -0,0 +1,9 @@
+#include <spawn.h>
+#include <unsupported_api.h>
+
+int posix_spawnattr_setpgroup(posix_spawnattr_t *attr, pid_t pgrp)
+{
+	unsupported_api(__FUNCTION__);
+	attr->__pgrp = pgrp;
+	return 0;
+}
diff --git a/third_party/musl/porting/liteos_a/user/src/process/posix_spawnattr_setsigdefault.c b/third_party/musl/porting/liteos_a/user/src/process/posix_spawnattr_setsigdefault.c
new file mode 100755
index 000000000..4c142b343
--- /dev/null
+++ b/third_party/musl/porting/liteos_a/user/src/process/posix_spawnattr_setsigdefault.c
@@ -0,0 +1,10 @@
+#include <spawn.h>
+#include <unsupported_api.h>
+
+int posix_spawnattr_setsigdefault(posix_spawnattr_t *restrict attr, const sigset_t *restrict def)
+{
+	unsupported_api(__FUNCTION__);
+
+	attr->__def = *def;
+	return 0;
+}
diff --git a/third_party/musl/porting/liteos_a/user/src/process/posix_spawnattr_setsigmask.c b/third_party/musl/porting/liteos_a/user/src/process/posix_spawnattr_setsigmask.c
new file mode 100755
index 000000000..46173effe
--- /dev/null
+++ b/third_party/musl/porting/liteos_a/user/src/process/posix_spawnattr_setsigmask.c
@@ -0,0 +1,10 @@
+#include <spawn.h>
+#include <unsupported_api.h>
+
+int posix_spawnattr_setsigmask(posix_spawnattr_t *restrict attr, const sigset_t *restrict mask)
+{
+	unsupported_api(__FUNCTION__);
+
+	attr->__mask = *mask;
+	return 0;
+}
diff --git a/third_party/musl/porting/liteos_a/user/src/process/posix_spawnp.c b/third_party/musl/porting/liteos_a/user/src/process/posix_spawnp.c
new file mode 100755
index 000000000..e1ac20d68
--- /dev/null
+++ b/third_party/musl/porting/liteos_a/user/src/process/posix_spawnp.c
@@ -0,0 +1,15 @@
+#include <spawn.h>
+#include <unistd.h>
+#include <unsupported_api.h>
+
+int posix_spawnp(pid_t *restrict res, const char *restrict file,
+	const posix_spawn_file_actions_t *fa,
+	const posix_spawnattr_t *restrict attr,
+	char *const argv[restrict], char *const envp[restrict])
+{
+	posix_spawnattr_t spawnp_attr = { 0 };
+	unsupported_api(__FUNCTION__);
+	if (attr) spawnp_attr = *attr;
+	spawnp_attr.__fn = (void *)__execvpe;
+	return posix_spawn(res, file, fa, &spawnp_attr, argv, envp);
+}
diff --git a/third_party/musl/porting/liteos_a/user/src/process/system.c b/third_party/musl/porting/liteos_a/user/src/process/system.c
new file mode 100755
index 000000000..50aaa7532
--- /dev/null
+++ b/third_party/musl/porting/liteos_a/user/src/process/system.c
@@ -0,0 +1,49 @@
+#include <unistd.h>
+#include <stdlib.h>
+#include <signal.h>
+#include <sys/wait.h>
+#include <spawn.h>
+#include <errno.h>
+#include <unsupported_api.h>
+#include "pthread_impl.h"
+
+extern char **__environ;
+
+int system(const char *cmd)
+{
+	pid_t pid;
+	sigset_t old, reset;
+	struct sigaction sa = { .sa_handler = SIG_IGN }, oldint, oldquit;
+	int status = -1, ret;
+	posix_spawnattr_t attr;
+
+	unsupported_api(__FUNCTION__);
+
+	pthread_testcancel();
+
+	if (!cmd) return 1;
+
+	sigaction(SIGINT, &sa, &oldint);
+	sigaction(SIGQUIT, &sa, &oldquit);
+	sigaddset(&sa.sa_mask, SIGCHLD);
+	sigprocmask(SIG_BLOCK, &sa.sa_mask, &old);
+
+	sigemptyset(&reset);
+	if (oldint.sa_handler != SIG_IGN) sigaddset(&reset, SIGINT);
+	if (oldquit.sa_handler != SIG_IGN) sigaddset(&reset, SIGQUIT);
+	posix_spawnattr_init(&attr);
+	posix_spawnattr_setsigmask(&attr, &old);
+	posix_spawnattr_setsigdefault(&attr, &reset);
+	posix_spawnattr_setflags(&attr, POSIX_SPAWN_SETSIGDEF|POSIX_SPAWN_SETSIGMASK);
+	ret = posix_spawn(&pid, "/bin/sh", 0, &attr,
+		(char *[]){"sh", "-c", (char *)cmd, 0}, __environ);
+	posix_spawnattr_destroy(&attr);
+
+	if (!ret) while (waitpid(pid, &status, 0)<0 && errno == EINTR);
+	sigaction(SIGINT, &oldint, NULL);
+	sigaction(SIGQUIT, &oldquit, NULL);
+	sigprocmask(SIG_SETMASK, &old, NULL);
+
+	if (ret) errno = ret;
+	return status;
+}
diff --git a/third_party/musl/porting/liteos_a/user/src/process/waitid.c b/third_party/musl/porting/liteos_a/user/src/process/waitid.c
new file mode 100755
index 000000000..6622e06dc
--- /dev/null
+++ b/third_party/musl/porting/liteos_a/user/src/process/waitid.c
@@ -0,0 +1,9 @@
+#include <sys/wait.h>
+#include <unsupported_api.h>
+#include "syscall.h"
+
+int waitid(idtype_t type, id_t id, siginfo_t *info, int options)
+{
+	unsupported_api(__FUNCTION__);
+	return syscall_cp(SYS_waitid, type, id, info, options, 0);
+}
diff --git a/third_party/musl/porting/liteos_a/user/src/sched/affinity.c b/third_party/musl/porting/liteos_a/user/src/sched/affinity.c
new file mode 100755
index 000000000..14b061f2d
--- /dev/null
+++ b/third_party/musl/porting/liteos_a/user/src/sched/affinity.c
@@ -0,0 +1,46 @@
+#define _GNU_SOURCE
+#include <sched.h>
+#include <string.h>
+#include "pthread_impl.h"
+#include "syscall.h"
+
+int sched_setaffinity(pid_t tid, size_t size, const cpu_set_t *set)
+{
+    if (size != sizeof(cpu_set_t)) {
+        errno = EINVAL;
+        return -1;
+    }
+    return syscall(SYS_sched_setaffinity, tid, (unsigned short)(set->__bits[0]), MUSL_TYPE_PROCESS);
+}
+
+int pthread_setaffinity_np(pthread_t td, size_t size, const cpu_set_t *set)
+{
+    if (size != sizeof(cpu_set_t)) {
+        return EINVAL;
+    }
+    return -__syscall(SYS_sched_setaffinity, td->tid, (unsigned short)(set->__bits[0]), MUSL_TYPE_THREAD);
+}
+
+static int do_getaffinity(pid_t tid, size_t size, cpu_set_t *set, int flag)
+{
+    unsigned int cpuset;
+    if (size != sizeof(cpu_set_t)) {
+        return -EINVAL;
+    }
+    int ret = __syscall(SYS_sched_getaffinity, tid, &cpuset, flag);
+    if (ret < 0) {
+        return ret;
+    }
+    set->__bits[0] = (long)cpuset;
+    return 0;
+}
+
+int sched_getaffinity(pid_t tid, size_t size, cpu_set_t *set)
+{
+    return __syscall_ret(do_getaffinity(tid, size, set, MUSL_TYPE_PROCESS));
+}
+
+int pthread_getaffinity_np(pthread_t td, size_t size, cpu_set_t *set)
+{
+    return -do_getaffinity(td->tid, size, set, MUSL_TYPE_THREAD);
+}
diff --git a/third_party/musl/porting/liteos_a/user/src/sched/sched_getparam.c b/third_party/musl/porting/liteos_a/user/src/sched/sched_getparam.c
new file mode 100755
index 000000000..463b5297c
--- /dev/null
+++ b/third_party/musl/porting/liteos_a/user/src/sched/sched_getparam.c
@@ -0,0 +1,24 @@
+#include <sched.h>
+#include <errno.h>
+#include <string.h>
+#include "syscall.h"
+#include "pthread_impl.h"
+
+int sched_getparam(pid_t pid, struct sched_param *param)
+{
+	int r;
+	if (!param) {
+		r = -EINVAL;
+		goto exit;
+	}
+
+	memset(param, 0, sizeof(struct sched_param));
+	r = __syscall(SYS_sched_getparam, pid, MUSL_TYPE_PROCESS);
+	if (r >= 0) {
+		param->sched_priority = r;
+		r = 0;
+	}
+
+exit:
+	return __syscall_ret(r);
+}
diff --git a/third_party/musl/porting/liteos_a/user/src/sched/sched_getscheduler.c b/third_party/musl/porting/liteos_a/user/src/sched/sched_getscheduler.c
new file mode 100755
index 000000000..0f988f596
--- /dev/null
+++ b/third_party/musl/porting/liteos_a/user/src/sched/sched_getscheduler.c
@@ -0,0 +1,10 @@
+#include <sched.h>
+#include <errno.h>
+#include "syscall.h"
+#include "pthread_impl.h"
+
+int sched_getscheduler(pid_t pid)
+{
+	int r = __syscall(SYS_sched_getscheduler, pid, MUSL_TYPE_PROCESS);
+	return __syscall_ret(r);
+}
diff --git a/third_party/musl/porting/liteos_a/user/src/sched/sched_setparam.c b/third_party/musl/porting/liteos_a/user/src/sched/sched_setparam.c
new file mode 100755
index 000000000..95e27b1d8
--- /dev/null
+++ b/third_party/musl/porting/liteos_a/user/src/sched/sched_setparam.c
@@ -0,0 +1,18 @@
+#include <sched.h>
+#include <errno.h>
+#include "syscall.h"
+#include "pthread_impl.h"
+
+int sched_setparam(pid_t pid, const struct sched_param *param)
+{
+	int r;
+	if (!param) {
+		r = -EINVAL;
+		goto exit;
+	}
+
+	r = __syscall(SYS_sched_setparam, pid, param->sched_priority, MUSL_TYPE_PROCESS);
+
+exit:
+	return __syscall_ret(r);
+}
diff --git a/third_party/musl/porting/liteos_a/user/src/sched/sched_setscheduler.c b/third_party/musl/porting/liteos_a/user/src/sched/sched_setscheduler.c
new file mode 100755
index 000000000..8bd4147f8
--- /dev/null
+++ b/third_party/musl/porting/liteos_a/user/src/sched/sched_setscheduler.c
@@ -0,0 +1,18 @@
+#include <sched.h>
+#include <errno.h>
+#include "syscall.h"
+#include "pthread_impl.h"
+
+int sched_setscheduler(pid_t pid, int sched, const struct sched_param *param)
+{
+	int r;
+	if (!param) {
+		r = -EINVAL;
+		goto exit;
+	}
+
+	r = __syscall(SYS_sched_setscheduler, pid, sched, param->sched_priority, MUSL_TYPE_PROCESS);
+
+exit:
+	return __syscall_ret(r);
+}
diff --git a/third_party/musl/porting/liteos_a/user/src/sched/sched_yield.c b/third_party/musl/porting/liteos_a/user/src/sched/sched_yield.c
new file mode 100755
index 000000000..3b5101dbe
--- /dev/null
+++ b/third_party/musl/porting/liteos_a/user/src/sched/sched_yield.c
@@ -0,0 +1,7 @@
+#include <sched.h>
+#include "syscall.h"
+
+int sched_yield()
+{
+	return syscall(SYS_sched_yield, 0);
+}
diff --git a/third_party/musl/porting/liteos_a/user/src/select/pselect.c b/third_party/musl/porting/liteos_a/user/src/select/pselect.c
new file mode 100755
index 000000000..ef454b379
--- /dev/null
+++ b/third_party/musl/porting/liteos_a/user/src/select/pselect.c
@@ -0,0 +1,28 @@
+#include <sys/select.h>
+#include <signal.h>
+#include <stdint.h>
+#include <errno.h>
+#include <unsupported_api.h>
+#include "syscall.h"
+
+#define IS32BIT(x) !((x)+0x80000000ULL>>32)
+#define CLAMP(x) (int)(IS32BIT(x) ? (x) : 0x7fffffffU+((0ULL+(x))>>63))
+
+int pselect(int n, fd_set *restrict rfds, fd_set *restrict wfds, fd_set *restrict efds, const struct timespec *restrict ts, const sigset_t *restrict mask)
+{
+	syscall_arg_t data[2] = { (uintptr_t)mask, _NSIG/8 };
+	time_t s = ts ? ts->tv_sec : 0;
+	long ns = ts ? ts->tv_nsec : 0;
+	unsupported_api(__FUNCTION__);
+#ifdef SYS_pselect6_time64
+	int r = -ENOSYS;
+	if (SYS_pselect6 == SYS_pselect6_time64 || !IS32BIT(s))
+		r = __syscall_cp(SYS_pselect6_time64, n, rfds, wfds, efds,
+			ts ? ((long long[]){s, ns}) : 0, data);
+	if (SYS_pselect6 == SYS_pselect6_time64 || r!=-ENOSYS)
+		return __syscall_ret(r);
+	s = CLAMP(s);
+#endif
+	return syscall_cp(SYS_pselect6, n, rfds, wfds, efds,
+		ts ? ((long[]){s, ns}) : 0, data);
+}
diff --git a/third_party/musl/porting/liteos_a/user/src/select/select.c b/third_party/musl/porting/liteos_a/user/src/select/select.c
new file mode 100755
index 000000000..b4b1ba988
--- /dev/null
+++ b/third_party/musl/porting/liteos_a/user/src/select/select.c
@@ -0,0 +1,44 @@
+#include <sys/select.h>
+#include <signal.h>
+#include <stdint.h>
+#include <errno.h>
+#include "syscall.h"
+
+#define IS32BIT(x) !((x)+0x80000000ULL>>32)
+#define CLAMP(x) (int)(IS32BIT(x) ? (x) : 0x7fffffffU+((0ULL+(x))>>63))
+
+int select(int n, fd_set *restrict rfds, fd_set *restrict wfds, fd_set *restrict efds, struct timeval *restrict tv)
+{
+	time_t s = tv ? tv->tv_sec : 0;
+	suseconds_t us = tv ? tv->tv_usec : 0;
+	long ns;
+	const time_t max_time = (1ULL<<8*sizeof(time_t)-1)-1;
+
+	if (s<0 || us<0) return __syscall_ret(-EINVAL);
+	if (us/1000000 > max_time - s) {
+		s = max_time;
+		us = 999999;
+		ns = 999999999;
+	} else {
+		s += us/1000000;
+		us %= 1000000;
+		ns = us*1000;
+	}
+
+#ifdef SYS_pselect6_time64
+	int r = -ENOSYS;
+	if (SYS_pselect6 == SYS_pselect6_time64 || !IS32BIT(s))
+		r = __syscall_cp(SYS_pselect6_time64, n, rfds, wfds, efds,
+			tv ? ((long long[]){s, ns}) : 0,
+			((syscall_arg_t[]){ 0, _NSIG/8 }));
+	if (SYS_pselect6 == SYS_pselect6_time64 || r!=-ENOSYS)
+		return __syscall_ret(r);
+#endif
+#ifdef SYS_select
+	return syscall_cp(SYS_select, n, rfds, wfds, efds,
+		tv ? ((long long[]){s, us}) : 0);
+#else
+	return syscall_cp(SYS_pselect6, n, rfds, wfds, efds,
+		tv ? ((long long[]){s, ns}) : 0, ((syscall_arg_t[]){ 0, _NSIG/8 }));
+#endif
+}
diff --git a/third_party/musl/porting/liteos_a/user/src/signal/arm/restore.s b/third_party/musl/porting/liteos_a/user/src/signal/arm/restore.s
new file mode 100755
index 000000000..5450c9a1b
--- /dev/null
+++ b/third_party/musl/porting/liteos_a/user/src/signal/arm/restore.s
@@ -0,0 +1,28 @@
+.syntax unified
+
+.global arm_signal_process
+.global arm_do_signal
+.hidden arm_do_signal
+.type arm_do_signal,%function
+arm_do_signal:
+	stmfd sp!, {r0-r12}
+	mov r4, sp
+	bic sp, sp, #7
+	blx arm_signal_process
+	mov sp, r4
+	ldmfd sp!, {r0-r12}
+	b __restore
+
+.global __restore
+.hidden __restore
+.type __restore,%function
+__restore:
+	mov r7,#119
+	swi 0x0
+
+.global __restore_rt
+.hidden __restore_rt
+.type __restore_rt,%function
+__restore_rt:
+	mov r7,#173
+	swi 0x0
diff --git a/third_party/musl/porting/liteos_a/user/src/signal/getitimer.c b/third_party/musl/porting/liteos_a/user/src/signal/getitimer.c
new file mode 100755
index 000000000..8a8046a76
--- /dev/null
+++ b/third_party/musl/porting/liteos_a/user/src/signal/getitimer.c
@@ -0,0 +1,7 @@
+#include <sys/time.h>
+#include "syscall.h"
+
+int getitimer(int which, struct itimerval *old)
+{
+	return syscall(SYS_getitimer, which, old);
+}
diff --git a/third_party/musl/porting/liteos_a/user/src/signal/killpg.c b/third_party/musl/porting/liteos_a/user/src/signal/killpg.c
new file mode 100755
index 000000000..238b69bdc
--- /dev/null
+++ b/third_party/musl/porting/liteos_a/user/src/signal/killpg.c
@@ -0,0 +1,13 @@
+#include <signal.h>
+#include <errno.h>
+#include <unsupported_api.h>
+
+int killpg(pid_t pgid, int sig)
+{
+	unsupported_api(__FUNCTION__);
+	if (pgid < 0) {
+		errno = EINVAL;
+		return -1;
+	}
+	return kill(-pgid, sig);
+}
diff --git a/third_party/musl/porting/liteos_a/user/src/signal/psiginfo.c b/third_party/musl/porting/liteos_a/user/src/signal/psiginfo.c
new file mode 100755
index 000000000..bdf5cae39
--- /dev/null
+++ b/third_party/musl/porting/liteos_a/user/src/signal/psiginfo.c
@@ -0,0 +1,8 @@
+#include <signal.h>
+#include <unsupported_api.h>
+
+void psiginfo(const siginfo_t *si, const char *msg)
+{
+	unsupported_api(__FUNCTION__);
+	psignal(si->si_signo, msg);
+}
diff --git a/third_party/musl/porting/liteos_a/user/src/signal/setitimer.c b/third_party/musl/porting/liteos_a/user/src/signal/setitimer.c
new file mode 100755
index 000000000..9ddac66eb
--- /dev/null
+++ b/third_party/musl/porting/liteos_a/user/src/signal/setitimer.c
@@ -0,0 +1,10 @@
+#include <sys/time.h>
+#include <errno.h>
+#include "syscall.h"
+
+#define IS32BIT(x) !((x)+0x80000000ULL>>32)
+
+int setitimer(int which, const struct itimerval *restrict new, struct itimerval *restrict old)
+{
+	return syscall(SYS_setitimer, which, new, old);
+}
diff --git a/third_party/musl/porting/liteos_a/user/src/signal/sigaction.c b/third_party/musl/porting/liteos_a/user/src/signal/sigaction.c
new file mode 100755
index 000000000..45e1cebd9
--- /dev/null
+++ b/third_party/musl/porting/liteos_a/user/src/signal/sigaction.c
@@ -0,0 +1,364 @@
+#include <signal.h>
+#include <errno.h>
+#include <string.h>
+#include "stdbool.h"
+#include "syscall.h"
+#include "pthread_impl.h"
+#include "libc.h"
+#include "lock.h"
+#include "ksigaction.h"
+
+#define DEFAULT_SIG_NUM 64
+#define SIGNO2SET(s)            ((sigset_t)1 << (s))
+#define NULL_SIGNAL_SET         ((sigset_t)0x00000000)
+#define SET_BIT(bitmap, pos)    (bitmap |= (1u << pos))
+#define CLEAR_BIT(bitmap, pos)  (bitmap &= ~(1u << pos))
+#define CHECK_BIT(bitmap, pos)  ((bitmap & (1u << pos)) ? 1 : 0)
+#define SIG_FLAG_NOIGNORE 1
+
+
+struct sigactq {
+	struct sigaction act;
+	bool	ign_flag;
+	unsigned char   signo;
+	unsigned char   sigmask;
+	unsigned char   reserve[2];
+};
+typedef struct sigactq sigactq_t;
+
+
+
+
+typedef void (*sa_sighandler_t)(int);
+typedef struct sigaction sigaction_t;
+
+static sigactq_t g_sig_arr[DEFAULT_SIG_NUM];
+static pthread_spinlock_t sig_lite_lock;
+
+struct sig_default_act {
+	unsigned char singNo;
+	unsigned char flag;
+	sa_sighandler_t action;
+};
+
+
+static void __sig_core(int signo);
+static void __sig_kill(int signo);
+static void __sig_cont(int signo);
+static void __sig_stop(int signo);
+static void __sig_ignore(int signo);
+static const struct sig_default_act sig_default_action[] = {
+	{SIGHUP, 0, __sig_kill},
+	{SIGINT, 0, __sig_kill},
+	{SIGQUIT, 0, __sig_core},
+	{SIGILL, 0, __sig_core},
+	{SIGTRAP, 0, __sig_core},
+	{SIGABRT, 0, __sig_core},
+	{SIGBUS, 0, __sig_core},
+	{SIGFPE, 0, __sig_core},
+	{SIGKILL, SIG_FLAG_NOIGNORE, __sig_kill},
+	{SIGUSR1, 0, __sig_kill},
+	{SIGSEGV, 0, __sig_core},
+	{SIGUSR2, 0, __sig_kill},
+	{SIGPIPE, 0, __sig_kill},
+	{SIGALRM, 0, __sig_kill},
+	{SIGTERM, 0, __sig_kill},
+	{SIGSTKFLT, 0, __sig_kill},
+	{SIGCHLD, 0, __sig_ignore},
+	{SIGCONT, SIG_FLAG_NOIGNORE, __sig_cont},
+	{SIGSTOP, SIG_FLAG_NOIGNORE, __sig_stop},
+	{SIGTSTP, 0, __sig_stop},
+	{SIGTTIN, 0, __sig_stop},
+	{SIGTTOU, 0, __sig_stop},
+	{SIGURG, 0, __sig_ignore},
+	{SIGXCPU, 0, __sig_core},
+	{SIGXFSZ, 0, __sig_core},
+	{SIGVTALRM, 0, __sig_kill},
+	{SIGPROF, 0, __sig_kill},
+	{SIGWINCH, 0, __sig_ignore},
+	{SIGIO, 0, __sig_kill},
+	{SIGPWR, 0, __sig_kill},
+	{SIGSYS, 0, __sig_ignore},
+	{32, 0, __sig_ignore},
+	{33, 0, __sig_ignore},
+	{34, 0, __sig_ignore},
+	{35, 0, __sig_ignore},
+	{36, 0, __sig_ignore},
+	{37, 0, __sig_ignore},
+	{38, 0, __sig_ignore},
+	{39, 0, __sig_ignore},
+	{40, 0, __sig_ignore},
+	{41, 0, __sig_ignore},
+	{42, 0, __sig_ignore},
+	{43, 0, __sig_ignore},
+	{44, 0, __sig_ignore},
+	{45, 0, __sig_ignore},
+	{46, 0, __sig_ignore},
+	{47, 0, __sig_ignore},
+	{48, 0, __sig_ignore},
+	{49, 0, __sig_ignore},
+	{50, 0, __sig_ignore},
+	{51, 0, __sig_ignore},
+	{52, 0, __sig_ignore},
+	{53, 0, __sig_ignore},
+	{54, 0, __sig_ignore},
+	{55, 0, __sig_ignore},
+	{56, 0, __sig_ignore},
+	{57, 0, __sig_ignore},
+	{58, 0, __sig_ignore},
+	{59, 0, __sig_ignore},
+	{60, 0, __sig_ignore},
+	{61, 0, __sig_ignore},
+	{62, 0, __sig_ignore},
+	{63, 0, __sig_ignore},
+	{64, 0, __sig_ignore},
+};
+
+static void __sig_core(int signo)
+{
+	exit(-1);
+}
+
+static void __sig_kill(int signo)
+{
+	exit(-1);
+}
+
+static void __sig_cont(int signo)
+{
+	return;
+}
+
+static void __sig_stop(int signo)
+{
+    return;
+}
+
+static void __sig_ignore(int signo)
+{
+    return;
+}
+
+static sigactq_t *__sig_find_action(int sig)
+{
+	int i;
+
+	for (i = 0; i < sizeof(sig_default_action) / sizeof(struct sig_default_act); i++) {
+		if (g_sig_arr[i].signo == sig) {
+			return (g_sig_arr + i);
+		}
+	}
+}
+
+static void __sig_copy_sigaction(sigaction_t *src, sigaction_t *dst)
+{
+	dst->sa_handler = src->sa_handler;
+	dst->sa_mask = src->sa_mask;
+	dst->sa_flags = src->sa_flags;
+}
+
+static int __sig_cannot_catche(int sig, sa_sighandler_t handler)
+{
+	int i;
+
+	for (i = 0; i < sizeof(sig_default_action) / sizeof(struct sig_default_act); i++) {
+		if (sig == sig_default_action[i].singNo) {
+			return (sig_default_action[i].flag == SIG_FLAG_NOIGNORE) && (handler != SIG_DFL);
+		}
+	}
+	/* This sig can be catch and ignore return false */
+	return 0;
+}
+
+static void __sig_operation(unsigned int receivedSigno)
+{
+	int i;
+	sigset_t mask, oldmask;
+
+	sigemptyset(&mask);
+	sigemptyset(&oldmask);
+
+	for (i = 0; i < sizeof(sig_default_action) / sizeof(struct sig_default_act); i++) {
+		if (!g_sig_arr[i].ign_flag && g_sig_arr[i].signo == receivedSigno && g_sig_arr[i].act.sa_handler) {
+			sigaddset(&mask, receivedSigno);
+			sigprocmask(SIG_BLOCK, &mask, &oldmask);
+			sigprocmask(SIG_BLOCK, &g_sig_arr[i].act.sa_mask, NULL);
+			(*g_sig_arr[i].act.sa_handler)(g_sig_arr[i].signo);
+			sigprocmask(SIG_SETMASK, &oldmask, NULL);
+			return;
+		}
+	}
+}
+
+void arm_signal_process(unsigned int receivedSig)
+{
+	__sig_operation(receivedSig);
+}
+
+static void __sig_add_def_action()
+{
+	int i;
+
+	for (i = 0; i < sizeof(sig_default_action) / sizeof(struct sig_default_act); i++) {
+		g_sig_arr[i].signo = (unsigned char)sig_default_action[i].singNo;
+		g_sig_arr[i].act.sa_handler = sig_default_action[i].action;
+		sigemptyset(&g_sig_arr[i].act.sa_mask);
+		g_sig_arr[i].act.sa_flags = sig_default_action[i].flag;
+		g_sig_arr[i].ign_flag = false;
+	}
+}
+
+static sa_sighandler_t __sig_find_def_action(unsigned char signo)
+{
+	int i;
+
+	for (i = 0; i < sizeof(sig_default_action) / sizeof(struct sig_default_act); i++) {
+		if (signo == sig_default_action[i].singNo) {
+			return sig_default_action[i].action;
+		}
+	}
+	return NULL;
+}
+
+static int __sig_dfl_opr(int sig, sigactq_t *sigact, const sigaction_t *act)
+{
+	sa_sighandler_t def_handler = NULL;
+
+	def_handler = __sig_find_def_action(sig);
+
+	if (def_handler != NULL) {
+		/* Replace it from signal action queue */
+		sigact->act.sa_handler = def_handler;
+		sigact->act.sa_mask = act->sa_mask;
+		sigact->act.sa_flags = act->sa_flags;
+	}
+	return 0;
+}
+
+static int __sig_action_opr(int sig, const sigaction_t *act, sigaction_t *oact)
+{
+	int ret = 0;
+	sa_sighandler_t handler = NULL;
+	sigactq_t *sigact = NULL;
+
+	if (act == NULL) return -EINVAL;
+
+	if (sig < SIGHUP || sig > (_NSIG - 1)) return -EINVAL;
+
+	handler = act->sa_handler;
+	/* Skip sig that can not be catched */
+	if (__sig_cannot_catche(sig, handler)) return -EINVAL;
+
+	pthread_spin_lock(&sig_lite_lock);
+	sigact = __sig_find_action(sig);
+	if (sigact && oact) __sig_copy_sigaction(&sigact->act, oact);
+
+	sigact->ign_flag = false;
+
+	if (handler == SIG_IGN && sigact) {
+		sigact->ign_flag = true;
+	} else if (handler == SIG_DFL) {
+		ret = __sig_dfl_opr(sig, sigact, act);
+	} else {
+		sigact->act.sa_handler = handler;
+		sigact->act.sa_mask = act->sa_mask;
+		sigact->act.sa_flags = act->sa_flags;
+	}
+
+	pthread_spin_unlock(&sig_lite_lock);
+	return ret;
+}
+
+void __sig_init(void)
+{
+	signal(SIGSYS, arm_do_signal);
+	pthread_spin_init(&sig_lite_lock, 0);
+	__sig_add_def_action();
+}
+
+static volatile int dummy_lock[1] = { 0 };
+
+extern hidden volatile int __abort_lock[1];
+
+weak_alias(dummy_lock, __abort_lock);
+
+static int unmask_done;
+static unsigned long handler_set[_NSIG/(8*sizeof(long))];
+
+void __get_handler_set(sigset_t *set)
+{
+	memcpy(set, handler_set, sizeof handler_set);
+}
+
+volatile int __eintr_valid_flag;
+
+int __libc_sigaction(int sig, const struct sigaction *restrict sa, struct sigaction *restrict old)
+{
+	sigaction_t ksa, ksa_old;
+	unsigned long set[_NSIG/(8*sizeof(long))];
+	int r = 0;
+
+	if (sa) {
+		if ((uintptr_t)sa->sa_handler > 1UL) {
+			a_or_l(handler_set+(sig-1)/(8*sizeof(long)),
+				1UL<<(sig-1)%(8*sizeof(long)));
+
+			/* If pthread_create has not yet been called,
+			 * implementation-internal signals might not
+			 * yet have been unblocked. They must be
+			 * unblocked before any signal handler is
+			 * installed, so that an application cannot
+			 * receive an illegal sigset_t (with them
+			 * blocked) as part of the ucontext_t passed
+			 * to the signal handler. */
+			if (!libc.threaded && !unmask_done) {
+				__syscall(SYS_rt_sigprocmask, SIG_UNBLOCK,
+					SIGPT_SET, 0, _NSIG/8);
+				unmask_done = 1;
+			}
+
+			if (!(sa->sa_flags & SA_RESTART)) {
+				a_store(&__eintr_valid_flag, 1);
+			}
+		}
+		/* Changing the disposition of SIGABRT to anything but
+		 * SIG_DFL requires a lock, so that it cannot be changed
+		 * while abort is terminating the process after simply
+		 * calling raise(SIGABRT) failed to do so. */
+		if (sa->sa_handler != SIG_DFL && sig == SIGABRT) {
+			__block_all_sigs(&set);
+			LOCK(__abort_lock);
+		}
+		ksa.sa_handler = sa->sa_handler;
+		ksa.sa_flags = sa->sa_flags | SA_RESTORER;
+		ksa.sa_restorer = (sa->sa_flags & SA_SIGINFO) ? __restore_rt : __restore;
+		memcpy(&ksa.sa_mask, &sa->sa_mask, _NSIG/8);
+	}
+
+	if (sig == SIGSYS) {
+		return syscall(SYS_rt_sigaction, sig, sa?&ksa:0, old?&ksa_old:0, _NSIG/8);
+	} else {
+		r = __sig_action_opr(sig, (const sigaction_t*)sa?&ksa:0, (sigaction_t*)old?&ksa_old:0);
+	}
+	if (sig == SIGABRT && sa && sa->sa_handler != SIG_DFL) {
+		UNLOCK(__abort_lock);
+		__restore_sigs(&set);
+	}
+	if (old && !r) {
+		old->sa_handler = ksa_old.sa_handler;
+		old->sa_flags = ksa_old.sa_flags;
+		memcpy(&old->sa_mask, &ksa_old.sa_mask, _NSIG/8);
+	}
+	return __syscall_ret(r);
+}
+
+int __sigaction(int sig, const struct sigaction *restrict sa, struct sigaction *restrict old)
+{
+	if (sig-32U < 3 || sig-1U >= _NSIG-1) {
+		errno = EINVAL;
+		return -1;
+	}
+	return __libc_sigaction(sig, sa, old);
+}
+
+weak_alias(__sigaction, sigaction);
diff --git a/third_party/musl/porting/liteos_a/user/src/signal/sigaltstack.c b/third_party/musl/porting/liteos_a/user/src/signal/sigaltstack.c
new file mode 100755
index 000000000..619e38750
--- /dev/null
+++ b/third_party/musl/porting/liteos_a/user/src/signal/sigaltstack.c
@@ -0,0 +1,21 @@
+#include <signal.h>
+#include <errno.h>
+#include <unsupported_api.h>
+
+#include "syscall.h"
+
+int sigaltstack(const stack_t *restrict ss, stack_t *restrict old)
+{
+	unsupported_api(__FUNCTION__);
+	if (ss) {
+		if (!(ss->ss_flags & SS_DISABLE) && ss->ss_size < MINSIGSTKSZ) {
+			errno = ENOMEM;
+			return -1;
+		}
+		if (ss->ss_flags & SS_ONSTACK) {
+			errno = EINVAL;
+			return -1;
+		}
+	}
+	return syscall(SYS_sigaltstack, ss, old);
+}
diff --git a/third_party/musl/porting/liteos_a/user/src/signal/siginterrupt.c b/third_party/musl/porting/liteos_a/user/src/signal/siginterrupt.c
new file mode 100755
index 000000000..487318b4a
--- /dev/null
+++ b/third_party/musl/porting/liteos_a/user/src/signal/siginterrupt.c
@@ -0,0 +1,13 @@
+#include <signal.h>
+#include <unsupported_api.h>
+
+int siginterrupt(int sig, int flag)
+{
+	struct sigaction sa;
+	unsupported_api(__FUNCTION__);
+	sigaction(sig, 0, &sa);
+	if (flag) sa.sa_flags &= ~SA_RESTART;
+	else sa.sa_flags |= SA_RESTART;
+
+	return sigaction(sig, &sa, 0);
+}
diff --git a/third_party/musl/porting/liteos_a/user/src/signal/siglongjmp.c b/third_party/musl/porting/liteos_a/user/src/signal/siglongjmp.c
new file mode 100755
index 000000000..803f2dd86
--- /dev/null
+++ b/third_party/musl/porting/liteos_a/user/src/signal/siglongjmp.c
@@ -0,0 +1,12 @@
+#include <setjmp.h>
+#include <signal.h>
+#include <unsupported_api.h>
+
+#include "syscall.h"
+#include "pthread_impl.h"
+
+_Noreturn void siglongjmp(sigjmp_buf buf, int ret)
+{
+	unsupported_api(__FUNCTION__);
+	longjmp(buf, ret);
+}
diff --git a/third_party/musl/porting/liteos_a/user/src/signal/sigqueue.c b/third_party/musl/porting/liteos_a/user/src/signal/sigqueue.c
new file mode 100755
index 000000000..e169defa0
--- /dev/null
+++ b/third_party/musl/porting/liteos_a/user/src/signal/sigqueue.c
@@ -0,0 +1,25 @@
+#include <signal.h>
+#include <string.h>
+#include <unistd.h>
+#include <unsupported_api.h>
+
+#include "syscall.h"
+#include "pthread_impl.h"
+
+int sigqueue(pid_t pid, int sig, const union sigval value)
+{
+	siginfo_t si;
+	sigset_t set;
+	int r;
+	unsupported_api(__FUNCTION__);
+	memset(&si, 0, sizeof si);
+	si.si_signo = sig;
+	si.si_code = SI_QUEUE;
+	si.si_value = value;
+	si.si_uid = getuid();
+	__block_app_sigs(&set);
+	si.si_pid = getpid();
+	r = syscall(SYS_rt_sigqueueinfo, pid, sig, &si);
+	__restore_sigs(&set);
+	return r;
+}
diff --git a/third_party/musl/porting/liteos_a/user/src/signal/sigsuspend.c b/third_party/musl/porting/liteos_a/user/src/signal/sigsuspend.c
new file mode 100755
index 000000000..ab1f0bda4
--- /dev/null
+++ b/third_party/musl/porting/liteos_a/user/src/signal/sigsuspend.c
@@ -0,0 +1,24 @@
+#include <signal.h>
+#include "syscall.h"
+
+int sigsuspend(const sigset_t *mask)
+{
+	int ret,retval;
+	sigset_t oldset;
+
+	retval = sigprocmask(SIG_BLOCK, 0, &oldset);
+	if (retval != 0){
+		return retval;
+	}
+
+	ret = syscall_cp(SYS_rt_sigsuspend, mask, _NSIG/8);
+
+	if (ret == -1){
+		retval = sigprocmask(SIG_SETMASK, &oldset, 0);
+		if (retval != 0){
+			return retval;
+		}
+	}
+
+	return ret;
+}
\ No newline at end of file
diff --git a/third_party/musl/porting/liteos_a/user/src/stat/fchmod.c b/third_party/musl/porting/liteos_a/user/src/stat/fchmod.c
new file mode 100755
index 000000000..7e469a931
--- /dev/null
+++ b/third_party/musl/porting/liteos_a/user/src/stat/fchmod.c
@@ -0,0 +1,22 @@
+#include <sys/stat.h>
+#include <errno.h>
+#include <fcntl.h>
+#include <unsupported_api.h>
+
+#include "syscall.h"
+
+int fchmod(int fd, mode_t mode)
+{
+	unsupported_api(__FUNCTION__);
+	int ret = __syscall(SYS_fchmod, fd, mode);
+	if (ret != -EBADF || __syscall(SYS_fcntl, fd, F_GETFD) < 0)
+		return __syscall_ret(ret);
+
+	char buf[15+3*sizeof(int)];
+	__procfdname(buf, fd);
+#ifdef SYS_chmod
+	return syscall(SYS_chmod, buf, mode);
+#else
+	return syscall(SYS_fchmodat, AT_FDCWD, buf, mode);
+#endif
+}
diff --git a/third_party/musl/porting/liteos_a/user/src/stat/fchmodat.c b/third_party/musl/porting/liteos_a/user/src/stat/fchmodat.c
new file mode 100755
index 000000000..2c777e1b7
--- /dev/null
+++ b/third_party/musl/porting/liteos_a/user/src/stat/fchmodat.c
@@ -0,0 +1,41 @@
+#include <sys/stat.h>
+#include <fcntl.h>
+#include <errno.h>
+#include <unsupported_api.h>
+
+#include "syscall.h"
+#include "kstat.h"
+
+int fchmodat(int fd, const char *path, mode_t mode, int flag)
+{
+	unsupported_api(__FUNCTION__);
+	if (!flag) return syscall(SYS_fchmodat, fd, path, mode, flag);
+
+	if (flag != AT_SYMLINK_NOFOLLOW)
+		return __syscall_ret(-EINVAL);
+
+	struct kstat st;
+	int ret, fd2;
+	char proc[15+3*sizeof(int)];
+
+	if ((ret = __syscall(SYS_fstatat, fd, path, &st, flag)))
+		return __syscall_ret(ret);
+	if (S_ISLNK(st.st_mode))
+		return __syscall_ret(-EOPNOTSUPP);
+
+	if ((fd2 = __syscall(SYS_openat, fd, path, O_RDONLY|O_PATH|O_NOFOLLOW|O_NOCTTY|O_CLOEXEC)) < 0) {
+		if (fd2 == -ELOOP)
+			return __syscall_ret(-EOPNOTSUPP);
+		return __syscall_ret(fd2);
+	}
+
+	__procfdname(proc, fd2);
+	ret = __syscall(SYS_fstatat, AT_FDCWD, proc, &st, 0);
+	if (!ret) {
+		if (S_ISLNK(st.st_mode)) ret = -EOPNOTSUPP;
+		else ret = __syscall(SYS_fchmodat, AT_FDCWD, proc, mode);
+	}
+
+	__syscall(SYS_close, fd2);
+	return __syscall_ret(ret);
+}
diff --git a/third_party/musl/porting/liteos_a/user/src/stat/futimens.c b/third_party/musl/porting/liteos_a/user/src/stat/futimens.c
new file mode 100755
index 000000000..2ab329a08
--- /dev/null
+++ b/third_party/musl/porting/liteos_a/user/src/stat/futimens.c
@@ -0,0 +1,8 @@
+#include <sys/stat.h>
+#include <unsupported_api.h>
+
+int futimens(int fd, const struct timespec times[2])
+{
+	unsupported_api(__FUNCTION__);
+	return utimensat(fd, 0, times, 0);
+}
diff --git a/third_party/musl/porting/liteos_a/user/src/stat/mkfifo.c b/third_party/musl/porting/liteos_a/user/src/stat/mkfifo.c
new file mode 100755
index 000000000..9081d7ef4
--- /dev/null
+++ b/third_party/musl/porting/liteos_a/user/src/stat/mkfifo.c
@@ -0,0 +1,7 @@
+#include <sys/stat.h>
+#include "syscall.h"
+
+int mkfifo(const char *path, mode_t mode)
+{
+	return syscall(SYS_mkfifo, path, mode);
+}
diff --git a/third_party/musl/porting/liteos_a/user/src/stat/mkfifoat.c b/third_party/musl/porting/liteos_a/user/src/stat/mkfifoat.c
new file mode 100755
index 000000000..768a31786
--- /dev/null
+++ b/third_party/musl/porting/liteos_a/user/src/stat/mkfifoat.c
@@ -0,0 +1,8 @@
+#include <sys/stat.h>
+#include <unsupported_api.h>
+
+int mkfifoat(int fd, const char *path, mode_t mode)
+{
+	unsupported_api(__FUNCTION__);
+	return mknodat(fd, path, mode | S_IFIFO, 0);
+}
diff --git a/third_party/musl/porting/liteos_a/user/src/stat/mknod.c b/third_party/musl/porting/liteos_a/user/src/stat/mknod.c
new file mode 100755
index 000000000..5c40a9ee9
--- /dev/null
+++ b/third_party/musl/porting/liteos_a/user/src/stat/mknod.c
@@ -0,0 +1,14 @@
+#include <sys/stat.h>
+#include <fcntl.h>
+#include "syscall.h"
+#include <unsupported_api.h>
+
+int mknod(const char *path, mode_t mode, dev_t dev)
+{
+	unsupported_api(__FUNCTION__);
+#ifdef SYS_mknod
+	return syscall(SYS_mknod, path, mode, dev);
+#else
+	return syscall(SYS_mknodat, AT_FDCWD, path, mode, dev);
+#endif
+}
diff --git a/third_party/musl/porting/liteos_a/user/src/stat/mknodat.c b/third_party/musl/porting/liteos_a/user/src/stat/mknodat.c
new file mode 100755
index 000000000..15510c456
--- /dev/null
+++ b/third_party/musl/porting/liteos_a/user/src/stat/mknodat.c
@@ -0,0 +1,9 @@
+#include <sys/stat.h>
+#include "syscall.h"
+#include <unsupported_api.h>
+
+int mknodat(int fd, const char *path, mode_t mode, dev_t dev)
+{
+	unsupported_api(__FUNCTION__);
+	return syscall(SYS_mknodat, fd, path, mode, dev);
+}
diff --git a/third_party/musl/porting/liteos_a/user/src/stat/statvfs.c b/third_party/musl/porting/liteos_a/user/src/stat/statvfs.c
new file mode 100755
index 000000000..c7f14a04b
--- /dev/null
+++ b/third_party/musl/porting/liteos_a/user/src/stat/statvfs.c
@@ -0,0 +1,68 @@
+#include <sys/statvfs.h>
+#include <sys/statfs.h>
+#include <unsupported_api.h>
+
+#include "syscall.h"
+
+static int __statfs(const char *path, struct statfs *buf)
+{
+	*buf = (struct statfs){0};
+#ifdef SYS_statfs64
+	return syscall(SYS_statfs64, path, sizeof *buf, buf);
+#else
+	return syscall(SYS_statfs, path, buf);
+#endif
+}
+
+static int __fstatfs(int fd, struct statfs *buf)
+{
+	unsupported_api(__FUNCTION__);
+	*buf = (struct statfs){0};
+#ifdef SYS_fstatfs64
+	return syscall(SYS_fstatfs64, fd, sizeof *buf, buf);
+#else
+	return syscall(SYS_fstatfs, fd, buf);
+#endif
+}
+
+weak_alias(__statfs, statfs);
+weak_alias(__fstatfs, fstatfs);
+
+static void fixup(struct statvfs *out, const struct statfs *in)
+{
+	*out = (struct statvfs){0};
+	out->f_bsize = in->f_bsize;
+	out->f_frsize = in->f_frsize ? in->f_frsize : in->f_bsize;
+	out->f_blocks = in->f_blocks;
+	out->f_bfree = in->f_bfree;
+	out->f_bavail = in->f_bavail;
+	out->f_files = in->f_files;
+	out->f_ffree = in->f_ffree;
+	out->f_favail = in->f_ffree;
+	out->f_fsid = in->f_fsid.__val[0];
+	out->f_flag = in->f_flags;
+	out->f_namemax = in->f_namelen;
+}
+
+int statvfs(const char *restrict path, struct statvfs *restrict buf)
+{
+	struct statfs kbuf;
+	if (__statfs(path, &kbuf)<0) return -1;
+	fixup(buf, &kbuf);
+	return 0;
+}
+
+int fstatvfs(int fd, struct statvfs *buf)
+{
+	struct statfs kbuf;
+
+	unsupported_api(__FUNCTION__);
+	if (__fstatfs(fd, &kbuf)<0) return -1;
+	fixup(buf, &kbuf);
+	return 0;
+}
+
+weak_alias(statvfs, statvfs64);
+weak_alias(statfs, statfs64);
+weak_alias(fstatvfs, fstatvfs64);
+weak_alias(fstatfs, fstatfs64);
diff --git a/third_party/musl/porting/liteos_a/user/src/stat/utimensat.c b/third_party/musl/porting/liteos_a/user/src/stat/utimensat.c
new file mode 100755
index 000000000..ed3283eb8
--- /dev/null
+++ b/third_party/musl/porting/liteos_a/user/src/stat/utimensat.c
@@ -0,0 +1,63 @@
+#include <sys/stat.h>
+#include <sys/time.h>
+#include <fcntl.h>
+#include <errno.h>
+#include <unsupported_api.h>
+
+#include "syscall.h"
+
+#define IS32BIT(x) !((x)+0x80000000ULL>>32)
+#define NS_SPECIAL(ns) ((ns)==UTIME_NOW || (ns)==UTIME_OMIT)
+
+int utimensat(int fd, const char *path, const struct timespec times[2], int flags)
+{
+	int r;
+	unsupported_api(__FUNCTION__);
+	if (times && times[0].tv_nsec==UTIME_NOW && times[1].tv_nsec==UTIME_NOW)
+		times = 0;
+#ifdef SYS_utimensat_time64
+	r = -ENOSYS;
+	time_t s0=0, s1=0;
+	long ns0=0, ns1=0;
+	if (times) {
+		ns0 = times[0].tv_nsec;
+		ns1 = times[1].tv_nsec;
+		if (!NS_SPECIAL(ns0)) s0 = times[0].tv_sec;
+		if (!NS_SPECIAL(ns1)) s1 = times[1].tv_sec;
+	}
+	if (SYS_utimensat == SYS_utimensat_time64 || !IS32BIT(s0) || !IS32BIT(s1))
+		r = __syscall(SYS_utimensat_time64, fd, path, times ?
+			((long long[]){s0, ns0, s1, ns1}) : 0, flags);
+	if (SYS_utimensat == SYS_utimensat_time64 || r!=-ENOSYS)
+		return __syscall_ret(r);
+	if (!IS32BIT(s0) || !IS32BIT(s1))
+		return __syscall_ret(-ENOTSUP);
+	r = __syscall(SYS_utimensat, fd, path,
+		times ? ((long[]){s0, ns0, s1, ns1}) : 0, flags);
+#else
+	r = __syscall(SYS_utimensat, fd, path, times, flags);
+#endif
+
+#ifdef SYS_futimesat
+	if (r != -ENOSYS || flags) return __syscall_ret(r);
+	long *tv=0, tmp[4];
+	if (times) {
+		int i;
+		tv = tmp;
+		for (i=0; i<2; i++) {
+			if (times[i].tv_nsec >= 1000000000ULL) {
+				if (NS_SPECIAL(times[i].tv_nsec))
+					return __syscall_ret(-ENOSYS);
+				return __syscall_ret(-EINVAL);
+			}
+			tmp[2*i+0] = times[i].tv_sec;
+			tmp[2*i+1] = times[i].tv_nsec / 1000;
+		}
+	}
+
+	r = __syscall(SYS_futimesat, fd, path, tv);
+	if (r != -ENOSYS || fd != AT_FDCWD) return __syscall_ret(r);
+	r = __syscall(SYS_utimes, path, tv);
+#endif
+	return __syscall_ret(r);
+}
diff --git a/third_party/musl/porting/liteos_a/user/src/stdio/flockfile.c b/third_party/musl/porting/liteos_a/user/src/stdio/flockfile.c
new file mode 100755
index 000000000..eb1771bcd
--- /dev/null
+++ b/third_party/musl/porting/liteos_a/user/src/stdio/flockfile.c
@@ -0,0 +1,12 @@
+#include <unsupported_api.h>
+
+#include "stdio_impl.h"
+#include "pthread_impl.h"
+
+void flockfile(FILE *f)
+{
+	unsupported_api(__FUNCTION__);
+	if (!ftrylockfile(f)) return;
+	__lockfile(f);
+	__register_locked_file(f, __pthread_self());
+}
diff --git a/third_party/musl/porting/liteos_a/user/src/stdio/open_wmemstream.c b/third_party/musl/porting/liteos_a/user/src/stdio/open_wmemstream.c
new file mode 100755
index 000000000..760da562b
--- /dev/null
+++ b/third_party/musl/porting/liteos_a/user/src/stdio/open_wmemstream.c
@@ -0,0 +1,104 @@
+#include "stdio_impl.h"
+#include <wchar.h>
+#include <errno.h>
+#include <limits.h>
+#include <string.h>
+#include <stdlib.h>
+#include <unsupported_api.h>
+#include "libc.h"
+
+struct cookie {
+	wchar_t **bufp;
+	size_t *sizep;
+	size_t pos;
+	wchar_t *buf;
+	size_t len;
+	size_t space;
+	mbstate_t mbs;
+};
+
+struct wms_FILE {
+	FILE f;
+	struct cookie c;
+	unsigned char buf[1];
+};
+
+static off_t wms_seek(FILE *f, off_t off, int whence)
+{
+	ssize_t base;
+	struct cookie *c = f->cookie;
+	if (whence>2U) {
+fail:
+		errno = EINVAL;
+		return -1;
+	}
+	base = (size_t [3]){0, c->pos, c->len}[whence];
+	if (off < -base || off > SSIZE_MAX/4-base) goto fail;
+	memset(&c->mbs, 0, sizeof c->mbs);
+	return c->pos = base+off;
+}
+
+static size_t wms_write(FILE *f, const unsigned char *buf, size_t len)
+{
+	struct cookie *c = f->cookie;
+	size_t len2;
+	wchar_t *newbuf;
+	if (len + c->pos >= c->space) {
+		len2 = 2*c->space+1 | c->pos+len+1;
+		if (len2 > SSIZE_MAX/4) return 0;
+		newbuf = realloc(c->buf, len2*4);
+		if (!newbuf) return 0;
+		*c->bufp = c->buf = newbuf;
+		memset(c->buf + c->space, 0, 4*(len2 - c->space));
+		c->space = len2;
+	}
+	
+	len2 = mbsnrtowcs(c->buf+c->pos, (void *)&buf, len, c->space-c->pos, &c->mbs);
+	if (len2 == -1) return 0;
+	c->pos += len2;
+	if (c->pos >= c->len) c->len = c->pos;
+	*c->sizep = c->pos;
+	return len;
+}
+
+static int wms_close(FILE *f)
+{
+	return 0;
+}
+
+FILE *open_wmemstream(wchar_t **bufp, size_t *sizep)
+{
+	struct wms_FILE *f;
+	wchar_t *buf;
+
+	unsupported_api(__FUNCTION__);
+	if (!(f=malloc(sizeof *f))) return 0;
+	if (!(buf=malloc(sizeof *buf))) {
+		free(f);
+		return 0;
+	}
+	memset(&f->f, 0, sizeof f->f);
+	memset(&f->c, 0, sizeof f->c);
+	f->f.cookie = &f->c;
+
+	f->c.bufp = bufp;
+	f->c.sizep = sizep;
+	f->c.pos = f->c.len = f->c.space = *sizep = 0;
+	f->c.buf = *bufp = buf;
+	*buf = 0;
+
+	f->f.flags = F_NORD;
+	f->f.fd = -1;
+	f->f.buf = f->buf;
+	f->f.buf_size = 0;
+	f->f.lbf = EOF;
+	f->f.write = wms_write;
+	f->f.seek = wms_seek;
+	f->f.close = wms_close;
+
+	if (!libc.threaded) f->f.lock = -1;
+
+	fwide(&f->f, 1);
+
+	return __ofl_add(&f->f);
+}
diff --git a/third_party/musl/porting/liteos_a/user/src/stdio/popen.c b/third_party/musl/porting/liteos_a/user/src/stdio/popen.c
new file mode 100755
index 000000000..c75e27f68
--- /dev/null
+++ b/third_party/musl/porting/liteos_a/user/src/stdio/popen.c
@@ -0,0 +1,75 @@
+#include <fcntl.h>
+#include <unistd.h>
+#include <errno.h>
+#include <string.h>
+#include <spawn.h>
+#include <unsupported_api.h>
+#include "stdio_impl.h"
+#include "syscall.h"
+
+extern char **__environ;
+
+FILE *popen(const char *cmd, const char *mode)
+{
+	int p[2], op, e;
+	pid_t pid;
+	FILE *f;
+	posix_spawn_file_actions_t fa;
+
+	unsupported_api(__FUNCTION__);
+	if (*mode == 'r') {
+		op = 0;
+	} else if (*mode == 'w') {
+		op = 1;
+	} else {
+		errno = EINVAL;
+		return 0;
+	}
+
+	if (pipe2(p, O_CLOEXEC)) return NULL;
+	f = fdopen(p[op], mode);
+	if (!f) {
+		__syscall(SYS_close, p[0]);
+		__syscall(SYS_close, p[1]);
+		return NULL;
+	}
+	FLOCK(f);
+
+	/* If the child's end of the pipe happens to already be on the final
+	 * fd number to which it will be assigned (either 0 or 1), it must
+	 * be moved to a different fd. Otherwise, there is no safe way to
+	 * remove the close-on-exec flag in the child without also creating
+	 * a file descriptor leak race condition in the parent. */
+	if (p[1-op] == 1-op) {
+		int tmp = fcntl(1-op, F_DUPFD_CLOEXEC, 0);
+		if (tmp < 0) {
+			e = errno;
+			goto fail;
+		}
+		__syscall(SYS_close, p[1-op]);
+		p[1-op] = tmp;
+	}
+
+	e = ENOMEM;
+	if (!posix_spawn_file_actions_init(&fa)) {
+		if (!posix_spawn_file_actions_adddup2(&fa, p[1-op], 1-op)) {
+			if (!(e = posix_spawn(&pid, "/bin/sh", &fa, 0,
+			    (char *[]){ "sh", "-c", (char *)cmd, 0 }, __environ))) {
+				posix_spawn_file_actions_destroy(&fa);
+				f->pipe_pid = pid;
+				if (!strchr(mode, 'e'))
+					fcntl(p[op], F_SETFD, 0);
+				__syscall(SYS_close, p[1-op]);
+				FUNLOCK(f);
+				return f;
+			}
+		}
+		posix_spawn_file_actions_destroy(&fa);
+	}
+fail:
+	fclose(f);
+	__syscall(SYS_close, p[1-op]);
+
+	errno = e;
+	return 0;
+}
diff --git a/third_party/musl/porting/liteos_a/user/src/stdio/tmpfile.c b/third_party/musl/porting/liteos_a/user/src/stdio/tmpfile.c
new file mode 100755
index 000000000..ad02d4bed
--- /dev/null
+++ b/third_party/musl/porting/liteos_a/user/src/stdio/tmpfile.c
@@ -0,0 +1,34 @@
+#include <stdio.h>
+#include <fcntl.h>
+#include <stdlib.h>
+#include <unsupported_api.h>
+
+#include "stdio_impl.h"
+
+#define MAXTRIES 100
+
+FILE *tmpfile(void)
+{
+	char s[] = "/tmp/tmpfile_XXXXXX";
+	int fd;
+	FILE *f;
+	int try;
+	unsupported_api(__FUNCTION__);
+	for (try=0; try<MAXTRIES; try++) {
+		__randname(s+13);
+		fd = sys_open(s, O_RDWR|O_CREAT|O_EXCL, 0600);
+		if (fd >= 0) {
+#ifdef SYS_unlink
+			__syscall(SYS_unlink, s);
+#else
+			__syscall(SYS_unlinkat, AT_FDCWD, s, 0);
+#endif
+			f = __fdopen(fd, "w+");
+			if (!f) __syscall(SYS_close, fd);
+			return f;
+		}
+	}
+	return 0;
+}
+
+weak_alias(tmpfile, tmpfile64);
diff --git a/third_party/musl/porting/liteos_a/user/src/stdio/tmpnam.c b/third_party/musl/porting/liteos_a/user/src/stdio/tmpnam.c
new file mode 100755
index 000000000..c3d536487
--- /dev/null
+++ b/third_party/musl/porting/liteos_a/user/src/stdio/tmpnam.c
@@ -0,0 +1,32 @@
+#include <stdio.h>
+#include <fcntl.h>
+#include <errno.h>
+#include <sys/stat.h>
+#include <string.h>
+#include <stdlib.h>
+#include <unsupported_api.h>
+
+#include "syscall.h"
+#include "kstat.h"
+
+#define MAXTRIES 100
+
+char *tmpnam(char *buf)
+{
+	static char internal[L_tmpnam];
+	char s[] = "/tmp/tmpnam_XXXXXX";
+	int try;
+	int r;
+	unsupported_api(__FUNCTION__);
+	for (try=0; try<MAXTRIES; try++) {
+		__randname(s+12);
+#ifdef SYS_lstat
+		r = __syscall(SYS_lstat, s, &(struct kstat){0});
+#else
+		r = __syscall(SYS_fstatat, AT_FDCWD, s,
+			&(struct kstat){0}, AT_SYMLINK_NOFOLLOW);
+#endif
+		if (r == -ENOENT) return strcpy(buf ? buf : internal, s);
+	}
+	return 0;
+}
diff --git a/third_party/musl/porting/liteos_a/user/src/stdlib/qsort.c b/third_party/musl/porting/liteos_a/user/src/stdlib/qsort.c
new file mode 100755
index 000000000..294b6afb1
--- /dev/null
+++ b/third_party/musl/porting/liteos_a/user/src/stdlib/qsort.c
@@ -0,0 +1,121 @@
+/* Copyright (C) 2011 by Valentin Ochs
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a copy
+ * of this software and associated documentation files (the "Software"), to
+ * deal in the Software without restriction, including without limitation the
+ * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
+ * sell copies of the Software, and to permit persons to whom the Software is
+ * furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
+ * IN THE SOFTWARE.
+ */
+
+#include <stdlib.h>
+#include <string.h>
+
+typedef int (*cmpfun)(const void *, const void *);
+
+#define MIDDLE_ONE(a, b, c)                                      \
+    (*cmp)(a, b) < 0 ?                                           \
+    ((*cmp)(b, c) < 0 ? (b) : ((*cmp)(a, c) < 0 ? (c) : (a))):   \
+    ((*cmp)(b, c) > 0 ? (b) : ((*cmp)(a, c) < 0 ? (a) : (c)))
+
+#define SWAPN(a, b, n)                                           \
+    do {                                                         \
+        register char *x = (char *)(a);                          \
+        register char *y = (char *)(b);                          \
+        register char tmp;                                       \
+        int i = (n) / sizeof(char);                              \
+        for (--i; i >= 0; i--) {                                 \
+            tmp = *x;                                            \
+            *x++ = *y;                                           \
+            *y++ = tmp;                                          \
+        }                                                        \
+    } while (0)
+
+void qsort(void *base, size_t nel, size_t width, cmpfun cmp)
+{
+    char *start, *end, *m, *l, *r;
+    int i, j, swapflag = 0;
+    char temp[width];
+
+    if (width == 0 || base == NULL || nel == 0) {
+        return;
+    }
+
+    start = (char *)base;
+    end = start + (nel - 1) * width;
+loop:
+    if (nel < 7) { // insertion sort
+insertqort:
+        for (l = start + width; l <= end; l += width) {
+            memcpy(temp, l, width);
+            for (m = l - width; m >= start; m -= width) {
+                if ((*cmp)(m, temp) > 0) {
+                    memcpy((m + width), m, width);
+                } else {
+                    break;
+                }
+            }
+            memcpy((m + width), temp, width);
+        }
+        return;
+    }
+
+    // quick sort
+    m = start + (nel >> 1) * width;
+    m = MIDDLE_ONE(start, m, end);
+    if (m != start) {
+        SWAPN(start, m, width);
+        m = start;
+    }
+    l = start + width;
+    r = end;
+
+    while (l <= r) {
+        while (l <= r && (*cmp)(l, m) < 0) {
+            l += width;
+        }
+        while (l <= r && (*cmp)(r, m) >= 0) {
+            r -= width;
+        }
+        if (l < r) {
+            SWAPN(l, r, width);
+            l += width;
+            r -= width;
+            swapflag = 1;
+        }
+    }
+    SWAPN(m, l - width, width);
+    m = l - width;
+    if (swapflag == 0) {
+        goto insertqort;
+    }
+
+    if (m - start > end - m) {
+        qsort(start, (m - start) / width, width, (*cmp));
+        if (m == end) {
+            return;
+        }
+        start = m + width;
+        nel = (end - start) / width + 1;
+        goto loop;
+    } else {
+        qsort(m + width, (end - m) / width, width, (*cmp));
+        if (m == start) {
+            return;
+        }
+        end = m - width;
+        nel = (end - start) / width + 1;
+        goto loop;
+    }
+}
diff --git a/third_party/musl/porting/liteos_a/user/src/string/strcasecmp.c b/third_party/musl/porting/liteos_a/user/src/string/strcasecmp.c
new file mode 100755
index 000000000..0c91b2541
--- /dev/null
+++ b/third_party/musl/porting/liteos_a/user/src/string/strcasecmp.c
@@ -0,0 +1,18 @@
+#include <strings.h>
+#include <ctype.h>
+#include <unsupported_api.h>
+
+int strcasecmp(const char *_l, const char *_r)
+{
+	const unsigned char *l=(void *)_l, *r=(void *)_r;
+	for (; *l && *r && (*l == *r || tolower(*l) == tolower(*r)); l++, r++);
+	return tolower(*l) - tolower(*r);
+}
+
+int __strcasecmp_l(const char *l, const char *r, locale_t loc)
+{
+	unsupported_api(__FUNCTION__);
+	return strcasecmp(l, r);
+}
+
+weak_alias(__strcasecmp_l, strcasecmp_l);
diff --git a/third_party/musl/porting/liteos_a/user/src/string/strncasecmp.c b/third_party/musl/porting/liteos_a/user/src/string/strncasecmp.c
new file mode 100755
index 000000000..2b8143a0c
--- /dev/null
+++ b/third_party/musl/porting/liteos_a/user/src/string/strncasecmp.c
@@ -0,0 +1,19 @@
+#include <strings.h>
+#include <ctype.h>
+#include <unsupported_api.h>
+
+int strncasecmp(const char *_l, const char *_r, size_t n)
+{
+	const unsigned char *l=(void *)_l, *r=(void *)_r;
+	if (!n--) return 0;
+	for (; *l && *r && n && (*l == *r || tolower(*l) == tolower(*r)); l++, r++, n--);
+	return tolower(*l) - tolower(*r);
+}
+
+int __strncasecmp_l(const char *l, const char *r, size_t n, locale_t loc)
+{
+	unsupported_api(__FUNCTION__);
+	return strncasecmp(l, r, n);
+}
+
+weak_alias(__strncasecmp_l, strncasecmp_l);
diff --git a/third_party/musl/porting/liteos_a/user/src/termios/cfsetospeed.c b/third_party/musl/porting/liteos_a/user/src/termios/cfsetospeed.c
new file mode 100755
index 000000000..5e4be9396
--- /dev/null
+++ b/third_party/musl/porting/liteos_a/user/src/termios/cfsetospeed.c
@@ -0,0 +1,25 @@
+#define _BSD_SOURCE
+#include <termios.h>
+#include <sys/ioctl.h>
+#include <errno.h>
+#include <unsupported_api.h>
+
+int cfsetospeed(struct termios *tio, speed_t speed)
+{
+	unsupported_api(__FUNCTION__);
+	if (speed & ~CBAUD) {
+		errno = EINVAL;
+		return -1;
+	}
+	tio->c_cflag &= ~CBAUD;
+	tio->c_cflag |= speed;
+	return 0;
+}
+
+int cfsetispeed(struct termios *tio, speed_t speed)
+{
+	unsupported_api(__FUNCTION__);
+	return speed ? cfsetospeed(tio, speed) : 0;
+}
+
+weak_alias(cfsetospeed, cfsetspeed);
diff --git a/third_party/musl/porting/liteos_a/user/src/thread/__timedwait.c b/third_party/musl/porting/liteos_a/user/src/thread/__timedwait.c
new file mode 100755
index 000000000..b4ca0fea1
--- /dev/null
+++ b/third_party/musl/porting/liteos_a/user/src/thread/__timedwait.c
@@ -0,0 +1,82 @@
+#include <pthread.h>
+#include <time.h>
+#include <errno.h>
+#include "futex.h"
+#include "syscall.h"
+#include "pthread_impl.h"
+
+#define IS32BIT(x) !((x)+0x80000000ULL>>32)
+#define CLAMP(x) (int)(IS32BIT(x) ? (x) : 0x7fffffffU+((0ULL+(x))>>63))
+
+static int __futex4_cp(volatile void *addr, int op, int val, const struct timespec *to)
+{
+	int r;
+	unsigned int useconds = 0xffffffffU;
+#if 0
+#ifdef SYS_futex_time64
+	time_t s = to ? to->tv_sec : 0;
+	long ns = to ? to->tv_nsec : 0;
+	r = -ENOSYS;
+	if (SYS_futex == SYS_futex_time64 || !IS32BIT(s))
+		r = __syscall_cp(SYS_futex_time64, addr, op, val,
+			to ? ((long long[]){s, ns}) : 0);
+	if (SYS_futex == SYS_futex_time64 || r!=-ENOSYS) return r;
+	to = to ? (void *)(long[]){CLAMP(s), ns} : 0;
+#endif
+#endif
+
+	if (to) {
+		useconds = (to->tv_sec * 1000000 + to->tv_nsec / 1000);
+		if ((useconds == 0) && (to->tv_nsec != 0)) {
+			useconds = 1;
+		}
+	}
+
+	r = __syscall_cp(SYS_futex, addr, op, val, useconds);
+	if (r != -ENOSYS) return r;
+	return __syscall_cp(SYS_futex, addr, op & ~FUTEX_PRIVATE, val, useconds);
+}
+
+static volatile int dummy = 0;
+weak_alias(dummy, __eintr_valid_flag);
+
+int __timedwait_cp(volatile int *addr, int val,
+	clockid_t clk, const struct timespec *at, int priv)
+{
+	int r;
+	struct timespec to, *top=0;
+
+	if (priv) priv = FUTEX_PRIVATE;
+
+	if (at) {
+		if (at->tv_nsec >= 1000000000UL) return EINVAL;
+		if (__clock_gettime(clk, &to)) return EINVAL;
+		to.tv_sec = at->tv_sec - to.tv_sec;
+		if ((to.tv_nsec = at->tv_nsec - to.tv_nsec) < 0) {
+			to.tv_sec--;
+			to.tv_nsec += 1000000000;
+		}
+		if (to.tv_sec < 0) return ETIMEDOUT;
+		top = &to;
+	}
+
+	r = -__futex4_cp(addr, FUTEX_WAIT|priv, val, top);
+	if (r != EINTR && r != ETIMEDOUT && r != ECANCELED) r = 0;
+	/* Mitigate bug in old kernels wrongly reporting EINTR for non-
+	 * interrupting (SA_RESTART) signal handlers. This is only practical
+	 * when NO interrupting signal handlers have been installed, and
+	 * works by sigaction tracking whether that's the case. */
+	if (r == EINTR && !__eintr_valid_flag) r = 0;
+
+	return r;
+}
+
+int __timedwait(volatile int *addr, int val,
+	clockid_t clk, const struct timespec *at, int priv)
+{
+	int cs, r;
+	__pthread_setcancelstate(PTHREAD_CANCEL_DISABLE, &cs);
+	r = __timedwait_cp(addr, val, clk, at, priv);
+	__pthread_setcancelstate(cs, 0);
+	return r;
+}
diff --git a/third_party/musl/porting/liteos_a/user/src/thread/__wait.c b/third_party/musl/porting/liteos_a/user/src/thread/__wait.c
new file mode 100755
index 000000000..587395611
--- /dev/null
+++ b/third_party/musl/porting/liteos_a/user/src/thread/__wait.c
@@ -0,0 +1,17 @@
+#include "pthread_impl.h"
+
+void __wait(volatile int *addr, volatile int *waiters, int val, int priv)
+{
+	int spins=100;
+	if (priv) priv = FUTEX_PRIVATE;
+	while (spins-- && (!waiters || !*waiters)) {
+		if (*addr==val) a_spin();
+		else return;
+	}
+	if (waiters) a_inc(waiters);
+	while (*addr==val) {
+		__syscall(SYS_futex, addr, FUTEX_WAIT|priv, val, 0xffffffffu) != -ENOSYS
+		|| __syscall(SYS_futex, addr, FUTEX_WAIT, val, 0xffffffffu);
+	}
+	if (waiters) a_dec(waiters);
+}
diff --git a/third_party/musl/porting/liteos_a/user/src/thread/arm/__set_thread_area.c b/third_party/musl/porting/liteos_a/user/src/thread/arm/__set_thread_area.c
new file mode 100755
index 000000000..4d73c5d3c
--- /dev/null
+++ b/third_party/musl/porting/liteos_a/user/src/thread/arm/__set_thread_area.c
@@ -0,0 +1,56 @@
+#include <stdint.h>
+#include <elf.h>
+#include "pthread_impl.h"
+#include "libc.h"
+
+#define HWCAP_TLS (1 << 15)
+
+extern hidden const unsigned char
+	__a_barrier_oldkuser[], __a_barrier_v6[], __a_barrier_v7[],
+	__a_cas_v6[], __a_cas_v7[],
+	__a_gettp_cp15[];
+
+#define __a_barrier_kuser 0xffff0fa0
+#define __a_barrier_oldkuser (uintptr_t)__a_barrier_oldkuser
+#define __a_barrier_v6 (uintptr_t)__a_barrier_v6
+#define __a_barrier_v7 (uintptr_t)__a_barrier_v7
+
+#define __a_cas_kuser 0xffff0fc0
+#define __a_cas_v6 (uintptr_t)__a_cas_v6
+#define __a_cas_v7 (uintptr_t)__a_cas_v7
+
+#define __a_gettp_kuser 0xffff0fe0
+#define __a_gettp_cp15 (uintptr_t)__a_gettp_cp15
+
+extern hidden uintptr_t __a_barrier_ptr, __a_cas_ptr, __a_gettp_ptr;
+
+int __set_thread_area(void *p)
+{
+#ifdef SYS_set_thread_area
+	return __syscall(SYS_set_thread_area, p);
+#else
+#if !__ARM_ARCH_7A__ && !__ARM_ARCH_7R__ && __ARM_ARCH < 7
+	if (__hwcap & HWCAP_TLS) {
+		size_t *aux;
+		__a_cas_ptr = __a_cas_v7;
+		__a_barrier_ptr = __a_barrier_v7;
+		for (aux=libc.auxv; *aux; aux+=2) {
+			if (*aux != AT_PLATFORM) continue;
+			const char *s = (void *)aux[1];
+			if (s[0]!='v' || s[1]!='6' || s[2]-'0'<10u) break;
+			__a_cas_ptr = __a_cas_v6;
+			__a_barrier_ptr = __a_barrier_v6;
+			break;
+		}
+	} else {
+		int ver = *(int *)0xffff0ffc;
+		__a_gettp_ptr = __a_gettp_kuser;
+		__a_cas_ptr = __a_cas_kuser;
+		__a_barrier_ptr = __a_barrier_kuser;
+		if (ver < 2) a_crash();
+		if (ver < 3) __a_barrier_ptr = __a_barrier_oldkuser;
+	}
+#endif
+	return __syscall(0xf0005, p);
+#endif
+}
diff --git a/third_party/musl/porting/liteos_a/user/src/thread/pthread_attr_get.c b/third_party/musl/porting/liteos_a/user/src/thread/pthread_attr_get.c
new file mode 100755
index 000000000..0e4db95e5
--- /dev/null
+++ b/third_party/musl/porting/liteos_a/user/src/thread/pthread_attr_get.c
@@ -0,0 +1,101 @@
+#include <unsupported_api.h>
+#include "pthread_impl.h"
+
+int pthread_attr_getdetachstate(const pthread_attr_t *a, int *state)
+{
+	*state = a->_a_detach;
+	return 0;
+}
+int pthread_attr_getguardsize(const pthread_attr_t *restrict a, size_t *restrict size)
+{
+	*size = a->_a_guardsize;
+	return 0;
+}
+
+int pthread_attr_getinheritsched(const pthread_attr_t *restrict a, int *restrict inherit)
+{
+	*inherit = a->_a_sched;
+	return 0;
+}
+
+int pthread_attr_getschedparam(const pthread_attr_t *restrict a, struct sched_param *restrict param)
+{
+	param->sched_priority = a->_a_prio;
+	return 0;
+}
+
+int pthread_attr_getschedpolicy(const pthread_attr_t *restrict a, int *restrict policy)
+{
+	*policy = a->_a_policy;
+	return 0;
+}
+
+int pthread_attr_getscope(const pthread_attr_t *restrict a, int *restrict scope)
+{
+	*scope = PTHREAD_SCOPE_PROCESS;
+	return 0;
+}
+
+int pthread_attr_getstack(const pthread_attr_t *restrict a, void **restrict addr, size_t *restrict size)
+{
+	if (!a->_a_stackaddr)
+		return EINVAL;
+	*size = a->_a_stacksize;
+	*addr = (void *)(a->_a_stackaddr - *size);
+	return 0;
+}
+
+int pthread_attr_getstacksize(const pthread_attr_t *restrict a, size_t *restrict size)
+{
+	*size = a->_a_stacksize;
+	return 0;
+}
+
+int pthread_barrierattr_getpshared(const pthread_barrierattr_t *restrict a, int *restrict pshared)
+{
+	*pshared = !!a->__attr;
+	return 0;
+}
+
+int pthread_condattr_getclock(const pthread_condattr_t *restrict a, clockid_t *restrict clk)
+{
+	*clk = a->__attr & 0x7fffffff;
+	return 0;
+}
+
+int pthread_condattr_getpshared(const pthread_condattr_t *restrict a, int *restrict pshared)
+{
+	*pshared = a->__attr>>31;
+	return 0;
+}
+
+int pthread_mutexattr_getprotocol(const pthread_mutexattr_t *restrict a, int *restrict protocol)
+{
+	unsupported_api(__FUNCTION__);
+	*protocol = PTHREAD_PRIO_NONE;
+	return 0;
+}
+int pthread_mutexattr_getpshared(const pthread_mutexattr_t *restrict a, int *restrict pshared)
+{
+	*pshared = a->__attr / 128U % 2;
+	return 0;
+}
+
+int pthread_mutexattr_getrobust(const pthread_mutexattr_t *restrict a, int *restrict robust)
+{
+	unsupported_api(__FUNCTION__);
+	*robust = a->__attr / 4U % 2;
+	return 0;
+}
+
+int pthread_mutexattr_gettype(const pthread_mutexattr_t *restrict a, int *restrict type)
+{
+	*type = a->__attr & 3;
+	return 0;
+}
+
+int pthread_rwlockattr_getpshared(const pthread_rwlockattr_t *restrict a, int *restrict pshared)
+{
+	*pshared = a->__attr[0];
+	return 0;
+}
diff --git a/third_party/musl/porting/liteos_a/user/src/thread/pthread_attr_init.c b/third_party/musl/porting/liteos_a/user/src/thread/pthread_attr_init.c
new file mode 100755
index 000000000..aa43c71d6
--- /dev/null
+++ b/third_party/musl/porting/liteos_a/user/src/thread/pthread_attr_init.c
@@ -0,0 +1,13 @@
+#include "pthread_impl.h"
+
+int pthread_attr_init(pthread_attr_t *a)
+{
+	*a = (pthread_attr_t){0};
+	__acquire_ptc();
+	a->_a_stacksize = __default_stacksize;
+	a->_a_guardsize = __default_guardsize;
+	a->_a_policy = SCHED_RR;
+	a->_a_prio = 25;
+	__release_ptc();
+	return 0;
+}
diff --git a/third_party/musl/porting/liteos_a/user/src/thread/pthread_attr_setschedparam.c b/third_party/musl/porting/liteos_a/user/src/thread/pthread_attr_setschedparam.c
new file mode 100755
index 000000000..233ce58c8
--- /dev/null
+++ b/third_party/musl/porting/liteos_a/user/src/thread/pthread_attr_setschedparam.c
@@ -0,0 +1,11 @@
+#include "pthread_impl.h"
+
+int pthread_attr_setschedparam(pthread_attr_t *restrict a, const struct sched_param *restrict param)
+{
+	if (param->sched_priority < 0 || param->sched_priority > PTHREAD_PRIORITY_LOWEST) {
+		return EINVAL;
+	}
+
+	a->_a_prio = param->sched_priority;
+	return 0;
+}
diff --git a/third_party/musl/porting/liteos_a/user/src/thread/pthread_attr_setschedpolicy.c b/third_party/musl/porting/liteos_a/user/src/thread/pthread_attr_setschedpolicy.c
new file mode 100755
index 000000000..df19df73f
--- /dev/null
+++ b/third_party/musl/porting/liteos_a/user/src/thread/pthread_attr_setschedpolicy.c
@@ -0,0 +1,11 @@
+#include "pthread_impl.h"
+
+int pthread_attr_setschedpolicy(pthread_attr_t *a, int policy)
+{
+	if (policy != SCHED_RR && policy != SCHED_FIFO) {
+		return EINVAL;
+	}
+
+	a->_a_policy = policy;
+	return 0;
+}
diff --git a/third_party/musl/porting/liteos_a/user/src/thread/pthread_attr_setscope.c b/third_party/musl/porting/liteos_a/user/src/thread/pthread_attr_setscope.c
new file mode 100755
index 000000000..f632883bd
--- /dev/null
+++ b/third_party/musl/porting/liteos_a/user/src/thread/pthread_attr_setscope.c
@@ -0,0 +1,13 @@
+#include "pthread_impl.h"
+
+int pthread_attr_setscope(pthread_attr_t *a, int scope)
+{
+	switch (scope) {
+	case PTHREAD_SCOPE_SYSTEM:
+		return ENOTSUP;
+	case PTHREAD_SCOPE_PROCESS:
+		return 0;
+	default:
+		return EINVAL;
+	}
+}
diff --git a/third_party/musl/porting/liteos_a/user/src/thread/pthread_barrier_wait.c b/third_party/musl/porting/liteos_a/user/src/thread/pthread_barrier_wait.c
new file mode 100755
index 000000000..5a56b5e44
--- /dev/null
+++ b/third_party/musl/porting/liteos_a/user/src/thread/pthread_barrier_wait.c
@@ -0,0 +1,111 @@
+#include "pthread_impl.h"
+
+static int pshared_barrier_wait(pthread_barrier_t *b)
+{
+	int limit = (b->_b_limit & INT_MAX) + 1;
+	int ret = 0;
+	int v, w;
+
+	if (limit==1) return PTHREAD_BARRIER_SERIAL_THREAD;
+
+	while ((v=a_cas(&b->_b_lock, 0, limit)))
+		__wait(&b->_b_lock, &b->_b_waiters, v, 0);
+
+	/* Wait for <limit> threads to get to the barrier */
+	if (++b->_b_count == limit) {
+		a_store(&b->_b_count, 0);
+		ret = PTHREAD_BARRIER_SERIAL_THREAD;
+		if (b->_b_waiters2) __wake(&b->_b_count, -1, 0);
+	} else {
+		a_store(&b->_b_lock, 0);
+		if (b->_b_waiters) __wake(&b->_b_lock, 1, 0);
+		while ((v=b->_b_count)>0)
+			__wait(&b->_b_count, &b->_b_waiters2, v, 0);
+	}
+
+	__vm_lock();
+
+	/* Ensure all threads have a vm lock before proceeding */
+	if (a_fetch_add(&b->_b_count, -1)==1-limit) {
+		a_store(&b->_b_count, 0);
+		if (b->_b_waiters2) __wake(&b->_b_count, -1, 0);
+	} else {
+		while ((v=b->_b_count))
+			__wait(&b->_b_count, &b->_b_waiters2, v, 0);
+	}
+	
+	/* Perform a recursive unlock suitable for self-sync'd destruction */
+	do {
+		v = b->_b_lock;
+		w = b->_b_waiters;
+	} while (a_cas(&b->_b_lock, v, v==INT_MIN+1 ? 0 : v-1) != v);
+
+	/* Wake a thread waiting to reuse or destroy the barrier */
+	if (v==INT_MIN+1 || (v==1 && w))
+		__wake(&b->_b_lock, 1, 0);
+
+	__vm_unlock();
+
+	return ret;
+}
+
+struct instance
+{
+	volatile int count;
+	volatile int last;
+	volatile int waiters;
+	volatile int finished;
+};
+
+int pthread_barrier_wait(pthread_barrier_t *b)
+{
+	int limit = b->_b_limit;
+	struct instance *inst;
+
+	/* Trivial case: count was set at 1 */
+	if (!limit) return PTHREAD_BARRIER_SERIAL_THREAD;
+
+	/* Process-shared barriers require a separate, inefficient wait */
+	if (limit < 0) return pshared_barrier_wait(b);
+
+	/* Otherwise we need a lock on the barrier object */
+	while (a_swap(&b->_b_lock, 1))
+		__wait(&b->_b_lock, &b->_b_waiters, 1, 1);
+	inst = b->_b_inst;
+
+	/* First thread to enter the barrier becomes the "instance owner" */
+	if (!inst) {
+		struct instance new_inst = { 0 };
+		int spins = 200;
+		b->_b_inst = inst = &new_inst;
+		a_store(&b->_b_lock, 0);
+		if (b->_b_waiters) __wake(&b->_b_lock, 1, 1);
+		while (spins-- && !inst->finished)
+			a_spin();
+		a_inc(&inst->finished);
+		while (inst->finished == 1)
+			__syscall(SYS_futex,&inst->finished,FUTEX_WAIT|FUTEX_PRIVATE,1,0xffffffffu) != -ENOSYS
+			|| __syscall(SYS_futex,&inst->finished,FUTEX_WAIT,1,0xffffffffu);
+		return PTHREAD_BARRIER_SERIAL_THREAD;
+	}
+
+	/* Last thread to enter the barrier wakes all non-instance-owners */
+	if (++inst->count == limit) {
+		b->_b_inst = 0;
+		a_store(&b->_b_lock, 0);
+		if (b->_b_waiters) __wake(&b->_b_lock, 1, 1);
+		a_store(&inst->last, 1);
+		if (inst->waiters)
+			__wake(&inst->last, -1, 1);
+	} else {
+		a_store(&b->_b_lock, 0);
+		if (b->_b_waiters) __wake(&b->_b_lock, 1, 1);
+		__wait(&inst->last, &inst->waiters, 0, 1);
+	}
+
+	/* Last thread to exit the barrier wakes the instance owner */
+	if (a_fetch_add(&inst->count,-1)==1 && a_fetch_add(&inst->finished,1))
+		__wake(&inst->finished, 1, 1);
+
+	return 0;
+}
diff --git a/third_party/musl/porting/liteos_a/user/src/thread/pthread_cancel.c b/third_party/musl/porting/liteos_a/user/src/thread/pthread_cancel.c
new file mode 100755
index 000000000..c372f05fb
--- /dev/null
+++ b/third_party/musl/porting/liteos_a/user/src/thread/pthread_cancel.c
@@ -0,0 +1,89 @@
+#define _GNU_SOURCE
+#include <string.h>
+#include "pthread_impl.h"
+#include "syscall.h"
+
+hidden long __cancel(), __syscall_cp_asm(), __syscall_cp_c();
+
+long __cancel()
+{
+	pthread_t self = __pthread_self();
+	if (self->canceldisable == PTHREAD_CANCEL_ENABLE || self->cancelasync)
+		pthread_exit(PTHREAD_CANCELED);
+	self->canceldisable = PTHREAD_CANCEL_DISABLE;
+	return -ECANCELED;
+}
+
+long __syscall_cp_asm(volatile void *, syscall_arg_t,
+                      syscall_arg_t, syscall_arg_t, syscall_arg_t,
+                      syscall_arg_t, syscall_arg_t, syscall_arg_t);
+
+long __syscall_cp_c(syscall_arg_t nr,
+                    syscall_arg_t u, syscall_arg_t v, syscall_arg_t w,
+                    syscall_arg_t x, syscall_arg_t y, syscall_arg_t z)
+{
+	pthread_t self;
+	long r;
+	int st;
+
+	if ((st=(self=__pthread_self())->canceldisable)
+	    && (st==PTHREAD_CANCEL_DISABLE || nr==SYS_close))
+		return __syscall(nr, u, v, w, x, y, z);
+
+	r = __syscall_cp_asm(&self->cancel, nr, u, v, w, x, y, z);
+	if (r==-EINTR && nr!=SYS_close && self->cancel &&
+	    self->canceldisable != PTHREAD_CANCEL_DISABLE)
+		r = __cancel();
+	return r;
+}
+
+static void _sigaddset(sigset_t *set, int sig)
+{
+	unsigned s = sig-1;
+	set->__bits[s/8/sizeof *set->__bits] |= 1UL<<(s&8*sizeof *set->__bits-1);
+}
+
+extern hidden const char __cp_begin[1], __cp_end[1], __cp_cancel[1];
+
+static void cancel_handler(int sig, siginfo_t *si, void *ctx)
+{
+	pthread_t self = __pthread_self();
+	a_barrier();
+	if (!self->cancel || self->canceldisable == PTHREAD_CANCEL_DISABLE) return;
+	if(self->cancelasync){
+		pthread_exit(PTHREAD_CANCELED);
+	}
+}
+
+void __testcancel()
+{
+	pthread_t self = __pthread_self();
+	if (self->cancel && !self->canceldisable)
+		__cancel();
+}
+
+static void init_cancellation()
+{
+	struct sigaction sa = {
+		.sa_flags = SA_SIGINFO | SA_RESTART,
+		.sa_sigaction = cancel_handler
+	};
+	memset(&sa.sa_mask, -1, _NSIG/8);
+	__libc_sigaction(SIGCANCEL, &sa, 0);
+}
+
+int pthread_cancel(pthread_t t)
+{
+	static int init;
+	if (!init) {
+		init_cancellation();
+		init = 1;
+	}
+	a_store(&t->cancel, 1);
+	if (t == pthread_self()) {
+		if (t->canceldisable == PTHREAD_CANCEL_ENABLE && t->cancelasync)
+			pthread_exit(PTHREAD_CANCELED);
+		return 0;
+	}
+	return pthread_kill(t, SIGCANCEL);
+}
diff --git a/third_party/musl/src/thread/pthread_clone.c b/third_party/musl/porting/liteos_a/user/src/thread/pthread_clone.c
old mode 100644
new mode 100755
similarity index 100%
rename from third_party/musl/src/thread/pthread_clone.c
rename to third_party/musl/porting/liteos_a/user/src/thread/pthread_clone.c
diff --git a/third_party/musl/porting/liteos_a/user/src/thread/pthread_create.c b/third_party/musl/porting/liteos_a/user/src/thread/pthread_create.c
new file mode 100755
index 000000000..7cc0d5481
--- /dev/null
+++ b/third_party/musl/porting/liteos_a/user/src/thread/pthread_create.c
@@ -0,0 +1,384 @@
+#define _GNU_SOURCE
+#include "pthread_impl.h"
+#include "stdio_impl.h"
+#include "libc.h"
+#include "lock.h"
+#include <sys/mman.h>
+#include <string.h>
+#include <stddef.h>
+
+static void dummy_0()
+{
+}
+weak_alias(dummy_0, __acquire_ptc);
+weak_alias(dummy_0, __release_ptc);
+weak_alias(dummy_0, __pthread_tsd_run_dtors);
+weak_alias(dummy_0, __do_orphaned_stdio_locks);
+weak_alias(dummy_0, __dl_thread_cleanup);
+
+static int tl_lock_count;
+static int tl_lock_waiters;
+
+void __tl_lock(void)
+{
+	int tid = __pthread_self()->tid;
+	int val = __thread_list_lock;
+	if (val == tid) {
+		tl_lock_count++;
+		return;
+	}
+	while ((val = a_cas(&__thread_list_lock, 0, tid)))
+		__wait(&__thread_list_lock, &tl_lock_waiters, val, 0);
+}
+
+void __tl_unlock(void)
+{
+	if (tl_lock_count) {
+		tl_lock_count--;
+		return;
+	}
+	a_store(&__thread_list_lock, 0);
+	if (tl_lock_waiters) __wake(&__thread_list_lock, 1, 0);
+}
+
+void __tl_sync(pthread_t td)
+{
+	a_barrier();
+	int val = __thread_list_lock;
+	if (!val) return;
+	__wait(&__thread_list_lock, &tl_lock_waiters, val, 0);
+	if (tl_lock_waiters) __wake(&__thread_list_lock, 1, 0);
+}
+
+_Noreturn void __pthread_exit(void *result)
+{
+	pthread_t self = __pthread_self();
+	sigset_t set;
+
+	self->canceldisable = 1;
+	self->cancelasync = 0;
+	self->result = result;
+
+	while (self->cancelbuf) {
+		void (*f)(void *) = self->cancelbuf->__f;
+		void *x = self->cancelbuf->__x;
+		self->cancelbuf = self->cancelbuf->__next;
+		f(x);
+	}
+
+	__pthread_tsd_run_dtors();
+
+	/* Access to target the exiting thread with syscalls that use
+	 * its kernel tid is controlled by killlock. For detached threads,
+	 * any use past this point would have undefined behavior, but for
+	 * joinable threads it's a valid usage that must be handled. */
+	LOCK(self->killlock);
+
+	/* The thread list lock must be AS-safe, and thus requires
+	 * application signals to be blocked before it can be taken. */
+	__block_app_sigs(&set);
+	__tl_lock();
+
+	/* If this is the only thread in the list, don't proceed with
+	 * termination of the thread, but restore the previous lock and
+	 * signal state to prepare for exit to call atexit handlers. */
+	if (self->next == self) {
+		__tl_unlock();
+		__restore_sigs(&set);
+		UNLOCK(self->killlock);
+		exit(0);
+	}
+
+	/* At this point we are committed to thread termination. Unlink
+	 * the thread from the list. This change will not be visible
+	 * until the lock is released, which only happens after SYS_exit
+	 * has been called, via the exit futex address pointing at the lock. */
+	libc.threads_minus_1--;
+	self->next->prev = self->prev;
+	self->prev->next = self->next;
+	self->prev = self->next = self;
+
+	/* Process robust list in userspace to handle non-pshared mutexes
+	 * and the detached thread case where the robust list head will
+	 * be invalid when the kernel would process it. */
+#if 0
+	__vm_lock();
+	volatile void *volatile *rp;
+	while ((rp=self->robust_list.head) && rp != &self->robust_list.head) {
+		pthread_mutex_t *m = (void *)((char *)rp
+			- offsetof(pthread_mutex_t, _m_next));
+		int waiters = m->_m_waiters;
+		int priv = (m->_m_type & 128) ^ 128;
+		self->robust_list.pending = rp;
+		self->robust_list.head = *rp;
+		int cont = a_swap(&m->_m_lock, 0x40000000);
+		self->robust_list.pending = 0;
+		if (cont < 0 || waiters)
+			__wake(&m->_m_lock, 1, priv);
+	}
+	__vm_unlock();
+#endif
+
+	__do_orphaned_stdio_locks();
+	__dl_thread_cleanup();
+
+	/* This atomic potentially competes with a concurrent pthread_detach
+	 * call; the loser is responsible for freeing thread resources. */
+	int state = a_cas(&self->detach_state, DT_JOINABLE, DT_EXITING);
+#if 0
+	if (state==DT_DETACHED && self->map_base) {
+		/* Robust list will no longer be valid, and was already
+		 * processed above, so unregister it with the kernel. */
+		if (self->robust_list.off)
+			__syscall(SYS_set_robust_list, 0, 3*sizeof(long));
+
+		/* Since __unmapself bypasses the normal munmap code path,
+		 * explicitly wait for vmlock holders first. */
+		__vm_wait();
+
+		/* The following call unmaps the thread's stack mapping
+		 * and then exits without touching the stack. */
+		__unmapself(self->map_base, self->map_size);
+	}
+
+	/* Wake any joiner. */
+	__wake(&self->detach_state, 1, 1);
+#endif
+
+	/* After the kernel thread exits, its tid may be reused. Clear it
+	 * to prevent inadvertent use and inform functions that would use
+	 * it that it's no longer available. */
+	if (self->detach_state == DT_DETACHED) {
+		/* Detached threads must block even implementation-internal
+		 * signals, since they will not have a stack in their last
+		 * moments of existence. */
+		__block_all_sigs(&set);
+		self->tid = 0;
+	}
+
+	__tl_unlock();
+	UNLOCK(self->killlock);
+
+	for (;;) __syscall(SYS_exit, 0);
+}
+
+void __do_cleanup_push(struct __ptcb *cb)
+{
+	struct pthread *self = __pthread_self();
+	cb->__next = self->cancelbuf;
+	self->cancelbuf = cb;
+}
+
+void __do_cleanup_pop(struct __ptcb *cb)
+{
+	__pthread_self()->cancelbuf = cb->__next;
+}
+
+struct start_args {
+	void *(*start_func)(void *);
+	void *start_arg;
+	volatile int control;
+	unsigned long sig_mask[_NSIG/8/sizeof(long)];
+};
+
+static int start(void *p)
+{
+	struct start_args *args = (struct start_args *)p;
+	__syscall(SYS_rt_sigprocmask, SIG_SETMASK, &args->sig_mask, 0, _NSIG/8);
+	__pthread_exit(args->start_func(args->start_arg));
+	return 0;
+}
+
+static int start_c11(void *p)
+{
+	struct start_args *args = (struct start_args *)p;
+	int (*start)(void*) = (int(*)(void*)) args->start_func;
+	__pthread_exit((void *)(uintptr_t)start(args->start_arg));
+	return 0;
+}
+
+#define ROUND(x) (((x)+PAGE_SIZE-1)&-PAGE_SIZE)
+
+/* pthread_key_create.c overrides this */
+static volatile size_t dummy = 0;
+weak_alias(dummy, __pthread_tsd_size);
+static void *dummy_tsd[1] = { 0 };
+weak_alias(dummy_tsd, __pthread_tsd_main);
+
+int __pthread_init_and_check_attr(const pthread_attr_t *restrict attrp, pthread_attr_t *attr)
+{
+	int policy = 0;
+	struct sched_param param = { 0 };
+	int c11 = (attrp == __ATTRP_C11_THREAD);
+	int ret;
+
+	if (attrp && !c11) memcpy(attr, attrp, sizeof(pthread_attr_t));
+
+	if (!attrp || c11) {
+		pthread_attr_init(attr);
+	}
+
+	if (!attr->_a_sched) {
+		ret = pthread_getschedparam(pthread_self(), &policy, &param);
+		if (ret) return ret;
+		attr->_a_policy = policy;
+		attr->_a_prio = param.sched_priority;
+	}
+
+	if (attr->_a_policy != SCHED_RR && attr->_a_policy != SCHED_FIFO) {
+		return EINVAL;
+	}
+
+	if (attr->_a_prio < 0 || attr->_a_prio > PTHREAD_PRIORITY_LOWEST) {
+		return EINVAL;
+	}
+
+	return 0;
+}
+
+int __pthread_create(pthread_t *restrict res, const pthread_attr_t *restrict attrp, void *(*entry)(void *), void *restrict arg)
+{
+	int ret, c11 = (attrp == __ATTRP_C11_THREAD);
+	size_t size, guard;
+	struct pthread *self, *new;
+	unsigned char *map = 0, *stack = 0, *tsd = 0, *stack_limit;
+	unsigned flags = CLONE_VM | CLONE_FS | CLONE_FILES | CLONE_SIGHAND
+		| CLONE_THREAD | CLONE_SYSVSEM | CLONE_SETTLS
+		| CLONE_PARENT_SETTID | CLONE_CHILD_CLEARTID | CLONE_DETACHED;
+	pthread_attr_t attr = { 0 };
+	sigset_t set;
+
+	if (!libc.can_do_threads) return ENOSYS;
+	if (!entry) return EINVAL;
+	self = __pthread_self();
+	__acquire_ptc();
+
+	ret = __pthread_init_and_check_attr(attrp, &attr);
+	if (ret) {
+		__release_ptc();
+		return ret;
+	}
+
+	if (attr._a_stackaddr) {
+		size_t need = libc.tls_size + __pthread_tsd_size;
+		size = attr._a_stacksize;
+		stack = (void *)(attr._a_stackaddr & -16);
+		stack_limit = (void *)(attr._a_stackaddr - size);
+		/* Use application-provided stack for TLS only when
+		 * it does not take more than ~12% or 2k of the
+		 * application's stack space. */
+		if (need < size/8 && need < 2048) {
+			tsd = stack - __pthread_tsd_size;
+			stack = tsd - libc.tls_size;
+			memset(stack, 0, need);
+		} else {
+			size = ROUND(need);
+		}
+		guard = 0;
+	} else {
+		guard = ROUND(attr._a_guardsize);
+		size = guard + ROUND(attr._a_stacksize
+			+ libc.tls_size +  __pthread_tsd_size);
+	}
+
+	if (!tsd) {
+		if (guard) {
+			map = __mmap(0, size, PROT_READ|PROT_WRITE|PROT_NONE, MAP_PRIVATE|MAP_ANON, -1, 0);
+			if (map == MAP_FAILED) goto fail;
+			if (__mprotect(map+guard, size-guard, PROT_READ|PROT_WRITE)
+			    && errno != ENOSYS) {
+				__munmap(map, size);
+				goto fail;
+			}
+		} else {
+			map = __mmap(0, size, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANON, -1, 0);
+			if (map == MAP_FAILED) goto fail;
+		}
+		tsd = map + size - __pthread_tsd_size;
+		if (!stack) {
+			stack = tsd - libc.tls_size;
+			stack_limit = map + guard;
+		}
+	}
+
+	new = __copy_tls(tsd - libc.tls_size);
+	new->map_base = map;
+	new->map_size = size;
+	new->stack = stack;
+	new->stack_size = stack - stack_limit;
+	new->guard_size = guard;
+	new->self = new;
+	new->tsd = (void *)tsd;
+	new->locale = &libc.global_locale;
+	if (attr._a_detach) {
+		new->detach_state = DT_DETACHED;
+	} else {
+		new->detach_state = DT_JOINABLE;
+	}
+	new->robust_list.head = &new->robust_list.head;
+	new->CANARY = self->CANARY;
+	new->sysinfo = self->sysinfo;
+
+	/* Setup argument structure for the new thread on its stack.
+	 * It's safe to access from the caller only until the thread
+	 * list is unlocked. */
+	stack -= (uintptr_t)stack % sizeof(uintptr_t);
+	stack -= sizeof(struct start_args);
+	struct start_args *args = (void *)stack;
+	args->start_func = entry;
+	args->start_arg = arg;
+	args->control = attr._a_sched ? 1 : 0;
+
+	/* Application signals (but not the synccall signal) must be
+	 * blocked before the thread list lock can be taken, to ensure
+	 * that the lock is AS-safe. */
+	__block_app_sigs(&set);
+
+	/* Ensure SIGCANCEL is unblocked in new thread. This requires
+	 * working with a copy of the set so we can restore the
+	 * original mask in the calling thread. */
+	memcpy(&args->sig_mask, &set, sizeof args->sig_mask);
+	args->sig_mask[(SIGCANCEL-1)/8/sizeof(long)] &=
+		~(1UL<<((SIGCANCEL-1)%(8*sizeof(long))));
+
+	__tl_lock();
+	libc.threads_minus_1++;
+	ret = __thread_clone((c11 ? start_c11 : start), flags, new, stack);
+
+	/* All clone failures translate to EAGAIN. If explicit scheduling
+	 * was requested, attempt it before unlocking the thread list so
+	 * that the failed thread is never exposed and so that we can
+	 * clean up all transient resource usage before returning. */
+	if (ret < 0) {
+		ret = -EAGAIN;
+	} else {
+		new->next = self->next;
+		new->prev = self;
+		new->next->prev = new;
+		new->prev->next = new;
+
+		*res = new;
+		__tl_unlock();
+		__restore_sigs(&set);
+		__release_ptc();
+		ret = __syscall(SYS_sched_setscheduler,
+			new->tid, attr._a_policy, attr._a_prio, MUSL_TYPE_THREAD);
+	}
+
+	if (ret < 0) {
+		libc.threads_minus_1--;
+		__tl_unlock();
+		__restore_sigs(&set);
+		__release_ptc();
+		if (map) __munmap(map, size);
+		return -ret;
+	}
+
+	return 0;
+fail:
+	__release_ptc();
+	return EAGAIN;
+}
+
+weak_alias(__pthread_exit, pthread_exit);
+weak_alias(__pthread_create, pthread_create);
diff --git a/third_party/musl/porting/liteos_a/user/src/thread/pthread_detach.c b/third_party/musl/porting/liteos_a/user/src/thread/pthread_detach.c
new file mode 100755
index 000000000..a29e25308
--- /dev/null
+++ b/third_party/musl/porting/liteos_a/user/src/thread/pthread_detach.c
@@ -0,0 +1,19 @@
+#include "pthread_impl.h"
+#include <threads.h>
+
+static int __pthread_detach(pthread_t t)
+{
+	int ret;
+
+	/* If the cas fails, detach state is either already-detached
+	 * or exiting/exited, and pthread_join will trap or cleanup. */
+	if (a_cas(&t->detach_state, DT_JOINABLE, DT_DETACHED) != DT_JOINABLE)
+		return __pthread_join(t, 0);
+	ret = __syscall(SYS_pthread_set_detach, t->tid);
+	if (ret) a_swap(&t->detach_state, DT_JOINABLE);
+	if (ret == ESRCH) ret = 0;
+	return ret;
+}
+
+weak_alias(__pthread_detach, pthread_detach);
+weak_alias(__pthread_detach, thrd_detach);
diff --git a/third_party/musl/porting/liteos_a/user/src/thread/pthread_getconcurrency.c b/third_party/musl/porting/liteos_a/user/src/thread/pthread_getconcurrency.c
new file mode 100755
index 000000000..4156988ee
--- /dev/null
+++ b/third_party/musl/porting/liteos_a/user/src/thread/pthread_getconcurrency.c
@@ -0,0 +1,8 @@
+#include <pthread.h>
+#include <unsupported_api.h>
+
+int pthread_getconcurrency()
+{
+	unsupported_api(__FUNCTION__);
+	return 0;
+}
diff --git a/third_party/musl/porting/liteos_a/user/src/thread/pthread_getschedparam.c b/third_party/musl/porting/liteos_a/user/src/thread/pthread_getschedparam.c
new file mode 100755
index 000000000..0948509a1
--- /dev/null
+++ b/third_party/musl/porting/liteos_a/user/src/thread/pthread_getschedparam.c
@@ -0,0 +1,27 @@
+#include "pthread_impl.h"
+#include "lock.h"
+
+int pthread_getschedparam(pthread_t t, int *restrict policy, struct sched_param *restrict param)
+{
+	int r;
+	LOCK(t->killlock);
+	if (!t->tid) {
+		r = ESRCH;
+	} else {
+		r = __syscall(SYS_sched_getparam, t->tid, MUSL_TYPE_THREAD);
+		if (r >= 0) {
+			param->sched_priority = r;
+			r = __syscall(SYS_sched_getscheduler, t->tid, MUSL_TYPE_THREAD);
+			if (r >= 0) {
+				*policy = r;
+				r = 0;
+			}
+		}
+
+		if (r < 0) {
+			r = -r;
+		}
+	}
+	UNLOCK(t->killlock);
+	return r;
+}
diff --git a/third_party/musl/porting/liteos_a/user/src/thread/pthread_join.c b/third_party/musl/porting/liteos_a/user/src/thread/pthread_join.c
new file mode 100755
index 000000000..9801bf14c
--- /dev/null
+++ b/third_party/musl/porting/liteos_a/user/src/thread/pthread_join.c
@@ -0,0 +1,58 @@
+#define _GNU_SOURCE
+#include "pthread_impl.h"
+#include <sys/mman.h>
+
+static void dummy1(pthread_t t)
+{
+}
+weak_alias(dummy1, __tl_sync);
+
+static int __pthread_timedjoin_np(pthread_t t, void **res, const struct timespec *at)
+{
+	int state, cs, r = 0;
+	unsigned int tid;
+	pthread_t self = __pthread_self();
+	__pthread_testcancel();
+	__pthread_setcancelstate(PTHREAD_CANCEL_DISABLE, &cs);
+	if (cs == PTHREAD_CANCEL_ENABLE) __pthread_setcancelstate(cs, 0);
+	if (t == self) {
+		r = EINVAL;
+		goto out;
+	}
+
+	switch (t->detach_state) {
+		case DT_JOINABLE: {
+			r = __syscall(SYS_pthread_join, t->tid);
+			break;
+		}
+		case DT_EXITING:
+			break;
+		case DT_DETACHED:
+		default:
+			r = EINVAL;
+			break;
+	}
+
+out:
+	__pthread_setcancelstate(cs, 0);
+	if (r == ESRCH || r == EINVAL) return r;
+	__tl_sync(t);
+	if (res) *res = t->result;
+	tid = t->tid;
+	t->tid = 0;
+	return __syscall(SYS_pthread_deatch, tid);
+}
+
+int __pthread_join(pthread_t t, void **res)
+{
+	return __pthread_timedjoin_np(t, res, 0);
+}
+
+static int __pthread_tryjoin_np(pthread_t t, void **res)
+{
+	return t->detach_state==DT_JOINABLE ? EBUSY : __pthread_join(t, res);
+}
+
+weak_alias(__pthread_tryjoin_np, pthread_tryjoin_np);
+weak_alias(__pthread_timedjoin_np, pthread_timedjoin_np);
+weak_alias(__pthread_join, pthread_join);
diff --git a/third_party/musl/porting/liteos_a/user/src/thread/pthread_mutex_consistent.c b/third_party/musl/porting/liteos_a/user/src/thread/pthread_mutex_consistent.c
new file mode 100755
index 000000000..52cc962c5
--- /dev/null
+++ b/third_party/musl/porting/liteos_a/user/src/thread/pthread_mutex_consistent.c
@@ -0,0 +1,17 @@
+#include <unsupported_api.h>
+#include "pthread_impl.h"
+#include "atomic.h"
+
+int pthread_mutex_consistent(pthread_mutex_t *m)
+{
+	unsupported_api(__FUNCTION__);
+
+	int old = m->_m_lock;
+	int own = old & 0x3fffffff;
+	if (!(m->_m_type & 4) || !own || !(old & 0x40000000))
+		return EINVAL;
+	if (own != __pthread_self()->tid)
+		return EPERM;
+	a_and(&m->_m_lock, ~0x40000000);
+	return 0;
+}
diff --git a/third_party/musl/porting/liteos_a/user/src/thread/pthread_mutex_getprioceiling.c b/third_party/musl/porting/liteos_a/user/src/thread/pthread_mutex_getprioceiling.c
new file mode 100755
index 000000000..c6699947f
--- /dev/null
+++ b/third_party/musl/porting/liteos_a/user/src/thread/pthread_mutex_getprioceiling.c
@@ -0,0 +1,8 @@
+#include <unsupported_api.h>
+#include "pthread_impl.h"
+
+int pthread_mutex_getprioceiling(const pthread_mutex_t *restrict m, int *restrict ceiling)
+{
+	unsupported_api(__FUNCTION__);
+	return EINVAL;
+}
diff --git a/third_party/musl/porting/liteos_a/user/src/thread/pthread_mutex_timedlock.c b/third_party/musl/porting/liteos_a/user/src/thread/pthread_mutex_timedlock.c
new file mode 100755
index 000000000..ef3ffdbfc
--- /dev/null
+++ b/third_party/musl/porting/liteos_a/user/src/thread/pthread_mutex_timedlock.c
@@ -0,0 +1,90 @@
+#include "pthread_impl.h"
+
+#define IS32BIT(x) !((x)+0x80000000ULL>>32)
+#define CLAMP(x) (int)(IS32BIT(x) ? (x) : 0x7fffffffU+((0ULL+(x))>>63))
+
+static int __futex4(volatile void *addr, int op, int val, const struct timespec *to)
+{
+#ifdef SYS_futex_time64
+	time_t s = to ? to->tv_sec : 0;
+	long ns = to ? to->tv_nsec : 0;
+	int r = -ENOSYS;
+	if (SYS_futex == SYS_futex_time64 || !IS32BIT(s))
+		r = __syscall(SYS_futex_time64, addr, op, val,
+			to ? ((long long[]){s, ns}) : 0);
+	if (SYS_futex == SYS_futex_time64 || r!=-ENOSYS) return r;
+	to = to ? (void *)(long[]){CLAMP(s), ns} : 0;
+#endif
+	return __syscall(SYS_futex, addr, op, val, to);
+}
+
+static int pthread_mutex_timedlock_pi(pthread_mutex_t *restrict m, const struct timespec *restrict at)
+{
+	int type = m->_m_type;
+	int priv = (type & 128) ^ 128;
+	pthread_t self = __pthread_self();
+	int e;
+
+	if (!priv) self->robust_list.pending = &m->_m_next;
+
+	do e = -__futex4(&m->_m_lock, FUTEX_LOCK_PI|priv, 0, at);
+	while (e==EINTR);
+	if (e) self->robust_list.pending = 0;
+
+	switch (e) {
+	case 0:
+		/* Catch spurious success for non-robust mutexes. */
+		if (!(type&4) && ((m->_m_lock & 0x40000000) || m->_m_waiters)) {
+			a_store(&m->_m_waiters, -1);
+			__syscall(SYS_futex, &m->_m_lock, FUTEX_UNLOCK_PI|priv);
+			self->robust_list.pending = 0;
+			break;
+		}
+		/* Signal to trylock that we already have the lock. */
+		m->_m_count = -1;
+		return __pthread_mutex_trylock(m);
+	case ETIMEDOUT:
+		return e;
+	case EDEADLK:
+		if ((type&3) == PTHREAD_MUTEX_ERRORCHECK) return e;
+	}
+	do e = __timedwait(&(int){0}, 0, CLOCK_REALTIME, at, 1);
+	while (e != ETIMEDOUT);
+	return e;
+}
+
+int __pthread_mutex_timedlock(pthread_mutex_t *restrict m, const struct timespec *restrict at)
+{
+	if ((m->_m_type&15) == PTHREAD_MUTEX_NORMAL
+	    && !a_cas(&m->_m_lock, 0, EBUSY))
+		return 0;
+
+	int type = m->_m_type;
+	int r, t, priv = (type & 128) ^ 128;
+
+	r = __pthread_mutex_trylock(m);
+	if (r != EBUSY) return r;
+
+	int spins = 100;
+	while (spins-- && m->_m_lock && !m->_m_waiters) a_spin();
+
+	while ((r=__pthread_mutex_trylock(m)) == EBUSY) {
+		r = m->_m_lock;
+		int own = r & 0x3fffffff;
+		if (!r)
+			continue;
+		if ((type&3) == PTHREAD_MUTEX_ERRORCHECK
+		    && own == __pthread_self()->tid)
+			return EDEADLK;
+
+		a_inc(&m->_m_waiters);
+		t = r | 0x80000000;
+		a_cas(&m->_m_lock, r, t);
+		r = __timedwait(&m->_m_lock, t, CLOCK_REALTIME, at, priv);
+		a_dec(&m->_m_waiters);
+		if (r && r != EINTR) break;
+	}
+	return r;
+}
+
+weak_alias(__pthread_mutex_timedlock, pthread_mutex_timedlock);
diff --git a/third_party/musl/porting/liteos_a/user/src/thread/pthread_mutex_trylock.c b/third_party/musl/porting/liteos_a/user/src/thread/pthread_mutex_trylock.c
new file mode 100755
index 000000000..9fb6c5128
--- /dev/null
+++ b/third_party/musl/porting/liteos_a/user/src/thread/pthread_mutex_trylock.c
@@ -0,0 +1,46 @@
+#include "pthread_impl.h"
+
+int __pthread_mutex_trylock_owner(pthread_mutex_t *m)
+{
+	int old, own;
+	int type = m->_m_type;
+	pthread_t self = __pthread_self();
+	int tid = self->tid;
+
+	old = m->_m_lock;
+	own = old & 0x3fffffff;
+	if (own == tid) {
+		if ((type&PTHREAD_MUTEX_TYPE_MASK) == PTHREAD_MUTEX_RECURSIVE) {
+			if ((unsigned)m->_m_count >= INT_MAX) return EAGAIN;
+			m->_m_count++;
+			return 0;
+		}
+	}
+	if (own == 0x3fffffff) return ENOTRECOVERABLE;
+	tid |= 0x80000000;
+	if (own) return EBUSY;
+	if (a_cas(&m->_m_lock, old, tid) != old) {
+		self->robust_list.pending = 0;
+		return EBUSY;
+	}
+
+#if 0
+	volatile void *next = self->robust_list.head;
+	m->_m_next = next;
+	m->_m_prev = &self->robust_list.head;
+	if (next != &self->robust_list.head) *(volatile void *volatile *)
+		((char *)next - sizeof(void *)) = &m->_m_next;
+	self->robust_list.head = &m->_m_next;
+	self->robust_list.pending = 0;
+#endif
+	return 0;
+}
+
+int __pthread_mutex_trylock(pthread_mutex_t *m)
+{
+	if ((m->_m_type&PTHREAD_MUTEX_TYPE_MASK) == PTHREAD_MUTEX_NORMAL)
+		return a_cas(&m->_m_lock, 0, EBUSY) & EBUSY;
+	return __pthread_mutex_trylock_owner(m);
+}
+
+weak_alias(__pthread_mutex_trylock, pthread_mutex_trylock);
diff --git a/third_party/musl/porting/liteos_a/user/src/thread/pthread_mutex_unlock.c b/third_party/musl/porting/liteos_a/user/src/thread/pthread_mutex_unlock.c
new file mode 100755
index 000000000..6922c8f04
--- /dev/null
+++ b/third_party/musl/porting/liteos_a/user/src/thread/pthread_mutex_unlock.c
@@ -0,0 +1,31 @@
+#include "pthread_impl.h"
+
+int __pthread_mutex_unlock(pthread_mutex_t *m)
+{
+	pthread_t self;
+	int waiters = m->_m_waiters;
+	int cont;
+	int type = m->_m_type & PTHREAD_MUTEX_TYPE_MASK;
+	int priv = (m->_m_type & 128) ^ 128;
+	int new = 0;
+	int old;
+
+	if (type != PTHREAD_MUTEX_NORMAL) {
+		self = __pthread_self();
+		old = m->_m_lock;
+		int own = old & 0x3fffffff;
+		if (own != self->tid)
+			return EPERM;
+		if ((type&PTHREAD_MUTEX_TYPE_MASK) == PTHREAD_MUTEX_RECURSIVE && m->_m_count)
+			return m->_m_count--, 0;
+
+	}
+
+	cont = a_swap(&m->_m_lock, new);
+
+	if (waiters || cont<0)
+		__wake(&m->_m_lock, 1, priv);
+	return 0;
+}
+
+weak_alias(__pthread_mutex_unlock, pthread_mutex_unlock);
diff --git a/third_party/musl/porting/liteos_a/user/src/thread/pthread_mutexattr_setprotocol.c b/third_party/musl/porting/liteos_a/user/src/thread/pthread_mutexattr_setprotocol.c
new file mode 100755
index 000000000..cde69b8a1
--- /dev/null
+++ b/third_party/musl/porting/liteos_a/user/src/thread/pthread_mutexattr_setprotocol.c
@@ -0,0 +1,31 @@
+#include "pthread_impl.h"
+#include <unsupported_api.h>
+#include "syscall.h"
+
+static pthread_once_t check_pi_once;
+static int check_pi_result;
+
+static void check_pi()
+{
+	volatile int lk = 0;
+	check_pi_result = -__syscall(SYS_futex, &lk, FUTEX_LOCK_PI, 0, 0);
+}
+
+int pthread_mutexattr_setprotocol(pthread_mutexattr_t *a, int protocol)
+{
+	unsupported_api(__FUNCTION__);
+	switch (protocol) {
+	case PTHREAD_PRIO_NONE:
+		a->__attr &= ~8;
+		return 0;
+	case PTHREAD_PRIO_INHERIT:
+		pthread_once(&check_pi_once, check_pi);
+		if (check_pi_result) return check_pi_result;
+		a->__attr |= 8;
+		return 0;
+	case PTHREAD_PRIO_PROTECT:
+		return ENOTSUP;
+	default:
+		return EINVAL;
+	}
+}
diff --git a/third_party/musl/porting/liteos_a/user/src/thread/pthread_mutexattr_setrobust.c b/third_party/musl/porting/liteos_a/user/src/thread/pthread_mutexattr_setrobust.c
new file mode 100755
index 000000000..859350db3
--- /dev/null
+++ b/third_party/musl/porting/liteos_a/user/src/thread/pthread_mutexattr_setrobust.c
@@ -0,0 +1,27 @@
+#include "pthread_impl.h"
+#include <unsupported_api.h>
+#include "syscall.h"
+
+static pthread_once_t check_robust_once;
+static int check_robust_result;
+
+static void check_robust()
+{
+	void *p;
+	size_t l;
+	check_robust_result = -__syscall(SYS_get_robust_list, 0, &p, &l);
+}
+
+int pthread_mutexattr_setrobust(pthread_mutexattr_t *a, int robust)
+{
+	unsupported_api(__FUNCTION__);
+	if (robust > 1U) return EINVAL;
+	if (robust) {
+		pthread_once(&check_robust_once, check_robust);
+		if (check_robust_result) return check_robust_result;
+		a->__attr |= 4;
+		return 0;
+	}
+	a->__attr &= ~4;
+	return 0;
+}
diff --git a/third_party/musl/porting/liteos_a/user/src/thread/pthread_self.c b/third_party/musl/porting/liteos_a/user/src/thread/pthread_self.c
new file mode 100755
index 000000000..886ea4029
--- /dev/null
+++ b/third_party/musl/porting/liteos_a/user/src/thread/pthread_self.c
@@ -0,0 +1,17 @@
+#include "pthread_impl.h"
+#include <threads.h>
+
+pthread_t __pthread_self()
+{
+	uintptr_t p;
+	p = __syscall(SYS_get_thread_area);
+	return (void *)(p - sizeof(struct pthread));
+}
+
+static pthread_t __pthread_self_internal()
+{
+	return __pthread_self();
+}
+
+weak_alias(__pthread_self_internal, pthread_self);
+weak_alias(__pthread_self_internal, thrd_current);
diff --git a/third_party/musl/porting/liteos_a/user/src/thread/pthread_setconcurrency.c b/third_party/musl/porting/liteos_a/user/src/thread/pthread_setconcurrency.c
new file mode 100755
index 000000000..a39423332
--- /dev/null
+++ b/third_party/musl/porting/liteos_a/user/src/thread/pthread_setconcurrency.c
@@ -0,0 +1,11 @@
+#include <pthread.h>
+#include <errno.h>
+#include <unsupported_api.h>
+
+int pthread_setconcurrency(int val)
+{
+	unsupported_api(__FUNCTION__);
+	if (val < 0) return EINVAL;
+	if (val > 0) return EAGAIN;
+	return 0;
+}
diff --git a/third_party/musl/porting/liteos_a/user/src/thread/pthread_setschedparam.c b/third_party/musl/porting/liteos_a/user/src/thread/pthread_setschedparam.c
new file mode 100755
index 000000000..1d781d132
--- /dev/null
+++ b/third_party/musl/porting/liteos_a/user/src/thread/pthread_setschedparam.c
@@ -0,0 +1,20 @@
+#include "pthread_impl.h"
+#include "lock.h"
+
+int pthread_setschedparam(pthread_t t, int policy, const struct sched_param *param)
+{
+	int r;
+
+	if (policy != SCHED_RR && policy != SCHED_FIFO) {
+		return EINVAL;
+	}
+
+	if (param->sched_priority < 0 || param->sched_priority > PTHREAD_PRIORITY_LOWEST) {
+		return EINVAL;
+	}
+
+	LOCK(t->killlock);
+	r = !t->tid ? ESRCH : -__syscall(SYS_sched_setscheduler, t->tid, policy, param->sched_priority, MUSL_TYPE_THREAD);
+	UNLOCK(t->killlock);
+	return r;
+}
diff --git a/third_party/musl/porting/liteos_a/user/src/thread/pthread_setschedprio.c b/third_party/musl/porting/liteos_a/user/src/thread/pthread_setschedprio.c
new file mode 100755
index 000000000..68bf3486d
--- /dev/null
+++ b/third_party/musl/porting/liteos_a/user/src/thread/pthread_setschedprio.c
@@ -0,0 +1,16 @@
+#include "pthread_impl.h"
+#include "lock.h"
+
+int pthread_setschedprio(pthread_t t, int prio)
+{
+	int r;
+
+	if (prio < 0 || prio > PTHREAD_PRIORITY_LOWEST) {
+		return EINVAL;
+	}
+
+	LOCK(t->killlock);
+	r = !t->tid ? ESRCH : -__syscall(SYS_sched_setparam, t->tid, prio, MUSL_TYPE_THREAD);
+	UNLOCK(t->killlock);
+	return r;
+}
diff --git a/third_party/musl/porting/liteos_a/user/src/thread/sem_open.c b/third_party/musl/porting/liteos_a/user/src/thread/sem_open.c
new file mode 100755
index 000000000..f85eecb7d
--- /dev/null
+++ b/third_party/musl/porting/liteos_a/user/src/thread/sem_open.c
@@ -0,0 +1,171 @@
+#include <semaphore.h>
+#include <sys/mman.h>
+#include <limits.h>
+#include <fcntl.h>
+#include <unistd.h>
+#include <string.h>
+#include <stdarg.h>
+#include <errno.h>
+#include <time.h>
+#include <stdio.h>
+#include <sys/stat.h>
+#include <stdlib.h>
+#include <pthread.h>
+#include "lock.h"
+
+static struct {
+	ino_t ino;
+	sem_t *sem;
+	int refcnt;
+} *semtab;
+static volatile int lock[1];
+
+#define FLAGS (O_RDWR|O_NOFOLLOW|O_CLOEXEC|O_NONBLOCK)
+
+sem_t *sem_open(const char *name, int flags, ...)
+{
+	va_list ap;
+	mode_t mode;
+	unsigned value;
+	int fd, i, e, slot, first=1, cnt, cs;
+	sem_t newsem;
+	void *map;
+	char tmp[64];
+	struct timespec ts;
+	struct stat st;
+	char buf[NAME_MAX+10];
+
+	if (!(name = __shm_mapname(name, buf)))
+		return SEM_FAILED;
+
+	LOCK(lock);
+	/* Allocate table if we don't have one yet */
+	if (!semtab && !(semtab = calloc(sizeof *semtab, SEM_NSEMS_MAX))) {
+		UNLOCK(lock);
+		return SEM_FAILED;
+	}
+
+	/* Reserve a slot in case this semaphore is not mapped yet;
+	 * this is necessary because there is no way to handle
+	 * failures after creation of the file. */
+	slot = -1;
+	for (cnt=i=0; i<SEM_NSEMS_MAX; i++) {
+		cnt += semtab[i].refcnt;
+		if (!semtab[i].sem && slot < 0) slot = i;
+	}
+	/* Avoid possibility of overflow later */
+	if (cnt == INT_MAX || slot < 0) {
+		errno = EMFILE;
+		UNLOCK(lock);
+		return SEM_FAILED;
+	}
+	/* Dummy pointer to make a reservation */
+	semtab[slot].sem = (sem_t *)-1;
+	UNLOCK(lock);
+
+	flags &= (O_CREAT|O_EXCL);
+
+	pthread_setcancelstate(PTHREAD_CANCEL_DISABLE, &cs);
+
+	/* Early failure check for exclusive open; otherwise the case
+	 * where the semaphore already exists is expensive. */
+	if (flags == (O_CREAT|O_EXCL) && access(name, F_OK) == 0) {
+		errno = EEXIST;
+		goto fail;
+	}
+
+	for (;;) {
+		/* If exclusive mode is not requested, try opening an
+		 * existing file first and fall back to creation. */
+		if (flags != (O_CREAT|O_EXCL)) {
+			fd = open(name, FLAGS);
+			if (fd >= 0) {
+				if (fstat(fd, &st) < 0 ||
+				    (map = mmap(0, sizeof(sem_t), PROT_READ|PROT_WRITE, MAP_SHARED, fd, 0)) == MAP_FAILED) {
+					close(fd);
+					goto fail;
+				}
+				break;
+			}
+			if (errno != ENOENT)
+				goto fail;
+		}
+		if (!(flags & O_CREAT))
+			goto fail;
+		if (first) {
+			first = 0;
+			va_start(ap, flags);
+			mode = va_arg(ap, mode_t) & 0666;
+			value = va_arg(ap, unsigned);
+			va_end(ap);
+			if (value > SEM_VALUE_MAX) {
+				errno = EINVAL;
+				goto fail;
+			}
+			sem_init(&newsem, 1, value);
+		}
+		/* Create a temp file with the new semaphore contents
+		 * and attempt to atomically link it as the new name */
+		clock_gettime(CLOCK_REALTIME, &ts);
+		snprintf(tmp, sizeof(tmp), "/dev/shm/tmp-%d", (int)ts.tv_nsec);
+		fd = open(tmp, O_CREAT|O_EXCL|FLAGS, mode);
+		if (fd < 0) {
+			if (errno == EEXIST) continue;
+			goto fail;
+		}
+		if (write(fd, &newsem, sizeof newsem) != sizeof newsem || fstat(fd, &st) < 0 ||
+		    (map = mmap(0, sizeof(sem_t), PROT_READ|PROT_WRITE, MAP_SHARED, fd, 0)) == MAP_FAILED) {
+			close(fd);
+			unlink(tmp);
+			goto fail;
+		}
+		e = link(tmp, name) ? errno : 0;
+		unlink(tmp);
+		if (!e) break;
+		munmap(map, sizeof(sem_t));
+		/* Failure is only fatal when doing an exclusive open;
+		 * otherwise, next iteration will try to open the
+		 * existing file. */
+		if (e != EEXIST || flags == (O_CREAT|O_EXCL))
+			goto fail;
+	}
+
+	/* See if the newly mapped semaphore is already mapped. If
+	 * so, unmap the new mapping and use the existing one. Otherwise,
+	 * add it to the table of mapped semaphores. */
+	LOCK(lock);
+	for (i=0; i<SEM_NSEMS_MAX && semtab[i].ino != st.st_ino; i++);
+	if (i<SEM_NSEMS_MAX) {
+		munmap(map, sizeof(sem_t));
+		semtab[slot].sem = 0;
+		slot = i;
+		map = semtab[i].sem;
+	}
+	semtab[slot].refcnt++;
+	semtab[slot].sem = map;
+	semtab[slot].ino = st.st_ino;
+	UNLOCK(lock);
+	pthread_setcancelstate(cs, 0);
+	return map;
+
+fail:
+	pthread_setcancelstate(cs, 0);
+	LOCK(lock);
+	semtab[slot].sem = 0;
+	UNLOCK(lock);
+	return SEM_FAILED;
+}
+
+int sem_close(sem_t *sem)
+{
+	int i;
+	LOCK(lock);
+	for (i=0; i<SEM_NSEMS_MAX && semtab[i].sem != sem; i++);
+	if (!--semtab[i].refcnt) {
+		semtab[i].sem = 0;
+		semtab[i].ino = 0;
+	}
+	UNLOCK(lock);
+	munmap(sem, sizeof *sem);
+	return 0;
+}
diff --git a/third_party/musl/porting/liteos_a/user/src/thread/thrd_yield.c b/third_party/musl/porting/liteos_a/user/src/thread/thrd_yield.c
new file mode 100755
index 000000000..4138c146f
--- /dev/null
+++ b/third_party/musl/porting/liteos_a/user/src/thread/thrd_yield.c
@@ -0,0 +1,7 @@
+#include <threads.h>
+#include "syscall.h"
+
+void thrd_yield()
+{
+	__syscall(SYS_sched_yield, -1);
+}
diff --git a/third_party/musl/porting/liteos_a/user/src/time/__map_file.c b/third_party/musl/porting/liteos_a/user/src/time/__map_file.c
new file mode 100755
index 000000000..80e0df3db
--- /dev/null
+++ b/third_party/musl/porting/liteos_a/user/src/time/__map_file.c
@@ -0,0 +1,21 @@
+#include <sys/mman.h>
+#include <fcntl.h>
+#include <sys/stat.h>
+#include "syscall.h"
+#include "kstat.h"
+
+const char unsigned *__map_file(const char *pathname, size_t *size)
+{
+	struct kstat st;
+	const unsigned char *map = MAP_FAILED;
+	int fd = sys_open(pathname, O_RDONLY|O_CLOEXEC|O_NONBLOCK);
+	if (fd < 0) return 0;
+	if (!syscall(SYS_fstat, fd, &st)) {
+		map = __mmap(0, st.st_size, PROT_READ, MAP_SHARED, fd, 0);
+		*size = st.st_size;
+	}
+	if (map == MAP_FAILED) {
+		__syscall(SYS_close, fd);
+	}
+	return map == MAP_FAILED ? 0 : map;
+}
diff --git a/third_party/musl/porting/liteos_a/user/src/time/__tz.c b/third_party/musl/porting/liteos_a/user/src/time/__tz.c
new file mode 100755
index 000000000..0ff172f9d
--- /dev/null
+++ b/third_party/musl/porting/liteos_a/user/src/time/__tz.c
@@ -0,0 +1,424 @@
+#include "time_impl.h"
+#include <stdint.h>
+#include <limits.h>
+#include <stdlib.h>
+#include <string.h>
+#include <sys/mman.h>
+#include "libc.h"
+#include "lock.h"
+#include <unsupported_api.h>
+
+long  __timezone = 0;
+int   __daylight = 0;
+char *__tzname[2] = { 0, 0 };
+
+weak_alias(__timezone, timezone);
+weak_alias(__daylight, daylight);
+weak_alias(__tzname, tzname);
+
+static char std_name[TZNAME_MAX+1];
+static char dst_name[TZNAME_MAX+1];
+const char __utc[] = "UTC";
+
+static int dst_off;
+static int r0[5], r1[5];
+
+static const unsigned char *zi, *trans, *index, *types, *abbrevs, *abbrevs_end;
+static size_t map_size;
+
+static char old_tz_buf[32];
+static char *old_tz = old_tz_buf;
+static size_t old_tz_size = sizeof old_tz_buf;
+
+static volatile int lock[1];
+
+static int getint(const char **p)
+{
+	unsigned x;
+	for (x=0; **p-'0'<10U; (*p)++) x = **p-'0' + 10*x;
+	return x;
+}
+
+static int getoff(const char **p)
+{
+	int neg = 0;
+	if (**p == '-') {
+		++*p;
+		neg = 1;
+	} else if (**p == '+') {
+		++*p;
+	}
+	int off = 3600*getint(p);
+	if (**p == ':') {
+		++*p;
+		off += 60*getint(p);
+		if (**p == ':') {
+			++*p;
+			off += getint(p);
+		}
+	}
+	return neg ? -off : off;
+}
+
+static void getrule(const char **p, int rule[5])
+{
+	int r = rule[0] = **p;
+
+	if (r!='M') {
+		if (r=='J') ++*p;
+		else rule[0] = 0;
+		rule[1] = getint(p);
+	} else {
+		++*p; rule[1] = getint(p);
+		++*p; rule[2] = getint(p);
+		++*p; rule[3] = getint(p);
+	}
+
+	if (**p=='/') {
+		++*p;
+		rule[4] = getoff(p);
+	} else {
+		rule[4] = 7200;
+	}
+}
+
+static void getname(char *d, const char **p)
+{
+	int i;
+	if (**p == '<') {
+		++*p;
+		for (i=0; (*p)[i]!='>' && i<TZNAME_MAX; i++)
+			d[i] = (*p)[i];
+		++*p;
+	} else {
+		for (i=0; ((*p)[i]|32)-'a'<26U && i<TZNAME_MAX; i++)
+			d[i] = (*p)[i];
+	}
+	*p += i;
+	d[i] = 0;
+}
+
+#define VEC(...) ((const unsigned char[]){__VA_ARGS__})
+
+static uint32_t zi_read32(const unsigned char *z)
+{
+	return (unsigned)z[0]<<24 | z[1]<<16 | z[2]<<8 | z[3];
+}
+
+static size_t zi_dotprod(const unsigned char *z, const unsigned char *v, size_t n)
+{
+	size_t y;
+	uint32_t x;
+	for (y=0; n; n--, z+=4, v++) {
+		x = zi_read32(z);
+		y += x * *v;
+	}
+	return y;
+}
+
+static void do_tzset()
+{
+	char buf[NAME_MAX+25], *pathname=buf+24;
+	const char *try, *s, *p;
+	const unsigned char *map = 0;
+	size_t i;
+	static const char search[] =
+		"/usr/share/zoneinfo/\0/share/zoneinfo/\0/etc/zoneinfo/\0";
+
+	s = getenv("TZ");
+	if (!s) s = "/etc/localtime";
+	if (!*s) s = __utc;
+
+	if (old_tz && !strcmp(s, old_tz)) return;
+
+	for (i=0; i<5; i++) r0[i] = r1[i] = 0;
+
+	if (zi) __munmap((void *)zi, map_size);
+
+	/* Cache the old value of TZ to check if it has changed. Avoid
+	 * free so as not to pull it into static programs. Growth
+	 * strategy makes it so free would have minimal benefit anyway. */
+	i = strlen(s);
+	if (i > PATH_MAX+1) s = __utc, i = 3;
+	if (i >= old_tz_size) {
+		old_tz_size *= 2;
+		if (i >= old_tz_size) old_tz_size = i+1;
+		if (old_tz_size > PATH_MAX+2) old_tz_size = PATH_MAX+2;
+		old_tz = malloc(old_tz_size);
+	}
+	if (old_tz) memcpy(old_tz, s, i+1);
+
+	/* Non-suid can use an absolute tzfile pathname or a relative
+	 * pathame beginning with "."; in secure mode, only the
+	 * standard path will be searched. */
+	if (*s == ':' || ((p=strchr(s, '/')) && !memchr(s, ',', p-s))) {
+		if (*s == ':') s++;
+		if (*s == '/' || *s == '.') {
+			if (!libc.secure || !strcmp(s, "/etc/localtime"))
+				map = __map_file(s, &map_size);
+		} else {
+			size_t l = strlen(s);
+			if (l <= NAME_MAX && !strchr(s, '.')) {
+				memcpy(pathname, s, l+1);
+				pathname[l] = 0;
+				for (try=search; !map && *try; try+=l+1) {
+					l = strlen(try);
+					memcpy(pathname-l, try, l);
+					map = __map_file(pathname-l, &map_size);
+				}
+			}
+		}
+		if (!map) s = __utc;
+	}
+	if (map && (map_size < 44 || memcmp(map, "TZif", 4))) {
+		__munmap((void *)map, map_size);
+		map = 0;
+		s = __utc;
+	}
+
+	zi = map;
+	if (map) {
+		int scale = 2;
+		if (sizeof(time_t) > 4 && map[4]=='2') {
+			size_t skip = zi_dotprod(zi+20, VEC(1,1,8,5,6,1), 6);
+			trans = zi+skip+44+44;
+			scale++;
+		} else {
+			trans = zi+44;
+		}
+		index = trans + (zi_read32(trans-12) << scale);
+		types = index + zi_read32(trans-12);
+		abbrevs = types + 6*zi_read32(trans-8);
+		abbrevs_end = abbrevs + zi_read32(trans-4);
+		if (zi[map_size-1] == '\n') {
+			for (s = (const char *)zi+map_size-2; *s!='\n'; s--);
+			s++;
+		} else {
+			const unsigned char *p;
+			__tzname[0] = __tzname[1] = 0;
+			__daylight = __timezone = dst_off = 0;
+			for (p=types; p<abbrevs; p+=6) {
+				if (!p[4] && !__tzname[0]) {
+					__tzname[0] = (char *)abbrevs + p[5];
+					__timezone = -zi_read32(p);
+				}
+				if (p[4] && !__tzname[1]) {
+					__tzname[1] = (char *)abbrevs + p[5];
+					dst_off = -zi_read32(p);
+					__daylight = 1;
+				}
+			}
+			if (!__tzname[0]) __tzname[0] = __tzname[1];
+			if (!__tzname[0]) __tzname[0] = (char *)__utc;
+			if (!__daylight) {
+				__tzname[1] = __tzname[0];
+				dst_off = __timezone;
+			}
+			return;
+		}
+	}
+
+	if (!s) s = __utc;
+	getname(std_name, &s);
+	__tzname[0] = std_name;
+	__timezone = getoff(&s);
+	getname(dst_name, &s);
+	__tzname[1] = dst_name;
+	if (dst_name[0]) {
+		__daylight = 1;
+		if (*s == '+' || *s=='-' || *s-'0'<10U)
+			dst_off = getoff(&s);
+		else
+			dst_off = __timezone - 3600;
+	} else {
+		__daylight = 0;
+		dst_off = __timezone;
+	}
+
+	if (*s == ',') s++, getrule(&s, r0);
+	if (*s == ',') s++, getrule(&s, r1);
+}
+
+/* Search zoneinfo rules to find the one that applies to the given time,
+ * and determine alternate opposite-DST-status rule that may be needed. */
+
+static size_t scan_trans(long long t, int local, size_t *alt)
+{
+	int scale = 3 - (trans == zi+44);
+	uint64_t x;
+	int off = 0;
+
+	size_t a = 0, n = (index-trans)>>scale, m;
+
+	if (!n) {
+		if (alt) *alt = 0;
+		return 0;
+	}
+
+	/* Binary search for 'most-recent rule before t'. */
+	while (n > 1) {
+		m = a + n/2;
+		x = zi_read32(trans + (m<<scale));
+		if (scale == 3) x = x<<32 | zi_read32(trans + (m<<scale) + 4);
+		else x = (int32_t)x;
+		if (local) off = (int32_t)zi_read32(types + 6 * index[m-1]);
+		if (t - off < (int64_t)x) {
+			n /= 2;
+		} else {
+			a = m;
+			n -= n/2;
+		}
+	}
+
+	/* First and last entry are special. First means to use lowest-index
+	 * non-DST type. Last means to apply POSIX-style rule if available. */
+	n = (index-trans)>>scale;
+	if (a == n-1) return -1;
+	if (a == 0) {
+		x = zi_read32(trans + (a<<scale));
+		if (scale == 3) x = x<<32 | zi_read32(trans + (a<<scale) + 4);
+		else x = (int32_t)x;
+		if (local) off = (int32_t)zi_read32(types + 6 * index[a-1]);
+		if (t - off < (int64_t)x) {
+			for (a=0; a<(abbrevs-types)/6; a++) {
+				if (types[6*a+4] != types[4]) break;
+			}
+			if (a == (abbrevs-types)/6) a = 0;
+			if (types[6*a+4]) {
+				*alt = a;
+				return 0;
+			} else {
+				*alt = 0;
+				return a;
+			}
+		}
+	}
+
+	/* Try to find a neighboring opposite-DST-status rule. */
+	if (alt) {
+		if (a && types[6*index[a-1]+4] != types[6*index[a]+4])
+			*alt = index[a-1];
+		else if (a+1<n && types[6*index[a+1]+4] != types[6*index[a]+4])
+			*alt = index[a+1];
+		else
+			*alt = index[a];
+	}
+
+	return index[a];
+}
+
+static int days_in_month(int m, int is_leap)
+{
+	if (m==2) return 28+is_leap;
+	else return 30+((0xad5>>(m-1))&1);
+}
+
+/* Convert a POSIX DST rule plus year to seconds since epoch. */
+
+static long long rule_to_secs(const int *rule, int year)
+{
+	int is_leap;
+	long long t = __year_to_secs(year, &is_leap);
+	int x, m, n, d;
+	if (rule[0]!='M') {
+		x = rule[1];
+		if (rule[0]=='J' && (x < 60 || !is_leap)) x--;
+		t += 86400 * x;
+	} else {
+		m = rule[1];
+		n = rule[2];
+		d = rule[3];
+		t += __month_to_secs(m-1, is_leap);
+		int wday = (int)((t + 4*86400) % (7*86400)) / 86400;
+		int days = d - wday;
+		if (days < 0) days += 7;
+		if (n == 5 && days+28 >= days_in_month(m, is_leap)) n = 4;
+		t += 86400 * (days + 7*(n-1));
+	}
+	t += rule[4];
+	return t;
+}
+
+/* Determine the time zone in effect for a given time in seconds since the
+ * epoch. It can be given in local or universal time. The results will
+ * indicate whether DST is in effect at the queried time, and will give both
+ * the GMT offset for the active zone/DST rule and the opposite DST. This
+ * enables a caller to efficiently adjust for the case where an explicit
+ * DST specification mismatches what would be in effect at the time. */
+
+void __secs_to_zone(long long t, int local, int *isdst, long *offset, long *oppoff, const char **zonename)
+{
+	LOCK(lock);
+
+	do_tzset();
+
+	if (zi) {
+		size_t alt, i = scan_trans(t, local, &alt);
+		if (i != -1) {
+			*isdst = types[6*i+4];
+			*offset = (int32_t)zi_read32(types+6*i);
+			*zonename = (const char *)abbrevs + types[6*i+5];
+			if (oppoff) *oppoff = (int32_t)zi_read32(types+6*alt);
+			UNLOCK(lock);
+			return;
+		}
+	}
+
+	if (!__daylight) goto std;
+
+	/* FIXME: may be broken if DST changes right at year boundary?
+	 * Also, this could be more efficient.*/
+	long long y = t / 31556952 + 70;
+	while (__year_to_secs(y, 0) > t) y--;
+	while (__year_to_secs(y+1, 0) < t) y++;
+
+	long long t0 = rule_to_secs(r0, y);
+	long long t1 = rule_to_secs(r1, y);
+
+	if (!local) {
+		t0 += __timezone;
+		t1 += dst_off;
+	}
+	if (t0 < t1) {
+		if (t >= t0 && t < t1) goto dst;
+		goto std;
+	} else {
+		if (t >= t1 && t < t0) goto std;
+		goto dst;
+	}
+std:
+	*isdst = 0;
+	*offset = -__timezone;
+	if (oppoff) *oppoff = -dst_off;
+	*zonename = __tzname[0];
+	UNLOCK(lock);
+	return;
+dst:
+	*isdst = 1;
+	*offset = -dst_off;
+	if (oppoff) *oppoff = -__timezone;
+	*zonename = __tzname[1];
+	UNLOCK(lock);
+}
+
+static void __tzset()
+{
+	unsupported_api(__FUNCTION__);
+	LOCK(lock);
+	do_tzset();
+	UNLOCK(lock);
+}
+
+weak_alias(__tzset, tzset);
+
+const char *__tm_to_tzname(const struct tm *tm)
+{
+	const void *p = tm->__tm_zone;
+	LOCK(lock);
+	do_tzset();
+	if (p != __utc && p != __tzname[0] && p != __tzname[1] &&
+	    (!zi || (uintptr_t)p-(uintptr_t)abbrevs >= abbrevs_end - abbrevs))
+		p = "";
+	UNLOCK(lock);
+	return p;
+}
diff --git a/third_party/musl/porting/liteos_a/user/src/time/clock.c b/third_party/musl/porting/liteos_a/user/src/time/clock.c
new file mode 100755
index 000000000..06994710b
--- /dev/null
+++ b/third_party/musl/porting/liteos_a/user/src/time/clock.c
@@ -0,0 +1,18 @@
+#include <time.h>
+#include <limits.h>
+#include <unsupported_api.h>
+
+clock_t clock()
+{
+	struct timespec ts;
+
+	unsupported_api(__FUNCTION__);
+	if (__clock_gettime(CLOCK_PROCESS_CPUTIME_ID, &ts))
+		return -1;
+
+	if (ts.tv_sec > LONG_MAX/1000000
+	 || ts.tv_nsec/1000 > LONG_MAX-1000000*ts.tv_sec)
+		return -1;
+
+	return ts.tv_sec*1000000 + ts.tv_nsec/1000;
+}
diff --git a/third_party/musl/porting/liteos_a/user/src/time/times.c b/third_party/musl/porting/liteos_a/user/src/time/times.c
new file mode 100755
index 000000000..9c50144f6
--- /dev/null
+++ b/third_party/musl/porting/liteos_a/user/src/time/times.c
@@ -0,0 +1,7 @@
+#include <sys/times.h>
+#include "syscall.h"
+
+clock_t times(struct tms *tms)
+{
+	return syscall(SYS_times, tms);
+}
diff --git a/third_party/musl/porting/liteos_a/user/src/time/utime.c b/third_party/musl/porting/liteos_a/user/src/time/utime.c
new file mode 100755
index 000000000..36279de35
--- /dev/null
+++ b/third_party/musl/porting/liteos_a/user/src/time/utime.c
@@ -0,0 +1,13 @@
+#include <utime.h>
+#include <sys/stat.h>
+#include <time.h>
+#include <fcntl.h>
+#include <unsupported_api.h>
+
+int utime(const char *path, const struct utimbuf *times)
+{
+	unsupported_api(__FUNCTION__);
+	return utimensat(AT_FDCWD, path, times ? ((struct timespec [2]){
+		{ .tv_sec = times->actime }, { .tv_sec = times->modtime }})
+		: 0, 0);
+}
diff --git a/third_party/musl/porting/liteos_a/user/src/unistd/ctermid.c b/third_party/musl/porting/liteos_a/user/src/unistd/ctermid.c
new file mode 100755
index 000000000..dc30487f7
--- /dev/null
+++ b/third_party/musl/porting/liteos_a/user/src/unistd/ctermid.c
@@ -0,0 +1,9 @@
+#include <stdio.h>
+#include <string.h>
+#include <unsupported_api.h>
+
+char *ctermid(char *s)
+{
+	unsupported_api(__FUNCTION__);
+	return s ? strcpy(s, "/dev/tty") : "/dev/tty";
+}
diff --git a/third_party/musl/porting/liteos_a/user/src/unistd/faccessat.c b/third_party/musl/porting/liteos_a/user/src/unistd/faccessat.c
new file mode 100755
index 000000000..29e24e03a
--- /dev/null
+++ b/third_party/musl/porting/liteos_a/user/src/unistd/faccessat.c
@@ -0,0 +1,58 @@
+#include <unistd.h>
+#include <fcntl.h>
+#include <sys/wait.h>
+#include <unsupported_api.h>
+#include "syscall.h"
+#include "pthread_impl.h"
+
+struct ctx {
+	int fd;
+	const char *filename;
+	int amode;
+	int p;
+};
+
+static int checker(void *p)
+{
+	struct ctx *c = p;
+	int ret;
+	if (__syscall(SYS_setregid, __syscall(SYS_getegid), -1)
+	    || __syscall(SYS_setreuid, __syscall(SYS_geteuid), -1))
+		__syscall(SYS_exit, 1);
+	ret = __syscall(SYS_faccessat, c->fd, c->filename, c->amode, 0);
+	__syscall(SYS_write, c->p, &ret, sizeof ret);
+	return 0;
+}
+
+int faccessat(int fd, const char *filename, int amode, int flag)
+{
+	unsupported_api(__FUNCTION__);
+	if (!flag || (flag==AT_EACCESS && getuid()==geteuid() && getgid()==getegid()))
+		return syscall(SYS_faccessat, fd, filename, amode, flag);
+
+	if (flag != AT_EACCESS)
+		return __syscall_ret(-EINVAL);
+
+	char stack[1024];
+	sigset_t set;
+	pid_t pid;
+	int status;
+	int ret, p[2];
+
+	if (pipe2(p, O_CLOEXEC)) return __syscall_ret(-EBUSY);
+	struct ctx c = { .fd = fd, .filename = filename, .amode = amode, .p = p[1] };
+
+	__block_all_sigs(&set);
+	
+	pid = __clone(checker, stack+sizeof stack, 0, &c);
+	__syscall(SYS_close, p[1]);
+
+	if (pid<0 || __syscall(SYS_read, p[0], &ret, sizeof ret) != sizeof(ret))
+		ret = -EBUSY;
+	__syscall(SYS_close, p[0]);
+	__syscall(SYS_wait4, pid, &status, __WCLONE, 0);
+
+	__restore_sigs(&set);
+
+	return __syscall_ret(ret);
+}
diff --git a/third_party/musl/porting/liteos_a/user/src/unistd/fchdir.c b/third_party/musl/porting/liteos_a/user/src/unistd/fchdir.c
new file mode 100755
index 000000000..54f9eb232
--- /dev/null
+++ b/third_party/musl/porting/liteos_a/user/src/unistd/fchdir.c
@@ -0,0 +1,18 @@
+#include <unistd.h>
+#include <errno.h>
+#include <fcntl.h>
+#include <unsupported_api.h>
+
+#include "syscall.h"
+
+int fchdir(int fd)
+{
+	unsupported_api(__FUNCTION__);
+	int ret = __syscall(SYS_fchdir, fd);
+	if (ret != -EBADF || __syscall(SYS_fcntl, fd, F_GETFD) < 0)
+		return __syscall_ret(ret);
+
+	char buf[15+3*sizeof(int)];
+	__procfdname(buf, fd);
+	return syscall(SYS_chdir, buf);
+}
diff --git a/third_party/musl/porting/liteos_a/user/src/unistd/fchown.c b/third_party/musl/porting/liteos_a/user/src/unistd/fchown.c
new file mode 100755
index 000000000..441e39cb4
--- /dev/null
+++ b/third_party/musl/porting/liteos_a/user/src/unistd/fchown.c
@@ -0,0 +1,23 @@
+#include <unistd.h>
+#include <errno.h>
+#include <fcntl.h>
+#include <unsupported_api.h>
+
+#include "syscall.h"
+
+int fchown(int fd, uid_t uid, gid_t gid)
+{
+	unsupported_api(__FUNCTION__);
+	int ret = __syscall(SYS_fchown, fd, uid, gid);
+	if (ret != -EBADF || __syscall(SYS_fcntl, fd, F_GETFD) < 0)
+		return __syscall_ret(ret);
+
+	char buf[15+3*sizeof(int)];
+	__procfdname(buf, fd);
+#ifdef SYS_chown
+	return syscall(SYS_chown, buf, uid, gid);
+#else
+	return syscall(SYS_fchownat, AT_FDCWD, buf, uid, gid, 0);
+#endif
+
+}
diff --git a/third_party/musl/porting/liteos_a/user/src/unistd/fchownat.c b/third_party/musl/porting/liteos_a/user/src/unistd/fchownat.c
new file mode 100755
index 000000000..88fce2c18
--- /dev/null
+++ b/third_party/musl/porting/liteos_a/user/src/unistd/fchownat.c
@@ -0,0 +1,10 @@
+#include <unistd.h>
+#include <unsupported_api.h>
+
+#include "syscall.h"
+
+int fchownat(int fd, const char *path, uid_t uid, gid_t gid, int flag)
+{
+	unsupported_api(__FUNCTION__);
+	return syscall(SYS_fchownat, fd, path, uid, gid, flag);
+}
diff --git a/third_party/musl/porting/liteos_a/user/src/unistd/fdatasync.c b/third_party/musl/porting/liteos_a/user/src/unistd/fdatasync.c
new file mode 100755
index 000000000..ee88d08da
--- /dev/null
+++ b/third_party/musl/porting/liteos_a/user/src/unistd/fdatasync.c
@@ -0,0 +1,10 @@
+#include <unistd.h>
+#include <unsupported_api.h>
+
+#include "syscall.h"
+
+int fdatasync(int fd)
+{
+	unsupported_api(__FUNCTION__);
+	return syscall_cp(SYS_fdatasync, fd);
+}
diff --git a/third_party/musl/src/unistd/format.c b/third_party/musl/porting/liteos_a/user/src/unistd/format.c
old mode 100644
new mode 100755
similarity index 100%
rename from third_party/musl/src/unistd/format.c
rename to third_party/musl/porting/liteos_a/user/src/unistd/format.c
diff --git a/third_party/musl/porting/liteos_a/user/src/unistd/gethostname.c b/third_party/musl/porting/liteos_a/user/src/unistd/gethostname.c
new file mode 100755
index 000000000..91eecdf7a
--- /dev/null
+++ b/third_party/musl/porting/liteos_a/user/src/unistd/gethostname.c
@@ -0,0 +1,15 @@
+#include <unistd.h>
+#include <sys/utsname.h>
+#include <unsupported_api.h>
+
+int gethostname(char *name, size_t len)
+{
+	size_t i;
+	struct utsname uts;
+	unsupported_api(__FUNCTION__);
+	if (uname(&uts)) return -1;
+	if (len > sizeof uts.nodename) len = sizeof uts.nodename;
+	for (i=0; i<len && (name[i] = uts.nodename[i]); i++);
+	if (i && i==len) name[i-1] = 0;
+	return 0;
+}
diff --git a/third_party/musl/porting/liteos_a/user/src/unistd/getlogin.c b/third_party/musl/porting/liteos_a/user/src/unistd/getlogin.c
new file mode 100755
index 000000000..004a9c4d1
--- /dev/null
+++ b/third_party/musl/porting/liteos_a/user/src/unistd/getlogin.c
@@ -0,0 +1,9 @@
+#include <unistd.h>
+#include <stdlib.h>
+#include <unsupported_api.h>
+
+char *getlogin(void)
+{
+	unsupported_api(__FUNCTION__);
+	return getenv("LOGNAME");
+}
diff --git a/third_party/musl/porting/liteos_a/user/src/unistd/getlogin_r.c b/third_party/musl/porting/liteos_a/user/src/unistd/getlogin_r.c
new file mode 100755
index 000000000..41bd656ef
--- /dev/null
+++ b/third_party/musl/porting/liteos_a/user/src/unistd/getlogin_r.c
@@ -0,0 +1,14 @@
+#include <unistd.h>
+#include <string.h>
+#include <errno.h>
+#include <unsupported_api.h>
+
+int getlogin_r(char *name, size_t size)
+{
+	char *logname = getlogin();
+	unsupported_api(__FUNCTION__);
+	if (!logname) return ENXIO; /* or...? */
+	if (strlen(logname) >= size) return ERANGE;
+	strcpy(name, logname);
+	return 0;
+}
diff --git a/third_party/musl/porting/liteos_a/user/src/unistd/getsid.c b/third_party/musl/porting/liteos_a/user/src/unistd/getsid.c
new file mode 100755
index 000000000..ecb02e0b0
--- /dev/null
+++ b/third_party/musl/porting/liteos_a/user/src/unistd/getsid.c
@@ -0,0 +1,9 @@
+#include <unistd.h>
+#include "syscall.h"
+#include <unsupported_api.h>
+
+pid_t getsid(pid_t pid)
+{
+	unsupported_api(__FUNCTION__);
+	return syscall(SYS_getsid, pid);
+}
diff --git a/third_party/musl/porting/liteos_a/user/src/unistd/lchown.c b/third_party/musl/porting/liteos_a/user/src/unistd/lchown.c
new file mode 100755
index 000000000..e155ee02d
--- /dev/null
+++ b/third_party/musl/porting/liteos_a/user/src/unistd/lchown.c
@@ -0,0 +1,14 @@
+#include <unistd.h>
+#include <fcntl.h>
+#include "syscall.h"
+#include <unsupported_api.h>
+
+int lchown(const char *path, uid_t uid, gid_t gid)
+{
+	unsupported_api(__FUNCTION__);
+#ifdef SYS_lchown
+	return syscall(SYS_lchown, path, uid, gid);
+#else
+	return syscall(SYS_fchownat, AT_FDCWD, path, uid, gid, AT_SYMLINK_NOFOLLOW);
+#endif
+}
diff --git a/third_party/musl/porting/liteos_a/user/src/unistd/nice.c b/third_party/musl/porting/liteos_a/user/src/unistd/nice.c
new file mode 100755
index 000000000..ec55a1375
--- /dev/null
+++ b/third_party/musl/porting/liteos_a/user/src/unistd/nice.c
@@ -0,0 +1,18 @@
+#include <unistd.h>
+#include <sys/resource.h>
+#include <limits.h>
+#include "syscall.h"
+#include <unsupported_api.h>
+
+int nice(int inc)
+{
+	int prio = inc;
+	unsupported_api(__FUNCTION__);
+	// Only query old priority if it can affect the result.
+	// This also avoids issues with integer overflow.
+	if (inc > -2*NZERO && inc < 2*NZERO)
+		prio += getpriority(PRIO_PROCESS, 0);
+	if (prio > NZERO-1) prio = NZERO-1;
+	if (prio < -NZERO) prio = -NZERO;
+	return setpriority(PRIO_PROCESS, 0, prio) ? -1 : prio;
+}
diff --git a/third_party/musl/porting/liteos_a/user/src/unistd/pipe2.c b/third_party/musl/porting/liteos_a/user/src/unistd/pipe2.c
new file mode 100755
index 000000000..2125dd322
--- /dev/null
+++ b/third_party/musl/porting/liteos_a/user/src/unistd/pipe2.c
@@ -0,0 +1,24 @@
+#include <unistd.h>
+#include <errno.h>
+#include <fcntl.h>
+#include <unsupported_api.h>
+#include "syscall.h"
+
+int pipe2(int fd[2], int flag)
+{
+	if (!flag) return pipe(fd);
+	unsupported_api(__FUNCTION__);
+	int ret = __syscall(SYS_pipe2, fd, flag);
+	if (ret != -ENOSYS) return __syscall_ret(ret);
+	ret = pipe(fd);
+	if (ret) return ret;
+	if (flag & O_CLOEXEC) {
+		__syscall(SYS_fcntl, fd[0], F_SETFD, FD_CLOEXEC);
+		__syscall(SYS_fcntl, fd[1], F_SETFD, FD_CLOEXEC);
+	}
+	if (flag & O_NONBLOCK) {
+		__syscall(SYS_fcntl, fd[0], F_SETFL, O_NONBLOCK);
+		__syscall(SYS_fcntl, fd[1], F_SETFL, O_NONBLOCK);
+	}
+	return 0;
+}
diff --git a/third_party/musl/porting/liteos_a/user/src/unistd/renameat.c b/third_party/musl/porting/liteos_a/user/src/unistd/renameat.c
new file mode 100755
index 000000000..77d5d9a43
--- /dev/null
+++ b/third_party/musl/porting/liteos_a/user/src/unistd/renameat.c
@@ -0,0 +1,14 @@
+#include <stdio.h>
+#include <unsupported_api.h>
+
+#include "syscall.h"
+
+int renameat(int oldfd, const char *old, int newfd, const char *new)
+{
+	unsupported_api(__FUNCTION__);
+#ifdef SYS_renameat
+	return syscall(SYS_renameat, oldfd, old, newfd, new);
+#else
+	return syscall(SYS_renameat2, oldfd, old, newfd, new, 0);
+#endif
+}
diff --git a/third_party/musl/porting/liteos_a/user/src/unistd/setegid.c b/third_party/musl/porting/liteos_a/user/src/unistd/setegid.c
new file mode 100755
index 000000000..3abdfaf82
--- /dev/null
+++ b/third_party/musl/porting/liteos_a/user/src/unistd/setegid.c
@@ -0,0 +1,13 @@
+#include <unistd.h>
+#include "libc.h"
+#include "syscall.h"
+#include "errno.h"
+
+int setegid(gid_t egid)
+{
+	if (egid == -1) {
+		errno = EINVAL;
+		return -1;
+	}
+	return __setxid(SYS_setresgid, -1, egid, -1);
+}
diff --git a/third_party/musl/porting/liteos_a/user/src/unistd/seteuid.c b/third_party/musl/porting/liteos_a/user/src/unistd/seteuid.c
new file mode 100755
index 000000000..ea2562c74
--- /dev/null
+++ b/third_party/musl/porting/liteos_a/user/src/unistd/seteuid.c
@@ -0,0 +1,13 @@
+#include <unistd.h>
+#include "syscall.h"
+#include "libc.h"
+#include "errno.h"
+
+int seteuid(uid_t euid)
+{
+	if (euid == -1) {
+		errno = EINVAL;
+		return -1;
+	}
+	return __setxid(SYS_setresuid, -1, euid, -1);
+}
diff --git a/third_party/musl/porting/liteos_a/user/src/unistd/setsid.c b/third_party/musl/porting/liteos_a/user/src/unistd/setsid.c
new file mode 100755
index 000000000..54e4d9347
--- /dev/null
+++ b/third_party/musl/porting/liteos_a/user/src/unistd/setsid.c
@@ -0,0 +1,10 @@
+#include <unistd.h>
+#include <unsupported_api.h>
+
+#include "syscall.h"
+
+pid_t setsid(void)
+{
+	unsupported_api(__FUNCTION__);
+	return syscall(SYS_setsid);
+}
diff --git a/third_party/musl/porting/liteos_a/user/src/unistd/setxid.c b/third_party/musl/porting/liteos_a/user/src/unistd/setxid.c
new file mode 100755
index 000000000..647beaeb9
--- /dev/null
+++ b/third_party/musl/porting/liteos_a/user/src/unistd/setxid.c
@@ -0,0 +1,39 @@
+#include <unistd.h>
+#include <errno.h>
+#include "syscall.h"
+#include "libc.h"
+#include "pthread_impl.h"
+
+struct ctx {
+	int id, eid, sid;
+	int nr, err;
+};
+
+static void do_setxid(void *p)
+{
+	struct ctx *c = p;
+	if (c->err>0) return;
+	int ret = -__syscall(c->nr, c->id, c->eid, c->sid);
+	if (ret && !c->err) {
+		/* If one thread fails to set ids after another has already
+		 * succeeded, forcibly killing the process is the only safe
+		 * thing to do. State is inconsistent and dangerous. Use
+		 * SIGKILL because it is uncatchable. */
+		__block_all_sigs(0);
+		__syscall(SYS_kill, __syscall(SYS_getpid), SIGKILL);
+	}
+	c->err = ret;
+}
+
+int __setxid(int nr, int id, int eid, int sid)
+{
+	/* err is initially nonzero so that failure of the first thread does not
+	 * trigger the safety kill above. */
+	struct ctx c = { .nr = nr, .id = id, .eid = eid, .sid = sid, .err = -1 };
+	do_setxid(&c);
+	if (c.err) {
+		if (c.err>0) errno = c.err;
+		return -1;
+	}
+	return 0;
+}
diff --git a/third_party/musl/porting/liteos_a/user/src/unistd/sync.c b/third_party/musl/porting/liteos_a/user/src/unistd/sync.c
new file mode 100755
index 000000000..666aaf7d7
--- /dev/null
+++ b/third_party/musl/porting/liteos_a/user/src/unistd/sync.c
@@ -0,0 +1,10 @@
+#include <unistd.h>
+#include <unsupported_api.h>
+
+#include "syscall.h"
+
+void sync(void)
+{
+	unsupported_api(__FUNCTION__);
+	__syscall(SYS_sync);
+}
diff --git a/third_party/musl/porting/liteos_a/user/src/unistd/tcgetpgrp.c b/third_party/musl/porting/liteos_a/user/src/unistd/tcgetpgrp.c
new file mode 100755
index 000000000..5fc8ae273
--- /dev/null
+++ b/third_party/musl/porting/liteos_a/user/src/unistd/tcgetpgrp.c
@@ -0,0 +1,13 @@
+#include <unistd.h>
+#include <termios.h>
+#include <sys/ioctl.h>
+#include <unsupported_api.h>
+
+pid_t tcgetpgrp(int fd)
+{
+	int pgrp;
+	unsupported_api(__FUNCTION__);
+	if (ioctl(fd, TIOCGPGRP, &pgrp) < 0)
+		return -1;
+	return pgrp;
+}
diff --git a/third_party/musl/porting/liteos_a/user/src/unistd/ttyname.c b/third_party/musl/porting/liteos_a/user/src/unistd/ttyname.c
new file mode 100755
index 000000000..31f3dc189
--- /dev/null
+++ b/third_party/musl/porting/liteos_a/user/src/unistd/ttyname.c
@@ -0,0 +1,16 @@
+#include <unistd.h>
+#include <errno.h>
+#include <limits.h>
+#include <unsupported_api.h>
+
+char *ttyname(int fd)
+{
+	static char buf[TTY_NAME_MAX];
+	int result;
+	unsupported_api(__FUNCTION__);
+	if ((result = ttyname_r(fd, buf, sizeof buf))) {
+		errno = result;
+		return NULL;
+	}
+	return buf;
+}
diff --git a/third_party/musl/porting/liteos_a/user_debug/include/debug.h b/third_party/musl/porting/liteos_a/user_debug/include/debug.h
new file mode 100755
index 000000000..674ccaa94
--- /dev/null
+++ b/third_party/musl/porting/liteos_a/user_debug/include/debug.h
@@ -0,0 +1,88 @@
+#ifndef _DEBUG_H
+#define _DEBUG_H
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/**
+ * @brief Initialization of the memory debug function, including the output method of memory debug information
+ * and signal registration. You can use command line parameters, "--mwatch" or "--mrecord <full path>", to
+ * call mem_check_init(char *) when executing your program.
+ *
+ * @param f_path   The full path of the file to be created where the memory debug information will be written.
+ * If the param is NULL or the file creation fails, the memory debug information will be output via serial
+ * port.
+ *
+ * @return void.
+ */
+void mem_check_init(char *f_path);
+
+/**
+ * @brief View thread-level heap memory usage information, signal registration index is 35, you can use "kill -35 pid"
+ * to call watch_mem() when your program is running. The output way of memory debug information is determined by how
+ * the mem_check_init(char *) interface is called.
+ *
+ * @param void.
+ *
+ * @return void.
+ */
+void watch_mem(void);
+
+/**
+ * @brief Check whether the heap memory leak is exist or not, signal registration index is 36, you can use "kill -36
+ * pid" to call check_leak() when your program is running. The output way of memory debug information is determined by
+ * how the mem_check_init(char *) interface is called.
+ *
+ * @param void.
+ *
+ * @return void.
+ */
+void check_leak(void);
+
+/**
+ * @brief Check whether the heap memory is integrited or not, signal registration index is 37, you can use "kill -37
+ * pid" to call check_heap_integrity() when your program is running. The output way of memory debug information is
+ * determined by how the mem_check_init(char *) interface is called.
+ *
+ * @param void.
+ *
+ * @return void.
+ */
+void check_heap_integrity(void);
+
+/**
+ * @brief Store the address of the call stack information, the max number is param size.
+ *
+ * @param buffer   The array to store address of the call stack information.
+ * @param size     The size of buffer.
+ *
+ * @return The exact number of the address.
+ */
+int backtrace(void **buffer, int size);
+
+/**
+ * @brief Find the symbol information corresponding to the address stored in the buffer for dynamic linking.
+ *
+ * @param buffer   The array stored address of the exact number.
+ * @param size     The exact number of the address stored in the buffer.
+ *
+ * @return The pointer to the memory allocated from heap holds the symbol information corresponding to the address
+ * stored in the buffer. You should free the memory the pointer points to after calling backtrace_symbols().
+ */
+char **backtrace_symbols(void *const *buffer, int size);
+
+/**
+ * @brief Print the call stack information of the function calling print_trace().
+ *
+ * @param void.
+ *
+ * @return void.
+ */
+void print_trace(void);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
diff --git a/third_party/musl/porting/liteos_a/user_debug/ldso/dynlink.c b/third_party/musl/porting/liteos_a/user_debug/ldso/dynlink.c
new file mode 100755
index 000000000..e311c674f
--- /dev/null
+++ b/third_party/musl/porting/liteos_a/user_debug/ldso/dynlink.c
@@ -0,0 +1,2345 @@
+#define _GNU_SOURCE
+#define SYSCALL_NO_TLS 1
+#include <stdio.h>
+#include <stdlib.h>
+#include <stdarg.h>
+#include <stddef.h>
+#include <string.h>
+#include <unistd.h>
+#include <stdint.h>
+#include <elf.h>
+#include <sys/mman.h>
+#include <limits.h>
+#include <fcntl.h>
+#include <sys/stat.h>
+#include <errno.h>
+#include <link.h>
+#include <setjmp.h>
+#include <pthread.h>
+#include <ctype.h>
+#include <dlfcn.h>
+#include <semaphore.h>
+#include <sys/membarrier.h>
+#include "pthread_impl.h"
+#include "libc.h"
+#include "dynlink.h"
+#include "malloc_impl.h"
+
+static void error(const char *, ...);
+
+#define MAXP2(a,b) (-(-(a)&-(b)))
+#define ALIGN(x,y) ((x)+(y)-1 & -(y))
+
+#define container_of(p,t,m) ((t*)((char *)(p)-offsetof(t,m)))
+#define countof(a) ((sizeof (a))/(sizeof (a)[0]))
+
+struct debug {
+	int ver;
+	void *head;
+	void (*bp)(void);
+	int state;
+	void *base;
+};
+
+struct td_index {
+	size_t args[2];
+	struct td_index *next;
+};
+
+struct dso {
+#if DL_FDPIC
+	struct fdpic_loadmap *loadmap;
+#else
+	unsigned char *base;
+#endif
+	char *name;
+	size_t *dynv;
+	struct dso *next, *prev;
+
+	Phdr *phdr;
+	int phnum;
+	size_t phentsize;
+	Sym *syms;
+	Elf_Symndx *hashtab;
+	uint32_t *ghashtab;
+	int16_t *versym;
+	char *strings;
+	struct dso *syms_next, *lazy_next;
+	size_t *lazy, lazy_cnt;
+	unsigned char *map;
+	size_t map_len;
+	char relocated;
+	char constructed;
+	char kernel_mapped;
+	char mark;
+	char bfs_built;
+	char runtime_loaded;
+	struct dso **deps, *needed_by;
+	size_t ndeps_direct;
+	size_t next_dep;
+	int ctor_visitor;
+	char *rpath_orig, *rpath;
+	struct tls_module tls;
+	size_t tls_id;
+	size_t relro_start, relro_end;
+	uintptr_t *new_dtv;
+	unsigned char *new_tls;
+	struct td_index *td_index;
+	struct dso *fini_next;
+	char *shortname;
+#if DL_FDPIC
+	unsigned char *base;
+#else
+	struct fdpic_loadmap *loadmap;
+#endif
+	struct funcdesc {
+		void *addr;
+		size_t *got;
+	} *funcdescs;
+	size_t *got;
+	char buf[];
+};
+
+struct symdef {
+	Sym *sym;
+	struct dso *dso;
+};
+
+typedef void (*stage3_func)(size_t *, size_t *);
+
+static struct builtin_tls {
+	char c;
+	struct pthread pt;
+	void *space[16];
+} builtin_tls[1];
+#define MIN_TLS_ALIGN offsetof(struct builtin_tls, pt)
+
+#define ADDEND_LIMIT 4096
+static size_t *saved_addends, *apply_addends_to;
+
+static struct dso ldso;
+static struct dso *head, *tail, *fini_head, *syms_tail, *lazy_head;
+static char *env_path, *sys_path;
+static unsigned long long gencnt;
+static int runtime;
+static int ldd_mode;
+static int ldso_fail;
+static int noload;
+static int shutting_down;
+static jmp_buf *rtld_fail;
+static pthread_rwlock_t lock;
+static struct debug debug;
+static struct tls_module *tls_tail;
+static size_t tls_cnt, tls_offset, tls_align = MIN_TLS_ALIGN;
+static size_t static_tls_cnt;
+static pthread_mutex_t init_fini_lock;
+static pthread_cond_t ctor_cond;
+static struct dso *builtin_deps[2];
+static struct dso *const no_deps[1];
+static struct dso *builtin_ctor_queue[4];
+static struct dso **main_ctor_queue;
+static struct fdpic_loadmap *app_loadmap;
+static struct fdpic_dummy_loadmap app_dummy_loadmap;
+
+struct debug *_dl_debug_addr = &debug;
+
+extern hidden int __malloc_replaced;
+
+hidden void (*const __init_array_start)(void)=0, (*const __fini_array_start)(void)=0;
+
+extern hidden void (*const __init_array_end)(void), (*const __fini_array_end)(void);
+
+weak_alias(__init_array_start, __init_array_end);
+weak_alias(__fini_array_start, __fini_array_end);
+
+static int dl_strcmp(const char *l, const char *r)
+{
+	for (; *l==*r && *l; l++, r++);
+	return *(unsigned char *)l - *(unsigned char *)r;
+}
+#define strcmp(l,r) dl_strcmp(l,r)
+
+/* Compute load address for a virtual address in a given dso. */
+#if DL_FDPIC
+static void *laddr(const struct dso *p, size_t v)
+{
+	size_t j=0;
+	if (!p->loadmap) return p->base + v;
+	for (j=0; v-p->loadmap->segs[j].p_vaddr >= p->loadmap->segs[j].p_memsz; j++);
+	return (void *)(v - p->loadmap->segs[j].p_vaddr + p->loadmap->segs[j].addr);
+}
+static void *laddr_pg(const struct dso *p, size_t v)
+{
+	size_t j=0;
+	size_t pgsz = PAGE_SIZE;
+	if (!p->loadmap) return p->base + v;
+	for (j=0; ; j++) {
+		size_t a = p->loadmap->segs[j].p_vaddr;
+		size_t b = a + p->loadmap->segs[j].p_memsz;
+		a &= -pgsz;
+		b += pgsz-1;
+		b &= -pgsz;
+		if (v-a<b-a) break;
+	}
+	return (void *)(v - p->loadmap->segs[j].p_vaddr + p->loadmap->segs[j].addr);
+}
+static void (*fdbarrier(void *p))()
+{
+	void (*fd)();
+	__asm__("" : "=r"(fd) : "0"(p));
+	return fd;
+}
+#define fpaddr(p, v) fdbarrier((&(struct funcdesc){ \
+	laddr(p, v), (p)->got }))
+#else
+#define laddr(p, v) (void *)((p)->base + (v))
+#define laddr_pg(p, v) laddr(p, v)
+#define fpaddr(p, v) ((void (*)())laddr(p, v))
+#endif
+
+static void decode_vec(size_t *v, size_t *a, size_t cnt)
+{
+	size_t i;
+	for (i=0; i<cnt; i++) a[i] = 0;
+	for (; v[0]; v+=2) if (v[0]-1<cnt-1) {
+		a[0] |= 1UL<<v[0];
+		a[v[0]] = v[1];
+	}
+}
+
+static int search_vec(size_t *v, size_t *r, size_t key)
+{
+	for (; v[0]!=key; v+=2)
+		if (!v[0]) return 0;
+	*r = v[1];
+	return 1;
+}
+
+static uint32_t sysv_hash(const char *s0)
+{
+	const unsigned char *s = (void *)s0;
+	uint_fast32_t h = 0;
+	while (*s) {
+		h = 16*h + *s++;
+		h ^= h>>24 & 0xf0;
+	}
+	return h & 0xfffffff;
+}
+
+static uint32_t gnu_hash(const char *s0)
+{
+	const unsigned char *s = (void *)s0;
+	uint_fast32_t h = 5381;
+	for (; *s; s++)
+		h += h*32 + *s;
+	return h;
+}
+
+static Sym *sysv_lookup(const char *s, uint32_t h, struct dso *dso)
+{
+	size_t i;
+	Sym *syms = dso->syms;
+	Elf_Symndx *hashtab = dso->hashtab;
+	char *strings = dso->strings;
+	for (i=hashtab[2+h%hashtab[0]]; i; i=hashtab[2+hashtab[0]+i]) {
+		if ((!dso->versym || dso->versym[i] >= 0)
+		    && (!strcmp(s, strings+syms[i].st_name)))
+			return syms+i;
+	}
+	return 0;
+}
+
+static Sym *gnu_lookup(uint32_t h1, uint32_t *hashtab, struct dso *dso, const char *s)
+{
+	uint32_t nbuckets = hashtab[0];
+	uint32_t *buckets = hashtab + 4 + hashtab[2]*(sizeof(size_t)/4);
+	uint32_t i = buckets[h1 % nbuckets];
+
+	if (!i) return 0;
+
+	uint32_t *hashval = buckets + nbuckets + (i - hashtab[1]);
+
+	for (h1 |= 1; ; i++) {
+		uint32_t h2 = *hashval++;
+		if ((h1 == (h2|1)) && (!dso->versym || dso->versym[i] >= 0)
+		    && !strcmp(s, dso->strings + dso->syms[i].st_name))
+			return dso->syms+i;
+		if (h2 & 1) break;
+	}
+
+	return 0;
+}
+
+static Sym *gnu_lookup_filtered(uint32_t h1, uint32_t *hashtab, struct dso *dso, const char *s, uint32_t fofs, size_t fmask)
+{
+	const size_t *bloomwords = (const void *)(hashtab+4);
+	size_t f = bloomwords[fofs & (hashtab[2]-1)];
+	if (!(f & fmask)) return 0;
+
+	f >>= (h1 >> hashtab[3]) % (8 * sizeof f);
+	if (!(f & 1)) return 0;
+
+	return gnu_lookup(h1, hashtab, dso, s);
+}
+
+#define OK_TYPES (1<<STT_NOTYPE | 1<<STT_OBJECT | 1<<STT_FUNC | 1<<STT_COMMON | 1<<STT_TLS)
+#define OK_BINDS (1<<STB_GLOBAL | 1<<STB_WEAK | 1<<STB_GNU_UNIQUE)
+
+#ifndef ARCH_SYM_REJECT_UND
+#define ARCH_SYM_REJECT_UND(s) 0
+#endif
+
+#if defined(__GNUC__)
+__attribute__((always_inline))
+#endif
+static inline struct symdef find_sym2(struct dso *dso, const char *s, int need_def, int use_deps)
+{
+	uint32_t h = 0, gh = gnu_hash(s), gho = gh / (8*sizeof(size_t)), *ght;
+	size_t ghm = 1ul << gh % (8*sizeof(size_t));
+	struct symdef def = {0};
+	struct dso **deps = use_deps ? dso->deps : 0;
+	for (; dso; dso=use_deps ? *deps++ : dso->syms_next) {
+		Sym *sym;
+		if ((ght = dso->ghashtab)) {
+			sym = gnu_lookup_filtered(gh, ght, dso, s, gho, ghm);
+		} else {
+			if (!h) h = sysv_hash(s);
+			sym = sysv_lookup(s, h, dso);
+		}
+		if (!sym) continue;
+		if (!sym->st_shndx)
+			if (need_def || (sym->st_info&0xf) == STT_TLS
+			    || ARCH_SYM_REJECT_UND(sym))
+				continue;
+		if (!sym->st_value)
+			if ((sym->st_info&0xf) != STT_TLS)
+				continue;
+		if (!(1<<(sym->st_info&0xf) & OK_TYPES)) continue;
+		if (!(1<<(sym->st_info>>4) & OK_BINDS)) continue;
+		def.sym = sym;
+		def.dso = dso;
+		break;
+	}
+	return def;
+}
+
+static struct symdef find_sym(struct dso *dso, const char *s, int need_def)
+{
+	return find_sym2(dso, s, need_def, 0);
+}
+
+static void do_relocs(struct dso *dso, size_t *rel, size_t rel_size, size_t stride)
+{
+	unsigned char *base = dso->base;
+	Sym *syms = dso->syms;
+	char *strings = dso->strings;
+	Sym *sym;
+	const char *name;
+	void *ctx;
+	int type;
+	int sym_index;
+	struct symdef def;
+	size_t *reloc_addr;
+	size_t sym_val;
+	size_t tls_val;
+	size_t addend;
+	int skip_relative = 0, reuse_addends = 0, save_slot = 0;
+
+	if (dso == &ldso) {
+		/* Only ldso's REL table needs addend saving/reuse. */
+		if (rel == apply_addends_to)
+			reuse_addends = 1;
+		skip_relative = 1;
+	}
+
+	for (; rel_size; rel+=stride, rel_size-=stride*sizeof(size_t)) {
+		if (skip_relative && IS_RELATIVE(rel[1], dso->syms)) continue;
+		type = R_TYPE(rel[1]);
+		if (type == REL_NONE) continue;
+		reloc_addr = laddr(dso, rel[0]);
+
+		if (stride > 2) {
+			addend = rel[2];
+		} else if (type==REL_GOT || type==REL_PLT|| type==REL_COPY) {
+			addend = 0;
+		} else if (reuse_addends) {
+			/* Save original addend in stage 2 where the dso
+			 * chain consists of just ldso; otherwise read back
+			 * saved addend since the inline one was clobbered. */
+			if (head==&ldso)
+				saved_addends[save_slot] = *reloc_addr;
+			addend = saved_addends[save_slot++];
+		} else {
+			addend = *reloc_addr;
+		}
+
+		sym_index = R_SYM(rel[1]);
+		if (sym_index) {
+			sym = syms + sym_index;
+			name = strings + sym->st_name;
+			ctx = type==REL_COPY ? head->syms_next : head;
+			def = (sym->st_info>>4) == STB_LOCAL
+				? (struct symdef){ .dso = dso, .sym = sym }
+				: find_sym(ctx, name, type==REL_PLT);
+			if (!def.sym && (sym->st_shndx != SHN_UNDEF
+			    || sym->st_info>>4 != STB_WEAK)) {
+				if (dso->lazy && (type==REL_PLT || type==REL_GOT)) {
+					dso->lazy[3*dso->lazy_cnt+0] = rel[0];
+					dso->lazy[3*dso->lazy_cnt+1] = rel[1];
+					dso->lazy[3*dso->lazy_cnt+2] = addend;
+					dso->lazy_cnt++;
+					continue;
+				}
+				error("Error relocating %s: %s: symbol not found",
+					dso->name, name);
+				if (runtime) longjmp(*rtld_fail, 1);
+				continue;
+			}
+		} else {
+			sym = 0;
+			def.sym = 0;
+			def.dso = dso;
+		}
+
+		sym_val = def.sym ? (size_t)laddr(def.dso, def.sym->st_value) : 0;
+		tls_val = def.sym ? def.sym->st_value : 0;
+
+		if ((type == REL_TPOFF || type == REL_TPOFF_NEG)
+		    && def.dso->tls_id > static_tls_cnt) {
+			error("Error relocating %s: %s: initial-exec TLS "
+				"resolves to dynamic definition in %s",
+				dso->name, name, def.dso->name);
+			longjmp(*rtld_fail, 1);
+		}
+
+		switch(type) {
+		case REL_NONE:
+			break;
+		case REL_OFFSET:
+			addend -= (size_t)reloc_addr;
+		case REL_SYMBOLIC:
+		case REL_GOT:
+		case REL_PLT:
+			*reloc_addr = sym_val + addend;
+			break;
+		case REL_USYMBOLIC:
+			memcpy(reloc_addr, &(size_t){sym_val + addend}, sizeof(size_t));
+			break;
+		case REL_RELATIVE:
+			*reloc_addr = (size_t)base + addend;
+			break;
+		case REL_SYM_OR_REL:
+			if (sym) *reloc_addr = sym_val + addend;
+			else *reloc_addr = (size_t)base + addend;
+			break;
+		case REL_COPY:
+			memcpy(reloc_addr, (void *)sym_val, sym->st_size);
+			break;
+		case REL_OFFSET32:
+			*(uint32_t *)reloc_addr = sym_val + addend
+				- (size_t)reloc_addr;
+			break;
+		case REL_FUNCDESC:
+			*reloc_addr = def.sym ? (size_t)(def.dso->funcdescs
+				+ (def.sym - def.dso->syms)) : 0;
+			break;
+		case REL_FUNCDESC_VAL:
+			if ((sym->st_info&0xf) == STT_SECTION) *reloc_addr += sym_val;
+			else *reloc_addr = sym_val;
+			reloc_addr[1] = def.sym ? (size_t)def.dso->got : 0;
+			break;
+		case REL_DTPMOD:
+			*reloc_addr = def.dso->tls_id;
+			break;
+		case REL_DTPOFF:
+			*reloc_addr = tls_val + addend - DTP_OFFSET;
+			break;
+#ifdef TLS_ABOVE_TP
+		case REL_TPOFF:
+			*reloc_addr = tls_val + def.dso->tls.offset + TPOFF_K + addend;
+			break;
+#else
+		case REL_TPOFF:
+			*reloc_addr = tls_val - def.dso->tls.offset + addend;
+			break;
+		case REL_TPOFF_NEG:
+			*reloc_addr = def.dso->tls.offset - tls_val + addend;
+			break;
+#endif
+		case REL_TLSDESC:
+			if (stride<3) addend = reloc_addr[1];
+			if (def.dso->tls_id > static_tls_cnt) {
+				struct td_index *new = malloc(sizeof *new);
+				if (!new) {
+					error(
+					"Error relocating %s: cannot allocate TLSDESC for %s",
+					dso->name, sym ? name : "(local)" );
+					longjmp(*rtld_fail, 1);
+				}
+				new->next = dso->td_index;
+				dso->td_index = new;
+				new->args[0] = def.dso->tls_id;
+				new->args[1] = tls_val + addend - DTP_OFFSET;
+				reloc_addr[0] = (size_t)__tlsdesc_dynamic;
+				reloc_addr[1] = (size_t)new;
+			} else {
+				reloc_addr[0] = (size_t)__tlsdesc_static;
+#ifdef TLS_ABOVE_TP
+				reloc_addr[1] = tls_val + def.dso->tls.offset
+					+ TPOFF_K + addend;
+#else
+				reloc_addr[1] = tls_val - def.dso->tls.offset
+					+ addend;
+#endif
+			}
+#ifdef TLSDESC_BACKWARDS
+			/* Some archs (32-bit ARM at least) invert the order of
+			 * the descriptor members. Fix them up here. */
+			size_t tmp = reloc_addr[0];
+			reloc_addr[0] = reloc_addr[1];
+			reloc_addr[1] = tmp;
+#endif
+			break;
+		default:
+			error("Error relocating %s: unsupported relocation type %d",
+				dso->name, type);
+			if (runtime) longjmp(*rtld_fail, 1);
+			continue;
+		}
+	}
+}
+
+static void redo_lazy_relocs()
+{
+	struct dso *p = lazy_head, *next;
+	lazy_head = 0;
+	for (; p; p=next) {
+		next = p->lazy_next;
+		size_t size = p->lazy_cnt*3*sizeof(size_t);
+		p->lazy_cnt = 0;
+		do_relocs(p, p->lazy, size, 3);
+		if (p->lazy_cnt) {
+			p->lazy_next = lazy_head;
+			lazy_head = p;
+		} else {
+			free(p->lazy);
+			p->lazy = 0;
+			p->lazy_next = 0;
+		}
+	}
+}
+
+/* A huge hack: to make up for the wastefulness of shared libraries
+ * needing at least a page of dirty memory even if they have no global
+ * data, we reclaim the gaps at the beginning and end of writable maps
+ * and "donate" them to the heap. */
+
+static void reclaim(struct dso *dso, size_t start, size_t end)
+{
+	if (start >= dso->relro_start && start < dso->relro_end) start = dso->relro_end;
+	if (end   >= dso->relro_start && end   < dso->relro_end) end = dso->relro_start;
+	if (start >= end) return;
+	char *base = laddr_pg(dso, start);
+	__malloc_donate(base, base+(end-start));
+}
+
+static void reclaim_gaps(struct dso *dso)
+{
+	Phdr *ph = dso->phdr;
+	size_t phcnt = dso->phnum;
+
+	for (; phcnt--; ph=(void *)((char *)ph+dso->phentsize)) {
+		if (ph->p_type!=PT_LOAD) continue;
+		if ((ph->p_flags&(PF_R|PF_W))!=(PF_R|PF_W)) continue;
+		reclaim(dso, ph->p_vaddr & -PAGE_SIZE, ph->p_vaddr);
+		reclaim(dso, ph->p_vaddr+ph->p_memsz,
+			ph->p_vaddr+ph->p_memsz+PAGE_SIZE-1 & -PAGE_SIZE);
+	}
+}
+
+static void *mmap_fixed(void *p, size_t n, int prot, int flags, int fd, off_t off)
+{
+	static int no_map_fixed;
+	char *q;
+	if (!no_map_fixed) {
+		q = mmap(p, n, prot, flags|MAP_FIXED, fd, off);
+		if (!DL_NOMMU_SUPPORT || q != MAP_FAILED || errno != EINVAL)
+			return q;
+		no_map_fixed = 1;
+	}
+	/* Fallbacks for MAP_FIXED failure on NOMMU kernels. */
+	if (flags & MAP_ANONYMOUS) {
+		memset(p, 0, n);
+		return p;
+	}
+	ssize_t r;
+	if (lseek(fd, off, SEEK_SET) < 0) return MAP_FAILED;
+	for (q=p; n; q+=r, off+=r, n-=r) {
+		r = read(fd, q, n);
+		if (r < 0 && errno != EINTR) return MAP_FAILED;
+		if (!r) {
+			memset(q, 0, n);
+			break;
+		}
+	}
+	return p;
+}
+
+static void unmap_library(struct dso *dso)
+{
+	if (dso->loadmap) {
+		size_t i;
+		for (i=0; i<dso->loadmap->nsegs; i++) {
+			if (!dso->loadmap->segs[i].p_memsz)
+				continue;
+			munmap((void *)dso->loadmap->segs[i].addr,
+				dso->loadmap->segs[i].p_memsz);
+		}
+		free(dso->loadmap);
+	} else if (dso->map && dso->map_len) {
+		munmap(dso->map, dso->map_len);
+	}
+}
+
+static void *map_library(int fd, struct dso *dso)
+{
+	Ehdr buf[(896+sizeof(Ehdr))/sizeof(Ehdr)];
+	void *allocated_buf=0;
+	size_t phsize;
+	size_t addr_min=SIZE_MAX, addr_max=0, map_len;
+	size_t this_min, this_max;
+	size_t nsegs = 0;
+	off_t off_start;
+	Ehdr *eh;
+	Phdr *ph, *ph0;
+	unsigned prot;
+	unsigned char *map=MAP_FAILED, *base;
+	size_t dyn=0;
+	size_t tls_image=0;
+	size_t i;
+
+	ssize_t l = read(fd, buf, sizeof buf);
+	eh = buf;
+	if (l<0) return 0;
+	if (l<sizeof *eh || (eh->e_type != ET_DYN && eh->e_type != ET_EXEC))
+		goto noexec;
+	phsize = eh->e_phentsize * eh->e_phnum;
+	if (phsize > sizeof buf - sizeof *eh) {
+		allocated_buf = malloc(phsize);
+		if (!allocated_buf) return 0;
+		l = pread(fd, allocated_buf, phsize, eh->e_phoff);
+		if (l < 0) goto error;
+		if (l != phsize) goto noexec;
+		ph = ph0 = allocated_buf;
+	} else if (eh->e_phoff + phsize > l) {
+		l = pread(fd, buf+1, phsize, eh->e_phoff);
+		if (l < 0) goto error;
+		if (l != phsize) goto noexec;
+		ph = ph0 = (void *)(buf + 1);
+	} else {
+		ph = ph0 = (void *)((char *)buf + eh->e_phoff);
+	}
+	for (i=eh->e_phnum; i; i--, ph=(void *)((char *)ph+eh->e_phentsize)) {
+		if (ph->p_type == PT_DYNAMIC) {
+			dyn = ph->p_vaddr;
+		} else if (ph->p_type == PT_TLS) {
+			tls_image = ph->p_vaddr;
+			dso->tls.align = ph->p_align;
+			dso->tls.len = ph->p_filesz;
+			dso->tls.size = ph->p_memsz;
+		} else if (ph->p_type == PT_GNU_RELRO) {
+			dso->relro_start = ph->p_vaddr & -PAGE_SIZE;
+			dso->relro_end = (ph->p_vaddr + ph->p_memsz) & -PAGE_SIZE;
+		} else if (ph->p_type == PT_GNU_STACK) {
+			if (!runtime && ph->p_memsz > __default_stacksize) {
+				__default_stacksize =
+					ph->p_memsz < DEFAULT_STACK_MAX ?
+					ph->p_memsz : DEFAULT_STACK_MAX;
+			}
+		}
+		if (ph->p_type != PT_LOAD) continue;
+		nsegs++;
+		if (ph->p_vaddr < addr_min) {
+			addr_min = ph->p_vaddr;
+			off_start = ph->p_offset;
+			prot = (((ph->p_flags&PF_R) ? PROT_READ : 0) |
+				((ph->p_flags&PF_W) ? PROT_WRITE: 0) |
+				((ph->p_flags&PF_X) ? PROT_EXEC : 0));
+		}
+		if (ph->p_vaddr+ph->p_memsz > addr_max) {
+			addr_max = ph->p_vaddr+ph->p_memsz;
+		}
+	}
+	if (!dyn) goto noexec;
+	if (DL_FDPIC && !(eh->e_flags & FDPIC_CONSTDISP_FLAG)) {
+		dso->loadmap = calloc(1, sizeof *dso->loadmap
+			+ nsegs * sizeof *dso->loadmap->segs);
+		if (!dso->loadmap) goto error;
+		dso->loadmap->nsegs = nsegs;
+		for (ph=ph0, i=0; i<nsegs; ph=(void *)((char *)ph+eh->e_phentsize)) {
+			if (ph->p_type != PT_LOAD) continue;
+			prot = (((ph->p_flags&PF_R) ? PROT_READ : 0) |
+				((ph->p_flags&PF_W) ? PROT_WRITE: 0) |
+				((ph->p_flags&PF_X) ? PROT_EXEC : 0));
+			map = mmap(0, ph->p_memsz + (ph->p_vaddr & PAGE_SIZE-1),
+				prot, MAP_PRIVATE,
+				fd, ph->p_offset & -PAGE_SIZE);
+			if (map == MAP_FAILED) {
+				unmap_library(dso);
+				goto error;
+			}
+			dso->loadmap->segs[i].addr = (size_t)map +
+				(ph->p_vaddr & PAGE_SIZE-1);
+			dso->loadmap->segs[i].p_vaddr = ph->p_vaddr;
+			dso->loadmap->segs[i].p_memsz = ph->p_memsz;
+			i++;
+			if (prot & PROT_WRITE) {
+				size_t brk = (ph->p_vaddr & PAGE_SIZE-1)
+					+ ph->p_filesz;
+				size_t pgbrk = brk + PAGE_SIZE-1 & -PAGE_SIZE;
+				size_t pgend = brk + ph->p_memsz - ph->p_filesz
+					+ PAGE_SIZE-1 & -PAGE_SIZE;
+				if (pgend > pgbrk && mmap_fixed(map+pgbrk,
+					pgend-pgbrk, prot,
+					MAP_PRIVATE|MAP_FIXED|MAP_ANONYMOUS,
+					-1, off_start) == MAP_FAILED)
+					goto error;
+				memset(map + brk, 0, pgbrk-brk);
+			}
+		}
+		map = (void *)dso->loadmap->segs[0].addr;
+		map_len = 0;
+		goto done_mapping;
+	}
+	addr_max += PAGE_SIZE-1;
+	addr_max &= -PAGE_SIZE;
+	addr_min &= -PAGE_SIZE;
+	off_start &= -PAGE_SIZE;
+	map_len = addr_max - addr_min + off_start;
+	/* The first time, we map too much, possibly even more than
+	 * the length of the file. This is okay because we will not
+	 * use the invalid part; we just need to reserve the right
+	 * amount of virtual address space to map over later. */
+	map = DL_NOMMU_SUPPORT
+		? mmap((void *)addr_min, map_len, PROT_READ|PROT_WRITE|PROT_EXEC,
+			MAP_PRIVATE|MAP_ANONYMOUS, -1, 0)
+		: mmap((void *)addr_min, map_len, prot,
+			MAP_PRIVATE, fd, off_start);
+	if (map==MAP_FAILED) goto error;
+	dso->map = map;
+	dso->map_len = map_len;
+	/* If the loaded file is not relocatable and the requested address is
+	 * not available, then the load operation must fail. */
+	if (eh->e_type != ET_DYN && addr_min && map!=(void *)addr_min) {
+		errno = EBUSY;
+		goto error;
+	}
+	base = map - addr_min;
+	dso->phdr = 0;
+	dso->phnum = 0;
+	for (ph=ph0, i=eh->e_phnum; i; i--, ph=(void *)((char *)ph+eh->e_phentsize)) {
+		if (ph->p_type != PT_LOAD) continue;
+		/* Check if the programs headers are in this load segment, and
+		 * if so, record the address for use by dl_iterate_phdr. */
+		if (!dso->phdr && eh->e_phoff >= ph->p_offset
+		    && eh->e_phoff+phsize <= ph->p_offset+ph->p_filesz) {
+			dso->phdr = (void *)(base + ph->p_vaddr
+				+ (eh->e_phoff-ph->p_offset));
+			dso->phnum = eh->e_phnum;
+			dso->phentsize = eh->e_phentsize;
+		}
+		this_min = ph->p_vaddr & -PAGE_SIZE;
+		this_max = ph->p_vaddr+ph->p_memsz+PAGE_SIZE-1 & -PAGE_SIZE;
+		off_start = ph->p_offset & -PAGE_SIZE;
+		prot = (((ph->p_flags&PF_R) ? PROT_READ : 0) |
+			((ph->p_flags&PF_W) ? PROT_WRITE: 0) |
+			((ph->p_flags&PF_X) ? PROT_EXEC : 0));
+		if ((ph->p_flags & PF_R) && (ph->p_flags & PF_X) && (!(ph->p_flags & PF_W))) {
+			Phdr *next_ph = ph;
+			for (int j = i - 1; j > 0; j--) {
+				next_ph = (void *)((char *)next_ph+eh->e_phentsize);
+				if (next_ph->p_type != PT_LOAD) {
+					continue;
+				}
+				size_t p_vaddr = (next_ph->p_vaddr & -(PAGE_SIZE));
+				if (p_vaddr > this_max) {
+					mprotect(base + this_max, p_vaddr - this_max , PROT_READ);
+				}
+				break;
+			}
+		}
+		/* Reuse the existing mapping for the lowest-address LOAD */
+		if ((ph->p_vaddr & -PAGE_SIZE) != addr_min || DL_NOMMU_SUPPORT)
+			if (mmap_fixed(base+this_min, this_max-this_min, prot, MAP_PRIVATE|MAP_FIXED, fd, off_start) == MAP_FAILED)
+				goto error;
+		if (ph->p_memsz > ph->p_filesz && (ph->p_flags&PF_W)) {
+			size_t brk = (size_t)base+ph->p_vaddr+ph->p_filesz;
+			size_t pgbrk = brk+PAGE_SIZE-1 & -PAGE_SIZE;
+			memset((void *)brk, 0, pgbrk-brk & PAGE_SIZE-1);
+			if (pgbrk-(size_t)base < this_max && mmap_fixed((void *)pgbrk, (size_t)base+this_max-pgbrk, prot, MAP_PRIVATE|MAP_FIXED|MAP_ANONYMOUS, -1, 0) == MAP_FAILED)
+				goto error;
+		}
+	}
+	for (i=0; ((size_t *)(base+dyn))[i]; i+=2)
+		if (((size_t *)(base+dyn))[i]==DT_TEXTREL) {
+			if (mprotect(map, map_len, PROT_READ|PROT_WRITE|PROT_EXEC)
+			    && errno != ENOSYS)
+				goto error;
+			break;
+		}
+done_mapping:
+	dso->base = base;
+	dso->dynv = laddr(dso, dyn);
+	if (dso->tls.size) dso->tls.image = laddr(dso, tls_image);
+	free(allocated_buf);
+	return map;
+noexec:
+	errno = ENOEXEC;
+error:
+	if (map!=MAP_FAILED) unmap_library(dso);
+	free(allocated_buf);
+	return 0;
+}
+
+static int path_open(const char *name, const char *s, char *buf, size_t buf_size)
+{
+	size_t l;
+	int fd;
+	for (;;) {
+		s += strspn(s, ":\n");
+		l = strcspn(s, ":\n");
+		if (l-1 >= INT_MAX) return -1;
+		if (snprintf(buf, buf_size, "%.*s/%s", (int)l, s, name) < buf_size) {
+			if ((fd = open(buf, O_RDONLY))>=0) return fd; // open(buf, O_RDONLY|O_CLOEXEC)
+			switch (errno) {
+			case ENOENT:
+			case ENOTDIR:
+			case EACCES:
+			case ENAMETOOLONG:
+				break;
+			default:
+				/* Any negative value but -1 will inhibit
+				 * futher path search. */
+				return -2;
+			}
+		}
+		s += l;
+	}
+}
+
+static int fixup_rpath(struct dso *p, char *buf, size_t buf_size)
+{
+	size_t n, l;
+	const char *s, *t, *origin;
+	char *d;
+	if (p->rpath || !p->rpath_orig) return 0;
+	if (!strchr(p->rpath_orig, '$')) {
+		p->rpath = p->rpath_orig;
+		return 0;
+	}
+	n = 0;
+	s = p->rpath_orig;
+	while ((t=strchr(s, '$'))) {
+		if (strncmp(t, "$ORIGIN", 7) && strncmp(t, "${ORIGIN}", 9))
+			return 0;
+		s = t+1;
+		n++;
+	}
+	if (n > SSIZE_MAX/PATH_MAX) return 0;
+
+	if (p->kernel_mapped) {
+		/* $ORIGIN searches cannot be performed for the main program
+		 * when it is suid/sgid/AT_SECURE. This is because the
+		 * pathname is under the control of the caller of execve.
+		 * For libraries, however, $ORIGIN can be processed safely
+		 * since the library's pathname came from a trusted source
+		 * (either system paths or a call to dlopen). */
+		if (libc.secure)
+			return 0;
+		l = readlink("/proc/self/exe", buf, buf_size);
+		if (l == -1) switch (errno) {
+		case ENOENT:
+		case ENOTDIR:
+		case EACCES:
+			break;
+		default:
+			return -1;
+		}
+		if (l >= buf_size)
+			return 0;
+		buf[l] = 0;
+		origin = buf;
+	} else {
+		origin = p->name;
+	}
+	t = strrchr(origin, '/');
+	if (t) {
+		l = t-origin;
+	} else {
+		/* Normally p->name will always be an absolute or relative
+		 * pathname containing at least one '/' character, but in the
+		 * case where ldso was invoked as a command to execute a
+		 * program in the working directory, app.name may not. Fix. */
+		origin = ".";
+		l = 1;
+	}
+	/* Disallow non-absolute origins for suid/sgid/AT_SECURE. */
+	if (libc.secure && *origin != '/')
+		return 0;
+	p->rpath = malloc(strlen(p->rpath_orig) + n*l + 1);
+	if (!p->rpath) return -1;
+
+	d = p->rpath;
+	s = p->rpath_orig;
+	while ((t=strchr(s, '$'))) {
+		memcpy(d, s, t-s);
+		d += t-s;
+		memcpy(d, origin, l);
+		d += l;
+		/* It was determined previously that the '$' is followed
+		 * either by "ORIGIN" or "{ORIGIN}". */
+		s = t + 7 + 2*(t[1]=='{');
+	}
+	strcpy(d, s);
+	return 0;
+}
+
+static void decode_dyn(struct dso *p)
+{
+	size_t dyn[DYN_CNT];
+	decode_vec(p->dynv, dyn, DYN_CNT);
+	p->syms = laddr(p, dyn[DT_SYMTAB]);
+	p->strings = laddr(p, dyn[DT_STRTAB]);
+	if (dyn[0]&(1<<DT_HASH))
+		p->hashtab = laddr(p, dyn[DT_HASH]);
+	if (dyn[0]&(1<<DT_RPATH))
+		p->rpath_orig = p->strings + dyn[DT_RPATH];
+	if (dyn[0]&(1<<DT_RUNPATH))
+		p->rpath_orig = p->strings + dyn[DT_RUNPATH];
+	if (dyn[0]&(1<<DT_PLTGOT))
+		p->got = laddr(p, dyn[DT_PLTGOT]);
+	if (search_vec(p->dynv, dyn, DT_GNU_HASH))
+		p->ghashtab = laddr(p, *dyn);
+	if (search_vec(p->dynv, dyn, DT_VERSYM))
+		p->versym = laddr(p, *dyn);
+}
+
+static size_t count_syms(struct dso *p)
+{
+	if (p->hashtab) return p->hashtab[1];
+
+	size_t nsym, i;
+	uint32_t *buckets = p->ghashtab + 4 + (p->ghashtab[2]*sizeof(size_t)/4);
+	uint32_t *hashval;
+	for (i = nsym = 0; i < p->ghashtab[0]; i++) {
+		if (buckets[i] > nsym)
+			nsym = buckets[i];
+	}
+	if (nsym) {
+		hashval = buckets + p->ghashtab[0] + (nsym - p->ghashtab[1]);
+		do nsym++;
+		while (!(*hashval++ & 1));
+	}
+	return nsym;
+}
+
+static void *dl_mmap(size_t n)
+{
+	void *p;
+	int prot = PROT_READ|PROT_WRITE, flags = MAP_ANONYMOUS|MAP_PRIVATE;
+#ifdef SYS_mmap2
+	p = (void *)__syscall(SYS_mmap2, 0, n, prot, flags, -1, 0);
+#else
+	p = (void *)__syscall(SYS_mmap, 0, n, prot, flags, -1, 0);
+#endif
+	return (unsigned long)p > -4096UL ? 0 : p;
+}
+
+static void makefuncdescs(struct dso *p)
+{
+	static int self_done;
+	size_t nsym = count_syms(p);
+	size_t i, size = nsym * sizeof(*p->funcdescs);
+
+	if (!self_done) {
+		p->funcdescs = dl_mmap(size);
+		self_done = 1;
+	} else {
+		p->funcdescs = malloc(size);
+	}
+	if (!p->funcdescs) {
+		if (!runtime) a_crash();
+		error("Error allocating function descriptors for %s", p->name);
+		longjmp(*rtld_fail, 1);
+	}
+	for (i=0; i<nsym; i++) {
+		if ((p->syms[i].st_info&0xf)==STT_FUNC && p->syms[i].st_shndx) {
+			p->funcdescs[i].addr = laddr(p, p->syms[i].st_value);
+			p->funcdescs[i].got = p->got;
+		} else {
+			p->funcdescs[i].addr = 0;
+			p->funcdescs[i].got = 0;
+		}
+	}
+}
+
+static struct dso *load_library(const char *name, struct dso *needed_by)
+{
+	char buf[2*NAME_MAX+2];
+	char fullpath[2*NAME_MAX+2];
+	const char *pathname;
+	unsigned char *map;
+	struct dso *p, temp_dso = {0};
+	int fd;
+	struct stat st;
+	size_t alloc_size;
+	int n_th = 0;
+	int is_self = 0;
+
+	if (!*name) {
+		errno = EINVAL;
+		return 0;
+	}
+
+	/* Catch and block attempts to reload the implementation itself */
+	if (name[0]=='l' && name[1]=='i' && name[2]=='b') {
+		static const char reserved[] =
+			"c.pthread.rt.m.dl.util.xnet.";
+		const char *rp, *next;
+		for (rp=reserved; *rp; rp=next) {
+			next = strchr(rp, '.') + 1;
+			if (strncmp(name+3, rp, next-rp) == 0)
+				break;
+		}
+		if (*rp) {
+			if (ldd_mode) {
+				/* Track which names have been resolved
+				 * and only report each one once. */
+				static unsigned reported;
+				unsigned mask = 1U<<(rp-reserved);
+				if (!(reported & mask)) {
+					reported |= mask;
+					dprintf(1, "\t%s => %s (%p)\n",
+						name, ldso.name,
+						ldso.base);
+				}
+			}
+			is_self = 1;
+		}
+	}
+	if (!strcmp(name, ldso.name)) is_self = 1;
+	if (is_self) {
+		if (!ldso.prev) {
+			tail->next = &ldso;
+			ldso.prev = tail;
+			tail = &ldso;
+		}
+		return &ldso;
+	}
+	if (strchr(name, '/')) {
+		pathname = name;
+		fd = open(name, O_RDONLY); // open(name, O_RDONLY|O_CLOEXEC);
+	} else {
+		/* Search for the name to see if it's already loaded */
+		for (p=head->next; p; p=p->next) {
+			if (p->shortname && !strcmp(p->shortname, name)) {
+				return p;
+			}
+		}
+		if (strlen(name) > NAME_MAX) return 0;
+		fd = -1;
+		if (env_path) fd = path_open(name, env_path, buf, sizeof buf);
+		for (p=needed_by; fd == -1 && p; p=p->needed_by) {
+			if (fixup_rpath(p, buf, sizeof buf) < 0)
+				fd = -2; /* Inhibit further search. */
+			if (p->rpath)
+				fd = path_open(name, p->rpath, buf, sizeof buf);
+		}
+		if (fd == -1) {
+			if (!sys_path) {
+				char *prefix = 0;
+				size_t prefix_len;
+				if (ldso.name[0]=='/') {
+					char *s, *t, *z;
+					for (s=t=z=ldso.name; *s; s++)
+						if (*s=='/') z=t, t=s;
+					prefix_len = z-ldso.name;
+					if (prefix_len < PATH_MAX)
+						prefix = ldso.name;
+				}
+				if (!prefix) {
+					prefix = "";
+					prefix_len = 0;
+				}
+				char etc_ldso_path[prefix_len + 1
+					+ sizeof "/etc/ld-musl-" LDSO_ARCH ".path"];
+				snprintf(etc_ldso_path, sizeof etc_ldso_path,
+					"%.*s/etc/ld-musl-" LDSO_ARCH ".path",
+					(int)prefix_len, prefix);
+				FILE *f = fopen(etc_ldso_path, "rbe");
+				if (f) {
+					if (getdelim(&sys_path, (size_t[1]){0}, 0, f) <= 0) {
+						free(sys_path);
+						sys_path = "";
+					}
+					fclose(f);
+				} else if (errno != ENOENT) {
+					sys_path = "";
+				}
+			}
+			if (!sys_path || sys_path[0] == 0) sys_path = "/usr/lib:/lib:/usr/local/lib";
+			fd = path_open(name, sys_path, buf, sizeof buf);
+		}
+		pathname = buf;
+	}
+	if (fd < 0) return 0;
+
+	if (pathname[0] != '/') {
+		if (!realpath(pathname, fullpath)) {
+			close(fd);
+			return 0;
+		}
+		pathname = fullpath;
+	}
+
+	for (p=head->next; p; p=p->next) {
+		if (!strcmp(p->name, pathname)) {
+			/* If this library was previously loaded with a
+			 * pathname but a search found the same inode,
+			 * setup its shortname so it can be found by name. */
+			if (!p->shortname && pathname != name)
+				p->shortname = strrchr(p->name, '/')+1;
+			close(fd);
+			return p;
+		}
+	}
+	map = noload ? 0 : map_library(fd, &temp_dso);
+	if (!map) return 0;
+
+	/* Avoid the danger of getting two versions of libc mapped into the
+	 * same process when an absolute pathname was used. The symbols
+	 * checked are chosen to catch both musl and glibc, and to avoid
+	 * false positives from interposition-hack libraries. */
+	decode_dyn(&temp_dso);
+	if (find_sym(&temp_dso, "__libc_start_main", 1).sym &&
+	    find_sym(&temp_dso, "stdin", 1).sym) {
+		unmap_library(&temp_dso);
+		return load_library("libc.so", needed_by);
+	}
+	/* Past this point, if we haven't reached runtime yet, ldso has
+	 * committed either to use the mapped library or to abort execution.
+	 * Unmapping is not possible, so we can safely reclaim gaps. */
+	if (!runtime) reclaim_gaps(&temp_dso);
+
+	/* Allocate storage for the new DSO. When there is TLS, this
+	 * storage must include a reservation for all pre-existing
+	 * threads to obtain copies of both the new TLS, and an
+	 * extended DTV capable of storing an additional slot for
+	 * the newly-loaded DSO. */
+	alloc_size = sizeof *p + strlen(pathname) + 1;
+	if (runtime && temp_dso.tls.image) {
+		size_t per_th = temp_dso.tls.size + temp_dso.tls.align
+			+ sizeof(void *) * (tls_cnt+3);
+		n_th = libc.threads_minus_1 + 1;
+		if (n_th > SSIZE_MAX / per_th) alloc_size = SIZE_MAX;
+		else alloc_size += n_th * per_th;
+	}
+	p = calloc(1, alloc_size);
+	if (!p) {
+		unmap_library(&temp_dso);
+		return 0;
+	}
+	memcpy(p, &temp_dso, sizeof temp_dso);
+	p->needed_by = needed_by;
+	p->name = p->buf;
+	p->runtime_loaded = runtime;
+	strcpy(p->name, pathname);
+	/* Add a shortname only if name arg was not an explicit pathname. */
+	if (pathname != name) p->shortname = strrchr(p->name, '/')+1;
+	if (p->tls.image) {
+		p->tls_id = ++tls_cnt;
+		tls_align = MAXP2(tls_align, p->tls.align);
+#ifdef TLS_ABOVE_TP
+		p->tls.offset = tls_offset + ( (p->tls.align-1) &
+			(-tls_offset + (uintptr_t)p->tls.image) );
+		tls_offset = p->tls.offset + p->tls.size;
+#else
+		tls_offset += p->tls.size + p->tls.align - 1;
+		tls_offset -= (tls_offset + (uintptr_t)p->tls.image)
+			& (p->tls.align-1);
+		p->tls.offset = tls_offset;
+#endif
+		p->new_dtv = (void *)(-sizeof(size_t) &
+			(uintptr_t)(p->name+strlen(p->name)+sizeof(size_t)));
+		p->new_tls = (void *)(p->new_dtv + n_th*(tls_cnt+1));
+		if (tls_tail) tls_tail->next = &p->tls;
+		else libc.tls_head = &p->tls;
+		tls_tail = &p->tls;
+	}
+
+	tail->next = p;
+	p->prev = tail;
+	tail = p;
+
+	if (DL_FDPIC) makefuncdescs(p);
+
+	if (ldd_mode) dprintf(1, "\t%s => %s (%p)\n", name, pathname, p->base);
+
+	return p;
+}
+
+static void load_direct_deps(struct dso *p)
+{
+	size_t i, cnt=0;
+
+	if (p->deps) return;
+	/* For head, all preloads are direct pseudo-dependencies.
+	 * Count and include them now to avoid realloc later. */
+	if (p==head) for (struct dso *q=p->next; q; q=q->next)
+		cnt++;
+	for (i=0; p->dynv[i]; i+=2)
+		if (p->dynv[i] == DT_NEEDED) cnt++;
+	/* Use builtin buffer for apps with no external deps, to
+	 * preserve property of no runtime failure paths. */
+	p->deps = (p==head && cnt<2) ? builtin_deps :
+		calloc(cnt+1, sizeof *p->deps);
+	if (!p->deps) {
+		error("Error loading dependencies for %s", p->name);
+		if (runtime) longjmp(*rtld_fail, 1);
+	}
+	cnt=0;
+	if (p==head) for (struct dso *q=p->next; q; q=q->next)
+		p->deps[cnt++] = q;
+	for (i=0; p->dynv[i]; i+=2) {
+		if (p->dynv[i] != DT_NEEDED) continue;
+		struct dso *dep = load_library(p->strings + p->dynv[i+1], p);
+		if (!dep) {
+			error("Error loading shared library %s: %m (needed by %s)",
+				p->strings + p->dynv[i+1], p->name);
+			if (runtime) longjmp(*rtld_fail, 1);
+			continue;
+		}
+		p->deps[cnt++] = dep;
+	}
+	p->deps[cnt] = 0;
+	p->ndeps_direct = cnt;
+}
+
+static void load_deps(struct dso *p)
+{
+	if (p->deps) return;
+	for (; p; p=p->next)
+		load_direct_deps(p);
+}
+
+static void extend_bfs_deps(struct dso *p)
+{
+	size_t i, j, cnt, ndeps_all;
+	struct dso **tmp;
+
+	/* Can't use realloc if the original p->deps was allocated at
+	 * program entry and malloc has been replaced, or if it's
+	 * the builtin non-allocated trivial main program deps array. */
+	int no_realloc = (__malloc_replaced && !p->runtime_loaded)
+		|| p->deps == builtin_deps;
+
+	if (p->bfs_built) return;
+	ndeps_all = p->ndeps_direct;
+
+	/* Mark existing (direct) deps so they won't be duplicated. */
+	for (i=0; p->deps[i]; i++)
+		p->deps[i]->mark = 1;
+
+	/* For each dependency already in the list, copy its list of direct
+	 * dependencies to the list, excluding any items already in the
+	 * list. Note that the list this loop iterates over will grow during
+	 * the loop, but since duplicates are excluded, growth is bounded. */
+	for (i=0; p->deps[i]; i++) {
+		struct dso *dep = p->deps[i];
+		for (j=cnt=0; j<dep->ndeps_direct; j++)
+			if (!dep->deps[j]->mark) cnt++;
+		tmp = no_realloc ? 
+			malloc(sizeof(*tmp) * (ndeps_all+cnt+1)) :
+			realloc(p->deps, sizeof(*tmp) * (ndeps_all+cnt+1));
+		if (!tmp) {
+			error("Error recording dependencies for %s", p->name);
+			if (runtime) longjmp(*rtld_fail, 1);
+			continue;
+		}
+		if (no_realloc) {
+			memcpy(tmp, p->deps, sizeof(*tmp) * (ndeps_all+1));
+			no_realloc = 0;
+		}
+		p->deps = tmp;
+		for (j=0; j<dep->ndeps_direct; j++) {
+			if (dep->deps[j]->mark) continue;
+			dep->deps[j]->mark = 1;
+			p->deps[ndeps_all++] = dep->deps[j];
+		}
+		p->deps[ndeps_all] = 0;
+	}
+	p->bfs_built = 1;
+	for (p=head; p; p=p->next)
+		p->mark = 0;
+}
+
+static void load_preload(char *s)
+{
+	int tmp;
+	char *z;
+	for (z=s; *z; s=z) {
+		for (   ; *s && (isspace(*s) || *s==':'); s++);
+		for (z=s; *z && !isspace(*z) && *z!=':'; z++);
+		tmp = *z;
+		*z = 0;
+		load_library(s, 0);
+		*z = tmp;
+	}
+}
+
+static void add_syms(struct dso *p)
+{
+	if (!p->syms_next && syms_tail != p) {
+		syms_tail->syms_next = p;
+		syms_tail = p;
+	}
+}
+
+static void revert_syms(struct dso *old_tail)
+{
+	struct dso *p, *next;
+	/* Chop off the tail of the list of dsos that participate in
+	 * the global symbol table, reverting them to RTLD_LOCAL. */
+	for (p=old_tail; p; p=next) {
+		next = p->syms_next;
+		p->syms_next = 0;
+	}
+	syms_tail = old_tail;
+}
+
+static void do_mips_relocs(struct dso *p, size_t *got)
+{
+	size_t i, j, rel[2];
+	unsigned char *base = p->base;
+	i=0; search_vec(p->dynv, &i, DT_MIPS_LOCAL_GOTNO);
+	if (p==&ldso) {
+		got += i;
+	} else {
+		while (i--) *got++ += (size_t)base;
+	}
+	j=0; search_vec(p->dynv, &j, DT_MIPS_GOTSYM);
+	i=0; search_vec(p->dynv, &i, DT_MIPS_SYMTABNO);
+	Sym *sym = p->syms + j;
+	rel[0] = (unsigned char *)got - base;
+	for (i-=j; i; i--, sym++, rel[0]+=sizeof(size_t)) {
+		rel[1] = R_INFO(sym-p->syms, R_MIPS_JUMP_SLOT);
+		do_relocs(p, rel, sizeof rel, 2);
+	}
+}
+
+static void reloc_all(struct dso *p)
+{
+	size_t dyn[DYN_CNT];
+	for (; p; p=p->next) {
+		if (p->relocated) continue;
+		decode_vec(p->dynv, dyn, DYN_CNT);
+		if (NEED_MIPS_GOT_RELOCS)
+			do_mips_relocs(p, laddr(p, dyn[DT_PLTGOT]));
+		do_relocs(p, laddr(p, dyn[DT_JMPREL]), dyn[DT_PLTRELSZ],
+			2+(dyn[DT_PLTREL]==DT_RELA));
+		do_relocs(p, laddr(p, dyn[DT_REL]), dyn[DT_RELSZ], 2);
+		do_relocs(p, laddr(p, dyn[DT_RELA]), dyn[DT_RELASZ], 3);
+
+		if (head != &ldso && p->relro_start != p->relro_end &&
+		    mprotect(laddr(p, p->relro_start), p->relro_end-p->relro_start, PROT_READ)
+		    && errno != ENOSYS) {
+			error("Error relocating %s: RELRO protection failed: %m",
+				p->name);
+			if (runtime) longjmp(*rtld_fail, 1);
+		}
+
+		p->relocated = 1;
+	}
+}
+
+static void kernel_mapped_dso(struct dso *p)
+{
+	size_t min_addr = -1, max_addr = 0, cnt;
+	Phdr *ph = p->phdr;
+	for (cnt = p->phnum; cnt--; ph = (void *)((char *)ph + p->phentsize)) {
+		if (ph->p_type == PT_DYNAMIC) {
+			p->dynv = laddr(p, ph->p_vaddr);
+		} else if (ph->p_type == PT_GNU_RELRO) {
+			p->relro_start = ph->p_vaddr & -PAGE_SIZE;
+			p->relro_end = (ph->p_vaddr + ph->p_memsz) & -PAGE_SIZE;
+		} else if (ph->p_type == PT_GNU_STACK) {
+			if (!runtime && ph->p_memsz > __default_stacksize) {
+				__default_stacksize =
+					ph->p_memsz < DEFAULT_STACK_MAX ?
+					ph->p_memsz : DEFAULT_STACK_MAX;
+			}
+		}
+		if (ph->p_type != PT_LOAD) continue;
+		if (ph->p_vaddr < min_addr)
+			min_addr = ph->p_vaddr;
+		if (ph->p_vaddr+ph->p_memsz > max_addr)
+			max_addr = ph->p_vaddr+ph->p_memsz;
+	}
+	min_addr &= -PAGE_SIZE;
+	max_addr = (max_addr + PAGE_SIZE-1) & -PAGE_SIZE;
+	p->map = p->base + min_addr;
+	p->map_len = max_addr - min_addr;
+	p->kernel_mapped = 1;
+}
+
+void __libc_exit_fini()
+{
+	struct dso *p;
+	size_t dyn[DYN_CNT];
+	int self = __pthread_self()->tid;
+
+	/* Take both locks before setting shutting_down, so that
+	 * either lock is sufficient to read its value. The lock
+	 * order matches that in dlopen to avoid deadlock. */
+	pthread_rwlock_wrlock(&lock);
+	pthread_mutex_lock(&init_fini_lock);
+	shutting_down = 1;
+	pthread_rwlock_unlock(&lock);
+	for (p=fini_head; p; p=p->fini_next) {
+		while (p->ctor_visitor && p->ctor_visitor!=self)
+			pthread_cond_wait(&ctor_cond, &init_fini_lock);
+		if (!p->constructed) continue;
+		decode_vec(p->dynv, dyn, DYN_CNT);
+		if (dyn[0] & (1<<DT_FINI_ARRAY)) {
+			size_t n = dyn[DT_FINI_ARRAYSZ]/sizeof(size_t);
+			size_t *fn = (size_t *)laddr(p, dyn[DT_FINI_ARRAY])+n;
+			while (n--) ((void (*)(void))*--fn)();
+		}
+#ifndef NO_LEGACY_INITFINI
+		if ((dyn[0] & (1<<DT_FINI)) && dyn[DT_FINI])
+			fpaddr(p, dyn[DT_FINI])();
+#endif
+	}
+}
+
+static struct dso **queue_ctors(struct dso *dso)
+{
+	size_t cnt, qpos, spos, i;
+	struct dso *p, **queue, **stack;
+
+	if (ldd_mode) return 0;
+
+	/* Bound on queue size is the total number of indirect deps.
+	 * If a bfs deps list was built, we can use it. Otherwise,
+	 * bound by the total number of DSOs, which is always safe and
+	 * is reasonable we use it (for main app at startup). */
+	if (dso->bfs_built) {
+		for (cnt=0; dso->deps[cnt]; cnt++)
+			dso->deps[cnt]->mark = 0;
+		cnt++; /* self, not included in deps */
+	} else {
+		for (cnt=0, p=head; p; cnt++, p=p->next)
+			p->mark = 0;
+	}
+	cnt++; /* termination slot */
+	if (dso==head && cnt <= countof(builtin_ctor_queue))
+		queue = builtin_ctor_queue;
+	else
+		queue = calloc(cnt, sizeof *queue);
+
+	if (!queue) {
+		error("Error allocating constructor queue: %m\n");
+		if (runtime) longjmp(*rtld_fail, 1);
+		return 0;
+	}
+
+	/* Opposite ends of the allocated buffer serve as an output queue
+	 * and a working stack. Setup initial stack with just the argument
+	 * dso and initial queue empty... */
+	stack = queue;
+	qpos = 0;
+	spos = cnt;
+	stack[--spos] = dso;
+	dso->next_dep = 0;
+	dso->mark = 1;
+
+	/* Then perform pseudo-DFS sort, but ignoring circular deps. */
+	while (spos<cnt) {
+		p = stack[spos++];
+		while (p->next_dep < p->ndeps_direct) {
+			if (p->deps[p->next_dep]->mark) {
+				p->next_dep++;
+			} else {
+				stack[--spos] = p;
+				p = p->deps[p->next_dep];
+				p->next_dep = 0;
+				p->mark = 1;
+			}
+		}
+		queue[qpos++] = p;
+	}
+	queue[qpos] = 0;
+	for (i=0; i<qpos; i++) queue[i]->mark = 0;
+
+	return queue;
+}
+
+static void do_init_fini(struct dso **queue)
+{
+	struct dso *p;
+	size_t dyn[DYN_CNT], i;
+	int self = __pthread_self()->tid;
+
+	pthread_mutex_lock(&init_fini_lock);
+	for (i=0; (p=queue[i]); i++) {
+		while ((p->ctor_visitor && p->ctor_visitor!=self) || shutting_down)
+			pthread_cond_wait(&ctor_cond, &init_fini_lock);
+		if (p->ctor_visitor || p->constructed)
+			continue;
+		p->ctor_visitor = self;
+		
+		decode_vec(p->dynv, dyn, DYN_CNT);
+		if (dyn[0] & ((1<<DT_FINI) | (1<<DT_FINI_ARRAY))) {
+			p->fini_next = fini_head;
+			fini_head = p;
+		}
+
+		pthread_mutex_unlock(&init_fini_lock);
+
+#ifndef NO_LEGACY_INITFINI
+		if ((dyn[0] & (1<<DT_INIT)) && dyn[DT_INIT])
+			fpaddr(p, dyn[DT_INIT])();
+#endif
+		if (dyn[0] & (1<<DT_INIT_ARRAY)) {
+			size_t n = dyn[DT_INIT_ARRAYSZ]/sizeof(size_t);
+			size_t *fn = laddr(p, dyn[DT_INIT_ARRAY]);
+			while (n--) ((void (*)(void))*fn++)();
+		}
+
+		pthread_mutex_lock(&init_fini_lock);
+		p->ctor_visitor = 0;
+		p->constructed = 1;
+		pthread_cond_broadcast(&ctor_cond);
+	}
+	pthread_mutex_unlock(&init_fini_lock);
+}
+
+void __libc_start_init(void)
+{
+	do_init_fini(main_ctor_queue);
+	if (!__malloc_replaced && main_ctor_queue != builtin_ctor_queue)
+		free(main_ctor_queue);
+	main_ctor_queue = 0;
+}
+
+static void dl_debug_state(void)
+{
+}
+
+weak_alias(dl_debug_state, _dl_debug_state);
+
+void __init_tls(size_t *auxv)
+{
+}
+
+static void update_tls_size()
+{
+	libc.tls_cnt = tls_cnt;
+	libc.tls_align = tls_align;
+	libc.tls_size = ALIGN(
+		(1+tls_cnt) * sizeof(void *) +
+		tls_offset +
+		sizeof(struct pthread) +
+		tls_align * 2,
+	tls_align);
+}
+
+static void install_new_tls(void)
+{
+	sigset_t set;
+	pthread_t self = __pthread_self(), td;
+	struct dso *dtv_provider = container_of(tls_tail, struct dso, tls);
+	uintptr_t (*newdtv)[tls_cnt+1] = (void *)dtv_provider->new_dtv;
+	struct dso *p;
+	size_t i, j;
+	size_t old_cnt = self->dtv[0];
+
+	__block_app_sigs(&set);
+	__tl_lock();
+	/* Copy existing dtv contents from all existing threads. */
+	for (i=0, td=self; !i || td!=self; i++, td=td->next) {
+		memcpy(newdtv+i, td->dtv,
+			(old_cnt+1)*sizeof(uintptr_t));
+		newdtv[i][0] = tls_cnt;
+	}
+	/* Install new dtls into the enlarged, uninstalled dtv copies. */
+	for (p=head; ; p=p->next) {
+		if (p->tls_id <= old_cnt) continue;
+		unsigned char *mem = p->new_tls;
+		for (j=0; j<i; j++) {
+			unsigned char *new = mem;
+			new += ((uintptr_t)p->tls.image - (uintptr_t)mem)
+				& (p->tls.align-1);
+			memcpy(new, p->tls.image, p->tls.len);
+			newdtv[j][p->tls_id] =
+				(uintptr_t)new + DTP_OFFSET;
+			mem += p->tls.size + p->tls.align;
+		}
+		if (p->tls_id == tls_cnt) break;
+	}
+
+	/* Broadcast barrier to ensure contents of new dtv is visible
+	 * if the new dtv pointer is. The __membarrier function has a
+	 * fallback emulation using signals for kernels that lack the
+	 * feature at the syscall level. */
+
+	__membarrier(MEMBARRIER_CMD_PRIVATE_EXPEDITED, 0);
+
+	/* Install new dtv for each thread. */
+	for (j=0, td=self; !j || td!=self; j++, td=td->next) {
+		td->dtv = td->dtv_copy = newdtv[j];
+	}
+
+	__tl_unlock();
+	__restore_sigs(&set);
+}
+
+/* Stage 1 of the dynamic linker is defined in dlstart.c. It calls the
+ * following stage 2 and stage 3 functions via primitive symbolic lookup
+ * since it does not have access to their addresses to begin with. */
+
+/* Stage 2 of the dynamic linker is called after relative relocations 
+ * have been processed. It can make function calls to static functions
+ * and access string literals and static data, but cannot use extern
+ * symbols. Its job is to perform symbolic relocations on the dynamic
+ * linker itself, but some of the relocations performed may need to be
+ * replaced later due to copy relocations in the main program. */
+
+hidden void __dls2(unsigned char *base, size_t *sp)
+{
+	size_t *auxv;
+	for (auxv=sp+1+*sp+1; *auxv; auxv++);
+	auxv++;
+	if (DL_FDPIC) {
+		void *p1 = (void *)sp[-2];
+		void *p2 = (void *)sp[-1];
+		if (!p1) {
+			size_t aux[AUX_CNT];
+			decode_vec(auxv, aux, AUX_CNT);
+			if (aux[AT_BASE]) ldso.base = (void *)aux[AT_BASE];
+			else ldso.base = (void *)(aux[AT_PHDR] & -4096);
+		}
+		app_loadmap = p2 ? p1 : 0;
+		ldso.loadmap = p2 ? p2 : p1;
+		ldso.base = laddr(&ldso, 0);
+	} else {
+		ldso.base = base;
+	}
+	Ehdr *ehdr = (void *)ldso.base;
+	ldso.name = ldso.shortname = "libc.so";
+	ldso.phnum = ehdr->e_phnum;
+	ldso.phdr = laddr(&ldso, ehdr->e_phoff);
+	ldso.phentsize = ehdr->e_phentsize;
+	kernel_mapped_dso(&ldso);
+	decode_dyn(&ldso);
+
+	if (DL_FDPIC) makefuncdescs(&ldso);
+
+	/* Prepare storage for to save clobbered REL addends so they
+	 * can be reused in stage 3. There should be very few. If
+	 * something goes wrong and there are a huge number, abort
+	 * instead of risking stack overflow. */
+	size_t dyn[DYN_CNT];
+	decode_vec(ldso.dynv, dyn, DYN_CNT);
+	size_t *rel = laddr(&ldso, dyn[DT_REL]);
+	size_t rel_size = dyn[DT_RELSZ];
+	size_t symbolic_rel_cnt = 0;
+	apply_addends_to = rel;
+	for (; rel_size; rel+=2, rel_size-=2*sizeof(size_t))
+		if (!IS_RELATIVE(rel[1], ldso.syms)) symbolic_rel_cnt++;
+	if (symbolic_rel_cnt >= ADDEND_LIMIT) a_crash();
+	size_t addends[symbolic_rel_cnt+1];
+	saved_addends = addends;
+
+	head = &ldso;
+	reloc_all(&ldso);
+
+	ldso.relocated = 0;
+
+	/* Call dynamic linker stage-2b, __dls2b, looking it up
+	 * symbolically as a barrier against moving the address
+	 * load across the above relocation processing. */
+	struct symdef dls2b_def = find_sym(&ldso, "__dls2b", 0);
+	if (DL_FDPIC) ((stage3_func)&ldso.funcdescs[dls2b_def.sym-ldso.syms])(sp, auxv);
+	else ((stage3_func)laddr(&ldso, dls2b_def.sym->st_value))(sp, auxv);
+}
+
+/* Stage 2b sets up a valid thread pointer, which requires relocations
+ * completed in stage 2, and on which stage 3 is permitted to depend.
+ * This is done as a separate stage, with symbolic lookup as a barrier,
+ * so that loads of the thread pointer and &errno can be pure/const and
+ * thereby hoistable. */
+
+void __dls2b(size_t *sp, size_t *auxv)
+{
+	/* Setup early thread pointer in builtin_tls for ldso/libc itself to
+	 * use during dynamic linking. If possible it will also serve as the
+	 * thread pointer at runtime. */
+	search_vec(auxv, &__hwcap, AT_HWCAP);
+	libc.auxv = auxv;
+	libc.tls_size = sizeof builtin_tls;
+	libc.tls_align = tls_align;
+	if (__init_tp(__copy_tls((void *)builtin_tls)) < 0) {
+		a_crash();
+	}
+
+	struct symdef dls3_def = find_sym(&ldso, "__dls3", 0);
+	if (DL_FDPIC) ((stage3_func)&ldso.funcdescs[dls3_def.sym-ldso.syms])(sp, auxv);
+	else ((stage3_func)laddr(&ldso, dls3_def.sym->st_value))(sp, auxv);
+}
+
+/* Stage 3 of the dynamic linker is called with the dynamic linker/libc
+ * fully functional. Its job is to load (if not already loaded) and
+ * process dependencies and relocations for the main application and
+ * transfer control to its entry point. */
+
+void __dls3(size_t *sp, size_t *auxv)
+{
+	static struct dso app, vdso;
+	size_t aux[AUX_CNT];
+	size_t i;
+	char *env_preload=0;
+	char *replace_argv0=0;
+	size_t vdso_base;
+	int argc = *sp;
+	char **argv = (void *)(sp+1);
+	char **argv_orig = argv;
+	char **envp = argv+argc+1;
+
+	/* Find aux vector just past environ[] and use it to initialize
+	 * global data that may be needed before we can make syscalls. */
+	__environ = envp;
+	decode_vec(auxv, aux, AUX_CNT);
+	search_vec(auxv, &__sysinfo, AT_SYSINFO);
+	__pthread_self()->sysinfo = __sysinfo;
+	libc.page_size = aux[AT_PAGESZ];
+	libc.secure = ((aux[0]&0x7800)!=0x7800 || aux[AT_UID]!=aux[AT_EUID]
+		|| aux[AT_GID]!=aux[AT_EGID] || aux[AT_SECURE]);
+
+	/* Only trust user/env if kernel says we're not suid/sgid */
+	if (!libc.secure) {
+		env_path = getenv("LD_LIBRARY_PATH");
+		env_preload = getenv("LD_PRELOAD");
+	}
+
+	/* If the main program was already loaded by the kernel,
+	 * AT_PHDR will point to some location other than the dynamic
+	 * linker's program headers. */
+	if (aux[AT_PHDR] != (size_t)ldso.phdr) {
+		size_t interp_off = 0;
+		size_t tls_image = 0;
+		/* Find load address of the main program, via AT_PHDR vs PT_PHDR. */
+		Phdr *phdr = app.phdr = (void *)aux[AT_PHDR];
+		app.phnum = aux[AT_PHNUM];
+		app.phentsize = aux[AT_PHENT];
+		for (i=aux[AT_PHNUM]; i; i--, phdr=(void *)((char *)phdr + aux[AT_PHENT])) {
+			if (phdr->p_type == PT_PHDR)
+				app.base = (void *)(aux[AT_PHDR] - phdr->p_vaddr);
+			else if (phdr->p_type == PT_INTERP)
+				interp_off = (size_t)phdr->p_vaddr;
+			else if (phdr->p_type == PT_TLS) {
+				tls_image = phdr->p_vaddr;
+				app.tls.len = phdr->p_filesz;
+				app.tls.size = phdr->p_memsz;
+				app.tls.align = phdr->p_align;
+			}
+		}
+		if (DL_FDPIC) app.loadmap = app_loadmap;
+		if (app.tls.size) app.tls.image = laddr(&app, tls_image);
+		if (interp_off) ldso.name = "/lib/libc.so";
+#if 0
+		if ((aux[0] & (1UL<<AT_EXECFN))
+		    && strncmp((char *)aux[AT_EXECFN], "/proc/", 6))
+			app.name = (char *)aux[AT_EXECFN];
+		else
+			app.name = argv[0];
+#else
+		if (argv[0])
+			app.name = argv[0];
+		else
+			app.name = "none";
+#endif
+		kernel_mapped_dso(&app);
+	} else {
+		int fd;
+		char *ldname = argv[0];
+		size_t l = strlen(ldname);
+		if (l >= 3 && !strcmp(ldname+l-3, "ldd")) ldd_mode = 1;
+		argv++;
+		while (argv[0] && argv[0][0]=='-' && argv[0][1]=='-') {
+			char *opt = argv[0]+2;
+			*argv++ = (void *)-1;
+			if (!*opt) {
+				break;
+			} else if (!memcmp(opt, "list", 5)) {
+				ldd_mode = 1;
+			} else if (!memcmp(opt, "library-path", 12)) {
+				if (opt[12]=='=') env_path = opt+13;
+				else if (opt[12]) *argv = 0;
+				else if (*argv) env_path = *argv++;
+			} else if (!memcmp(opt, "preload", 7)) {
+				if (opt[7]=='=') env_preload = opt+8;
+				else if (opt[7]) *argv = 0;
+				else if (*argv) env_preload = *argv++;
+			} else if (!memcmp(opt, "argv0", 5)) {
+				if (opt[5]=='=') replace_argv0 = opt+6;
+				else if (opt[5]) *argv = 0;
+				else if (*argv) replace_argv0 = *argv++;
+			} else {
+				argv[0] = 0;
+			}
+		}
+		argv[-1] = (void *)(argc - (argv-argv_orig));
+		if (!argv[0]) {
+			dprintf(2, "musl libc (" LDSO_ARCH ")\n"
+				"Version %s\n"
+				"Dynamic Program Loader\n"
+				"Usage: %s [options] [--] pathname%s\n",
+				__libc_version, ldname,
+				ldd_mode ? "" : " [args]");
+			_exit(1);
+		}
+		fd = open(argv[0], O_RDONLY);
+		if (fd < 0) {
+			dprintf(2, "%s: cannot load %s: %s\n", ldname, argv[0], strerror(errno));
+			_exit(1);
+		}
+		Ehdr *ehdr = (void *)map_library(fd, &app);
+		if (!ehdr) {
+			dprintf(2, "%s: %s: Not a valid dynamic program\n", ldname, argv[0]);
+			_exit(1);
+		}
+		ldso.name = ldname;
+		app.name = argv[0];
+		aux[AT_ENTRY] = (size_t)laddr(&app, ehdr->e_entry);
+		/* Find the name that would have been used for the dynamic
+		 * linker had ldd not taken its place. */
+		if (ldd_mode) {
+			for (i=0; i<app.phnum; i++) {
+				if (app.phdr[i].p_type == PT_INTERP)
+					ldso.name = laddr(&app, app.phdr[i].p_vaddr);
+			}
+			dprintf(1, "\t%s (%p)\n", ldso.name, ldso.base);
+		}
+	}
+	if (app.tls.size) {
+		libc.tls_head = tls_tail = &app.tls;
+		app.tls_id = tls_cnt = 1;
+#ifdef TLS_ABOVE_TP
+		app.tls.offset = GAP_ABOVE_TP;
+		app.tls.offset += (-GAP_ABOVE_TP + (uintptr_t)app.tls.image)
+			& (app.tls.align-1);
+		tls_offset = app.tls.offset + app.tls.size;
+#else
+		tls_offset = app.tls.offset = app.tls.size
+			+ ( -((uintptr_t)app.tls.image + app.tls.size)
+			& (app.tls.align-1) );
+#endif
+		tls_align = MAXP2(tls_align, app.tls.align);
+	}
+	decode_dyn(&app);
+	if (DL_FDPIC) {
+		makefuncdescs(&app);
+		if (!app.loadmap) {
+			app.loadmap = (void *)&app_dummy_loadmap;
+			app.loadmap->nsegs = 1;
+			app.loadmap->segs[0].addr = (size_t)app.map;
+			app.loadmap->segs[0].p_vaddr = (size_t)app.map
+				- (size_t)app.base;
+			app.loadmap->segs[0].p_memsz = app.map_len;
+		}
+		argv[-3] = (void *)app.loadmap;
+	}
+
+	/* Initial dso chain consists only of the app. */
+	head = tail = syms_tail = &app;
+
+	/* Donate unused parts of app and library mapping to malloc */
+	reclaim_gaps(&app);
+	reclaim_gaps(&ldso);
+
+	/* Load preload/needed libraries, add symbols to global namespace. */
+	ldso.deps = (struct dso **)no_deps;
+	if (env_preload) load_preload(env_preload);
+ 	load_deps(&app);
+	for (struct dso *p=head; p; p=p->next)
+		add_syms(p);
+
+	/* Attach to vdso, if provided by the kernel, last so that it does
+	 * not become part of the global namespace.  */
+	if (search_vec(auxv, &vdso_base, AT_SYSINFO_EHDR) && vdso_base) {
+		Ehdr *ehdr = (void *)vdso_base;
+		Phdr *phdr = vdso.phdr = (void *)(vdso_base + ehdr->e_phoff);
+		vdso.phnum = ehdr->e_phnum;
+		vdso.phentsize = ehdr->e_phentsize;
+		for (i=ehdr->e_phnum; i; i--, phdr=(void *)((char *)phdr + ehdr->e_phentsize)) {
+			if (phdr->p_type == PT_DYNAMIC)
+				vdso.dynv = (void *)(vdso_base + phdr->p_offset);
+			if (phdr->p_type == PT_LOAD)
+				vdso.base = (void *)(vdso_base - phdr->p_vaddr + phdr->p_offset);
+		}
+		vdso.name = "";
+		vdso.shortname = "OHOS-vdso.so";
+		vdso.relocated = 1;
+		vdso.deps = (struct dso **)no_deps;
+		decode_dyn(&vdso);
+		vdso.prev = tail;
+		tail->next = &vdso;
+		tail = &vdso;
+	}
+
+	for (i=0; app.dynv[i]; i+=2) {
+		if (!DT_DEBUG_INDIRECT && app.dynv[i]==DT_DEBUG)
+			app.dynv[i+1] = (size_t)&debug;
+		if (DT_DEBUG_INDIRECT && app.dynv[i]==DT_DEBUG_INDIRECT) {
+			size_t *ptr = (size_t *) app.dynv[i+1];
+			*ptr = (size_t)&debug;
+		}
+	}
+
+	/* This must be done before final relocations, since it calls
+	 * malloc, which may be provided by the application. Calling any
+	 * application code prior to the jump to its entry point is not
+	 * valid in our model and does not work with FDPIC, where there
+	 * are additional relocation-like fixups that only the entry point
+	 * code can see to perform. */
+	main_ctor_queue = queue_ctors(&app);
+
+	/* Initial TLS must also be allocated before final relocations
+	 * might result in calloc being a call to application code. */
+	update_tls_size();
+	void *initial_tls = builtin_tls;
+	if (libc.tls_size > sizeof builtin_tls || tls_align > MIN_TLS_ALIGN) {
+		initial_tls = calloc(libc.tls_size, 1);
+		if (!initial_tls) {
+			dprintf(2, "%s: Error getting %zu bytes thread-local storage: %m\n",
+				argv[0], libc.tls_size);
+			_exit(127);
+		}
+	}
+	static_tls_cnt = tls_cnt;
+
+	/* The main program must be relocated LAST since it may contain
+	 * copy relocations which depend on libraries' relocations. */
+	reloc_all(app.next);
+	reloc_all(&app);
+
+	/* Actual copying to new TLS needs to happen after relocations,
+	 * since the TLS images might have contained relocated addresses. */
+	if (initial_tls != builtin_tls) {
+		if (__init_tp(__copy_tls(initial_tls)) < 0) {
+			a_crash();
+		}
+	} else {
+		size_t tmp_tls_size = libc.tls_size;
+		pthread_t self = __pthread_self();
+		/* Temporarily set the tls size to the full size of
+		 * builtin_tls so that __copy_tls will use the same layout
+		 * as it did for before. Then check, just to be safe. */
+		libc.tls_size = sizeof builtin_tls;
+		if (__copy_tls((void*)builtin_tls) != self) a_crash();
+		libc.tls_size = tmp_tls_size;
+	}
+
+	if (ldso_fail) _exit(127);
+	if (ldd_mode) _exit(0);
+
+	/* Determine if malloc was interposed by a replacement implementation
+	 * so that calloc and the memalign family can harden against the
+	 * possibility of incomplete replacement. */
+	if (find_sym(head, "malloc", 1).dso != &ldso)
+		__malloc_replaced = 1;
+
+	/* Switch to runtime mode: any further failures in the dynamic
+	 * linker are a reportable failure rather than a fatal startup
+	 * error. */
+	runtime = 1;
+
+	debug.ver = 1;
+	debug.bp = dl_debug_state;
+	debug.head = head;
+	debug.base = ldso.base;
+	debug.state = 0;
+	_dl_debug_state();
+
+	if (replace_argv0) argv[0] = replace_argv0;
+
+	errno = 0;
+
+	CRTJMP((void *)aux[AT_ENTRY], argv-1);
+	for(;;);
+}
+
+static void prepare_lazy(struct dso *p)
+{
+	size_t dyn[DYN_CNT], n, flags1=0;
+	decode_vec(p->dynv, dyn, DYN_CNT);
+	search_vec(p->dynv, &flags1, DT_FLAGS_1);
+	if (dyn[DT_BIND_NOW] || (dyn[DT_FLAGS] & DF_BIND_NOW) || (flags1 & DF_1_NOW))
+		return;
+	n = dyn[DT_RELSZ]/2 + dyn[DT_RELASZ]/3 + dyn[DT_PLTRELSZ]/2 + 1;
+	if (NEED_MIPS_GOT_RELOCS) {
+		size_t j=0; search_vec(p->dynv, &j, DT_MIPS_GOTSYM);
+		size_t i=0; search_vec(p->dynv, &i, DT_MIPS_SYMTABNO);
+		n += i-j;
+	}
+	p->lazy = calloc(n, 3*sizeof(size_t));
+	if (!p->lazy) {
+		error("Error preparing lazy relocation for %s: %m", p->name);
+		longjmp(*rtld_fail, 1);
+	}
+	p->lazy_next = lazy_head;
+	lazy_head = p;
+}
+
+void *dlopen(const char *file, int mode)
+{
+	struct dso *volatile p, *orig_tail, *orig_syms_tail, *orig_lazy_head, *next;
+	struct tls_module *orig_tls_tail;
+	size_t orig_tls_cnt, orig_tls_offset, orig_tls_align;
+	size_t i;
+	int cs;
+	jmp_buf jb;
+	struct dso **volatile ctor_queue = 0;
+
+	if (mode & ~(RTLD_LAZY | RTLD_NOW | RTLD_NOLOAD | RTLD_GLOBAL | RTLD_LOCAL | RTLD_NODELETE)) {
+		error("invalid mode parameter for dlopen().");
+		return NULL;
+	}
+
+	if ((mode & (RTLD_LAZY | RTLD_NOW)) == 0) {
+		error("invalid mode, one of RTLD_LAZY and RTLD_NOW must be set.");
+		return NULL;
+	}
+
+	if (!file) return head;
+
+	pthread_setcancelstate(PTHREAD_CANCEL_DISABLE, &cs);
+	pthread_rwlock_wrlock(&lock);
+	__inhibit_ptc();
+
+	p = 0;
+	if (shutting_down) {
+		error("Cannot dlopen while program is exiting.");
+		goto end;
+	}
+	orig_tls_tail = tls_tail;
+	orig_tls_cnt = tls_cnt;
+	orig_tls_offset = tls_offset;
+	orig_tls_align = tls_align;
+	orig_lazy_head = lazy_head;
+	orig_syms_tail = syms_tail;
+	orig_tail = tail;
+	noload = mode & RTLD_NOLOAD;
+
+	rtld_fail = &jb;
+	if (setjmp(*rtld_fail)) {
+		/* Clean up anything new that was (partially) loaded */
+		revert_syms(orig_syms_tail);
+		for (p=orig_tail->next; p; p=next) {
+			next = p->next;
+			while (p->td_index) {
+				void *tmp = p->td_index->next;
+				free(p->td_index);
+				p->td_index = tmp;
+			}
+			free(p->funcdescs);
+			if (p->rpath != p->rpath_orig)
+				free(p->rpath);
+			free(p->deps);
+			unmap_library(p);
+			free(p);
+		}
+		free(ctor_queue);
+		ctor_queue = 0;
+		if (!orig_tls_tail) libc.tls_head = 0;
+		tls_tail = orig_tls_tail;
+		if (tls_tail) tls_tail->next = 0;
+		tls_cnt = orig_tls_cnt;
+		tls_offset = orig_tls_offset;
+		tls_align = orig_tls_align;
+		lazy_head = orig_lazy_head;
+		tail = orig_tail;
+		tail->next = 0;
+		p = 0;
+		goto end;
+	} else p = load_library(file, head);
+
+	if (!p) {
+		error(noload ?
+			"Library %s is not already loaded" :
+			"Error loading shared library %s: %m",
+			file);
+		goto end;
+	}
+
+	/* First load handling */
+	load_deps(p);
+	extend_bfs_deps(p);
+	pthread_mutex_lock(&init_fini_lock);
+	if (!p->constructed) ctor_queue = queue_ctors(p);
+	pthread_mutex_unlock(&init_fini_lock);
+	if (!p->relocated && (mode & RTLD_LAZY)) {
+		prepare_lazy(p);
+		for (i=0; p->deps[i]; i++)
+			if (!p->deps[i]->relocated)
+				prepare_lazy(p->deps[i]);
+	}
+	if (!p->relocated || (mode & RTLD_GLOBAL)) {
+		/* Make new symbols global, at least temporarily, so we can do
+		 * relocations. If not RTLD_GLOBAL, this is reverted below. */
+		add_syms(p);
+		for (i=0; p->deps[i]; i++)
+			add_syms(p->deps[i]);
+	}
+	if (!p->relocated) {
+		reloc_all(p);
+	}
+
+	/* If RTLD_GLOBAL was not specified, undo any new additions
+	 * to the global symbol table. This is a nop if the library was
+	 * previously loaded and already global. */
+	if (!(mode & RTLD_GLOBAL))
+		revert_syms(orig_syms_tail);
+
+	/* Processing of deferred lazy relocations must not happen until
+	 * the new libraries are committed; otherwise we could end up with
+	 * relocations resolved to symbol definitions that get removed. */
+	redo_lazy_relocs();
+
+	update_tls_size();
+	if (tls_cnt != orig_tls_cnt)
+		install_new_tls();
+	_dl_debug_state();
+	orig_tail = tail;
+end:
+	__release_ptc();
+	if (p) gencnt++;
+	pthread_rwlock_unlock(&lock);
+	if (ctor_queue) {
+		do_init_fini(ctor_queue);
+		free(ctor_queue);
+	}
+	pthread_setcancelstate(cs, 0);
+	return p;
+}
+
+hidden int __dl_invalid_handle(void *h)
+{
+	struct dso *p;
+	for (p=head; p; p=p->next) if (h==p) return 0;
+	error("Invalid library handle %p", (void *)h);
+	return 1;
+}
+
+static void *addr2dso(size_t a)
+{
+	struct dso *p;
+	size_t i;
+	if (DL_FDPIC) for (p=head; p; p=p->next) {
+		i = count_syms(p);
+		if (a-(size_t)p->funcdescs < i*sizeof(*p->funcdescs))
+			return p;
+	}
+	for (p=head; p; p=p->next) {
+		if (DL_FDPIC && p->loadmap) {
+			for (i=0; i<p->loadmap->nsegs; i++) {
+				if (a-p->loadmap->segs[i].p_vaddr
+				    < p->loadmap->segs[i].p_memsz)
+					return p;
+			}
+		} else {
+			Phdr *ph = p->phdr;
+			size_t phcnt = p->phnum;
+			size_t entsz = p->phentsize;
+			size_t base = (size_t)p->base;
+			for (; phcnt--; ph=(void *)((char *)ph+entsz)) {
+				if (ph->p_type != PT_LOAD) continue;
+				if (a-base-ph->p_vaddr < ph->p_memsz)
+					return p;
+			}
+			if (a-(size_t)p->map < p->map_len)
+				return 0;
+		}
+	}
+	return 0;
+}
+
+static void *do_dlsym(struct dso *p, const char *s, void *ra)
+{
+	int use_deps = 0;
+	if (p == head || p == RTLD_DEFAULT) {
+		p = head;
+	} else if (p == RTLD_NEXT) {
+		p = addr2dso((size_t)ra);
+		if (!p) p=head;
+		p = p->next;
+	} else if (__dl_invalid_handle(p)) {
+		return 0;
+	} else
+		use_deps = 1;
+	struct symdef def = find_sym2(p, s, 0, use_deps);
+	if (!def.sym) {
+		error("Symbol not found: %s", s);
+		return 0;
+	}
+	if ((def.sym->st_info&0xf) == STT_TLS)
+		return __tls_get_addr((tls_mod_off_t []){def.dso->tls_id, def.sym->st_value-DTP_OFFSET});
+	if (DL_FDPIC && (def.sym->st_info&0xf) == STT_FUNC)
+		return def.dso->funcdescs + (def.sym - def.dso->syms);
+	return laddr(def.dso, def.sym->st_value);
+}
+
+int dladdr(const void *addr_arg, Dl_info *info)
+{
+	size_t addr = (size_t)addr_arg;
+	struct dso *p;
+	Sym *sym, *bestsym;
+	uint32_t nsym;
+	char *strings;
+	size_t best = 0;
+	size_t besterr = -1;
+
+	pthread_rwlock_rdlock(&lock);
+	p = addr2dso(addr);
+	pthread_rwlock_unlock(&lock);
+
+	if (!p) return 0;
+
+	sym = p->syms;
+	strings = p->strings;
+	nsym = count_syms(p);
+
+	if (DL_FDPIC) {
+		size_t idx = (addr-(size_t)p->funcdescs)
+			/ sizeof(*p->funcdescs);
+		if (idx < nsym && (sym[idx].st_info&0xf) == STT_FUNC) {
+			best = (size_t)(p->funcdescs + idx);
+			bestsym = sym + idx;
+			besterr = 0;
+		}
+	}
+
+	if (!best) for (; nsym; nsym--, sym++) {
+		if (sym->st_value
+		 && (1<<(sym->st_info&0xf) & OK_TYPES)
+		 && (1<<(sym->st_info>>4) & OK_BINDS)) {
+			size_t symaddr = (size_t)laddr(p, sym->st_value);
+			if (symaddr > addr || symaddr <= best)
+				continue;
+			best = symaddr;
+			bestsym = sym;
+			besterr = addr - symaddr;
+			if (addr == symaddr)
+				break;
+		}
+	}
+
+	if (best && besterr > bestsym->st_size-1) {
+		best = 0;
+		bestsym = 0;
+	}
+
+	info->dli_fname = p->name;
+	info->dli_fbase = p->map;
+
+	if (!best) {
+		info->dli_sname = 0;
+		info->dli_saddr = 0;
+		return 1;
+	}
+
+	if (DL_FDPIC && (bestsym->st_info&0xf) == STT_FUNC)
+		best = (size_t)(p->funcdescs + (bestsym - p->syms));
+	info->dli_sname = strings + bestsym->st_name;
+	info->dli_saddr = (void *)best;
+
+	return 1;
+}
+
+hidden void *__dlsym(void *restrict p, const char *restrict s, void *restrict ra)
+{
+	void *res;
+	pthread_rwlock_rdlock(&lock);
+	res = do_dlsym(p, s, ra);
+	pthread_rwlock_unlock(&lock);
+	return res;
+}
+
+hidden void *__dlsym_redir_time64(void *restrict p, const char *restrict s, void *restrict ra)
+{
+#if _REDIR_TIME64
+	const char *suffix, *suffix2 = "";
+	char redir[36];
+
+	/* Map the symbol name to a time64 version of itself according to the
+	 * pattern used for naming the redirected time64 symbols. */
+	size_t l = strnlen(s, sizeof redir);
+	if (l<4 || l==sizeof redir) goto no_redir;
+	if (s[l-2]=='_' && s[l-1]=='r') {
+		l -= 2;
+		suffix2 = s+l;
+	}
+	if (l<4) goto no_redir;
+	if (!strcmp(s+l-4, "time")) suffix = "64";
+	else suffix = "_time64";
+
+	/* Use the presence of the remapped symbol name in libc to determine
+	 * whether it's one that requires time64 redirection; replace if so. */
+	snprintf(redir, sizeof redir, "__%.*s%s%s", (int)l, s, suffix, suffix2);
+	if (find_sym(&ldso, redir, 1).sym) s = redir;
+no_redir:
+#endif
+	return __dlsym(p, s, ra);
+}
+
+int dl_iterate_phdr(int(*callback)(struct dl_phdr_info *info, size_t size, void *data), void *data)
+{
+	struct dso *current;
+	struct dl_phdr_info info;
+	int ret = 0;
+	for(current = head; current;) {
+		info.dlpi_addr      = (uintptr_t)current->base;
+		info.dlpi_name      = current->name;
+		info.dlpi_phdr      = current->phdr;
+		info.dlpi_phnum     = current->phnum;
+		info.dlpi_adds      = gencnt;
+		info.dlpi_subs      = 0;
+		info.dlpi_tls_modid = current->tls_id;
+		info.dlpi_tls_data  = current->tls.image;
+
+		ret = (callback)(&info, sizeof (info), data);
+
+		if (ret != 0) break;
+
+		pthread_rwlock_rdlock(&lock);
+		current = current->next;
+		pthread_rwlock_unlock(&lock);
+	}
+	return ret;
+}
+
+static void error(const char *fmt, ...)
+{
+	va_list ap;
+	va_start(ap, fmt);
+	if (!runtime) {
+		vdprintf(2, fmt, ap);
+		dprintf(2, "\n");
+		ldso_fail = 1;
+		va_end(ap);
+		return;
+	}
+	__dl_vseterr(fmt, ap);
+	va_end(ap);
+}
diff --git a/third_party/musl/porting/liteos_a/user_debug/src/env/__libc_start_main.c b/third_party/musl/porting/liteos_a/user_debug/src/env/__libc_start_main.c
new file mode 100755
index 000000000..2a380d829
--- /dev/null
+++ b/third_party/musl/porting/liteos_a/user_debug/src/env/__libc_start_main.c
@@ -0,0 +1,99 @@
+#include <elf.h>
+#include <poll.h>
+#include <fcntl.h>
+#include <signal.h>
+#include <unistd.h>
+#include "syscall.h"
+#include "atomic.h"
+#include "libc.h"
+
+static void dummy(void) {}
+weak_alias(dummy, _init);
+
+extern weak hidden void (*const __init_array_start)(void), (*const __init_array_end)(void);
+extern void parse_argv(int, char **);
+
+static void dummy1(void *p) {}
+weak_alias(dummy1, __init_ssp);
+
+#define AUX_CNT 38
+
+#ifdef __GNUC__
+__attribute__((__noinline__))
+#endif
+void __init_libc(char **envp, char *pn)
+{
+	size_t i, *auxv, aux[AUX_CNT] = { 0 };
+	__environ = envp;
+	for (i=0; envp[i]; i++);
+	libc.auxv = auxv = (void *)(envp+i+1);
+	for (i=0; auxv[i]; i+=2) if (auxv[i]<AUX_CNT) aux[auxv[i]] = auxv[i+1];
+	__hwcap = aux[AT_HWCAP];
+	if (aux[AT_SYSINFO]) __sysinfo = aux[AT_SYSINFO];
+	libc.page_size = aux[AT_PAGESZ];
+
+	if (!pn) pn = (void*)aux[AT_EXECFN];
+	if (!pn) pn = "";
+	__progname = __progname_full = pn;
+	for (i=0; pn[i]; i++) if (pn[i]=='/') __progname = pn+i+1;
+
+	__init_tls(aux);
+	__init_ssp((void *)aux[AT_RANDOM]);
+
+	if (aux[AT_UID]==aux[AT_EUID] && aux[AT_GID]==aux[AT_EGID]
+		&& !aux[AT_SECURE]) return;
+
+	struct pollfd pfd[3] = { {.fd=0}, {.fd=1}, {.fd=2} };
+	int r =
+#ifdef SYS_poll
+	__syscall(SYS_poll, pfd, 3, 0);
+#else
+	__syscall(SYS_ppoll, pfd, 3, &(struct timespec){0}, 0, _NSIG/8);
+#endif
+	if (r<0) a_crash();
+	for (i=0; i<3; i++) if (pfd[i].revents&POLLNVAL)
+		if (__sys_open("/dev/null", O_RDWR)<0)
+			a_crash();
+	libc.secure = 1;
+}
+
+static void libc_start_init(void)
+{
+	_init();
+	uintptr_t a = (uintptr_t)&__init_array_start;
+	for (; a<(uintptr_t)&__init_array_end; a+=sizeof(void(*)()))
+		(*(void (**)(void))a)();
+}
+
+weak_alias(libc_start_init, __libc_start_init);
+
+typedef int lsm2_fn(int (*)(int,char **,char **), int, char **);
+static lsm2_fn libc_start_main_stage2;
+
+int __libc_start_main(int (*main)(int,char **,char **), int argc, char **argv)
+{
+	char **envp = argv+argc+1;
+
+	/* External linkage, and explicit noinline attribute if available,
+	 * are used to prevent the stack frame used during init from
+	 * persisting for the entire process lifetime. */
+	__init_libc(envp, argv[0]);
+
+	/* Barrier against hoisting application code or anything using ssp
+	 * or thread pointer prior to its initialization above. */
+	lsm2_fn *stage2 = libc_start_main_stage2;
+	__asm__ ( "" : "+r"(stage2) : : "memory" );
+	return stage2(main, argc, argv);
+}
+
+static int libc_start_main_stage2(int (*main)(int,char **,char **), int argc, char **argv)
+{
+	char **envp = argv+argc+1;
+	__libc_start_init();
+	__sig_init();
+
+	parse_argv(argc, argv);
+	/* Pass control to the application */
+	exit(main(argc, argv, envp));
+	return 0;
+}
diff --git a/third_party/musl/porting/liteos_a/user_debug/src/exit/exit.c b/third_party/musl/porting/liteos_a/user_debug/src/exit/exit.c
new file mode 100755
index 000000000..5d2d00a33
--- /dev/null
+++ b/third_party/musl/porting/liteos_a/user_debug/src/exit/exit.c
@@ -0,0 +1,45 @@
+#include <stdlib.h>
+#include <stdint.h>
+#include <stdbool.h>
+#include <debug.h>
+#include "libc.h"
+
+extern bool g_enable_check;
+extern void mem_check_deinit(void);
+extern void clean_recycle_list(bool clean_all);
+
+static void dummy()
+{
+}
+
+/* atexit.c and __stdio_exit.c override these. the latter is linked
+ * as a consequence of linking either __toread.c or __towrite.c. */
+weak_alias(dummy, __funcs_on_exit);
+weak_alias(dummy, __stdio_exit);
+weak_alias(dummy, _fini);
+
+extern weak hidden void (*const __fini_array_start)(void), (*const __fini_array_end)(void);
+
+static void libc_exit_fini(void)
+{
+	uintptr_t a = (uintptr_t)&__fini_array_end;
+	for (; a>(uintptr_t)&__fini_array_start; a-=sizeof(void(*)()))
+		(*(void (**)())(a-sizeof(void(*)())))();
+	_fini();
+}
+
+weak_alias(libc_exit_fini, __libc_exit_fini);
+
+_Noreturn void exit(int code)
+{
+	if (g_enable_check) {
+		check_leak();
+		check_heap_integrity();
+		mem_check_deinit();
+		clean_recycle_list(true);
+	}
+	__funcs_on_exit();
+	__libc_exit_fini();
+	__stdio_exit();
+	_Exit(code);
+}
diff --git a/third_party/musl/porting/liteos_a/user_debug/src/internal/malloc_impl.h b/third_party/musl/porting/liteos_a/user_debug/src/internal/malloc_impl.h
new file mode 100755
index 000000000..6107f0b65
--- /dev/null
+++ b/third_party/musl/porting/liteos_a/user_debug/src/internal/malloc_impl.h
@@ -0,0 +1,105 @@
+#ifndef MALLOC_IMPL_H
+#define MALLOC_IMPL_H
+
+#include <sys/mman.h>
+#include <stdbool.h>
+
+#define BACKTRACE_DEPTH_MAX      5          /* The max depth of backtrace */
+#define BACKTRACE_START_OFFSET   0          /* The start offset of backtrace */
+#define SECONDARY_CALL_OFFSET    2          /* The backtrace offset for secondary call backtrace() */
+#define BACKTRACE_OFFSET         (BACKTRACE_START_OFFSET + SECONDARY_CALL_OFFSET)
+#define PREFIX_PLACE_HOLDER      10         /* Reserve positions for file name prefix "pid()_" */
+#define PTHREAD_NUM_MAX          128        /* Same as number of task of kernel */
+#define NODE_MAGIC               0xFCFCFCFC /* Magic number for node of chunk */
+#define FREE_MAGIC               0xFE       /* Magic number for filling freed heap memory not recycled to heap pool */
+#define RECYCLE_MAX              128        /* The queue size for free() to recycle */
+#define RECYCLE_SIZE_MAX         0x300000   /* The max sum size of freed chunk for recycle list */
+#define ITEM_BUFFER_SIZE         256        /* The buffer max size for one item of memory debug info */
+#define CHECK_POINT_TRACE_MAX    2          /* The trace max for check point */
+
+hidden void *__expand_heap(size_t *);
+
+hidden void __malloc_donate(char *, char *);
+
+hidden void *__memalign(size_t, size_t);
+
+struct chunk {
+	unsigned int checksum;
+	size_t psize, csize;
+	struct chunk *next, *prev;
+};
+
+struct bin {
+	unsigned int checksum;
+	volatile int lock[2];
+	struct chunk *head;
+	struct chunk *tail;
+};
+
+struct heap_block {
+	struct heap_block *next;
+	struct heap_block *prev;
+};
+
+struct list {
+	struct list *prev;
+	struct list *next;
+};
+
+struct node {
+	short tid, pid;
+	void *ptr;
+	size_t size;
+	void *lr[BACKTRACE_DEPTH_MAX];
+	struct list list;
+};
+
+struct stat_bin {
+	volatile int lock[2];
+	struct list head;
+	size_t t_total_size;
+};
+
+#define ROUNDUP(a, b) (((a) + ((b) - 1)) & ~((b) - 1))
+#define SIZE_ALIGN ROUNDUP(sizeof(struct chunk), 0x10)
+#define SIZE_MASK (-SIZE_ALIGN)
+#define OVERHEAD (sizeof(struct chunk))
+#define BLOCK_HEAD (sizeof(struct heap_block) + OVERHEAD)
+#define CHUNK_BLOCK_OFFSET (sizeof(struct heap_block))
+#define CHUNK_TO_BLOCK(c) (struct heap_block *)((char *)(c) - CHUNK_BLOCK_OFFSET)
+#define BLOCK_TO_CHUNK(p) (struct chunk *)((char *)(p) + CHUNK_BLOCK_OFFSET)
+#define MMAP_THRESHOLD (0x1c00*(4*sizeof(size_t)))
+#define DONTCARE SIZE_ALIGN
+#define RECLAIM 163840
+
+#define CHUNK_SIZE(c) ((c)->csize & -2)
+#define CHUNK_PSIZE(c) ((c)->psize & -2)
+#define PREV_CHUNK(c) ((struct chunk *)((char *)(c) - CHUNK_PSIZE(c)))
+#define NEXT_CHUNK(c) ((struct chunk *)((char *)(c) + CHUNK_SIZE(c)))
+#define MEM_TO_CHUNK(p) (struct chunk *)((char *)(p) - OVERHEAD)
+#define CHUNK_TO_MEM(c) (void *)((char *)(c) + OVERHEAD)
+#define BIN_TO_CHUNK(i) (&mal.bins[i].checksum)
+
+#define C_INUSE  ((size_t)1)
+
+#define IS_MMAPPED(c) !((c)->csize & (C_INUSE))
+
+hidden void __bin_chunk(struct chunk *);
+
+hidden extern int __malloc_replaced;
+
+hidden extern bool g_enable_check;
+hidden extern int g_recycle_num;
+hidden extern size_t g_recycle_size;
+hidden extern int g_mem_lock[];
+hidden extern void insert_node(void *ptr, size_t size);
+hidden extern int delete_node(void *ptr);
+hidden extern void insert_block_list(struct chunk *ptr);
+hidden extern void insert_free_tail(struct chunk *self);
+hidden extern struct chunk *get_free_head(void);
+hidden extern void get_free_trace(void *ptr);
+hidden extern void clean_recycle_list(bool clean_all);
+hidden extern void check_chunk_integrity(struct chunk *cur);
+hidden extern void calculate_checksum(struct chunk *cur, struct chunk *next);
+
+#endif
diff --git a/third_party/musl/porting/liteos_a/user_debug/src/malloc/backtrace.c b/third_party/musl/porting/liteos_a/user_debug/src/malloc/backtrace.c
new file mode 100755
index 000000000..859bbee79
--- /dev/null
+++ b/third_party/musl/porting/liteos_a/user_debug/src/malloc/backtrace.c
@@ -0,0 +1,141 @@
+#define _GNU_SOURCE
+#include <stdint.h>
+#include <malloc.h>
+#include <dlfcn.h>
+#include <string.h>
+#include <stdio.h>
+#include <debug.h>
+#include <unwind.h>
+
+#define TRACE_MAX_DEPTH 16
+#define STRING_MAX_LEN  256
+#define TRACE_IGNORE    1
+
+struct unwind_state_t {
+	_Unwind_Word **cur;
+	_Unwind_Word **end;
+};
+
+static _Unwind_Reason_Code unwind_callback(struct _Unwind_Context *context, void *arg)
+{
+	struct unwind_state_t *state = (struct unwind_state_t *)arg;
+	_Unwind_Word pc = _Unwind_GetIP(context);
+	if (pc != 0) {
+		if (state->cur != state->end) {
+			*state->cur = (_Unwind_Word *)pc;
+		} else {
+			return _URC_END_OF_STACK;
+		}
+	}
+	++state->cur;
+
+	return _URC_NO_REASON;
+}
+
+int backtrace(void **buffer, int size)
+{
+	struct unwind_state_t state;
+
+	if ((buffer == NULL) || (size <= 0)) {
+		return 0;
+	}
+
+	state.cur = (_Unwind_Word **)buffer;
+	state.end = (_Unwind_Word **)(buffer + size);
+	_Unwind_Backtrace(&unwind_callback, &state);
+
+	return (void **)state.cur - buffer;
+}
+
+char **backtrace_symbols(void *const *buffer, int size)
+{
+	int i;
+	char **str_location = NULL;
+	char *str_buffer = NULL;
+	char *str_base = NULL;
+	char **string = NULL;
+	Dl_info info = { 0 };
+	size_t total_size = 0;
+
+	if ((buffer == NULL) || (size <= 0)) {
+		return NULL;
+	}
+	str_location = (char **)malloc(size * sizeof(char *));
+	if (str_location == NULL) {
+		return NULL;
+	}
+	memset(str_location, 0, size * sizeof(char *));
+	for (i = 0; i < size; ++i) {
+		dladdr((void *)buffer[i], &info);
+		if ((info.dli_fname == NULL) || (info.dli_fname[0] == '\0')) {
+			break;
+		}
+		str_buffer = (char *)malloc(STRING_MAX_LEN * sizeof(char));
+		if (str_buffer == NULL) {
+			goto err;
+		}
+
+		snprintf(str_buffer, STRING_MAX_LEN, "    #%02d: <%s+%#x>[%#x] -> %s\n", i, info.dli_sname,
+			(uintptr_t)buffer[i] - (uintptr_t)info.dli_saddr,
+			(uintptr_t)buffer[i] - (uintptr_t)info.dli_fbase, info.dli_fname);
+		str_location[i] = str_buffer;
+		total_size += strlen(str_buffer) + 1;
+	}
+	string = (char **)malloc(total_size + (size * sizeof(char *)));
+	if (string == NULL) {
+		goto err;
+	}
+	memset(string, 0, total_size + (size * sizeof(char *)));
+	str_base = (char *)(string + size);
+	for (i = 0; i < size; ++i) {
+		if (str_location[i] == NULL) {
+			break;
+		}
+		strcpy(str_base, str_location[i]);
+		string[i] = str_base;
+		str_base += strlen(string[i]) + 1;
+		free(str_location[i]);
+	}
+	free(str_location);
+	return string;
+
+err:
+	for (i = 0; i < size; ++i) {
+		if (str_location[i]) {
+			free(str_location[i]);
+		}
+	}
+	free(str_location);
+	return NULL;
+}
+
+static void get_backtrace_addr(void *const *buffer, int nptrs)
+{
+	for (int i = 1; i < nptrs; ++i) {
+		printf("    #%02d: %#x\n", i, buffer[i]);
+	}
+}
+
+void print_trace()
+{
+	int nptrs, i;
+	void *buffer[TRACE_MAX_DEPTH];
+	char **strings = NULL;
+
+	nptrs = backtrace(buffer, TRACE_MAX_DEPTH);
+	printf("\nBacktrace() returned %d addresses\n", nptrs - TRACE_IGNORE);
+	strings = backtrace_symbols(buffer, nptrs);
+	if (strings == NULL) {
+		printf("backtrace_symbols() err!\n");
+		return;
+	}
+	for (i = 1; i < nptrs; ++i) {
+		if ((i == 1) && (strings[i] == NULL)) {
+			get_backtrace_addr(buffer, nptrs);
+			break;
+		}
+		printf("%s", strings[i]);
+	}
+	free(strings);
+}
+
diff --git a/third_party/musl/porting/liteos_a/user_debug/src/malloc/malloc.c b/third_party/musl/porting/liteos_a/user_debug/src/malloc/malloc.c
new file mode 100755
index 000000000..ba6900a40
--- /dev/null
+++ b/third_party/musl/porting/liteos_a/user_debug/src/malloc/malloc.c
@@ -0,0 +1,647 @@
+#define _GNU_SOURCE
+#include <stdlib.h>
+#include <string.h>
+#include <limits.h>
+#include <stdint.h>
+#include <errno.h>
+#include <unistd.h>
+#include <debug.h>
+#include <sys/mman.h>
+#include "libc.h"
+#include "atomic.h"
+#include "pthread_impl.h"
+#include "malloc_impl.h"
+
+#if defined(__GNUC__) && defined(__PIC__)
+#define inline inline __attribute__((always_inline))
+#endif
+
+static struct {
+	volatile uint64_t binmap;
+	struct bin bins[64];
+	volatile int free_lock[2];
+} mal;
+
+int __malloc_replaced;
+
+/* Synchronization tools */
+
+static inline void lock(volatile int *lk)
+{
+	if (libc.threads_minus_1)
+		while(a_swap(lk, 1)) __wait(lk, lk+1, 1, 1);
+}
+
+static inline void unlock(volatile int *lk)
+{
+	if (lk[0]) {
+		a_store(lk, 0);
+		if (lk[1]) __wake(lk, 1, 1);
+	}
+}
+
+static inline void lock_bin(int i)
+{
+	lock(mal.bins[i].lock);
+	if (!mal.bins[i].head)
+		mal.bins[i].head = mal.bins[i].tail = BIN_TO_CHUNK(i);
+}
+
+static inline void unlock_bin(int i)
+{
+	unlock(mal.bins[i].lock);
+}
+
+static int first_set(uint64_t x)
+{
+#if 1
+	return a_ctz_64(x);
+#else
+	static const char debruijn64[64] = {
+		0, 1, 2, 53, 3, 7, 54, 27, 4, 38, 41, 8, 34, 55, 48, 28,
+		62, 5, 39, 46, 44, 42, 22, 9, 24, 35, 59, 56, 49, 18, 29, 11,
+		63, 52, 6, 26, 37, 40, 33, 47, 61, 45, 43, 21, 23, 58, 17, 10,
+		51, 25, 36, 32, 60, 20, 57, 16, 50, 31, 19, 15, 30, 14, 13, 12
+	};
+	static const char debruijn32[32] = {
+		0, 1, 23, 2, 29, 24, 19, 3, 30, 27, 25, 11, 20, 8, 4, 13,
+		31, 22, 28, 18, 26, 10, 7, 12, 21, 17, 9, 6, 16, 5, 15, 14
+	};
+	if (sizeof(long) < 8) {
+		uint32_t y = x;
+		if (!y) {
+			y = x>>32;
+			return 32 + debruijn32[(y&-y)*0x076be629 >> 27];
+		}
+		return debruijn32[(y&-y)*0x076be629 >> 27];
+	}
+	return debruijn64[(x&-x)*0x022fdd63cc95386dull >> 58];
+#endif
+}
+
+static const unsigned char bin_tab[60] = {
+	            32,33,34,35,36,36,37,37,38,38,39,39,
+	40,40,40,40,41,41,41,41,42,42,42,42,43,43,43,43,
+	44,44,44,44,44,44,44,44,45,45,45,45,45,45,45,45,
+	46,46,46,46,46,46,46,46,47,47,47,47,47,47,47,47,
+};
+
+static int bin_index(size_t x)
+{
+	x = x / SIZE_ALIGN - 1;
+	if (x <= 32) return x;
+	if (x < 512) return bin_tab[x/8-4];
+	if (x > 0x1c00) return 63;
+	return bin_tab[x/128-4] + 16;
+}
+
+static int bin_index_up(size_t x)
+{
+	x = x / SIZE_ALIGN - 1;
+	if (x <= 32) return x;
+	x--;
+	if (x < 512) return bin_tab[x/8-4] + 1;
+	return bin_tab[x/128-4] + 17;
+}
+
+#if 0
+void __dump_heap(int x)
+{
+	struct chunk *c;
+	int i;
+	for (c = (void *)mal.heap; CHUNK_SIZE(c); c = NEXT_CHUNK(c))
+		fprintf(stderr, "base %p size %zu (%d) flags %d/%d\n",
+			c, CHUNK_SIZE(c), bin_index(CHUNK_SIZE(c)),
+			c->csize & 15,
+			NEXT_CHUNK(c)->psize & 15);
+	for (i=0; i<64; i++) {
+		if (mal.bins[i].head != BIN_TO_CHUNK(i) && mal.bins[i].head) {
+			fprintf(stderr, "bin %d: %p\n", i, mal.bins[i].head);
+			if (!(mal.binmap & 1ULL<<i))
+				fprintf(stderr, "missing from binmap!\n");
+		} else if (mal.binmap & 1ULL<<i)
+			fprintf(stderr, "binmap wrongly contains %d!\n", i);
+	}
+}
+#endif
+
+static struct chunk *expand_heap(size_t n)
+{
+	static int heap_lock[2];
+	static void *end;
+	void *p;
+	struct chunk *w;
+
+	/* The argument n already accounts for the caller's chunk
+	 * overhead needs, but if the heap can't be extended in-place,
+	 * we need room for an extra zero-sized sentinel chunk. */
+	n += SIZE_ALIGN;
+
+	lock(heap_lock);
+
+	p = __expand_heap(&n);
+	if (!p) {
+		unlock(heap_lock);
+		return 0;
+	}
+
+	lock(g_mem_lock);
+	/* If not just expanding existing space, we need to make a
+	 * new sentinel chunk below the allocated space. */
+	if (p != end) {
+		/* Valid/safe because of the prologue increment. */
+		n -= SIZE_ALIGN;
+		p = (char *)p + SIZE_ALIGN;
+		w = MEM_TO_CHUNK(p);
+		w->psize = 0 | C_INUSE;
+		insert_block_list(w);
+	}
+
+	/* Record new heap end and fill in footer. */
+	end = (char *)p + n;
+	w = MEM_TO_CHUNK(end);
+	w->psize = n | C_INUSE;
+	w->csize = 0 | C_INUSE;
+
+	/* Fill in header, which may be new or may be replacing a
+	 * zero-size sentinel header at the old end-of-heap. */
+	w = MEM_TO_CHUNK(p);
+	w->csize = n | C_INUSE;
+	calculate_checksum(w, MEM_TO_CHUNK(end));
+
+	unlock(g_mem_lock);
+	unlock(heap_lock);
+
+	return w;
+}
+
+static int adjust_size(size_t *n)
+{
+	/* Result of pointer difference must fit in ptrdiff_t. */
+	if (*n-1 > PTRDIFF_MAX - SIZE_ALIGN - PAGE_SIZE) {
+		if (*n) {
+			errno = ENOMEM;
+			return -1;
+		} else {
+			*n = SIZE_ALIGN;
+			return 0;
+		}
+	}
+	*n = (*n + OVERHEAD + SIZE_ALIGN - 1) & SIZE_MASK;
+	return 0;
+}
+
+static void unbin(struct chunk *c, int i)
+{
+	if (c->prev == c->next)
+		a_and_64(&mal.binmap, ~(1ULL<<i));
+	c->prev->next = c->next;
+	c->next->prev = c->prev;
+	c->csize |= C_INUSE;
+	NEXT_CHUNK(c)->psize |= C_INUSE;
+}
+
+static int alloc_fwd(struct chunk *c)
+{
+	int i;
+	size_t k;
+	while (!((k=c->csize) & C_INUSE)) {
+		i = bin_index(k);
+		lock_bin(i);
+		if (c->csize == k) {
+			unbin(c, i);
+			unlock_bin(i);
+			return 1;
+		}
+		unlock_bin(i);
+	}
+	return 0;
+}
+
+static int alloc_rev(struct chunk *c)
+{
+	int i;
+	size_t k;
+	while (!((k=c->psize) & C_INUSE)) {
+		i = bin_index(k);
+		lock_bin(i);
+		if (c->psize == k) {
+			unbin(PREV_CHUNK(c), i);
+			unlock_bin(i);
+			return 1;
+		}
+		unlock_bin(i);
+	}
+	return 0;
+}
+
+
+/* pretrim - trims a chunk _prior_ to removing it from its bin.
+ * Must be called with i as the ideal bin for size n, j the bin
+ * for the _free_ chunk self, and bin j locked. */
+static int pretrim(struct chunk *self, size_t n, int i, int j)
+{
+	size_t n1;
+	struct chunk *next, *split;
+
+	/* We cannot pretrim if it would require re-binning. */
+	if (j < 40) return 0;
+	if (j < i+3) {
+		if (j != 63) return 0;
+		n1 = CHUNK_SIZE(self);
+		if (n1-n <= MMAP_THRESHOLD) return 0;
+	} else {
+		n1 = CHUNK_SIZE(self);
+	}
+	if (bin_index(n1-n) != j) return 0;
+
+	next = NEXT_CHUNK(self);
+	split = (void *)((char *)self + n);
+	lock(g_mem_lock);
+	split->prev = self->prev;
+	split->next = self->next;
+	split->prev->next = split;
+	split->next->prev = split;
+	split->psize = n | C_INUSE;
+	split->csize = n1-n;
+	next->psize = n1-n;
+	calculate_checksum(split, next);
+	self->csize = n | C_INUSE;
+	calculate_checksum(self, NULL);
+	unlock(g_mem_lock);
+	return 1;
+}
+
+static void trim(struct chunk *self, size_t n)
+{
+	size_t n1 = CHUNK_SIZE(self);
+	struct chunk *next, *split;
+
+	if (n >= n1 - DONTCARE) return;
+
+	next = NEXT_CHUNK(self);
+	split = (void *)((char *)self + n);
+	lock(g_mem_lock);
+	split->psize = n | C_INUSE;
+	split->csize = n1-n | C_INUSE;
+	next->psize = n1-n | C_INUSE;
+	calculate_checksum(split, next);
+	self->csize = n | C_INUSE;
+	calculate_checksum(self, NULL);
+	unlock(g_mem_lock);
+
+	__bin_chunk(split);
+}
+
+void *malloc(size_t n)
+{
+	struct chunk *c;
+	int i, j;
+
+	if (adjust_size(&n) < 0) return 0;
+
+	if (n > MMAP_THRESHOLD) {
+		size_t len = n + OVERHEAD + PAGE_SIZE - 1 & -PAGE_SIZE;
+		if (g_enable_check) {
+			/* Allocate two more pages for protection, loacted at the head and tail of user memory respectively */
+			len += PAGE_SIZE << 1;
+		}
+		char *base = __mmap(0, len, PROT_READ|PROT_WRITE,
+			MAP_PRIVATE|MAP_ANONYMOUS, -1, 0);
+		if (base == (void *)-1) return 0;
+		if (g_enable_check) {
+			if (mprotect(base, PAGE_SIZE, PROT_NONE) ||
+				mprotect(base + len - PAGE_SIZE, PAGE_SIZE, PROT_NONE)) {
+				printf("%s %d, mprotect failed, err: %s!\n", __func__, __LINE__, strerror(errno));
+			}
+			base += PAGE_SIZE;
+		}
+		c = (void *)(base + SIZE_ALIGN - OVERHEAD);
+		c->csize = len - (SIZE_ALIGN - OVERHEAD);
+		c->psize = SIZE_ALIGN - OVERHEAD;
+		if (g_enable_check) {
+			c->csize -= PAGE_SIZE << 1;
+			insert_node(CHUNK_TO_MEM(c), CHUNK_SIZE(c));
+		}
+		return CHUNK_TO_MEM(c);
+	}
+
+	i = bin_index_up(n);
+	for (;;) {
+		uint64_t mask = mal.binmap & -(1ULL<<i);
+		if (!mask) {
+			c = expand_heap(n);
+			if (!c) return 0;
+			if (alloc_rev(c)) {
+				lock(g_mem_lock);
+				struct chunk *x = c;
+				c = PREV_CHUNK(c);
+				NEXT_CHUNK(x)->psize = c->csize =
+					x->csize + CHUNK_SIZE(c);
+				calculate_checksum(c, NEXT_CHUNK(x));
+				unlock(g_mem_lock);
+			}
+			break;
+		}
+		j = first_set(mask);
+		lock_bin(j);
+		c = mal.bins[j].head;
+		if (c != BIN_TO_CHUNK(j)) {
+			if (!pretrim(c, n, i, j)) unbin(c, j);
+			unlock_bin(j);
+			break;
+		}
+		unlock_bin(j);
+	}
+
+	/* Now patch up in case we over-allocated */
+	trim(c, n);
+	if (g_enable_check) {
+		insert_node(CHUNK_TO_MEM(c), CHUNK_SIZE(c));
+	}
+
+	return CHUNK_TO_MEM(c);
+}
+
+static size_t mal0_clear(char *p, size_t pagesz, size_t n)
+{
+#ifdef __GNUC__
+	typedef uint64_t __attribute__((__may_alias__)) T;
+#else
+	typedef unsigned char T;
+#endif
+	char *pp = p + n;
+	size_t i = (uintptr_t)pp & (pagesz - 1);
+	for (;;) {
+		pp = memset(pp - i, 0, i);
+		if (pp - p < pagesz) return pp - p;
+		for (i = pagesz; i; i -= 2*sizeof(T), pp -= 2*sizeof(T))
+		        if (((T *)pp)[-1] | ((T *)pp)[-2])
+				break;
+	}
+}
+
+void *calloc(size_t m, size_t n)
+{
+	if (n && m > (size_t)-1/n) {
+		errno = ENOMEM;
+		return 0;
+	}
+	n *= m;
+	void *p = malloc(n);
+	if (!p) return p;
+	if (!__malloc_replaced) {
+		if (IS_MMAPPED(MEM_TO_CHUNK(p)))
+			return p;
+		if (n >= PAGE_SIZE)
+			n = mal0_clear(p, PAGE_SIZE, n);
+	}
+	return memset(p, 0, n);
+}
+
+void *realloc(void *p, size_t n)
+{
+	struct chunk *self, *next;
+	size_t n0, n1;
+	void *new;
+
+	if (!p) return malloc(n);
+
+	if (adjust_size(&n) < 0) return 0;
+
+	self = MEM_TO_CHUNK(p);
+	n1 = n0 = CHUNK_SIZE(self);
+
+	if (IS_MMAPPED(self)) {
+		size_t extra = self->psize;
+		char *base = (char *)self - extra;
+		size_t oldlen = n0 + extra;
+		size_t newlen = n + extra;
+		/* Crash on realloc of freed chunk */
+		if (extra & 1) {
+			if (g_enable_check) {
+				get_free_trace(CHUNK_TO_MEM(self));
+				a_crash();
+			} else {
+				a_crash();
+			}
+		}
+		if (newlen < PAGE_SIZE && (new = malloc(n-OVERHEAD))) {
+			n0 = n;
+			goto copy_free_ret;
+		}
+		newlen = (newlen + PAGE_SIZE-1) & -PAGE_SIZE;
+		if (oldlen == newlen) return p;
+		if (g_enable_check) {
+			goto copy_realloc;
+		}
+		base = __mremap(base, oldlen, newlen, MREMAP_MAYMOVE);
+		if (base == (void *)-1)
+			goto copy_realloc;
+		self = (void *)(base + extra);
+		self->csize = newlen - extra;
+		return CHUNK_TO_MEM(self);
+	}
+
+	next = NEXT_CHUNK(self);
+
+	/* Crash on corrupted footer (likely from buffer overflow) */
+	if (next->psize != self->csize) a_crash();
+
+	/* Merge adjacent chunks if we need more space. This is not
+	 * a waste of time even if we fail to get enough space, because our
+	 * subsequent call to free would otherwise have to do the merge. */
+	if (n > n1 && alloc_fwd(next)) {
+		n1 += CHUNK_SIZE(next);
+		next = NEXT_CHUNK(next);
+	}
+	/* FIXME: find what's wrong here and reenable it..? */
+	if (0 && n > n1 && alloc_rev(self)) {
+		self = PREV_CHUNK(self);
+		n1 += CHUNK_SIZE(self);
+	}
+	lock(g_mem_lock);
+	self->csize = n1 | C_INUSE;
+	next->psize = n1 | C_INUSE;
+	calculate_checksum(self, next);
+	unlock(g_mem_lock);
+
+	/* If we got enough space, split off the excess and return */
+	if (n <= n1) {
+		//memmove(CHUNK_TO_MEM(self), p, n0-OVERHEAD);
+		trim(self, n);
+		if (g_enable_check) {
+			int status = delete_node(p);
+			if (status != 0) {
+				get_free_trace(CHUNK_TO_MEM(self));
+				a_crash();
+			}
+			insert_node(CHUNK_TO_MEM(self), CHUNK_SIZE(self));
+		}
+
+		return CHUNK_TO_MEM(self);
+	}
+
+copy_realloc:
+	/* As a last resort, allocate a new chunk and copy to it. */
+	new = malloc(n-OVERHEAD);
+	if (!new) return 0;
+	n0 = (n0 > n) ? n : n0;
+copy_free_ret:
+	memcpy(new, p, n0-OVERHEAD);
+	free(CHUNK_TO_MEM(self));
+	return new;
+}
+
+void __bin_chunk(struct chunk *self)
+{
+	struct chunk *next = NEXT_CHUNK(self);
+	size_t final_size, new_size, size;
+	int reclaim=0;
+	int i;
+
+	final_size = new_size = CHUNK_SIZE(self);
+
+	/* Crash on corrupted footer (likely from buffer overflow) */
+	if (next->psize != self->csize) a_crash();
+
+	for (;;) {
+		if (self->psize & next->csize & C_INUSE) {
+			lock(g_mem_lock);
+			self->csize = final_size | C_INUSE;
+			next->psize = final_size | C_INUSE;
+			calculate_checksum(self, next);
+			unlock(g_mem_lock);
+			i = bin_index(final_size);
+			lock_bin(i);
+			lock(mal.free_lock);
+			if (self->psize & next->csize & C_INUSE)
+				break;
+			unlock(mal.free_lock);
+			unlock_bin(i);
+		}
+
+		if (alloc_rev(self)) {
+			self = PREV_CHUNK(self);
+			size = CHUNK_SIZE(self);
+			final_size += size;
+			if (new_size+size > RECLAIM && (new_size+size^size) > size)
+				reclaim = 1;
+		}
+
+		if (alloc_fwd(next)) {
+			size = CHUNK_SIZE(next);
+			final_size += size;
+			if (new_size+size > RECLAIM && (new_size+size^size) > size)
+				reclaim = 1;
+			next = NEXT_CHUNK(next);
+		}
+	}
+
+	if (!(mal.binmap & 1ULL<<i))
+		a_or_64(&mal.binmap, 1ULL<<i);
+
+	lock(g_mem_lock);
+	self->csize = final_size;
+	next->psize = final_size;
+	calculate_checksum(self, next);
+	unlock(g_mem_lock);
+	unlock(mal.free_lock);
+
+	self->next = BIN_TO_CHUNK(i);
+	self->prev = mal.bins[i].tail;
+	self->next->prev = self;
+	self->prev->next = self;
+
+	/* Replace middle of large chunks with fresh zero pages */
+	if (reclaim) {
+		uintptr_t a = (uintptr_t)self + SIZE_ALIGN+PAGE_SIZE-1 & -PAGE_SIZE;
+		uintptr_t b = (uintptr_t)next - SIZE_ALIGN & -PAGE_SIZE;
+#if 0
+		__madvise((void *)a, b-a, MADV_DONTNEED);
+#else
+		__mmap((void *)a, b-a, PROT_READ|PROT_WRITE,
+			MAP_PRIVATE|MAP_ANONYMOUS|MAP_FIXED, -1, 0);
+#endif
+	}
+
+	unlock_bin(i);
+}
+
+static void unmap_chunk(struct chunk *self)
+{
+	size_t extra = self->psize;
+	char *base = (char *)self - extra;
+	size_t len = CHUNK_SIZE(self) + extra;
+	/* Crash on double free */
+	if (extra & 1) {
+		if (g_enable_check) {
+			get_free_trace(CHUNK_TO_MEM(self));
+			a_crash();
+		} else {
+			a_crash();
+		}
+	}
+	if (g_enable_check) {
+		base -= PAGE_SIZE;
+		len += PAGE_SIZE << 1;
+	}
+	__munmap(base, len);
+}
+
+void free(void *p)
+{
+	if (!p) return;
+
+	struct chunk *self = MEM_TO_CHUNK(p);
+	if (g_enable_check) {
+		if (!IS_MMAPPED(self)) {
+			check_chunk_integrity(self);
+		}
+		int status = delete_node(p);
+		if (status != 0) {
+			get_free_trace(p);
+			a_crash();
+		}
+	}
+
+	if (IS_MMAPPED(self))
+		unmap_chunk(self);
+	else {
+		if (g_enable_check) {
+			insert_free_tail(self);
+			if (g_recycle_size >= RECYCLE_SIZE_MAX) {
+				clean_recycle_list(false);
+				return;
+			}
+			if (g_recycle_num < RECYCLE_MAX) {
+				return;
+			}
+			self = get_free_head();
+		}
+		__bin_chunk(self);
+	}
+}
+
+void __malloc_donate(char *start, char *end)
+{
+	size_t align_start_up = (SIZE_ALIGN-1) & (-(uintptr_t)start - BLOCK_HEAD);
+	size_t align_end_down = (SIZE_ALIGN-1) & (uintptr_t)end;
+
+	/* Getting past this condition ensures that the padding for alignment
+	 * and header overhead will not overflow and will leave a nonzero
+	 * multiple of SIZE_ALIGN bytes between start and end. */
+	if (end - start <= BLOCK_HEAD + align_start_up + align_end_down)
+		return;
+	start += align_start_up + BLOCK_HEAD;
+	end   -= align_end_down;
+
+	lock(g_mem_lock);
+	struct chunk *c = MEM_TO_CHUNK(start), *n = MEM_TO_CHUNK(end);
+	c->psize = n->csize = C_INUSE;
+	c->csize = n->psize = C_INUSE | (end-start);
+	calculate_checksum(c, n);
+	insert_block_list(c);
+	unlock(g_mem_lock);
+	__bin_chunk(c);
+}
diff --git a/third_party/musl/porting/liteos_a/user_debug/src/malloc/memalign.c b/third_party/musl/porting/liteos_a/user_debug/src/malloc/memalign.c
new file mode 100755
index 000000000..a37c54440
--- /dev/null
+++ b/third_party/musl/porting/liteos_a/user_debug/src/malloc/memalign.c
@@ -0,0 +1,88 @@
+#include <stdlib.h>
+#include <stdint.h>
+#include <errno.h>
+#include "libc.h"
+#include "pthread_impl.h"
+#include "malloc_impl.h"
+
+static inline void lock(volatile int *lk)
+{
+	if (libc.threads_minus_1)
+		while(a_swap(lk, 1)) __wait(lk, lk+1, 1, 1);
+}
+
+static inline void unlock(volatile int *lk)
+{
+	if (lk[0]) {
+		a_store(lk, 0);
+		if (lk[1]) __wake(lk, 1, 1);
+	}
+}
+
+void *__memalign(size_t align, size_t len)
+{
+	unsigned char *mem, *new;
+
+	if ((align & -align) != align) {
+		errno = EINVAL;
+		return 0;
+	}
+
+	if (len > SIZE_MAX - align || __malloc_replaced) {
+		errno = ENOMEM;
+		return 0;
+	}
+
+	if (align <= SIZE_ALIGN)
+		return malloc(len);
+
+	if (!(mem = malloc(len + align-1)))
+		return 0;
+
+	new = (void *)((uintptr_t)mem + align-1 & -align);
+	if (new == mem) return mem;
+
+	struct chunk *c = MEM_TO_CHUNK(mem);
+	struct chunk *n = MEM_TO_CHUNK(new);
+
+	if (g_enable_check) {
+		int status = delete_node(mem);
+		if (status != 0) {
+			get_free_trace(mem);
+			a_crash();
+		}
+	}
+
+	if (IS_MMAPPED(c)) {
+		/* Apply difference between aligned and original
+		 * address to the "extra" field of mmapped chunk. */
+		n->psize = c->psize + (new-mem);
+		n->csize = c->csize - (new-mem);
+		if (g_enable_check) {
+			insert_node(CHUNK_TO_MEM(n), CHUNK_SIZE(n));
+		}
+		return new;
+	}
+
+	struct chunk *t = NEXT_CHUNK(c);
+
+	/* Split the allocated chunk into two chunks. The aligned part
+	 * that will be used has the size in its footer reduced by the
+	 * difference between the aligned and original addresses, and
+	 * the resulting size copied to its header. A new header and
+	 * footer are written for the split-off part to be freed. */
+	lock(g_mem_lock);
+	n->psize = c->csize = C_INUSE | (new-mem);
+	n->csize = t->psize -= new-mem;
+	calculate_checksum(c, n);
+	calculate_checksum(NULL, t);
+	unlock(g_mem_lock);
+	if (g_enable_check) {
+		insert_node(CHUNK_TO_MEM(n), CHUNK_SIZE(n));
+	}
+
+	__bin_chunk(c);
+	return new;
+}
+
+weak_alias(__memalign, memalign);
diff --git a/third_party/musl/porting/liteos_a/user_debug/src/malloc/memory_check.c b/third_party/musl/porting/liteos_a/user_debug/src/malloc/memory_check.c
new file mode 100755
index 000000000..6ef7e750c
--- /dev/null
+++ b/third_party/musl/porting/liteos_a/user_debug/src/malloc/memory_check.c
@@ -0,0 +1,831 @@
+#define _GNU_SOURCE
+#include <errno.h>
+#include <string.h>
+#include <stdbool.h>
+#include <debug.h>
+#include <fcntl.h>
+#include <dlfcn.h>
+#include <unistd.h>
+#include "libc.h"
+#include "atomic.h"
+#include "pthread_impl.h"
+#include "malloc_impl.h"
+
+#if defined(__GNUC__) && defined(__PIC__)
+#define inline inline __attribute__((always_inline))
+#endif
+
+bool g_enable_check = false;
+int g_recycle_num;
+size_t g_recycle_size;
+int g_mem_lock[2];
+static struct chunk recycle_list;
+static struct heap_block block_list;
+
+static struct {
+	struct stat_bin bins[PTHREAD_NUM_MAX];
+	struct stat_bin free_list;
+	size_t p_total_size;
+	size_t peak_size;
+	char *f_path;
+	char f_path_buf[PATH_MAX];
+	int fd;
+	bool verbose;
+} mem_stat;
+
+static inline void lock(volatile int *lk)
+{
+	if (libc.threads_minus_1)
+		while(a_swap(lk, 1)) __wait(lk, lk+1, 1, 1);
+}
+
+static inline void unlock(volatile int *lk)
+{
+	if (lk[0]) {
+		a_store(lk, 0);
+		if (lk[1]) __wake(lk, 1, 1);
+	}
+}
+
+static inline void lock_stat_bin(int tid)
+{
+	lock(mem_stat.bins[tid].lock);
+	if (!mem_stat.bins[tid].head.next)
+		mem_stat.bins[tid].head.next = mem_stat.bins[tid].head.prev = &mem_stat.bins[tid].head;
+}
+
+static inline void unlock_stat_bin(int tid)
+{
+	unlock(mem_stat.bins[tid].lock);
+}
+
+static void insert_free_list(struct node *node)
+{
+	struct list *list = NULL;
+
+	list = mem_stat.free_list.head.prev;
+	node->list.prev = list;
+	node->list.next = list->next;
+	list->next = &node->list;
+	node->list.next->prev = &node->list;
+}
+
+static int try_delete_node(int tid, void *ptr)
+{
+	struct list *list = NULL;
+	struct node *node = NULL;
+
+	lock_stat_bin(tid);
+	for (list = mem_stat.bins[tid].head.next; list != &mem_stat.bins[tid].head; list = list->next) {
+		node = (struct node *)((uintptr_t)list - (uint32_t)&((struct node *)0)->list);
+		if (node->ptr != ptr) {
+			continue;
+		}
+		list->prev->next = list->next;
+		list->next->prev = list->prev;
+		mem_stat.bins[tid].t_total_size -= node->size;
+		insert_free_list(node);
+		mem_stat.p_total_size -= node->size;
+		unlock_stat_bin(tid);
+		return 0;
+	}
+	unlock_stat_bin(tid);
+	return -1;
+}
+
+int delete_node(void *ptr)
+{
+	int tid = ((struct pthread *)pthread_self())->tid;
+	int status, i;
+
+	lock(g_mem_lock);
+	status = try_delete_node(tid, ptr);
+	if (status == 0) {
+		unlock(g_mem_lock);
+		return 0;
+	}
+
+	for (i = 0; i < PTHREAD_NUM_MAX; ++i) {
+		if (i == tid) {
+			continue;
+		}
+		status = try_delete_node(i, ptr);
+		if (status == 0) {
+			unlock(g_mem_lock);
+			return 0;
+		}
+	}
+	unlock(g_mem_lock);
+	return -1;
+}
+
+static struct node *expand_mem(void)
+{
+	struct node *ptr = NULL;
+	struct node *node = NULL;
+	size_t node_len = sizeof(struct node);
+	int n_node = PAGE_SIZE / node_len;
+	int i;
+
+	ptr = __mmap(0, PAGE_SIZE, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);
+	if (ptr == MAP_FAILED) {
+		printf("%s %d, map failed, err: %s\n", __func__, __LINE__, strerror(errno));
+		return NULL;
+	}
+
+	for (i = 1; i < n_node; ++i) {
+		node = (struct node *)((uintptr_t)ptr + i * node_len);
+		insert_free_list(node);
+	}
+
+	return ptr;
+}
+
+static struct node *alloc_node(void)
+{
+	struct list *list = NULL;
+	struct node *node = NULL;
+	int ret;
+
+	if (!mem_stat.free_list.head.next) {
+		mem_stat.free_list.head.next = mem_stat.free_list.head.prev = &mem_stat.free_list.head;
+	}
+
+	for (list = mem_stat.free_list.head.next; list != &mem_stat.free_list.head; list = list->next) {
+		node = (struct node *)((uintptr_t)list - (uint32_t)&((struct node *)0)->list);
+		list->prev->next = list->next;
+		list->next->prev = list->prev;
+		return node;
+	}
+
+	return expand_mem();
+}
+
+static struct node *create_node(int tid, void *ptr, size_t size)
+{
+	pid_t pid = getpid();
+	struct node *node = NULL;
+	void *lr[BACKTRACE_DEPTH_MAX + BACKTRACE_OFFSET + 1] = { 0 };
+	int nptr;
+
+	node = alloc_node();
+	if (node == NULL) {
+		return NULL;
+	}
+	mem_stat.p_total_size += size;
+	mem_stat.peak_size = (mem_stat.peak_size < mem_stat.p_total_size) ? mem_stat.p_total_size : mem_stat.peak_size;
+	node->tid = tid;
+	node->pid = pid;
+	node->ptr = ptr;
+	node->size = size;
+	nptr = backtrace(lr, BACKTRACE_DEPTH_MAX + BACKTRACE_OFFSET + 1);
+	memcpy(node->lr, lr + BACKTRACE_OFFSET + 1, BACKTRACE_DEPTH_MAX * sizeof(void *));
+	return node;
+}
+
+void insert_node(void *ptr, size_t size)
+{
+	int tid = ((struct pthread *)pthread_self())->tid;
+	struct list *list = NULL;
+	struct node *node = NULL;
+
+	lock(g_mem_lock);
+	node = create_node(tid, ptr, size);
+	if (node == NULL) {
+		unlock(g_mem_lock);
+		return;
+	}
+
+	lock_stat_bin(tid);
+	mem_stat.bins[tid].t_total_size += size;
+	list = mem_stat.bins[tid].head.prev;
+	node->list.prev = list;
+	node->list.next = list->next;
+	list->next = &node->list;
+	node->list.next->prev = &node->list;
+	unlock_stat_bin(tid);
+	unlock(g_mem_lock);
+}
+
+static void file_path_init(void)
+{
+	char *pos = NULL;
+	int len;
+
+	if (!mem_stat.f_path) {
+		return;
+	}
+
+	pos = strrchr(mem_stat.f_path, '/');
+	if (pos) {
+		len = pos - mem_stat.f_path + 1;
+		strncpy(mem_stat.f_path_buf, mem_stat.f_path, PATH_MAX - 1);
+		snprintf(mem_stat.f_path_buf + len, PATH_MAX - len, "pid(%d)_%s", getpid(), pos + 1);
+	} else {
+		snprintf(mem_stat.f_path_buf, PATH_MAX, "pid(%d)_%s", getpid(), mem_stat.f_path);
+	}
+}
+
+static bool get_file(void)
+{
+	if (!g_enable_check) {
+		printf("You should call mem_check_init(char *) or use command line parameters, "
+			"--mwatch or --mrecord <full path>, to call mem_check_init(char *) "
+			"when executing your program.\n");
+		return false;
+	}
+
+	if (mem_stat.verbose) {
+		return true;
+	}
+
+	file_path_init();
+	if (!access(mem_stat.f_path_buf, 0)) {
+		return true;
+	}
+	mem_stat.fd = open(mem_stat.f_path_buf, O_RDWR | O_CREAT);
+	if (mem_stat.fd < 0) {
+		printf("err: %s create failed, memory info will output from serial port!\n", mem_stat.f_path_buf);
+		mem_stat.verbose = true;
+	}
+	return true;
+}
+
+static int get_backtrace_info(void **buffer, int nptr, int fd, bool verbose, bool checkpoint)
+{
+	int i, ret;
+	char str_buf[ITEM_BUFFER_SIZE];
+	Dl_info info = { 0 };
+	bool checkpoint_head = false;
+	int checkpoint_trace_num = 0;
+	bool symbol_found;
+
+	for (i = 0; i < nptr; ++i) {
+		symbol_found = true;
+		dladdr((void *)buffer[i], &info);
+		if ((info.dli_fname == NULL) || (info.dli_fname[0] == '\0')) {
+			symbol_found = false;
+		}
+
+		if (checkpoint && !checkpoint_head) {
+			checkpoint_head = true;
+			if (verbose) {
+				printf("    [Check point]:\n");
+			} else {
+				snprintf(str_buf, ITEM_BUFFER_SIZE, "    [Check point]:\n");
+				ret = write(fd, str_buf, strlen(str_buf));
+				if (ret != strlen(str_buf)) {
+					goto err;
+				}
+			}
+		}
+		if (verbose) {
+			symbol_found ?
+			printf("\t#%02d: <%s+%#x>[%#x] -> %s\n", i, info.dli_sname, (uintptr_t)buffer[i] -
+				(uintptr_t)info.dli_saddr, (uintptr_t)buffer[i] - (uintptr_t)info.dli_fbase, info.dli_fname) :
+			printf("\t#%02d: %#x\n", i, buffer[i]);
+		} else {
+			symbol_found ?
+			snprintf(str_buf, ITEM_BUFFER_SIZE, "\t#%02d: <%s+%#x>[%#x] -> %s\n", i, info.dli_sname,
+				(uintptr_t)buffer[i] - (uintptr_t)info.dli_saddr, (uintptr_t)buffer[i] - (uintptr_t)info.dli_fbase,
+				info.dli_fname) :
+			snprintf(str_buf, ITEM_BUFFER_SIZE, "\t#%02d: %#x\n", i, buffer[i]);
+			ret = write(fd, str_buf, strlen(str_buf));
+			if (ret != strlen(str_buf)) {
+				goto err;
+			}
+		}
+		if (checkpoint) {
+			checkpoint_trace_num++;
+			if (checkpoint_trace_num == CHECK_POINT_TRACE_MAX) {
+				break;
+			}
+		}
+	}
+	return 0;
+err:
+	printf("Write failed, err: %s\n", strerror(errno));
+	return ret;
+}
+
+static int print_integrity_info(struct node *node)
+{
+	int ret;
+	char buffer[ITEM_BUFFER_SIZE];
+	char *str = "The possible attacker was allocated from:";
+
+	if (mem_stat.verbose) {
+		printf("\n==PID:%d== Memory integrity information:\n", getpid());
+		printf("    [TID:%d PID:%d allocated addr: %#x, size: %#x] %s\n", node->tid, node->pid, node->ptr, node->size,
+			str);
+	} else {
+		snprintf(buffer, ITEM_BUFFER_SIZE, "\n==PID:%d== Memory integrity information:\n", getpid());
+		ret = write(mem_stat.fd, buffer, strlen(buffer));
+		if (ret != strlen(buffer)) {
+			goto err;
+		}
+		snprintf(buffer, ITEM_BUFFER_SIZE, "    [TID:%d PID:%d allocated addr: %#x, size: %#x] %s\n", node->tid, node->pid,
+			node->ptr, node->size, str);
+		ret = write(mem_stat.fd, buffer, strlen(buffer));
+		if (ret != strlen(buffer)) {
+			goto err;
+		}
+	}
+	return 0;
+err:
+	printf("Write failed, err: %s\n", strerror(errno));
+	return ret;
+}
+
+static int check_mem_integrity(int tid, void *ptr)
+{
+	struct list *list = NULL;
+	struct node *node = NULL;
+	int nptr = 0;
+
+	lock_stat_bin(tid);
+	for (list = mem_stat.bins[tid].head.next; list != &mem_stat.bins[tid].head; list = list->next) {
+		node = (struct node *)((uintptr_t)list - (uint32_t)&((struct node *)0)->list);
+		if (node->ptr != ptr) {
+			continue;
+		}
+		if (print_integrity_info(node) != 0) {
+			unlock_stat_bin(tid);
+			printf("Memory integrity check failed!\n");
+			return -1;
+		}
+		while (node->lr[nptr] != NULL) {
+			++nptr;
+			if (nptr == BACKTRACE_DEPTH_MAX) {
+				break;
+			}
+		}
+		if ((nptr == 0) || (get_backtrace_info(node->lr, nptr, mem_stat.fd, mem_stat.verbose, false) != 0)) {
+			unlock_stat_bin(tid);
+			printf("get backtrace failed!\n");
+			return -1;
+		}
+		if (!mem_stat.verbose) {
+			printf("Memory integrity information saved in %s\n", mem_stat.f_path_buf);
+		}
+		unlock_stat_bin(tid);
+		return 0;
+	}
+	unlock_stat_bin(tid);
+	return 1;
+}
+
+static void get_integrity_info(void *ptr)
+{
+	int i, status;
+	int tid = ((struct pthread *)pthread_self())->tid;
+
+	status = check_mem_integrity(tid, ptr);
+	if (status != 1) {
+		return;
+	}
+
+	for (i = 0; i < PTHREAD_NUM_MAX; ++i) {
+		if (i == tid) {
+			continue;
+		}
+		status = check_mem_integrity(i, ptr);
+		if (status != 1) {
+			return;
+		}
+	}
+}
+
+bool is_invalid(struct chunk *self)
+{
+	uint32_t checksum;
+	checksum = CHUNK_SIZE(self) ^ CHUNK_PSIZE(self) ^ NODE_MAGIC;
+	if (checksum != self->checksum) {
+		return true;
+	} else {
+		return false;
+	}
+}
+
+void calculate_checksum(struct chunk *cur, struct chunk *next)
+{
+	if (cur) {
+		cur->checksum = CHUNK_SIZE(cur) ^ CHUNK_PSIZE(cur) ^ NODE_MAGIC;
+	}
+
+	if (next) {
+		next->checksum = CHUNK_SIZE(next) ^ CHUNK_PSIZE(next) ^ NODE_MAGIC;
+	}
+}
+
+void check_heap_integrity(void)
+{
+	struct chunk *cur = NULL;
+	struct chunk *next = NULL;
+	struct heap_block *block = NULL;
+
+	if (!block_list.next) {
+		return;
+	}
+
+	lock(g_mem_lock);
+	if (!get_file()) {
+		unlock(g_mem_lock);
+		return;
+	}
+	block = block_list.next;
+	while (block != &block_list) {
+		cur = BLOCK_TO_CHUNK(block);
+		do {
+			next = NEXT_CHUNK(cur);
+			if (is_invalid(next)) {
+				get_integrity_info(CHUNK_TO_MEM(cur));
+				unlock(g_mem_lock);
+				a_crash();
+			}
+			cur = next;
+		} while (CHUNK_SIZE(next));
+		block = block->next;
+	}
+	unlock(g_mem_lock);
+	printf("\nCheck heap integrity ok!\n");
+}
+
+void check_chunk_integrity(struct chunk *cur)
+{
+	struct chunk *next = NULL;
+
+	if (is_invalid(cur)) {
+		check_heap_integrity();
+	}
+
+	lock(g_mem_lock);
+	next = NEXT_CHUNK(cur);
+	if ((CHUNK_SIZE(next)) && is_invalid(next)) {
+		get_integrity_info(CHUNK_TO_MEM(cur));
+		unlock(g_mem_lock);
+		a_crash();
+	}
+	unlock(g_mem_lock);
+}
+
+void insert_block_list(struct chunk *self)
+{
+	struct heap_block *block = CHUNK_TO_BLOCK(self);
+	struct heap_block *cur = NULL;
+
+	if (!block_list.next) {
+		block_list.next = block_list.prev = &block_list;
+	}
+
+	cur = block_list.prev;
+	block->next = cur->next;
+	block->prev = cur;
+	cur->next = block;
+	block_list.prev = block;
+}
+
+void get_free_trace(void *ptr)
+{
+	void *lr[BACKTRACE_DEPTH_MAX + BACKTRACE_OFFSET] = { 0 };
+	int tid = ((struct pthread *)pthread_self())->tid;
+	char buffer[ITEM_BUFFER_SIZE];
+	int nptr, ret;
+
+	lock(g_mem_lock);
+	if (!get_file()) {
+		unlock(g_mem_lock);
+		return;
+	}
+	if (mem_stat.verbose) {
+		printf("\n==PID:%d== double free\n", getpid());
+		printf("    [TID:%d freed addr: %#x]:\n", tid, ptr);
+	} else {
+		snprintf(buffer, ITEM_BUFFER_SIZE, "\n==PID:%d== double free\n", getpid());
+		ret = write(mem_stat.fd, buffer, strlen(buffer));
+		if (ret != strlen(buffer)) {
+			goto err;
+		}
+		snprintf(buffer, ITEM_BUFFER_SIZE, "    [TID:%d freed addr: %#x]:\n", tid, ptr);
+		ret = write(mem_stat.fd, buffer, strlen(buffer));
+		if (ret != strlen(buffer)) {
+			goto err;
+		}
+	}
+
+	nptr = backtrace(lr, BACKTRACE_DEPTH_MAX + BACKTRACE_OFFSET);
+	if (get_backtrace_info(lr + BACKTRACE_OFFSET, nptr - BACKTRACE_OFFSET, mem_stat.fd, mem_stat.verbose, false) != 0) {
+		printf("Trace failed\n");
+	}
+
+	unlock(g_mem_lock);
+	return;
+err:
+	printf("Write failed, err: %s\n", strerror(errno));
+	unlock(g_mem_lock);
+	return;
+}
+
+void watch_mem(void)
+{
+	int tid, ret;
+	char buffer[ITEM_BUFFER_SIZE];
+	void *lr[BACKTRACE_DEPTH_MAX + BACKTRACE_OFFSET] = { 0 };
+	pid_t pid = getpid();
+	int nptr;
+
+	lock(g_mem_lock);
+	if (!get_file()) {
+		unlock(g_mem_lock);
+		return;
+	}
+	if (mem_stat.verbose) {
+		printf("\n==PID:%d== Heap memory statistics(bytes):\n", pid);
+	} else {
+		snprintf(buffer, ITEM_BUFFER_SIZE, "\n==PID:%d== Heap memory statistics(bytes):\n", pid);
+		ret = write(mem_stat.fd, buffer, strlen(buffer));
+		if (ret != strlen(buffer)) {
+			goto err2;
+		}
+	}
+	nptr = backtrace(lr, BACKTRACE_DEPTH_MAX + BACKTRACE_OFFSET);
+	if (get_backtrace_info(lr + BACKTRACE_OFFSET, nptr - BACKTRACE_OFFSET, mem_stat.fd, mem_stat.verbose, true) != 0) {
+		printf("Check failed\n");
+		unlock(g_mem_lock);
+		return;
+	}
+	for (tid = 0; tid < PTHREAD_NUM_MAX; ++tid) {
+		lock_stat_bin(tid);
+		if (mem_stat.bins[tid].t_total_size == 0) {
+			unlock_stat_bin(tid);
+			continue;
+		}
+		if (mem_stat.verbose) {
+			printf("\n    [TID: %d, Used: %#x]", tid, mem_stat.bins[tid].t_total_size);
+		} else {
+			snprintf(buffer, ITEM_BUFFER_SIZE, "\n    [TID: %d, Used: %#x]", tid, mem_stat.bins[tid].t_total_size);
+			ret = write(mem_stat.fd, buffer, strlen(buffer));
+			if (ret != strlen(buffer)) {
+				goto err1;
+			}
+		}
+		unlock_stat_bin(tid);
+	}
+	if (mem_stat.verbose) {
+		printf("\n\n==PID:%d== Total heap: %#x byte(s), Peak: %#x byte(s)\n", pid,
+				mem_stat.p_total_size, mem_stat.peak_size);
+	} else {
+		snprintf(buffer, ITEM_BUFFER_SIZE, "\n\n==PID:%d== Total heap: %#x byte(s), Peak: %#x byte(s)\n", pid,
+				 mem_stat.p_total_size, mem_stat.peak_size);
+		ret = write(mem_stat.fd, buffer, strlen(buffer));
+		if (ret != strlen(buffer)) {
+			goto err2;
+		}
+	}
+	if (!mem_stat.verbose) {
+		printf("Memory statistics information saved in %s\n", mem_stat.f_path_buf);
+	}
+	unlock(g_mem_lock);
+	return;
+err1:
+	unlock_stat_bin(tid);
+err2:
+	printf("Write failed, err: %s\n", strerror(errno));
+	unlock(g_mem_lock);
+}
+
+static int get_node_info(struct node *node, int fd, bool verbose, bool mem_leak_exist)
+{
+	char buffer[ITEM_BUFFER_SIZE];
+	void *lr[BACKTRACE_DEPTH_MAX + BACKTRACE_OFFSET] = { 0 };
+	int nptr, ret;
+
+	if (!mem_leak_exist) {
+		if (verbose) {
+			printf("\n==PID:%d== Detected memory leak(s):\n", getpid());
+		} else {
+			snprintf(buffer, ITEM_BUFFER_SIZE, "\n==PID:%d== Detected memory leak(s):\n", getpid());
+			ret = write(fd, buffer, strlen(buffer));
+			if (ret != strlen(buffer)) {
+				goto err;
+			}
+		}
+		nptr = backtrace(lr, BACKTRACE_DEPTH_MAX + BACKTRACE_OFFSET);
+		if (get_backtrace_info(lr + BACKTRACE_OFFSET, nptr - BACKTRACE_OFFSET, mem_stat.fd, mem_stat.verbose, true) != 0) {
+			printf("Check failed\n");
+			goto err;
+		}
+	}
+
+	if (verbose) {
+		printf("\n    [TID:%d Leak:%#x byte(s)] Allocated from:\n", node->tid, node->size);
+	} else {
+		snprintf(buffer, ITEM_BUFFER_SIZE, "\n    [TID:%d Leak:%#x byte(s)] Allocated from:\n", node->tid, node->size);
+		ret = write(fd, buffer, strlen(buffer));
+		if (ret != strlen(buffer)) {
+			goto err;
+		}
+	}
+	return 0;
+err:
+	printf("Write failed, err: %s\n", strerror(errno));
+	return ret;
+
+}
+
+static void print_summary_info(size_t leak_size, size_t allocs, int fd, bool verbose, bool mem_leak_exist)
+{
+	char buffer[ITEM_BUFFER_SIZE];
+	int ret;
+
+	if (!mem_leak_exist) {
+		if (verbose) {
+			printf("\nNo memory leak!\n");
+			return;
+		} else {
+			snprintf(buffer, ITEM_BUFFER_SIZE, "\nNo memory leak!\n");
+			ret = write(fd, buffer, strlen(buffer));
+			if (ret != strlen(buffer)) {
+				printf("Write failed, err: %s\n", strerror(errno));
+			}
+			return;
+		}
+	}
+
+	if (verbose) {
+		printf("\n==PID:%d== SUMMARY: %#x byte(s) leaked in %d allocation(s).\n", getpid(), leak_size, allocs);
+	} else {
+		snprintf(buffer, ITEM_BUFFER_SIZE, "\n==PID:%d== SUMMARY: %#x byte(s) leaked in %d allocation(s).\n", getpid(),
+			leak_size, allocs);
+		ret = write(fd, buffer, strlen(buffer));
+		if (ret != strlen(buffer)) {
+			printf("Write failed, err: %s\n", strerror(errno));
+		}
+	}
+}
+
+void check_leak(void)
+{
+	struct list *list = NULL;
+	struct node *node = NULL;
+	int tid, nptr;
+	size_t leak_size = 0;
+	size_t allocs = 0;
+	bool mem_leak_exist = false;
+	pid_t pid = getpid();
+
+	lock(g_mem_lock);
+	if (!get_file()) {
+		unlock(g_mem_lock);
+		return;
+	}
+	for (tid = 0; tid < PTHREAD_NUM_MAX; ++tid) {
+		lock_stat_bin(tid);
+		for (list = mem_stat.bins[tid].head.next; list != &mem_stat.bins[tid].head; list = list->next) {
+			node = (struct node *)((uintptr_t)list - (uint32_t)&((struct node *)0)->list);
+			if (node->pid != pid) {
+				continue;
+			}
+			if (get_node_info(node, mem_stat.fd, mem_stat.verbose, mem_leak_exist) != 0) {
+				unlock_stat_bin(tid);
+				unlock(g_mem_lock);
+				printf("Check failed\n");
+				return;
+			}
+			++allocs;
+			leak_size += node->size;
+			mem_leak_exist = true;
+			nptr = 0;
+			while (node->lr[nptr] != NULL) {
+				++nptr;
+				if (nptr == BACKTRACE_DEPTH_MAX) {
+					break;
+				}
+			}
+			if (nptr == 0) {
+				continue;
+			}
+			if (get_backtrace_info(node->lr, nptr, mem_stat.fd, mem_stat.verbose, false) != 0) {
+				unlock_stat_bin(tid);
+				unlock(g_mem_lock);
+				printf("Check failed\n");
+				return;
+			}
+		}
+		unlock_stat_bin(tid);
+	}
+	print_summary_info(leak_size, allocs, mem_stat.fd, mem_stat.verbose, mem_leak_exist);
+	if (!mem_stat.verbose) {
+		printf("Leak check information saved in %s\n", mem_stat.f_path_buf);
+	}
+	unlock(g_mem_lock);
+}
+
+void mem_check_init(char *f_path)
+{
+	signal(35, watch_mem);
+	signal(36, check_leak);
+	signal(37, check_heap_integrity);
+	g_enable_check = true;
+	mem_stat.fd = -1;
+	const char *string = "memory info will print to serial port!";
+
+	if (!f_path) {
+		goto out;
+	}
+
+	if (strlen(f_path) > (PATH_MAX - PREFIX_PLACE_HOLDER - 1)) {
+		printf("file name: %s is too long, %s\n", f_path, string);
+		goto out;
+	}
+	mem_stat.f_path = f_path;
+	file_path_init();
+	mem_stat.fd = open(mem_stat.f_path_buf, O_RDWR | O_CREAT | O_EXCL);
+	if (mem_stat.fd < 0) {
+		switch (errno) {
+		case EEXIST:
+			printf("file: %s is exist, %s\n", mem_stat.f_path_buf, string);
+			goto out;
+		default:
+			printf("path: %s create failed, %s\n", mem_stat.f_path_buf, string);
+			goto out;
+		}
+	}
+	mem_stat.verbose = false;
+	return;
+
+out:
+	mem_stat.verbose = true;
+}
+
+void mem_check_deinit()
+{
+	if (mem_stat.fd > 0) {
+		close(mem_stat.fd);
+	}
+}
+
+void parse_argv(int argc, char *argv[])
+{
+
+	if (argc <= 1) {
+		return;
+	}
+
+	if (!strcmp(argv[argc - 1], "--mwatch")) {
+		mem_check_init(NULL);
+	} else if ((argc > 2) && (!strcmp(argv[argc - 2], "--mrecord"))) {
+		mem_check_init(argv[argc - 1]);
+	} else if (!strcmp(argv[argc - 1], "--mrecord")) {
+		printf("usage: --mrecord filepath\n");
+	}
+}
+
+void insert_free_tail(struct chunk *self)
+{
+	volatile struct chunk *cur = NULL;
+	lock(g_mem_lock);
+	if (!recycle_list.next) {
+		recycle_list.next = recycle_list.prev = &recycle_list;
+	}
+	cur = recycle_list.prev;
+	self->next = cur->next;
+	self->prev = cur;
+	cur->next = self;
+	recycle_list.prev = self;
+	memset(CHUNK_TO_MEM(self), FREE_MAGIC, CHUNK_SIZE(self) - OVERHEAD);
+	++g_recycle_num;
+	g_recycle_size += CHUNK_SIZE(self);
+	unlock(g_mem_lock);
+}
+
+struct chunk *get_free_head(void)
+{
+	struct chunk *cur = NULL;
+	lock(g_mem_lock);
+	cur = recycle_list.next;
+	if ((cur == NULL) || (cur == &recycle_list)) {
+		unlock(g_mem_lock);
+		return NULL;
+	}
+	recycle_list.next = cur->next;
+	cur->next->prev = cur->prev;
+	--g_recycle_num;
+	g_recycle_size -= CHUNK_SIZE(cur);
+	unlock(g_mem_lock);
+	return cur;
+}
+
+void clean_recycle_list(bool clean_all)
+{
+	struct chunk *self = NULL;
+	self = get_free_head();
+	while (self) {
+		__bin_chunk(self);
+		if ((!clean_all) && (g_recycle_size < RECYCLE_SIZE_MAX)) {
+			break;
+		}
+		self = get_free_head();
+	}
+}
+
diff --git a/third_party/musl/porting/liteos_m/kernel/BUILD.gn b/third_party/musl/porting/liteos_m/kernel/BUILD.gn
new file mode 100755
index 000000000..1008f2e8b
--- /dev/null
+++ b/third_party/musl/porting/liteos_m/kernel/BUILD.gn
@@ -0,0 +1,169 @@
+# Copyright (c) 2013-2019 Huawei Technologies Co., Ltd. All rights reserved.
+# Copyright (c) 2020-2021 Huawei Device Co., Ltd. All rights reserved.
+#
+# Redistribution and use in source and binary forms, with or without modification,
+# are permitted provided that the following conditions are met:
+#
+# 1. Redistributions of source code must retain the above copyright notice, this list of
+#    conditions and the following disclaimer.
+#
+# 2. Redistributions in binary form must reproduce the above copyright notice, this list
+#    of conditions and the following disclaimer in the documentation and/or other materials
+#    provided with the distribution.
+#
+# 3. Neither the name of the copyright holder nor the names of its contributors may be used
+#    to endorse or promote products derived from this software without specific prior written
+#    permission.
+#
+# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+# "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+# THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+# PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
+# CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+# EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+# PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
+# OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+# WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
+# OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
+# ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+libc = "musl-c"
+libm = "musl-m"
+
+config("include") {
+  include_dirs = [
+    "include",
+  ]
+}
+
+static_library(libc) {
+  sources = [
+    #"src/errno/strerror.c",
+    "src/internal/shgetc.c",
+    "src/internal/intscan.c",
+    "src/stdlib/atoi.c",
+    #"src/stdlib/strtol.c",
+    "src/stdlib/atol.c",
+    "src/stdlib/atoll.c",
+    "src/stdlib/abs.c",
+    "src/network/h_errno.c",
+    "src/network/htonl.c",
+    "src/network/htons.c",
+    "src/network/ntohl.c",
+    "src/network/ntohs.c",
+    "src/exit/abort.c",
+    #"src/exit/assert.c",
+    "src/ctype/isascii.c",
+    "src/ctype/isxdigit.c",
+    "src/ctype/isdigit.c",
+    "src/ctype/isupper.c",
+    "src/ctype/isspace.c",
+    "src/ctype/isalnum.c",
+    "src/ctype/islower.c",
+    "src/ctype/tolower.c",
+    "src/ctype/toupper.c",
+    "src/ctype/isprint.c",
+    "src/ctype/__ctype_get_mb_cur_max.c",
+    "src/misc/dirname.c",
+    "src/locale/__lctrans.c",
+    "src/locale/langinfo.c",
+    "src/locale/c_locale.c",
+    "src/stdio/fputs.c",
+    "src/stdio/__stdio_close.c",
+    "src/stdio/fflush.c",
+    "src/stdio/__toread.c",
+    "src/stdio/ofl_add.c",
+    "src/stdio/__stdio_seek.c",
+    "src/stdio/__uflow.c",
+    "src/stdio/ftell.c",
+    "src/stdio/__stdio_read.c",
+    "src/stdio/fwrite.c",
+    "src/stdio/fread.c",
+    "src/stdio/fclose.c",
+    "src/stdio/stderr.c",
+    "src/stdio/fileno.c",
+    "src/stdio/perror.c",
+    "src/stdio/__lockfile.c",
+    "src/stdio/fgets.c",
+    "src/stdio/clearerr.c",
+    "src/stdio/__stdio_write.c",
+    "src/stdio/__fmodeflags.c",
+    "src/stdio/__fdopen.c",
+    "src/stdio/ofl.c",
+    "src/stdio/fseek.c",
+    "src/stdio/__stdout_write.c",
+    "src/stdio/rewind.c",
+    "src/stdio/__towrite.c",
+    "src/stdio/feof.c",
+    "src/stdio/fopen.c",
+    "src/stdio/stdout.c",
+    "src/stdio/stdin.c",
+    "src/time/strptime.c",
+    "src/time/strftime.c",
+    "src/time/__year_to_secs.c",
+    "src/time/__month_to_secs.c",
+    "src/time/__tz.c",
+    "src/time/__tm_to_secs.c",
+    "src/prng/random.c",
+    "src/regex/regexec.c",
+    "src/regex/regcomp.c",
+    "src/regex/tre-mem.c",
+    "src/string/strrchr.c",
+    "src/string/memcmp.c",
+    "src/string/strcspn.c",
+    "src/string/strstr.c",
+    "src/string/strchrnul.c",
+    "src/string/strchr.c",
+    "src/string/memcpy.c",
+    "src/string/strncmp.c",
+    "src/string/strcasecmp.c",
+    "src/string/strcmp.c",
+    "src/string/strncasecmp.c",
+    "src/string/memchr.c",
+    "src/string/memrchr.c",
+    "src/string/strdup.c",
+    "src/string/wcslen.c",
+    "src/string/memset.c",
+    "src/string/strlen.c",
+    "src/string/wcschr.c",
+  ]
+
+  include_dirs = [
+    "src/include",
+    "src/internal",
+  ]
+
+  include_dirs += [
+    "//kernel/liteos_m/kernel/arch/include",
+    "//kernel/liteos_m/kernel/include",
+    "//kernel/liteos_m/utils",
+  ]
+
+  public_configs = [ ":include" ]
+}
+
+static_library(libm) {
+  sources = [
+    "src/math/pow.c",
+    "src/math/log.c",
+    "src/math/sqrt.c",
+    "src/math/pow_data.c",
+    "src/math/log_data.c",
+    "src/math/exp_data.c",
+    "src/math/round.c",
+  ]
+
+  include_dirs = [
+    "src/include",
+    "src/internal",
+  ]
+
+  public_configs = [ ":include" ]
+}
+
+group("kernel") {
+  public_deps = [
+    ":$libc",
+    ":$libm",
+  ]
+}
diff --git a/third_party/musl/porting/liteos_m/kernel/include/aio.h b/third_party/musl/porting/liteos_m/kernel/include/aio.h
new file mode 100755
index 000000000..453c41b74
--- /dev/null
+++ b/third_party/musl/porting/liteos_m/kernel/include/aio.h
@@ -0,0 +1,73 @@
+#ifndef _AIO_H
+#define _AIO_H
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#include <features.h>
+#include <signal.h>
+#include <time.h>
+
+#define __NEED_ssize_t
+#define __NEED_off_t
+
+#include <bits/alltypes.h>
+
+struct aiocb {
+	int aio_fildes, aio_lio_opcode, aio_reqprio;
+	volatile void *aio_buf;
+	size_t aio_nbytes;
+	struct sigevent aio_sigevent;
+	void *__td;
+	int __lock[2];
+	volatile int __err;
+	ssize_t __ret;
+	off_t aio_offset;
+	void *__next, *__prev;
+	char __dummy4[32-2*sizeof(void *)];
+};
+
+#define AIO_CANCELED 0
+#define AIO_NOTCANCELED 1
+#define AIO_ALLDONE 2
+
+#define LIO_READ 0
+#define LIO_WRITE 1
+#define LIO_NOP 2
+
+#define LIO_WAIT 0
+#define LIO_NOWAIT 1
+
+int aio_read(struct aiocb *);
+int aio_write(struct aiocb *);
+int aio_error(const struct aiocb *);
+ssize_t aio_return(struct aiocb *);
+int aio_cancel(int, struct aiocb *);
+int aio_suspend(const struct aiocb *const [], int, const struct timespec *);
+int aio_fsync(int, struct aiocb *);
+
+int lio_listio(int, struct aiocb *__restrict const *__restrict, int, struct sigevent *__restrict);
+
+#if defined(_LARGEFILE64_SOURCE) || defined(_GNU_SOURCE)
+#define aiocb64 aiocb
+#define aio_read64 aio_read
+#define aio_write64 aio_write
+#define aio_error64 aio_error
+#define aio_return64 aio_return
+#define aio_cancel64 aio_cancel
+#define aio_suspend64 aio_suspend
+#define aio_fsync64 aio_fsync
+#define lio_listio64 lio_listio
+#define off64_t off_t
+#endif
+
+#if _REDIR_TIME64
+__REDIR(aio_suspend, __aio_suspend_time64);
+#endif
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
diff --git a/third_party/musl/porting/liteos_m/kernel/include/alloca.h b/third_party/musl/porting/liteos_m/kernel/include/alloca.h
new file mode 100755
index 000000000..b8d183d14
--- /dev/null
+++ b/third_party/musl/porting/liteos_m/kernel/include/alloca.h
@@ -0,0 +1,19 @@
+#ifndef	_ALLOCA_H
+#define	_ALLOCA_H
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#define	__NEED_size_t
+#include <bits/alltypes.h>
+
+void *alloca(size_t);
+
+#define alloca __builtin_alloca
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
diff --git a/third_party/musl/porting/liteos_m/kernel/include/ar.h b/third_party/musl/porting/liteos_m/kernel/include/ar.h
new file mode 100755
index 000000000..eafd51d0e
--- /dev/null
+++ b/third_party/musl/porting/liteos_m/kernel/include/ar.h
@@ -0,0 +1,25 @@
+#ifndef _AR_H
+#define _AR_H
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#define ARMAG "!<arch>\n"
+#define SARMAG 8
+#define ARFMAG "`\n"
+
+struct ar_hdr {
+	char ar_name[16];
+	char ar_date[12];
+	char ar_uid[6], ar_gid[6];
+	char ar_mode[8];
+	char ar_size[10];
+	char ar_fmag[2];
+};
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
diff --git a/third_party/musl/porting/liteos_m/kernel/include/arpa/ftp.h b/third_party/musl/porting/liteos_m/kernel/include/arpa/ftp.h
new file mode 100755
index 000000000..fb0a46f2b
--- /dev/null
+++ b/third_party/musl/porting/liteos_m/kernel/include/arpa/ftp.h
@@ -0,0 +1,35 @@
+#ifndef _ARPA_FTP_H
+#define _ARPA_FTP_H
+#define PRELIM 1
+#define COMPLETE 2
+#define CONTINUE 3
+#define TRANSIENT 4
+#define ERROR 5
+#define TYPE_A 1
+#define TYPE_E 2
+#define TYPE_I 3
+#define TYPE_L 4
+#define FORM_N 1
+#define FORM_T 2
+#define FORM_C 3
+#define STRU_F 1
+#define STRU_R 2
+#define STRU_P 3
+#define MODE_S 1
+#define MODE_B 2
+#define MODE_C 3
+#define REC_ESC '\377'
+#define REC_EOR '\001'
+#define REC_EOF '\002'
+#define BLK_EOR 0x80
+#define BLK_EOF 0x40
+#define BLK_ERRORS 0x20
+#define BLK_RESTART 0x10
+#define BLK_BYTECOUNT 2
+#ifdef FTP_NAMES
+char *modenames[] =  {"0", "Stream", "Block", "Compressed" };
+char *strunames[] =  {"0", "File", "Record", "Page" };
+char *typenames[] =  {"0", "ASCII", "EBCDIC", "Image", "Local" };
+char *formnames[] =  {"0", "Nonprint", "Telnet", "Carriage-control" };
+#endif
+#endif
diff --git a/third_party/musl/porting/liteos_m/kernel/include/arpa/inet.h b/third_party/musl/porting/liteos_m/kernel/include/arpa/inet.h
new file mode 100755
index 000000000..37f8c11ee
--- /dev/null
+++ b/third_party/musl/porting/liteos_m/kernel/include/arpa/inet.h
@@ -0,0 +1,36 @@
+#ifndef _ARPA_INET_H
+#define	_ARPA_INET_H
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#include <features.h>
+#include <netinet/in.h>
+
+uint32_t htonl(uint32_t);
+uint16_t htons(uint16_t);
+uint32_t ntohl(uint32_t);
+uint16_t ntohs(uint16_t);
+
+in_addr_t inet_addr (const char *);
+in_addr_t inet_network (const char *);
+char *inet_ntoa (struct in_addr);
+int inet_pton (int, const char *__restrict, void *__restrict);
+const char *inet_ntop (int, const void *__restrict, char *__restrict, socklen_t);
+
+int inet_aton (const char *, struct in_addr *);
+struct in_addr inet_makeaddr(in_addr_t, in_addr_t);
+in_addr_t inet_lnaof(struct in_addr);
+in_addr_t inet_netof(struct in_addr);
+
+#undef INET_ADDRSTRLEN
+#undef INET6_ADDRSTRLEN
+#define INET_ADDRSTRLEN  16
+#define INET6_ADDRSTRLEN 46
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
diff --git a/third_party/musl/porting/liteos_m/kernel/include/arpa/nameser.h b/third_party/musl/porting/liteos_m/kernel/include/arpa/nameser.h
new file mode 100755
index 000000000..581925a43
--- /dev/null
+++ b/third_party/musl/porting/liteos_m/kernel/include/arpa/nameser.h
@@ -0,0 +1,455 @@
+#ifndef _ARPA_NAMESER_H
+#define _ARPA_NAMESER_H
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#include <stddef.h>
+#include <stdint.h>
+
+#define __NAMESER	19991006
+#define NS_PACKETSZ	512
+#define NS_MAXDNAME	1025
+#define NS_MAXMSG	65535
+#define NS_MAXCDNAME	255
+#define NS_MAXLABEL	63
+#define NS_HFIXEDSZ	12
+#define NS_QFIXEDSZ	4
+#define NS_RRFIXEDSZ	10
+#define NS_INT32SZ	4
+#define NS_INT16SZ	2
+#define NS_INT8SZ	1
+#define NS_INADDRSZ	4
+#define NS_IN6ADDRSZ	16
+#define NS_CMPRSFLGS	0xc0
+#define NS_DEFAULTPORT	53
+
+typedef enum __ns_sect {
+	ns_s_qd = 0,
+	ns_s_zn = 0,
+	ns_s_an = 1,
+	ns_s_pr = 1,
+	ns_s_ns = 2,
+	ns_s_ud = 2,
+	ns_s_ar = 3,
+	ns_s_max = 4
+} ns_sect;
+
+typedef struct __ns_msg {
+	const unsigned char *_msg, *_eom;
+	uint16_t _id, _flags, _counts[ns_s_max];
+	const unsigned char *_sections[ns_s_max];
+	ns_sect _sect;
+	int _rrnum;
+	const unsigned char *_msg_ptr;
+} ns_msg;
+
+struct _ns_flagdata {  int mask, shift;  };
+extern const struct _ns_flagdata _ns_flagdata[];
+
+#define ns_msg_id(handle) ((handle)._id + 0)
+#define ns_msg_base(handle) ((handle)._msg + 0)
+#define ns_msg_end(handle) ((handle)._eom + 0)
+#define ns_msg_size(handle) ((handle)._eom - (handle)._msg)
+#define ns_msg_count(handle, section) ((handle)._counts[section] + 0)
+#define ns_msg_getflag(handle, flag) \
+	(((handle)._flags & _ns_flagdata[flag].mask) >> _ns_flagdata[flag].shift)
+
+typedef	struct __ns_rr {
+	char		name[NS_MAXDNAME];
+	uint16_t	type;
+	uint16_t	rr_class;
+	uint32_t	ttl;
+	uint16_t	rdlength;
+	const unsigned char *rdata;
+} ns_rr;
+
+#define ns_rr_name(rr)	(((rr).name[0] != '\0') ? (rr).name : ".")
+#define ns_rr_type(rr)	((ns_type)((rr).type + 0))
+#define ns_rr_class(rr)	((ns_class)((rr).rr_class + 0))
+#define ns_rr_ttl(rr)	((rr).ttl + 0)
+#define ns_rr_rdlen(rr)	((rr).rdlength + 0)
+#define ns_rr_rdata(rr)	((rr).rdata + 0)
+
+typedef enum __ns_flag {
+	ns_f_qr,
+	ns_f_opcode,
+	ns_f_aa,
+	ns_f_tc,
+	ns_f_rd,
+	ns_f_ra,
+	ns_f_z,
+	ns_f_ad,
+	ns_f_cd,
+	ns_f_rcode,
+	ns_f_max
+} ns_flag;
+
+typedef enum __ns_opcode {
+	ns_o_query = 0,
+	ns_o_iquery = 1,
+	ns_o_status = 2,
+	ns_o_notify = 4,
+	ns_o_update = 5,
+	ns_o_max = 6
+} ns_opcode;
+
+typedef	enum __ns_rcode {
+	ns_r_noerror = 0,
+	ns_r_formerr = 1,
+	ns_r_servfail = 2,
+	ns_r_nxdomain = 3,
+	ns_r_notimpl = 4,
+	ns_r_refused = 5,
+	ns_r_yxdomain = 6,
+	ns_r_yxrrset = 7,
+	ns_r_nxrrset = 8,
+	ns_r_notauth = 9,
+	ns_r_notzone = 10,
+	ns_r_max = 11,
+	ns_r_badvers = 16,
+	ns_r_badsig = 16,
+	ns_r_badkey = 17,
+	ns_r_badtime = 18
+} ns_rcode;
+
+typedef enum __ns_update_operation {
+	ns_uop_delete = 0,
+	ns_uop_add = 1,
+	ns_uop_max = 2
+} ns_update_operation;
+
+struct ns_tsig_key {
+        char name[NS_MAXDNAME], alg[NS_MAXDNAME];
+        unsigned char *data;
+        int len;
+};
+typedef struct ns_tsig_key ns_tsig_key;
+
+struct ns_tcp_tsig_state {
+	int counter;
+	struct dst_key *key;
+	void *ctx;
+	unsigned char sig[NS_PACKETSZ];
+	int siglen;
+};
+typedef struct ns_tcp_tsig_state ns_tcp_tsig_state;
+
+#define NS_TSIG_FUDGE 300
+#define NS_TSIG_TCP_COUNT 100
+#define NS_TSIG_ALG_HMAC_MD5 "HMAC-MD5.SIG-ALG.REG.INT"
+
+#define NS_TSIG_ERROR_NO_TSIG -10
+#define NS_TSIG_ERROR_NO_SPACE -11
+#define NS_TSIG_ERROR_FORMERR -12
+
+typedef enum __ns_type {
+	ns_t_invalid = 0,
+	ns_t_a = 1,
+	ns_t_ns = 2,
+	ns_t_md = 3,
+	ns_t_mf = 4,
+	ns_t_cname = 5,
+	ns_t_soa = 6,
+	ns_t_mb = 7,
+	ns_t_mg = 8,
+	ns_t_mr = 9,
+	ns_t_null = 10,
+	ns_t_wks = 11,
+	ns_t_ptr = 12,
+	ns_t_hinfo = 13,
+	ns_t_minfo = 14,
+	ns_t_mx = 15,
+	ns_t_txt = 16,
+	ns_t_rp = 17,
+	ns_t_afsdb = 18,
+	ns_t_x25 = 19,
+	ns_t_isdn = 20,
+	ns_t_rt = 21,
+	ns_t_nsap = 22,
+	ns_t_nsap_ptr = 23,
+	ns_t_sig = 24,
+	ns_t_key = 25,
+	ns_t_px = 26,
+	ns_t_gpos = 27,
+	ns_t_aaaa = 28,
+	ns_t_loc = 29,
+	ns_t_nxt = 30,
+	ns_t_eid = 31,
+	ns_t_nimloc = 32,
+	ns_t_srv = 33,
+	ns_t_atma = 34,
+	ns_t_naptr = 35,
+	ns_t_kx = 36,
+	ns_t_cert = 37,
+	ns_t_a6 = 38,
+	ns_t_dname = 39,
+	ns_t_sink = 40,
+	ns_t_opt = 41,
+	ns_t_apl = 42,
+	ns_t_tkey = 249,
+	ns_t_tsig = 250,
+	ns_t_ixfr = 251,
+	ns_t_axfr = 252,
+	ns_t_mailb = 253,
+	ns_t_maila = 254,
+	ns_t_any = 255,
+	ns_t_zxfr = 256,
+	ns_t_max = 65536
+} ns_type;
+
+#define	ns_t_qt_p(t) (ns_t_xfr_p(t) || (t) == ns_t_any || \
+		      (t) == ns_t_mailb || (t) == ns_t_maila)
+#define	ns_t_mrr_p(t) ((t) == ns_t_tsig || (t) == ns_t_opt)
+#define ns_t_rr_p(t) (!ns_t_qt_p(t) && !ns_t_mrr_p(t))
+#define ns_t_udp_p(t) ((t) != ns_t_axfr && (t) != ns_t_zxfr)
+#define ns_t_xfr_p(t) ((t) == ns_t_axfr || (t) == ns_t_ixfr || \
+		       (t) == ns_t_zxfr)
+
+typedef enum __ns_class {
+	ns_c_invalid = 0,
+	ns_c_in = 1,
+	ns_c_2 = 2,
+	ns_c_chaos = 3,
+	ns_c_hs = 4,
+	ns_c_none = 254,
+	ns_c_any = 255,
+	ns_c_max = 65536
+} ns_class;
+
+typedef enum __ns_key_types {
+	ns_kt_rsa = 1,
+	ns_kt_dh  = 2,
+	ns_kt_dsa = 3,
+	ns_kt_private = 254
+} ns_key_types;
+
+typedef enum __ns_cert_types {
+	cert_t_pkix = 1,
+	cert_t_spki = 2,
+	cert_t_pgp  = 3,
+	cert_t_url  = 253,
+	cert_t_oid  = 254
+} ns_cert_types;
+
+#define	NS_KEY_TYPEMASK		0xC000
+#define	NS_KEY_TYPE_AUTH_CONF	0x0000
+#define	NS_KEY_TYPE_CONF_ONLY	0x8000
+#define	NS_KEY_TYPE_AUTH_ONLY	0x4000
+#define	NS_KEY_TYPE_NO_KEY	0xC000
+#define	NS_KEY_NO_AUTH		0x8000
+#define	NS_KEY_NO_CONF		0x4000
+#define	NS_KEY_RESERVED2	0x2000
+#define	NS_KEY_EXTENDED_FLAGS	0x1000
+#define	NS_KEY_RESERVED4	0x0800
+#define	NS_KEY_RESERVED5	0x0400
+#define	NS_KEY_NAME_TYPE	0x0300
+#define	NS_KEY_NAME_USER	0x0000
+#define	NS_KEY_NAME_ENTITY	0x0200
+#define	NS_KEY_NAME_ZONE	0x0100
+#define	NS_KEY_NAME_RESERVED	0x0300
+#define	NS_KEY_RESERVED8	0x0080
+#define	NS_KEY_RESERVED9	0x0040
+#define	NS_KEY_RESERVED10	0x0020
+#define	NS_KEY_RESERVED11	0x0010
+#define	NS_KEY_SIGNATORYMASK	0x000F
+#define	NS_KEY_RESERVED_BITMASK ( NS_KEY_RESERVED2 | \
+				  NS_KEY_RESERVED4 | \
+				  NS_KEY_RESERVED5 | \
+				  NS_KEY_RESERVED8 | \
+				  NS_KEY_RESERVED9 | \
+				  NS_KEY_RESERVED10 | \
+				  NS_KEY_RESERVED11 )
+#define NS_KEY_RESERVED_BITMASK2 0xFFFF
+#define	NS_ALG_MD5RSA		1
+#define	NS_ALG_DH               2
+#define	NS_ALG_DSA              3
+#define	NS_ALG_DSS              NS_ALG_DSA
+#define	NS_ALG_EXPIRE_ONLY	253
+#define	NS_ALG_PRIVATE_OID	254
+
+#define NS_KEY_PROT_TLS         1
+#define NS_KEY_PROT_EMAIL       2
+#define NS_KEY_PROT_DNSSEC      3
+#define NS_KEY_PROT_IPSEC       4
+#define NS_KEY_PROT_ANY		255
+
+#define	NS_MD5RSA_MIN_BITS	 512
+#define	NS_MD5RSA_MAX_BITS	4096
+#define	NS_MD5RSA_MAX_BYTES	((NS_MD5RSA_MAX_BITS+7/8)*2+3)
+#define	NS_MD5RSA_MAX_BASE64	(((NS_MD5RSA_MAX_BYTES+2)/3)*4)
+#define NS_MD5RSA_MIN_SIZE	((NS_MD5RSA_MIN_BITS+7)/8)
+#define NS_MD5RSA_MAX_SIZE	((NS_MD5RSA_MAX_BITS+7)/8)
+
+#define NS_DSA_SIG_SIZE         41
+#define NS_DSA_MIN_SIZE         213
+#define NS_DSA_MAX_BYTES        405
+
+#define	NS_SIG_TYPE	0
+#define	NS_SIG_ALG	2
+#define	NS_SIG_LABELS	3
+#define	NS_SIG_OTTL	4
+#define	NS_SIG_EXPIR	8
+#define	NS_SIG_SIGNED	12
+#define	NS_SIG_FOOT	16
+#define	NS_SIG_SIGNER	18
+#define	NS_NXT_BITS 8
+#define	NS_NXT_BIT_SET(  n,p) (p[(n)/NS_NXT_BITS] |=  (0x80>>((n)%NS_NXT_BITS)))
+#define	NS_NXT_BIT_CLEAR(n,p) (p[(n)/NS_NXT_BITS] &= ~(0x80>>((n)%NS_NXT_BITS)))
+#define	NS_NXT_BIT_ISSET(n,p) (p[(n)/NS_NXT_BITS] &   (0x80>>((n)%NS_NXT_BITS)))
+#define NS_NXT_MAX 127
+
+#define NS_OPT_DNSSEC_OK        0x8000U
+#define NS_OPT_NSID		3
+
+#define NS_GET16(s, cp) (void)((s) = ns_get16(((cp)+=2)-2))
+#define NS_GET32(l, cp) (void)((l) = ns_get32(((cp)+=4)-4))
+#define NS_PUT16(s, cp) ns_put16((s), ((cp)+=2)-2)
+#define NS_PUT32(l, cp) ns_put32((l), ((cp)+=4)-4)
+
+unsigned ns_get16(const unsigned char *);
+unsigned long ns_get32(const unsigned char *);
+void ns_put16(unsigned, unsigned char *);
+void ns_put32(unsigned long, unsigned char *);
+
+int ns_initparse(const unsigned char *, int, ns_msg *);
+int ns_parserr(ns_msg *, ns_sect, int, ns_rr *);
+int ns_skiprr(const unsigned char *, const unsigned char *, ns_sect, int);
+int ns_name_uncompress(const unsigned char *, const unsigned char *, const unsigned char *, char *, size_t);
+
+
+#define	__BIND		19950621
+
+typedef struct {
+	unsigned	id :16;
+#if __BYTE_ORDER == __BIG_ENDIAN
+	unsigned	qr: 1;
+	unsigned	opcode: 4;
+	unsigned	aa: 1;
+	unsigned	tc: 1;
+	unsigned	rd: 1;
+	unsigned	ra: 1;
+	unsigned	unused :1;
+	unsigned	ad: 1;
+	unsigned	cd: 1;
+	unsigned	rcode :4;
+#else
+	unsigned	rd :1;
+	unsigned	tc :1;
+	unsigned	aa :1;
+	unsigned	opcode :4;
+	unsigned	qr :1;
+	unsigned	rcode :4;
+	unsigned	cd: 1;
+	unsigned	ad: 1;
+	unsigned	unused :1;
+	unsigned	ra :1;
+#endif
+	unsigned	qdcount :16;
+	unsigned	ancount :16;
+	unsigned	nscount :16;
+	unsigned	arcount :16;
+} HEADER;
+
+#define PACKETSZ	NS_PACKETSZ
+#define MAXDNAME	NS_MAXDNAME
+#define MAXCDNAME	NS_MAXCDNAME
+#define MAXLABEL	NS_MAXLABEL
+#define	HFIXEDSZ	NS_HFIXEDSZ
+#define QFIXEDSZ	NS_QFIXEDSZ
+#define RRFIXEDSZ	NS_RRFIXEDSZ
+#define	INT32SZ		NS_INT32SZ
+#define	INT16SZ		NS_INT16SZ
+#define INT8SZ		NS_INT8SZ
+#define	INADDRSZ	NS_INADDRSZ
+#define	IN6ADDRSZ	NS_IN6ADDRSZ
+#define	INDIR_MASK	NS_CMPRSFLGS
+#define NAMESERVER_PORT	NS_DEFAULTPORT
+
+#define S_ZONE		ns_s_zn
+#define S_PREREQ	ns_s_pr
+#define S_UPDATE	ns_s_ud
+#define S_ADDT		ns_s_ar
+
+#define QUERY		ns_o_query
+#define IQUERY		ns_o_iquery
+#define STATUS		ns_o_status
+#define	NS_NOTIFY_OP	ns_o_notify
+#define	NS_UPDATE_OP	ns_o_update
+
+#define NOERROR		ns_r_noerror
+#define FORMERR		ns_r_formerr
+#define SERVFAIL	ns_r_servfail
+#define NXDOMAIN	ns_r_nxdomain
+#define NOTIMP		ns_r_notimpl
+#define REFUSED		ns_r_refused
+#define YXDOMAIN	ns_r_yxdomain
+#define YXRRSET		ns_r_yxrrset
+#define NXRRSET		ns_r_nxrrset
+#define NOTAUTH		ns_r_notauth
+#define NOTZONE		ns_r_notzone
+
+#define DELETE		ns_uop_delete
+#define ADD		ns_uop_add
+
+#define T_A		ns_t_a
+#define T_NS		ns_t_ns
+#define T_MD		ns_t_md
+#define T_MF		ns_t_mf
+#define T_CNAME		ns_t_cname
+#define T_SOA		ns_t_soa
+#define T_MB		ns_t_mb
+#define T_MG		ns_t_mg
+#define T_MR		ns_t_mr
+#define T_NULL		ns_t_null
+#define T_WKS		ns_t_wks
+#define T_PTR		ns_t_ptr
+#define T_HINFO		ns_t_hinfo
+#define T_MINFO		ns_t_minfo
+#define T_MX		ns_t_mx
+#define T_TXT		ns_t_txt
+#define	T_RP		ns_t_rp
+#define T_AFSDB		ns_t_afsdb
+#define T_X25		ns_t_x25
+#define T_ISDN		ns_t_isdn
+#define T_RT		ns_t_rt
+#define T_NSAP		ns_t_nsap
+#define T_NSAP_PTR	ns_t_nsap_ptr
+#define	T_SIG		ns_t_sig
+#define	T_KEY		ns_t_key
+#define	T_PX		ns_t_px
+#define	T_GPOS		ns_t_gpos
+#define	T_AAAA		ns_t_aaaa
+#define	T_LOC		ns_t_loc
+#define	T_NXT		ns_t_nxt
+#define	T_EID		ns_t_eid
+#define	T_NIMLOC	ns_t_nimloc
+#define	T_SRV		ns_t_srv
+#define T_ATMA		ns_t_atma
+#define T_NAPTR		ns_t_naptr
+#define T_A6		ns_t_a6
+#define T_DNAME		ns_t_dname
+#define	T_TSIG		ns_t_tsig
+#define	T_IXFR		ns_t_ixfr
+#define T_AXFR		ns_t_axfr
+#define T_MAILB		ns_t_mailb
+#define T_MAILA		ns_t_maila
+#define T_ANY		ns_t_any
+
+#define C_IN		ns_c_in
+#define C_CHAOS		ns_c_chaos
+#define C_HS		ns_c_hs
+#define C_NONE		ns_c_none
+#define C_ANY		ns_c_any
+
+#define	GETSHORT		NS_GET16
+#define	GETLONG			NS_GET32
+#define	PUTSHORT		NS_PUT16
+#define	PUTLONG			NS_PUT32
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
diff --git a/third_party/musl/porting/liteos_m/kernel/include/arpa/nameser_compat.h b/third_party/musl/porting/liteos_m/kernel/include/arpa/nameser_compat.h
new file mode 100755
index 000000000..3aac25c98
--- /dev/null
+++ b/third_party/musl/porting/liteos_m/kernel/include/arpa/nameser_compat.h
@@ -0,0 +1,2 @@
+#include <arpa/nameser.h>
+
diff --git a/third_party/musl/porting/liteos_m/kernel/include/arpa/telnet.h b/third_party/musl/porting/liteos_m/kernel/include/arpa/telnet.h
new file mode 100755
index 000000000..e2ad97429
--- /dev/null
+++ b/third_party/musl/porting/liteos_m/kernel/include/arpa/telnet.h
@@ -0,0 +1,251 @@
+#ifndef _ARPA_TELNET_H
+#define	_ARPA_TELNET_H
+
+#define	IAC	255
+#define	DONT	254
+#define	DO	253
+#define	WONT	252
+#define	WILL	251
+#define	SB	250
+#define	GA	249
+#define	EL	248
+#define	EC	247
+#define	AYT	246
+#define	AO	245
+#define	IP	244
+#define	BREAK	243
+#define	DM	242
+#define	NOP	241
+#define	SE	240
+#define EOR     239
+#define	ABORT	238
+#define	SUSP	237
+#define	xEOF	236
+
+#define SYNCH	242
+
+#define telcmds ((char [][6]){ "EOF", "SUSP", "ABORT", "EOR", "SE", "NOP", "DMARK", "BRK", "IP", "AO", "AYT", "EC", "EL", "GA", "SB", "WILL", "WONT", "DO", "DONT", "IAC", 0 })
+
+#define	TELCMD_FIRST	xEOF
+#define	TELCMD_LAST	IAC
+#define	TELCMD_OK(x)	((unsigned int)(x) <= TELCMD_LAST && \
+			 (unsigned int)(x) >= TELCMD_FIRST)
+#define	TELCMD(x)	telcmds[(x)-TELCMD_FIRST]
+
+#define TELOPT_BINARY	0
+#define TELOPT_ECHO	1
+#define	TELOPT_RCP	2
+#define	TELOPT_SGA	3
+#define	TELOPT_NAMS	4
+#define	TELOPT_STATUS	5
+#define	TELOPT_TM	6
+#define	TELOPT_RCTE	7
+#define TELOPT_NAOL 	8
+#define TELOPT_NAOP 	9
+#define TELOPT_NAOCRD	10
+#define TELOPT_NAOHTS	11
+#define TELOPT_NAOHTD	12
+#define TELOPT_NAOFFD	13
+#define TELOPT_NAOVTS	14
+#define TELOPT_NAOVTD	15
+#define TELOPT_NAOLFD	16
+#define TELOPT_XASCII	17
+#define	TELOPT_LOGOUT	18
+#define	TELOPT_BM	19
+#define	TELOPT_DET	20
+#define	TELOPT_SUPDUP	21
+#define	TELOPT_SUPDUPOUTPUT 22
+#define	TELOPT_SNDLOC	23
+#define	TELOPT_TTYPE	24
+#define	TELOPT_EOR	25
+#define	TELOPT_TUID	26
+#define	TELOPT_OUTMRK	27
+#define	TELOPT_TTYLOC	28
+#define	TELOPT_3270REGIME 29
+#define	TELOPT_X3PAD	30
+#define	TELOPT_NAWS	31
+#define	TELOPT_TSPEED	32
+#define	TELOPT_LFLOW	33
+#define TELOPT_LINEMODE	34
+#define TELOPT_XDISPLOC	35
+#define TELOPT_OLD_ENVIRON 36
+#define	TELOPT_AUTHENTICATION 37/* Authenticate */
+#define	TELOPT_ENCRYPT	38
+#define TELOPT_NEW_ENVIRON 39
+#define	TELOPT_EXOPL	255
+
+
+#define	NTELOPTS	(1+TELOPT_NEW_ENVIRON)
+#ifdef TELOPTS
+char *telopts[NTELOPTS+1] = {
+	"BINARY", "ECHO", "RCP", "SUPPRESS GO AHEAD", "NAME",
+	"STATUS", "TIMING MARK", "RCTE", "NAOL", "NAOP",
+	"NAOCRD", "NAOHTS", "NAOHTD", "NAOFFD", "NAOVTS",
+	"NAOVTD", "NAOLFD", "EXTEND ASCII", "LOGOUT", "BYTE MACRO",
+	"DATA ENTRY TERMINAL", "SUPDUP", "SUPDUP OUTPUT",
+	"SEND LOCATION", "TERMINAL TYPE", "END OF RECORD",
+	"TACACS UID", "OUTPUT MARKING", "TTYLOC",
+	"3270 REGIME", "X.3 PAD", "NAWS", "TSPEED", "LFLOW",
+	"LINEMODE", "XDISPLOC", "OLD-ENVIRON", "AUTHENTICATION",
+	"ENCRYPT", "NEW-ENVIRON",
+	0,
+};
+#define	TELOPT_FIRST	TELOPT_BINARY
+#define	TELOPT_LAST	TELOPT_NEW_ENVIRON
+#define	TELOPT_OK(x)	((unsigned int)(x) <= TELOPT_LAST)
+#define	TELOPT(x)	telopts[(x)-TELOPT_FIRST]
+#endif
+
+#define	TELQUAL_IS	0
+#define	TELQUAL_SEND	1
+#define	TELQUAL_INFO	2
+#define	TELQUAL_REPLY	2
+#define	TELQUAL_NAME	3
+
+#define	LFLOW_OFF		0
+#define	LFLOW_ON		1
+#define	LFLOW_RESTART_ANY	2
+#define	LFLOW_RESTART_XON	3
+
+
+#define	LM_MODE		1
+#define	LM_FORWARDMASK	2
+#define	LM_SLC		3
+
+#define	MODE_EDIT	0x01
+#define	MODE_TRAPSIG	0x02
+#define	MODE_ACK	0x04
+#define MODE_SOFT_TAB	0x08
+#define MODE_LIT_ECHO	0x10
+
+#define	MODE_MASK	0x1f
+
+#define MODE_FLOW		0x0100
+#define MODE_ECHO		0x0200
+#define MODE_INBIN		0x0400
+#define MODE_OUTBIN		0x0800
+#define MODE_FORCE		0x1000
+
+#define	SLC_SYNCH	1
+#define	SLC_BRK		2
+#define	SLC_IP		3
+#define	SLC_AO		4
+#define	SLC_AYT		5
+#define	SLC_EOR		6
+#define	SLC_ABORT	7
+#define	SLC_EOF		8
+#define	SLC_SUSP	9
+#define	SLC_EC		10
+#define	SLC_EL		11
+#define	SLC_EW		12
+#define	SLC_RP		13
+#define	SLC_LNEXT	14
+#define	SLC_XON		15
+#define	SLC_XOFF	16
+#define	SLC_FORW1	17
+#define	SLC_FORW2	18
+
+#define	NSLC		18
+
+#define	SLC_NAMELIST	"0", "SYNCH", "BRK", "IP", "AO", "AYT", "EOR", \
+			"ABORT", "EOF", "SUSP", "EC", "EL", "EW", "RP", \
+			"LNEXT", "XON", "XOFF", "FORW1", "FORW2", 0,
+#ifdef	SLC_NAMES
+char *slc_names[] = {
+	SLC_NAMELIST
+};
+#else
+extern char *slc_names[];
+#define	SLC_NAMES SLC_NAMELIST
+#endif
+
+#define	SLC_NAME_OK(x)	((unsigned int)(x) <= NSLC)
+#define SLC_NAME(x)	slc_names[x]
+
+#define	SLC_NOSUPPORT	0
+#define	SLC_CANTCHANGE	1
+#define	SLC_VARIABLE	2
+#define	SLC_DEFAULT	3
+#define	SLC_LEVELBITS	0x03
+
+#define	SLC_FUNC	0
+#define	SLC_FLAGS	1
+#define	SLC_VALUE	2
+
+#define	SLC_ACK		0x80
+#define	SLC_FLUSHIN	0x40
+#define	SLC_FLUSHOUT	0x20
+
+#define	OLD_ENV_VAR	1
+#define	OLD_ENV_VALUE	0
+#define	NEW_ENV_VAR	0
+#define	NEW_ENV_VALUE	1
+#define	ENV_ESC		2
+#define ENV_USERVAR	3
+
+#define	AUTH_WHO_CLIENT		0
+#define	AUTH_WHO_SERVER		1
+#define	AUTH_WHO_MASK		1
+
+#define	AUTH_HOW_ONE_WAY	0
+#define	AUTH_HOW_MUTUAL		2
+#define	AUTH_HOW_MASK		2
+
+#define	AUTHTYPE_NULL		0
+#define	AUTHTYPE_KERBEROS_V4	1
+#define	AUTHTYPE_KERBEROS_V5	2
+#define	AUTHTYPE_SPX		3
+#define	AUTHTYPE_MINK		4
+#define	AUTHTYPE_CNT		5
+
+#define	AUTHTYPE_TEST		99
+
+#ifdef	AUTH_NAMES
+char *authtype_names[] = {
+	"NULL", "KERBEROS_V4", "KERBEROS_V5", "SPX", "MINK", 0,
+};
+#else
+extern char *authtype_names[];
+#endif
+
+#define	AUTHTYPE_NAME_OK(x)	((unsigned int)(x) < AUTHTYPE_CNT)
+#define	AUTHTYPE_NAME(x)	authtype_names[x]
+
+#define	ENCRYPT_IS		0
+#define	ENCRYPT_SUPPORT		1
+#define	ENCRYPT_REPLY		2
+#define	ENCRYPT_START		3
+#define	ENCRYPT_END		4
+#define	ENCRYPT_REQSTART	5
+#define	ENCRYPT_REQEND		6
+#define	ENCRYPT_ENC_KEYID	7
+#define	ENCRYPT_DEC_KEYID	8
+#define	ENCRYPT_CNT		9
+
+#define	ENCTYPE_ANY		0
+#define	ENCTYPE_DES_CFB64	1
+#define	ENCTYPE_DES_OFB64	2
+#define	ENCTYPE_CNT		3
+
+#ifdef	ENCRYPT_NAMES
+char *encrypt_names[] = {
+	"IS", "SUPPORT", "REPLY", "START", "END",
+	"REQUEST-START", "REQUEST-END", "ENC-KEYID", "DEC-KEYID",
+	0,
+};
+char *enctype_names[] = {
+	"ANY", "DES_CFB64",  "DES_OFB64",  0,
+};
+#else
+extern char *encrypt_names[];
+extern char *enctype_names[];
+#endif
+
+
+#define	ENCRYPT_NAME_OK(x)	((unsigned int)(x) < ENCRYPT_CNT)
+#define	ENCRYPT_NAME(x)		encrypt_names[x]
+
+#define	ENCTYPE_NAME_OK(x)	((unsigned int)(x) < ENCTYPE_CNT)
+#define	ENCTYPE_NAME(x)		enctype_names[x]
+
+#endif
diff --git a/third_party/musl/porting/liteos_m/kernel/include/arpa/tftp.h b/third_party/musl/porting/liteos_m/kernel/include/arpa/tftp.h
new file mode 100755
index 000000000..799c54f22
--- /dev/null
+++ b/third_party/musl/porting/liteos_m/kernel/include/arpa/tftp.h
@@ -0,0 +1,31 @@
+#ifndef _ARPA_TFTP_H
+#define _ARPA_TFTP_H
+#define SEGSIZE 512
+#define RRQ 01
+#define WRQ 02
+#define DATA 03
+#define ACK 04
+#define ERROR 05
+struct tftphdr {
+	short th_opcode;
+	union {
+		unsigned short tu_block;
+		short tu_code;
+		char tu_stuff[1];
+	} th_u;
+	char th_data[1];
+};
+#define th_block th_u.tu_block
+#define th_code th_u.tu_code
+#define th_stuff th_u.tu_stuff
+#define th_msg th_data
+#define EUNDEF 0
+#define ENOTFOUND 1
+#define EACCESS 2
+#define ENOSPACE 3
+#define EBADOP 4
+#define EBADID 5
+#define EEXISTS 6
+#define ENOUSER 7
+#endif
+
diff --git a/third_party/musl/porting/liteos_m/kernel/include/assert.h b/third_party/musl/porting/liteos_m/kernel/include/assert.h
new file mode 100755
index 000000000..a9bfa7d56
--- /dev/null
+++ b/third_party/musl/porting/liteos_m/kernel/include/assert.h
@@ -0,0 +1,28 @@
+#ifdef __ICCARM__ /* for iar */
+#include_next <assert.h>
+#else
+#include <features.h>
+
+#undef assert
+
+#ifdef NDEBUG
+#define	assert(x) (void)0
+#else
+#define assert(x) ((void)((x) || (__assert_fail(#x, __FILE__, __LINE__, __func__),0)))
+#endif
+
+#if __STDC_VERSION__ >= 201112L && !defined(__cplusplus)
+#define static_assert _Static_assert
+#endif
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+_Noreturn void __assert_fail (const char *, const char *, int, const char *);
+
+#ifdef __cplusplus
+}
+
+#endif /* __ICCARM__ */
+#endif
diff --git a/third_party/musl/porting/liteos_m/kernel/include/bits/alltypes.h b/third_party/musl/porting/liteos_m/kernel/include/bits/alltypes.h
new file mode 100755
index 000000000..e4c5af789
--- /dev/null
+++ b/third_party/musl/porting/liteos_m/kernel/include/bits/alltypes.h
@@ -0,0 +1,591 @@
+/* The time64 has not been used yet in liteos_m */
+#define _REDIR_TIME64 0
+#define _Addr int
+#define _Int64 long long
+#define _Reg int
+
+#ifdef __ARMEB__
+#define __BYTE_ORDER 4321
+#else
+#define __BYTE_ORDER 1234
+#endif
+
+#define __LONG_MAX 0x7fffffffL
+
+#ifdef __ICCARM__
+#ifndef __cplusplus
+#if defined(__NEED_wchar_t) && !defined(__DEFINED_wchar_t)
+#include <stddef.h>
+#define __DEFINED_wchar_t
+#endif
+#endif
+
+#if defined(__NEED_float_t) && !defined(__DEFINED_float_t)
+#include <math.h>
+#define __DEFINED_float_t
+#endif
+
+#if defined(__NEED_double_t) && !defined(__DEFINED_double_t)
+#include <math.h>
+#define __DEFINED_double_t
+#endif
+
+#if defined(__NEED_max_align_t) && !defined(__DEFINED_max_align_t)
+#include <stddef.h>
+#define __DEFINED_max_align_t
+#endif
+#endif /* __ICCARM__ */
+
+#ifndef __cplusplus
+#if defined(__NEED_wchar_t) && !defined(__DEFINED_wchar_t)
+typedef unsigned wchar_t;
+#define __DEFINED_wchar_t
+#endif
+
+#endif
+
+#if defined(__NEED_float_t) && !defined(__DEFINED_float_t)
+typedef float float_t;
+#define __DEFINED_float_t
+#endif
+
+#if defined(__NEED_double_t) && !defined(__DEFINED_double_t)
+typedef double double_t;
+#define __DEFINED_double_t
+#endif
+
+
+#if defined(__NEED_max_align_t) && !defined(__DEFINED_max_align_t)
+typedef struct { long long __ll; long double __ld; } max_align_t;
+#define __DEFINED_max_align_t
+#endif
+
+#define __LITTLE_ENDIAN 1234
+#define __BIG_ENDIAN 4321
+#define __USE_TIME_BITS64 1
+
+#ifdef __ICCARM__
+#if defined(__NEED_size_t) && !defined(__DEFINED_size_t)
+#include <stddef.h>
+#define __DEFINED_size_t
+#endif
+
+#if defined(__NEED_uintptr_t) && !defined(__DEFINED_uintptr_t)
+#include <stdint.h>
+#define __DEFINED_uintptr_t
+#endif
+
+#if defined(__NEED_ptrdiff_t) && !defined(__DEFINED_ptrdiff_t)
+#include <stddef.h>
+#define __DEFINED_ptrdiff_t
+#endif
+
+#if defined(__NEED_intptr_t) && !defined(__DEFINED_intptr_t)
+#include <stdint.h>
+#define __DEFINED_intptr_t
+#endif
+
+#if defined(__NEED_time_t) && !defined(__DEFINED_time_t)
+#include <time.h>
+#define __DEFINED_time_t
+#endif
+
+#if defined(__NEED_clock_t) && !defined(__DEFINED_clock_t)
+#include <time.h>
+#define __DEFINED_clock_t
+#endif
+
+#if defined(__NEED_struct_timespec) && !defined(__DEFINED_struct_timespec)
+#include <time.h>
+#define __DEFINED_struct_timespec
+#endif
+
+#if defined(__NEED_wint_t) && !defined(__DEFINED_wint_t)
+#include <wchar.h>
+#define __DEFINED_wint_t
+#endif
+
+#if defined(__NEED_wctype_t) && !defined(__DEFINED_wctype_t)
+#include <wchar.h>
+#define __DEFINED_wctype_t
+#endif
+
+#if defined(__NEED_va_list) && !defined(__DEFINED_va_list)
+#include <stdarg.h>
+#define __DEFINED_va_list
+#endif
+
+#if defined(__NEED_mbstate_t) && !defined(__DEFINED_mbstate_t)
+#include <wchar.h>
+#define __DEFINED_mbstate_t
+#endif
+
+#if defined(__NEED_int8_t) && !defined(__DEFINED_int8_t) && defined(__INT8_T_TYPE__)
+#include <stdint.h>
+#define __DEFINED_int8_t
+#endif
+
+#if defined(__NEED_int16_t) && !defined(__DEFINED_int16_t) && defined(__INT16_T_TYPE__)
+#include <stdint.h>
+#define __DEFINED_int16_t
+#endif
+
+#if defined(__NEED_int32_t) && !defined(__DEFINED_int32_t) && defined(__INT32_T_TYPE__)
+#include <stdint.h>
+#define __DEFINED_int32_t
+#endif
+
+#if defined(__NEED_int64_t) && !defined(__DEFINED_int64_t) && defined(__INT64_T_TYPE__)
+#include <stdint.h>
+#define __DEFINED_int64_t
+#endif
+
+#if defined(__NEED_uint8_t) && !defined(__DEFINED_uint8_t) && defined(__UINT8_T_TYPE__)
+#include <stdint.h>
+#define __DEFINED_uint8_t
+#endif
+
+#if defined(__NEED_uint16_t) && !defined(__DEFINED_uint16_t) && defined(__UINT16_T_TYPE__)
+#include <stdint.h>
+#define __DEFINED_uint16_t
+#endif
+
+#if defined(__NEED_uint32_t) && !defined(__DEFINED_uint32_t) && defined(__UINT32_T_TYPE__)
+#include <stdint.h>
+#define __DEFINED_uint32_t
+#endif
+
+#if defined(__NEED_uint64_t) && !defined(__DEFINED_uint64_t) && defined(__UINT64_T_TYPE__)
+#include <stdint.h>
+#define __DEFINED_uint64_t
+#endif
+
+#if defined(__NEED_intmax_t) && !defined(__DEFINED_intmax_t)
+#include <stdint.h>
+#define __DEFINED_intmax_t
+#endif
+
+#if defined(__NEED_uintmax_t) && !defined(__DEFINED_uintmax_t)
+#include <stdint.h>
+#define __DEFINED_uintmax_t
+#endif
+#endif /* __ICCARM__ */
+
+#if defined(__NEED_size_t) && !defined(__DEFINED_size_t)
+typedef unsigned _Addr size_t;
+#define __DEFINED_size_t
+#endif
+
+#if defined(__NEED_uintptr_t) && !defined(__DEFINED_uintptr_t)
+typedef unsigned _Addr uintptr_t;
+#define __DEFINED_uintptr_t
+#endif
+
+#if defined(__NEED_ptrdiff_t) && !defined(__DEFINED_ptrdiff_t)
+typedef _Addr ptrdiff_t;
+#define __DEFINED_ptrdiff_t
+#endif
+
+#if defined(__NEED_ssize_t) && !defined(__DEFINED_ssize_t)
+typedef _Addr ssize_t;
+#define __DEFINED_ssize_t
+#endif
+
+#if defined(__NEED_intptr_t) && !defined(__DEFINED_intptr_t)
+typedef _Addr intptr_t;
+#define __DEFINED_intptr_t
+#endif
+
+#if defined(__NEED_regoff_t) && !defined(__DEFINED_regoff_t)
+typedef _Addr regoff_t;
+#define __DEFINED_regoff_t
+#endif
+
+#if defined(__NEED_register_t) && !defined(__DEFINED_register_t)
+typedef _Reg register_t;
+#define __DEFINED_register_t
+#endif
+
+#if defined(__NEED_time_t) && !defined(__DEFINED_time_t)
+typedef _Int64 time_t;
+#define __DEFINED_time_t
+#endif
+
+#if defined(__NEED_suseconds_t) && !defined(__DEFINED_suseconds_t)
+typedef _Int64 suseconds_t;
+#define __DEFINED_suseconds_t
+#endif
+
+
+#if defined(__NEED_int8_t) && !defined(__DEFINED_int8_t)
+typedef signed char     int8_t;
+#define __DEFINED_int8_t
+#endif
+
+#if defined(__NEED_int16_t) && !defined(__DEFINED_int16_t)
+typedef signed short    int16_t;
+#define __DEFINED_int16_t
+#endif
+
+#if defined(__NEED_int32_t) && !defined(__DEFINED_int32_t)
+typedef signed int      int32_t;
+#define __DEFINED_int32_t
+#endif
+
+#if defined(__NEED_int64_t) && !defined(__DEFINED_int64_t)
+typedef signed _Int64   int64_t;
+#define __DEFINED_int64_t
+#endif
+
+#if defined(__NEED_intmax_t) && !defined(__DEFINED_intmax_t)
+typedef signed _Int64   intmax_t;
+#define __DEFINED_intmax_t
+#endif
+
+#if defined(__NEED_uint8_t) && !defined(__DEFINED_uint8_t)
+typedef unsigned char   uint8_t;
+#define __DEFINED_uint8_t
+#endif
+
+#if defined(__NEED_uint16_t) && !defined(__DEFINED_uint16_t)
+typedef unsigned short  uint16_t;
+#define __DEFINED_uint16_t
+#endif
+
+#if defined(__NEED_uint32_t) && !defined(__DEFINED_uint32_t)
+typedef unsigned int    uint32_t;
+#define __DEFINED_uint32_t
+#endif
+
+#if defined(__NEED_uint64_t) && !defined(__DEFINED_uint64_t)
+typedef unsigned _Int64 uint64_t;
+#define __DEFINED_uint64_t
+#endif
+
+#if defined(__NEED_u_int64_t) && !defined(__DEFINED_u_int64_t)
+typedef unsigned _Int64 u_int64_t;
+#define __DEFINED_u_int64_t
+#endif
+
+#if defined(__NEED_uintmax_t) && !defined(__DEFINED_uintmax_t)
+typedef unsigned _Int64 uintmax_t;
+#define __DEFINED_uintmax_t
+#endif
+
+
+#if defined(__NEED_mode_t) && !defined(__DEFINED_mode_t)
+typedef unsigned mode_t;
+#define __DEFINED_mode_t
+#endif
+
+#if defined(__NEED_nlink_t) && !defined(__DEFINED_nlink_t)
+typedef unsigned _Reg nlink_t;
+#define __DEFINED_nlink_t
+#endif
+
+#if defined(__NEED_off_t) && !defined(__DEFINED_off_t)
+typedef _Int64 off_t;
+#define __DEFINED_off_t
+#endif
+
+#if defined(__NEED_ino_t) && !defined(__DEFINED_ino_t)
+typedef unsigned _Int64 ino_t;
+#define __DEFINED_ino_t
+#endif
+
+#if defined(__NEED_dev_t) && !defined(__DEFINED_dev_t)
+typedef unsigned _Int64 dev_t;
+#define __DEFINED_dev_t
+#endif
+
+#if defined(__NEED_blksize_t) && !defined(__DEFINED_blksize_t)
+typedef long blksize_t;
+#define __DEFINED_blksize_t
+#endif
+
+#if defined(__NEED_blkcnt_t) && !defined(__DEFINED_blkcnt_t)
+typedef _Int64 blkcnt_t;
+#define __DEFINED_blkcnt_t
+#endif
+
+#if defined(__NEED_fsblkcnt_t) && !defined(__DEFINED_fsblkcnt_t)
+typedef unsigned _Int64 fsblkcnt_t;
+#define __DEFINED_fsblkcnt_t
+#endif
+
+#if defined(__NEED_fsfilcnt_t) && !defined(__DEFINED_fsfilcnt_t)
+typedef unsigned _Int64 fsfilcnt_t;
+#define __DEFINED_fsfilcnt_t
+#endif
+
+
+#if defined(__NEED_wint_t) && !defined(__DEFINED_wint_t)
+typedef unsigned wint_t;
+#define __DEFINED_wint_t
+#endif
+
+#if defined(__NEED_wctype_t) && !defined(__DEFINED_wctype_t)
+typedef unsigned long wctype_t;
+#define __DEFINED_wctype_t
+#endif
+
+
+#if defined(__NEED_timer_t) && !defined(__DEFINED_timer_t)
+typedef void * timer_t;
+#define __DEFINED_timer_t
+#endif
+
+#if defined(__NEED_clockid_t) && !defined(__DEFINED_clockid_t)
+typedef int clockid_t;
+#define __DEFINED_clockid_t
+#endif
+
+#if defined(__NEED_clock_t) && !defined(__DEFINED_clock_t)
+typedef long clock_t;
+#define __DEFINED_clock_t
+#endif
+
+#if defined(__NEED_struct_timeval) && !defined(__DEFINED_struct_timeval)
+struct timeval { time_t tv_sec; suseconds_t tv_usec; };
+#define __DEFINED_struct_timeval
+#endif
+
+#if defined(__NEED_struct_timespec) && !defined(__DEFINED_struct_timespec)
+struct timespec { time_t tv_sec; int :8*(sizeof(time_t)-sizeof(long))*(__BYTE_ORDER==4321); long tv_nsec; int :8*(sizeof(time_t)-sizeof(long))*(__BYTE_ORDER!=4321); };
+#define __DEFINED_struct_timespec
+#endif
+
+
+#if defined(__NEED_pid_t) && !defined(__DEFINED_pid_t)
+typedef int pid_t;
+#define __DEFINED_pid_t
+#endif
+
+#if defined(__NEED_id_t) && !defined(__DEFINED_id_t)
+typedef unsigned id_t;
+#define __DEFINED_id_t
+#endif
+
+#if defined(__NEED_uid_t) && !defined(__DEFINED_uid_t)
+typedef unsigned uid_t;
+#define __DEFINED_uid_t
+#endif
+
+#if defined(__NEED_gid_t) && !defined(__DEFINED_gid_t)
+typedef unsigned gid_t;
+#define __DEFINED_gid_t
+#endif
+
+#if defined(__NEED_key_t) && !defined(__DEFINED_key_t)
+typedef int key_t;
+#define __DEFINED_key_t
+#endif
+
+#if defined(__NEED_useconds_t) && !defined(__DEFINED_useconds_t)
+typedef unsigned useconds_t;
+#define __DEFINED_useconds_t
+#endif
+
+
+#ifdef __cplusplus
+#if defined(__NEED_pthread_t) && !defined(__DEFINED_pthread_t)
+typedef unsigned long pthread_t;
+#define __DEFINED_pthread_t
+#endif
+
+#else
+#if defined(__NEED_pthread_t) && !defined(__DEFINED_pthread_t)
+typedef struct __pthread * pthread_t;
+#define __DEFINED_pthread_t
+#endif
+
+#endif
+#if defined(__NEED_pthread_once_t) && !defined(__DEFINED_pthread_once_t)
+typedef int pthread_once_t;
+#define __DEFINED_pthread_once_t
+#endif
+
+#if defined(__NEED_pthread_key_t) && !defined(__DEFINED_pthread_key_t)
+typedef unsigned pthread_key_t;
+#define __DEFINED_pthread_key_t
+#endif
+
+#if defined(__NEED_pthread_spinlock_t) && !defined(__DEFINED_pthread_spinlock_t)
+typedef int pthread_spinlock_t;
+#define __DEFINED_pthread_spinlock_t
+#endif
+
+#if defined(__NEED_pthread_mutexattr_t) && !defined(__DEFINED_pthread_mutexattr_t)
+typedef struct { unsigned __attr; } pthread_mutexattr_t;
+#define __DEFINED_pthread_mutexattr_t
+#endif
+
+#if defined(__NEED_pthread_condattr_t) && !defined(__DEFINED_pthread_condattr_t)
+typedef struct { unsigned __attr; } pthread_condattr_t;
+#define __DEFINED_pthread_condattr_t
+#endif
+
+#if defined(__NEED_pthread_barrierattr_t) && !defined(__DEFINED_pthread_barrierattr_t)
+typedef struct { unsigned __attr; } pthread_barrierattr_t;
+#define __DEFINED_pthread_barrierattr_t
+#endif
+
+#if defined(__NEED_pthread_rwlockattr_t) && !defined(__DEFINED_pthread_rwlockattr_t)
+typedef struct { unsigned __attr[2]; } pthread_rwlockattr_t;
+#define __DEFINED_pthread_rwlockattr_t
+#endif
+
+
+#if defined(__NEED_struct__IO_FILE) && !defined(__DEFINED_struct__IO_FILE)
+struct _IO_FILE {
+  unsigned flags;
+  unsigned char *rpos, *rend;
+  int (*close)(struct _IO_FILE *);
+  unsigned char *wend, *wpos;
+  unsigned char *mustbezero_1;
+  unsigned char *wbase;
+  size_t (*read)(struct _IO_FILE *, unsigned char *, size_t);
+  size_t (*write)(struct _IO_FILE *, const unsigned char *, size_t);
+  off_t (*seek)(struct _IO_FILE *, off_t, int);
+  unsigned char *buf;
+  size_t buf_size;
+  struct _IO_FILE *prev, *next;
+  int fd;
+  int pipe_pid;
+  int mode;
+  void *lock;
+  int lbf;
+  void *cookie;
+  off_t off;
+  char *getln_buf;
+  void *mustbezero_2;
+  unsigned char *shend;
+  off_t shlim, shcnt;
+  struct __locale_struct *locale;
+};
+#define __DEFINED_struct__IO_FILE
+#endif
+
+#if defined(__NEED_FILE) && !defined(__DEFINED_FILE)
+typedef struct _IO_FILE FILE;
+#define __DEFINED_FILE
+#endif
+
+
+#if defined(__NEED_va_list) && !defined(__DEFINED_va_list)
+typedef __builtin_va_list va_list;
+#define __DEFINED_va_list
+#endif
+
+#if defined(__NEED___isoc_va_list) && !defined(__DEFINED___isoc_va_list)
+typedef __builtin_va_list __isoc_va_list;
+#define __DEFINED___isoc_va_list
+#endif
+
+
+#if defined(__NEED_mbstate_t) && !defined(__DEFINED_mbstate_t)
+typedef struct __mbstate_t { unsigned __opaque1, __opaque2; } mbstate_t;
+#define __DEFINED_mbstate_t
+#endif
+
+
+#if defined(__NEED_locale_t) && !defined(__DEFINED_locale_t)
+typedef struct __locale_struct * locale_t;
+#define __DEFINED_locale_t
+#endif
+
+
+#if defined(__NEED_sigset_t) && !defined(__DEFINED_sigset_t)
+typedef struct __sigset_t { unsigned long __bits[128/sizeof(long)]; } sigset_t;
+#define __DEFINED_sigset_t
+#endif
+
+
+#if defined(__NEED_struct_iovec) && !defined(__DEFINED_struct_iovec)
+struct iovec { void *iov_base; size_t iov_len; };
+#define __DEFINED_struct_iovec
+#endif
+
+
+#if defined(__NEED_socklen_t) && !defined(__DEFINED_socklen_t)
+typedef unsigned socklen_t;
+#define __DEFINED_socklen_t
+#endif
+
+#if defined(__NEED_sa_family_t) && !defined(__DEFINED_sa_family_t)
+typedef unsigned short sa_family_t;
+#define __DEFINED_sa_family_t
+#endif
+
+#if (defined(__NEED_sched_param) || defined(__NEED_pthread_attr_t)) && !defined(__DEFINED_sched_param)
+struct sched_param {
+    int sched_priority;
+    int __reserved1;
+#if _REDIR_TIME64
+    long __reserved2[4];
+#else
+    struct {
+        time_t __reserved1;
+        long __reserved2;
+    } __reserved2[2];
+#endif
+    int __reserved3;
+};
+#define __DEFINED_sched_param
+#endif
+
+#if defined(__NEED_pthread_attr_t) && !defined(__DEFINED_pthread_attr_t)
+typedef struct {
+    unsigned int detachstate;
+    unsigned int schedpolicy;
+    struct sched_param schedparam;
+    unsigned int inheritsched;
+    unsigned int scope;
+    unsigned int stackaddr_set;
+    void *stackaddr;
+    unsigned int stacksize_set;
+    size_t stacksize;
+} pthread_attr_t;
+#define __DEFINED_pthread_attr_t
+#endif
+
+#if defined(__NEED_pthread_mutex_t) && !defined(__DEFINED_pthread_mutex_t)
+typedef struct { unsigned int magic; unsigned int handle; } pthread_mutex_t;
+#define __DEFINED_pthread_mutex_t
+#endif
+
+#if defined(__NEED_mtx_t) && !defined(__DEFINED_mtx_t)
+typedef struct { union { int __i[sizeof(long)==8?10:6]; volatile int __vi[sizeof(long)==8?10:6]; volatile void *volatile __p[sizeof(long)==8?5:6]; } __u; } mtx_t;
+#define __DEFINED_mtx_t
+#endif
+
+#if defined(__NEED_pthread_cond_t) && !defined(__DEFINED_pthread_cond_t)
+#include "los_event.h"
+typedef struct pthread_cond {
+  volatile int count;      /**< The number of tasks blocked by condition */
+  EVENT_CB_S event;        /**< Event object*/
+  pthread_mutex_t* mutex;  /**< Mutex locker for condition variable protection */
+  volatile int value;      /**< Condition variable state value*/
+} pthread_cond_t;
+#define __DEFINED_pthread_cond_t
+#endif
+
+#if defined(__NEED_cnd_t) && !defined(__DEFINED_cnd_t)
+typedef struct { union { int __i[12]; volatile int __vi[12]; void *__p[12*sizeof(int)/sizeof(void*)]; } __u; } cnd_t;
+#define __DEFINED_cnd_t
+#endif
+
+#if defined(__NEED_pthread_rwlock_t) && !defined(__DEFINED_pthread_rwlock_t)
+typedef struct { union { int __i[sizeof(long)==8?14:8]; volatile int __vi[sizeof(long)==8?14:8]; void *__p[sizeof(long)==8?7:8]; } __u; } pthread_rwlock_t;
+#define __DEFINED_pthread_rwlock_t
+#endif
+
+#if defined(__NEED_pthread_barrier_t) && !defined(__DEFINED_pthread_barrier_t)
+typedef struct { union { int __i[sizeof(long)==8?8:5]; volatile int __vi[sizeof(long)==8?8:5]; void *__p[sizeof(long)==8?4:5]; } __u; } pthread_barrier_t;
+#define __DEFINED_pthread_barrier_t
+#endif
+
+
+#undef _Addr
+#undef _Int64
+#undef _Reg
diff --git a/third_party/musl/porting/liteos_m/kernel/include/bits/dirent.h b/third_party/musl/porting/liteos_m/kernel/include/bits/dirent.h
new file mode 100755
index 000000000..c845fe82d
--- /dev/null
+++ b/third_party/musl/porting/liteos_m/kernel/include/bits/dirent.h
@@ -0,0 +1,11 @@
+#define _DIRENT_HAVE_D_RECLEN
+#define _DIRENT_HAVE_D_OFF
+#define _DIRENT_HAVE_D_TYPE
+
+struct dirent {
+	ino_t d_ino;
+	off_t d_off;
+	unsigned short d_reclen;
+	unsigned char d_type;
+	char d_name[256];
+};
diff --git a/third_party/musl/porting/liteos_m/kernel/include/bits/errno.h b/third_party/musl/porting/liteos_m/kernel/include/bits/errno.h
new file mode 100755
index 000000000..4b1b0954f
--- /dev/null
+++ b/third_party/musl/porting/liteos_m/kernel/include/bits/errno.h
@@ -0,0 +1,135 @@
+#define ENOERR           0
+#define EPERM            1
+#define ENOENT           2
+#define ESRCH            3
+#define EINTR            4
+#define EIO              5
+#define ENXIO            6
+#define E2BIG            7
+#define ENOEXEC          8
+#define EBADF            9
+#define ECHILD          10
+#define EAGAIN          11
+#define ENOMEM          12
+#define EACCES          13
+#define EFAULT          14
+#define ENOTBLK         15
+#define EBUSY           16
+#define EEXIST          17
+#define EXDEV           18
+#define ENODEV          19
+#define ENOTDIR         20
+#define EISDIR          21
+#define EINVAL          22
+#define ENFILE          23
+#define EMFILE          24
+#define ENOTTY          25
+#define ETXTBSY         26
+#define EFBIG           27
+#define ENOSPC          28
+#define ESPIPE          29
+#define EROFS           30
+#define EMLINK          31
+#define EPIPE           32
+#define EDOM            33
+#define ERANGE          34
+#define EDEADLK         35
+#define ENAMETOOLONG    36
+#define ENOLCK          37
+#define ENOSYS          38
+#define ENOTEMPTY       39
+#define ELOOP           40
+#define EWOULDBLOCK     EAGAIN
+#define ENOMSG          42
+#define EIDRM           43
+#define ECHRNG          44
+#define EL2NSYNC        45
+#define EL3HLT          46
+#define EL3RST          47
+#define ELNRNG          48
+#define EUNATCH         49
+#define ENOCSI          50
+#define EL2HLT          51
+#define EBADE           52
+#define EBADR           53
+#define EXFULL          54
+#define ENOANO          55
+#define EBADRQC         56
+#define EBADSLT         57
+#define EDEADLOCK       EDEADLK
+#define EBFONT          59
+#define ENOSTR          60
+#define ENODATA         61
+#define ETIME           62
+#define ENOSR           63
+#define ENONET          64
+#define ENOPKG          65
+#define EREMOTE         66
+#define ENOLINK         67
+#define EADV            68
+#define ESRMNT          69
+#define ECOMM           70
+#define EPROTO          71
+#define EMULTIHOP       72
+#define EDOTDOT         73
+#define EBADMSG         74
+#define EOVERFLOW       75
+#define ENOTUNIQ        76
+#define EBADFD          77
+#define EREMCHG         78
+#define ELIBACC         79
+#define ELIBBAD         80
+#define ELIBSCN         81
+#define ELIBMAX         82
+#define ELIBEXEC        83
+#define EILSEQ          84
+#define ERESTART        85
+#define ESTRPIPE        86
+#define EUSERS          87
+#define ENOTSOCK        88
+#define EDESTADDRREQ    89
+#define EMSGSIZE        90
+#define EPROTOTYPE      91
+#define ENOPROTOOPT     92
+#define EPROTONOSUPPORT 93
+#define ESOCKTNOSUPPORT 94
+#define EOPNOTSUPP      95
+#define ENOTSUP         EOPNOTSUPP
+#define EPFNOSUPPORT    96
+#define EAFNOSUPPORT    97
+#define EADDRINUSE      98
+#define EADDRNOTAVAIL   99
+#define ENETDOWN        100
+#define ENETUNREACH     101
+#define ENETRESET       102
+#define ECONNABORTED    103
+#define ECONNRESET      104
+#define ENOBUFS         105
+#define EISCONN         106
+#define ENOTCONN        107
+#define ESHUTDOWN       108
+#define ETOOMANYREFS    109
+#define ETIMEDOUT       110
+#define ECONNREFUSED    111
+#define EHOSTDOWN       112
+#define EHOSTUNREACH    113
+#define EALREADY        114
+#define EINPROGRESS     115
+#define ESTALE          116
+#define EUCLEAN         117
+#define ENOTNAM         118
+#define ENAVAIL         119
+#define EISNAM          120
+#define EREMOTEIO       121
+#define EDQUOT          122
+#define ENOMEDIUM       123
+#define EMEDIUMTYPE     124
+#define ECANCELED       125
+#define ENOKEY          126
+#define EKEYEXPIRED     127
+#define EKEYREVOKED     128
+#define EKEYREJECTED    129
+#define EOWNERDEAD      130
+#define ENOTRECOVERABLE 131
+#define ERFKILL         132
+#define EHWPOISON       133
diff --git a/third_party/musl/porting/liteos_m/kernel/include/bits/fcntl.h b/third_party/musl/porting/liteos_m/kernel/include/bits/fcntl.h
new file mode 100755
index 000000000..4cb1753b7
--- /dev/null
+++ b/third_party/musl/porting/liteos_m/kernel/include/bits/fcntl.h
@@ -0,0 +1,40 @@
+#define O_CREAT        0100
+#define O_EXCL         0200
+#define O_NOCTTY       0400
+#define O_TRUNC       01000
+#define O_APPEND      02000
+#define O_NONBLOCK    04000
+#define O_DSYNC      010000
+#define O_SYNC     04010000
+#define O_RSYNC    04010000
+#define O_DIRECTORY  040000
+#define O_NOFOLLOW  0100000
+#define O_CLOEXEC  02000000
+
+#define O_ASYNC      020000
+#define O_DIRECT    0200000
+#define O_LARGEFILE 0400000
+#define O_NOATIME  01000000
+#define O_PATH    010000000
+#define O_TMPFILE 020040000
+#define O_NDELAY O_NONBLOCK
+
+#define F_DUPFD  0
+#define F_GETFD  1
+#define F_SETFD  2
+#define F_GETFL  3
+#define F_SETFL  4
+
+#define F_SETOWN 8
+#define F_GETOWN 9
+#define F_SETSIG 10
+#define F_GETSIG 11
+
+#define F_GETLK 12
+#define F_SETLK 13
+#define F_SETLKW 14
+
+#define F_SETOWN_EX 15
+#define F_GETOWN_EX 16
+
+#define F_GETOWNER_UIDS 17
diff --git a/third_party/musl/porting/liteos_m/kernel/include/bits/fenv.h b/third_party/musl/porting/liteos_m/kernel/include/bits/fenv.h
new file mode 100755
index 000000000..d85fc86d7
--- /dev/null
+++ b/third_party/musl/porting/liteos_m/kernel/include/bits/fenv.h
@@ -0,0 +1,23 @@
+#ifndef __ARM_PCS_VFP
+#define FE_ALL_EXCEPT 0
+#define FE_TONEAREST  0
+#else
+#define FE_INVALID    1
+#define FE_DIVBYZERO  2
+#define FE_OVERFLOW   4
+#define FE_UNDERFLOW  8
+#define FE_INEXACT    16
+#define FE_ALL_EXCEPT 31
+#define FE_TONEAREST  0
+#define FE_DOWNWARD   0x800000
+#define FE_UPWARD     0x400000
+#define FE_TOWARDZERO 0xc00000
+#endif
+
+typedef unsigned long fexcept_t;
+
+typedef struct {
+	unsigned long __cw;
+} fenv_t;
+
+#define FE_DFL_ENV      ((const fenv_t *) -1)
diff --git a/third_party/musl/porting/liteos_m/kernel/include/bits/float.h b/third_party/musl/porting/liteos_m/kernel/include/bits/float.h
new file mode 100755
index 000000000..c4a655e7b
--- /dev/null
+++ b/third_party/musl/porting/liteos_m/kernel/include/bits/float.h
@@ -0,0 +1,16 @@
+#define FLT_EVAL_METHOD 0
+
+#define LDBL_TRUE_MIN 4.94065645841246544177e-324L
+#define LDBL_MIN 2.22507385850720138309e-308L
+#define LDBL_MAX 1.79769313486231570815e+308L
+#define LDBL_EPSILON 2.22044604925031308085e-16L
+
+#define LDBL_MANT_DIG 53
+#define LDBL_MIN_EXP (-1021)
+#define LDBL_MAX_EXP 1024
+
+#define LDBL_DIG 15
+#define LDBL_MIN_10_EXP (-307)
+#define LDBL_MAX_10_EXP 308
+
+#define DECIMAL_DIG 17
diff --git a/third_party/musl/porting/liteos_m/kernel/include/bits/hwcap.h b/third_party/musl/porting/liteos_m/kernel/include/bits/hwcap.h
new file mode 100755
index 000000000..a3d87312d
--- /dev/null
+++ b/third_party/musl/porting/liteos_m/kernel/include/bits/hwcap.h
@@ -0,0 +1,53 @@
+#define HWCAP_SWP	(1 << 0)
+#define HWCAP_HALF	(1 << 1)
+#define HWCAP_THUMB	(1 << 2)
+#define HWCAP_26BIT	(1 << 3)
+#define HWCAP_FAST_MULT	(1 << 4)
+#define HWCAP_FPA	(1 << 5)
+#define HWCAP_VFP	(1 << 6)
+#define HWCAP_EDSP	(1 << 7)
+#define HWCAP_JAVA	(1 << 8)
+#define HWCAP_IWMMXT	(1 << 9)
+#define HWCAP_CRUNCH	(1 << 10)
+#define HWCAP_THUMBEE	(1 << 11)
+#define HWCAP_NEON	(1 << 12)
+#define HWCAP_VFPv3	(1 << 13)
+#define HWCAP_VFPv3D16	(1 << 14)
+#define HWCAP_TLS	(1 << 15)
+#define HWCAP_VFPv4	(1 << 16)
+#define HWCAP_IDIVA	(1 << 17)
+#define HWCAP_IDIVT	(1 << 18)
+#define HWCAP_VFPD32	(1 << 19)
+#define HWCAP_IDIV	(HWCAP_IDIVA | HWCAP_IDIVT)
+#define HWCAP_LPAE	(1 << 20)
+#define HWCAP_EVTSTRM	(1 << 21)
+
+#define HWCAP2_AES	(1 << 0)
+#define HWCAP2_PMULL	(1 << 1)
+#define HWCAP2_SHA1	(1 << 2)
+#define HWCAP2_SHA2	(1 << 3)
+#define HWCAP2_CRC32	(1 << 4)
+
+#define HWCAP_ARM_SWP	(1 << 0)
+#define HWCAP_ARM_HALF	(1 << 1)
+#define HWCAP_ARM_THUMB	(1 << 2)
+#define HWCAP_ARM_26BIT	(1 << 3)
+#define HWCAP_ARM_FAST_MULT	(1 << 4)
+#define HWCAP_ARM_FPA	(1 << 5)
+#define HWCAP_ARM_VFP	(1 << 6)
+#define HWCAP_ARM_EDSP	(1 << 7)
+#define HWCAP_ARM_JAVA	(1 << 8)
+#define HWCAP_ARM_IWMMXT	(1 << 9)
+#define HWCAP_ARM_CRUNCH	(1 << 10)
+#define HWCAP_ARM_THUMBEE	(1 << 11)
+#define HWCAP_ARM_NEON	(1 << 12)
+#define HWCAP_ARM_VFPv3	(1 << 13)
+#define HWCAP_ARM_VFPv3D16	(1 << 14)
+#define HWCAP_ARM_TLS	(1 << 15)
+#define HWCAP_ARM_VFPv4	(1 << 16)
+#define HWCAP_ARM_IDIVA	(1 << 17)
+#define HWCAP_ARM_IDIVT	(1 << 18)
+#define HWCAP_ARM_VFPD32	(1 << 19)
+#define HWCAP_ARM_IDIV	(HWCAP_ARM_IDIVA | HWCAP_ARM_IDIVT)
+#define HWCAP_ARM_LPAE	(1 << 20)
+#define HWCAP_ARM_EVTSTRM	(1 << 21)
diff --git a/third_party/musl/porting/liteos_m/kernel/include/bits/io.h b/third_party/musl/porting/liteos_m/kernel/include/bits/io.h
new file mode 100755
index 000000000..e69de29bb
diff --git a/third_party/musl/porting/liteos_m/kernel/include/bits/ioctl.h b/third_party/musl/porting/liteos_m/kernel/include/bits/ioctl.h
new file mode 100755
index 000000000..60ae8b850
--- /dev/null
+++ b/third_party/musl/porting/liteos_m/kernel/include/bits/ioctl.h
@@ -0,0 +1,115 @@
+#define _IOC(a,b,c,d) ( ((a)<<30) | ((b)<<8) | (c) | ((d)<<16) )
+#define _IOC_NONE  0U
+#define _IOC_WRITE 1U
+#define _IOC_READ  2U
+
+#define _IO(a,b) _IOC(_IOC_NONE,(a),(b),0)
+#define _IOW(a,b,c) _IOC(_IOC_WRITE,(a),(b),sizeof(c))
+#define _IOR(a,b,c) _IOC(_IOC_READ,(a),(b),sizeof(c))
+#define _IOWR(a,b,c) _IOC(_IOC_READ|_IOC_WRITE,(a),(b),sizeof(c))
+
+#define TCGETS		0x5401
+#define TCSETS		0x5402
+#define TCSETSW		0x5403
+#define TCSETSF		0x5404
+#define TCGETA		0x5405
+#define TCSETA		0x5406
+#define TCSETAW		0x5407
+#define TCSETAF		0x5408
+#define TCSBRK		0x5409
+#define TCXONC		0x540A
+#define TCFLSH		0x540B
+#define TIOCEXCL	0x540C
+#define TIOCNXCL	0x540D
+#define TIOCSCTTY	0x540E
+#define TIOCGPGRP	0x540F
+#define TIOCSPGRP	0x5410
+#define TIOCOUTQ	0x5411
+#define TIOCSTI		0x5412
+#define TIOCGWINSZ	0x5413
+#define TIOCSWINSZ	0x5414
+#define TIOCMGET	0x5415
+#define TIOCMBIS	0x5416
+#define TIOCMBIC	0x5417
+#define TIOCMSET	0x5418
+#define TIOCGSOFTCAR	0x5419
+#define TIOCSSOFTCAR	0x541A
+#define FIONREAD	0x541B
+#define TIOCINQ		FIONREAD
+#define TIOCLINUX	0x541C
+#define TIOCCONS	0x541D
+#define TIOCGSERIAL	0x541E
+#define TIOCSSERIAL	0x541F
+#define TIOCPKT		0x5420
+#define FIONBIO		0x5421
+#define TIOCNOTTY	0x5422
+#define TIOCSETD	0x5423
+#define TIOCGETD	0x5424
+#define TCSBRKP		0x5425
+#define TIOCSBRK	0x5427
+#define TIOCCBRK	0x5428
+#define TIOCGSID	0x5429
+#define TIOCGRS485	0x542E
+#define TIOCSRS485	0x542F
+#define TIOCGPTN	0x80045430
+#define TIOCSPTLCK	0x40045431
+#define TIOCGDEV	0x80045432
+#define TCGETX		0x5432
+#define TCSETX		0x5433
+#define TCSETXF		0x5434
+#define TCSETXW		0x5435
+#define TIOCSIG		0x40045436
+#define TIOCVHANGUP	0x5437
+#define TIOCGPKT	0x80045438
+#define TIOCGPTLCK	0x80045439
+#define TIOCGEXCL	0x80045440
+#define TIOCGPTPEER	0x5441
+#define TIOCGISO7816	0x80285442
+#define TIOCSISO7816	0xc0285443
+
+#define FIONCLEX	0x5450
+#define FIOCLEX		0x5451
+#define FIOASYNC	0x5452
+#define TIOCSERCONFIG	0x5453
+#define TIOCSERGWILD	0x5454
+#define TIOCSERSWILD	0x5455
+#define TIOCGLCKTRMIOS	0x5456
+#define TIOCSLCKTRMIOS	0x5457
+#define TIOCSERGSTRUCT	0x5458
+#define TIOCSERGETLSR   0x5459
+#define TIOCSERGETMULTI 0x545A
+#define TIOCSERSETMULTI 0x545B
+
+#define TIOCMIWAIT	0x545C
+#define TIOCGICOUNT	0x545D
+#define FIOQSIZE	0x5460
+
+#define TIOCM_LE        0x001
+#define TIOCM_DTR       0x002
+#define TIOCM_RTS       0x004
+#define TIOCM_ST        0x008
+#define TIOCM_SR        0x010
+#define TIOCM_CTS       0x020
+#define TIOCM_CAR       0x040
+#define TIOCM_RNG       0x080
+#define TIOCM_DSR       0x100
+#define TIOCM_CD        TIOCM_CAR
+#define TIOCM_RI        TIOCM_RNG
+#define TIOCM_OUT1      0x2000
+#define TIOCM_OUT2      0x4000
+#define TIOCM_LOOP      0x8000
+
+#define FIOSETOWN       0x8901
+#define SIOCSPGRP       0x8902
+#define FIOGETOWN       0x8903
+#define SIOCGPGRP       0x8904
+#define SIOCATMARK      0x8905
+#if __LONG_MAX == 0x7fffffff
+#define SIOCGSTAMP      _IOR(0x89, 6, char[16])
+#define SIOCGSTAMPNS    _IOR(0x89, 7, char[16])
+#else
+#define SIOCGSTAMP      0x8906
+#define SIOCGSTAMPNS    0x8907
+#endif
+
+#include <bits/ioctl_fix.h>
diff --git a/third_party/musl/porting/liteos_m/kernel/include/bits/ioctl_fix.h b/third_party/musl/porting/liteos_m/kernel/include/bits/ioctl_fix.h
new file mode 100755
index 000000000..ebb383daf
--- /dev/null
+++ b/third_party/musl/porting/liteos_m/kernel/include/bits/ioctl_fix.h
@@ -0,0 +1,2 @@
+#undef FIOQSIZE
+#define FIOQSIZE 0x545e
diff --git a/third_party/musl/porting/liteos_m/kernel/include/bits/ipc.h b/third_party/musl/porting/liteos_m/kernel/include/bits/ipc.h
new file mode 100755
index 000000000..40d6f3a25
--- /dev/null
+++ b/third_party/musl/porting/liteos_m/kernel/include/bits/ipc.h
@@ -0,0 +1,11 @@
+struct ipc_perm {
+	key_t __ipc_perm_key;
+	uid_t uid;
+	gid_t gid;
+	uid_t cuid;
+	gid_t cgid;
+	mode_t mode;
+	int __ipc_perm_seq;
+	long __pad1;
+	long __pad2;
+};
diff --git a/third_party/musl/porting/liteos_m/kernel/include/bits/ipcstat.h b/third_party/musl/porting/liteos_m/kernel/include/bits/ipcstat.h
new file mode 100755
index 000000000..4f4fcb0c5
--- /dev/null
+++ b/third_party/musl/porting/liteos_m/kernel/include/bits/ipcstat.h
@@ -0,0 +1 @@
+#define IPC_STAT 0x102
diff --git a/third_party/musl/porting/liteos_m/kernel/include/bits/kd.h b/third_party/musl/porting/liteos_m/kernel/include/bits/kd.h
new file mode 100755
index 000000000..33b873f49
--- /dev/null
+++ b/third_party/musl/porting/liteos_m/kernel/include/bits/kd.h
@@ -0,0 +1 @@
+#include <linux/kd.h>
diff --git a/third_party/musl/porting/liteos_m/kernel/include/bits/limits.h b/third_party/musl/porting/liteos_m/kernel/include/bits/limits.h
new file mode 100755
index 000000000..e69de29bb
diff --git a/third_party/musl/porting/liteos_m/kernel/include/bits/link.h b/third_party/musl/porting/liteos_m/kernel/include/bits/link.h
new file mode 100755
index 000000000..4a94d8f89
--- /dev/null
+++ b/third_party/musl/porting/liteos_m/kernel/include/bits/link.h
@@ -0,0 +1 @@
+typedef uint32_t Elf_Symndx;
diff --git a/third_party/musl/porting/liteos_m/kernel/include/bits/mman.h b/third_party/musl/porting/liteos_m/kernel/include/bits/mman.h
new file mode 100755
index 000000000..e69de29bb
diff --git a/third_party/musl/porting/liteos_m/kernel/include/bits/msg.h b/third_party/musl/porting/liteos_m/kernel/include/bits/msg.h
new file mode 100755
index 000000000..7bbbb2bf4
--- /dev/null
+++ b/third_party/musl/porting/liteos_m/kernel/include/bits/msg.h
@@ -0,0 +1,18 @@
+struct msqid_ds {
+	struct ipc_perm msg_perm;
+	unsigned long __msg_stime_lo;
+	unsigned long __msg_stime_hi;
+	unsigned long __msg_rtime_lo;
+	unsigned long __msg_rtime_hi;
+	unsigned long __msg_ctime_lo;
+	unsigned long __msg_ctime_hi;
+	unsigned long msg_cbytes;
+	msgqnum_t msg_qnum;
+	msglen_t msg_qbytes;
+	pid_t msg_lspid;
+	pid_t msg_lrpid;
+	unsigned long __unused[2];
+	time_t msg_stime;
+	time_t msg_rtime;
+	time_t msg_ctime;
+};
diff --git a/third_party/musl/porting/liteos_m/kernel/include/bits/poll.h b/third_party/musl/porting/liteos_m/kernel/include/bits/poll.h
new file mode 100755
index 000000000..e69de29bb
diff --git a/third_party/musl/porting/liteos_m/kernel/include/bits/posix.h b/third_party/musl/porting/liteos_m/kernel/include/bits/posix.h
new file mode 100755
index 000000000..30a38714f
--- /dev/null
+++ b/third_party/musl/porting/liteos_m/kernel/include/bits/posix.h
@@ -0,0 +1,2 @@
+#define _POSIX_V6_ILP32_OFFBIG  1
+#define _POSIX_V7_ILP32_OFFBIG  1
diff --git a/third_party/musl/porting/liteos_m/kernel/include/bits/ptrace.h b/third_party/musl/porting/liteos_m/kernel/include/bits/ptrace.h
new file mode 100755
index 000000000..9556ef4b7
--- /dev/null
+++ b/third_party/musl/porting/liteos_m/kernel/include/bits/ptrace.h
@@ -0,0 +1,25 @@
+#define PTRACE_GETWMMXREGS	18
+#define PTRACE_SETWMMXREGS	19
+#define PTRACE_GET_THREAD_AREA	22
+#define PTRACE_SET_SYSCALL	23
+#define PTRACE_GETCRUNCHREGS	25
+#define PTRACE_SETCRUNCHREGS	26
+#define PTRACE_GETVFPREGS	27
+#define PTRACE_SETVFPREGS	28
+#define PTRACE_GETHBPREGS	29
+#define PTRACE_SETHBPREGS	30
+#define PTRACE_GETFDPIC		31
+#define PTRACE_GETFDPIC_EXEC	0
+#define PTRACE_GETFDPIC_INTERP	1
+
+#define PT_GETWMMXREGS PTRACE_GETWMMXREGS
+#define PT_SETWMMXREGS PTRACE_SETWMMXREGS
+#define PT_GET_THREAD_AREA PTRACE_GET_THREAD_AREA
+#define PT_SET_SYSCALL PTRACE_SET_SYSCALL
+#define PT_GETCRUNCHREGS PTRACE_GETCRUNCHREGS
+#define PT_SETCRUNCHREGS PTRACE_SETCRUNCHREGS
+#define PT_GETVFPREGS PTRACE_GETVFPREGS
+#define PT_SETVFPREGS PTRACE_SETVFPREGS
+#define PT_GETHBPREGS PTRACE_GETHBPREGS
+#define PT_SETHBPREGS PTRACE_SETHBPREGS
+#define PT_GETFDPIC PTRACE_GETFDPIC
diff --git a/third_party/musl/porting/liteos_m/kernel/include/bits/reg.h b/third_party/musl/porting/liteos_m/kernel/include/bits/reg.h
new file mode 100755
index 000000000..0c7bffca0
--- /dev/null
+++ b/third_party/musl/porting/liteos_m/kernel/include/bits/reg.h
@@ -0,0 +1,3 @@
+#undef __WORDSIZE
+#define __WORDSIZE 32
+/* FIXME */
diff --git a/third_party/musl/porting/liteos_m/kernel/include/bits/resource.h b/third_party/musl/porting/liteos_m/kernel/include/bits/resource.h
new file mode 100755
index 000000000..e69de29bb
diff --git a/third_party/musl/porting/liteos_m/kernel/include/bits/sem.h b/third_party/musl/porting/liteos_m/kernel/include/bits/sem.h
new file mode 100755
index 000000000..544e3d2a5
--- /dev/null
+++ b/third_party/musl/porting/liteos_m/kernel/include/bits/sem.h
@@ -0,0 +1,18 @@
+struct semid_ds {
+	struct ipc_perm sem_perm;
+	unsigned long __sem_otime_lo;
+	unsigned long __sem_otime_hi;
+	unsigned long __sem_ctime_lo;
+	unsigned long __sem_ctime_hi;
+#if __BYTE_ORDER == __LITTLE_ENDIAN
+	unsigned short sem_nsems;
+	char __sem_nsems_pad[sizeof(long)-sizeof(short)];
+#else
+	char __sem_nsems_pad[sizeof(long)-sizeof(short)];
+	unsigned short sem_nsems;
+#endif
+	long __unused3;
+	long __unused4;
+	time_t sem_otime;
+	time_t sem_ctime;
+};
diff --git a/third_party/musl/porting/liteos_m/kernel/include/bits/setjmp.h b/third_party/musl/porting/liteos_m/kernel/include/bits/setjmp.h
new file mode 100755
index 000000000..55e3a95bb
--- /dev/null
+++ b/third_party/musl/porting/liteos_m/kernel/include/bits/setjmp.h
@@ -0,0 +1 @@
+typedef unsigned long long __jmp_buf[32];
diff --git a/third_party/musl/porting/liteos_m/kernel/include/bits/shm.h b/third_party/musl/porting/liteos_m/kernel/include/bits/shm.h
new file mode 100755
index 000000000..725fb4696
--- /dev/null
+++ b/third_party/musl/porting/liteos_m/kernel/include/bits/shm.h
@@ -0,0 +1,31 @@
+#define SHMLBA 4096
+
+struct shmid_ds {
+	struct ipc_perm shm_perm;
+	size_t shm_segsz;
+	unsigned long __shm_atime_lo;
+	unsigned long __shm_atime_hi;
+	unsigned long __shm_dtime_lo;
+	unsigned long __shm_dtime_hi;
+	unsigned long __shm_ctime_lo;
+	unsigned long __shm_ctime_hi;
+	pid_t shm_cpid;
+	pid_t shm_lpid;
+	unsigned long shm_nattch;
+	unsigned long __pad1;
+	unsigned long __pad2;
+	unsigned long __pad3;
+	time_t shm_atime;
+	time_t shm_dtime;
+	time_t shm_ctime;
+};
+
+struct shminfo {
+	unsigned long shmmax, shmmin, shmmni, shmseg, shmall, __unused[4];
+};
+
+struct shm_info {
+	int __used_ids;
+	unsigned long shm_tot, shm_rss, shm_swp;
+	unsigned long __swap_attempts, __swap_successes;
+};
diff --git a/third_party/musl/porting/liteos_m/kernel/include/bits/signal.h b/third_party/musl/porting/liteos_m/kernel/include/bits/signal.h
new file mode 100755
index 000000000..3c7898567
--- /dev/null
+++ b/third_party/musl/porting/liteos_m/kernel/include/bits/signal.h
@@ -0,0 +1,86 @@
+#if defined(_POSIX_SOURCE) || defined(_POSIX_C_SOURCE) \
+ || defined(_XOPEN_SOURCE) || defined(_GNU_SOURCE) || defined(_BSD_SOURCE)
+
+#if defined(_XOPEN_SOURCE) || defined(_GNU_SOURCE) || defined(_BSD_SOURCE)
+#define MINSIGSTKSZ 2048
+#define SIGSTKSZ 8192
+#endif
+
+#if defined(_GNU_SOURCE) || defined(_BSD_SOURCE)
+typedef int greg_t, gregset_t[18];
+typedef struct sigcontext {
+	unsigned long trap_no, error_code, oldmask;
+	unsigned long arm_r0, arm_r1, arm_r2, arm_r3;
+	unsigned long arm_r4, arm_r5, arm_r6, arm_r7;
+	unsigned long arm_r8, arm_r9, arm_r10, arm_fp;
+	unsigned long arm_ip, arm_sp, arm_lr, arm_pc;
+	unsigned long arm_cpsr, fault_address;
+} mcontext_t;
+#else
+typedef struct {
+	unsigned long __regs[21];
+} mcontext_t;
+#endif
+
+struct sigaltstack {
+	void *ss_sp;
+	int ss_flags;
+	size_t ss_size;
+};
+
+typedef struct __ucontext {
+	unsigned long uc_flags;
+	struct __ucontext *uc_link;
+	stack_t uc_stack;
+	mcontext_t uc_mcontext;
+	sigset_t uc_sigmask;
+	unsigned long long uc_regspace[64];
+} ucontext_t;
+
+#define SA_NOCLDSTOP  1
+#define SA_NOCLDWAIT  2
+#define SA_SIGINFO    4
+#define SA_ONSTACK    0x08000000
+#define SA_RESTART    0x10000000
+#define SA_NODEFER    0x40000000
+#define SA_RESETHAND  0x80000000
+#define SA_RESTORER   0x04000000
+
+#endif
+
+#define SIGHUP    1
+#define SIGINT    2
+#define SIGQUIT   3
+#define SIGILL    4
+#define SIGTRAP   5
+#define SIGABRT   6
+#define SIGIOT    SIGABRT
+#define SIGBUS    7
+#define SIGFPE    8
+#define SIGKILL   9
+#define SIGUSR1   10
+#define SIGSEGV   11
+#define SIGUSR2   12
+#define SIGPIPE   13
+#define SIGALRM   14
+#define SIGTERM   15
+#define SIGSTKFLT 16
+#define SIGCHLD   17
+#define SIGCONT   18
+#define SIGSTOP   19
+#define SIGTSTP   20
+#define SIGTTIN   21
+#define SIGTTOU   22
+#define SIGURG    23
+#define SIGXCPU   24
+#define SIGXFSZ   25
+#define SIGVTALRM 26
+#define SIGPROF   27
+#define SIGWINCH  28
+#define SIGIO     29
+#define SIGPOLL   29
+#define SIGPWR    30
+#define SIGSYS    31
+#define SIGUNUSED SIGSYS
+
+#define _NSIG 65
diff --git a/third_party/musl/porting/liteos_m/kernel/include/bits/socket.h b/third_party/musl/porting/liteos_m/kernel/include/bits/socket.h
new file mode 100755
index 000000000..e69de29bb
diff --git a/third_party/musl/porting/liteos_m/kernel/include/bits/soundcard.h b/third_party/musl/porting/liteos_m/kernel/include/bits/soundcard.h
new file mode 100755
index 000000000..fade986fe
--- /dev/null
+++ b/third_party/musl/porting/liteos_m/kernel/include/bits/soundcard.h
@@ -0,0 +1 @@
+#include <linux/soundcard.h>
diff --git a/third_party/musl/porting/liteos_m/kernel/include/bits/stat.h b/third_party/musl/porting/liteos_m/kernel/include/bits/stat.h
new file mode 100755
index 000000000..5d7828cf7
--- /dev/null
+++ b/third_party/musl/porting/liteos_m/kernel/include/bits/stat.h
@@ -0,0 +1,25 @@
+/* copied from kernel definition, but with padding replaced
+ * by the corresponding correctly-sized userspace types. */
+
+struct stat {
+	dev_t st_dev;
+	int __st_dev_padding;
+	long __st_ino_truncated;
+	mode_t st_mode;
+	nlink_t st_nlink;
+	uid_t st_uid;
+	gid_t st_gid;
+	dev_t st_rdev;
+	int __st_rdev_padding;
+	off_t st_size;
+	blksize_t st_blksize;
+	blkcnt_t st_blocks;
+	struct {
+		long tv_sec;
+		long tv_nsec;
+	} __st_atim32, __st_mtim32, __st_ctim32;
+	ino_t st_ino;
+	struct timespec st_atim;
+	struct timespec st_mtim;
+	struct timespec st_ctim;
+};
diff --git a/third_party/musl/porting/liteos_m/kernel/include/bits/statfs.h b/third_party/musl/porting/liteos_m/kernel/include/bits/statfs.h
new file mode 100755
index 000000000..f103f4e4f
--- /dev/null
+++ b/third_party/musl/porting/liteos_m/kernel/include/bits/statfs.h
@@ -0,0 +1,7 @@
+struct statfs {
+	unsigned long f_type, f_bsize;
+	fsblkcnt_t f_blocks, f_bfree, f_bavail;
+	fsfilcnt_t f_files, f_ffree;
+	fsid_t f_fsid;
+	unsigned long f_namelen, f_frsize, f_flags, f_spare[4];
+};
diff --git a/third_party/musl/porting/liteos_m/kernel/include/bits/stdint.h b/third_party/musl/porting/liteos_m/kernel/include/bits/stdint.h
new file mode 100755
index 000000000..1cd984605
--- /dev/null
+++ b/third_party/musl/porting/liteos_m/kernel/include/bits/stdint.h
@@ -0,0 +1,22 @@
+#ifndef __ICCARM__
+typedef int32_t int_fast16_t;
+typedef int32_t int_fast32_t;
+typedef uint32_t uint_fast16_t;
+typedef uint32_t uint_fast32_t;
+
+#define INT_FAST16_MIN  INT32_MIN
+#define INT_FAST32_MIN  INT32_MIN
+
+#define INT_FAST16_MAX  INT32_MAX
+#define INT_FAST32_MAX  INT32_MAX
+
+#define UINT_FAST16_MAX UINT32_MAX
+#define UINT_FAST32_MAX UINT32_MAX
+
+#define INTPTR_MIN      INT32_MIN
+#define INTPTR_MAX      INT32_MAX
+#define UINTPTR_MAX     UINT32_MAX
+#define PTRDIFF_MIN     INT32_MIN
+#define PTRDIFF_MAX     INT32_MAX
+#define SIZE_MAX        UINT32_MAX
+#endif
\ No newline at end of file
diff --git a/third_party/musl/porting/liteos_m/kernel/include/bits/syscall.h b/third_party/musl/porting/liteos_m/kernel/include/bits/syscall.h
new file mode 100755
index 000000000..090c697e2
--- /dev/null
+++ b/third_party/musl/porting/liteos_m/kernel/include/bits/syscall.h
@@ -0,0 +1,791 @@
+#define __NR_restart_syscall	0
+#define __NR_exit	1
+#define __NR_fork	2
+#define __NR_read	3
+#define __NR_write	4
+#define __NR_open	5
+#define __NR_close	6
+#define __NR_creat	8
+#define __NR_link	9
+#define __NR_unlink	10
+#define __NR_execve	11
+#define __NR_chdir	12
+#define __NR_mknod	14
+#define __NR_chmod	15
+#define __NR_lchown	16
+#define __NR_lseek	19
+#define __NR_getpid	20
+#define __NR_mount	21
+#define __NR_umount	22
+#define __NR_setuid	23
+#define __NR_getuid	24
+#define __NR_ptrace	26
+#define __NR_pause	29
+#define __NR_access	33
+#define __NR_nice	34
+#define __NR_sync	36
+#define __NR_kill	37
+#define __NR_rename	38
+#define __NR_mkdir	39
+#define __NR_rmdir	40
+#define __NR_dup	41
+#define __NR_pipe	42
+#define __NR_times	43
+#define __NR_brk	45
+#define __NR_setgid	46
+#define __NR_getgid	47
+#define __NR_geteuid	49
+#define __NR_getegid	50
+#define __NR_acct	51
+#define __NR_umount2	52
+#define __NR_ioctl	54
+#define __NR_fcntl	55
+#define __NR_setpgid	57
+#define __NR_umask	60
+#define __NR_chroot	61
+#define __NR_ustat	62
+#define __NR_dup2	63
+#define __NR_getppid	64
+#define __NR_getpgrp	65
+#define __NR_setsid	66
+#define __NR_sigaction	67
+#define __NR_setreuid	70
+#define __NR_setregid	71
+#define __NR_sigsuspend	72
+#define __NR_sigpending	73
+#define __NR_sethostname	74
+#define __NR_setrlimit	75
+#define __NR_getrusage	77
+#define __NR_gettimeofday_time32	78
+#define __NR_settimeofday_time32	79
+#define __NR_getgroups	80
+#define __NR_setgroups	81
+#define __NR_symlink	83
+#define __NR_readlink	85
+#define __NR_uselib	86
+#define __NR_swapon	87
+#define __NR_reboot	88
+#define __NR_munmap	91
+#define __NR_truncate	92
+#define __NR_ftruncate	93
+#define __NR_fchmod	94
+#define __NR_fchown	95
+#define __NR_getpriority	96
+#define __NR_setpriority	97
+#define __NR_statfs	99
+#define __NR_fstatfs	100
+#define __NR_syslog	103
+#define __NR_setitimer	104
+#define __NR_getitimer	105
+#define __NR_stat	106
+#define __NR_lstat	107
+#define __NR_fstat	108
+#define __NR_vhangup	111
+#define __NR_wait4	114
+#define __NR_swapoff	115
+#define __NR_sysinfo	116
+#define __NR_fsync	118
+#define __NR_sigreturn	119
+#define __NR_clone	120
+#define __NR_setdomainname	121
+#define __NR_uname	122
+#define __NR_adjtimex	124
+#define __NR_mprotect	125
+#define __NR_sigprocmask	126
+#define __NR_init_module	128
+#define __NR_delete_module	129
+#define __NR_quotactl	131
+#define __NR_getpgid	132
+#define __NR_fchdir	133
+#define __NR_bdflush	134
+#define __NR_sysfs	135
+#define __NR_personality	136
+#define __NR_setfsuid	138
+#define __NR_setfsgid	139
+#define __NR__llseek	140
+#define __NR_getdents	141
+#define __NR__newselect	142
+#define __NR_flock	143
+#define __NR_msync	144
+#define __NR_readv	145
+#define __NR_writev	146
+#define __NR_getsid	147
+#define __NR_fdatasync	148
+#define __NR__sysctl	149
+#define __NR_mlock	150
+#define __NR_munlock	151
+#define __NR_mlockall	152
+#define __NR_munlockall	153
+#define __NR_sched_setparam	154
+#define __NR_sched_getparam	155
+#define __NR_sched_setscheduler	156
+#define __NR_sched_getscheduler	157
+#define __NR_sched_yield	158
+#define __NR_sched_get_priority_max	159
+#define __NR_sched_get_priority_min	160
+#define __NR_sched_rr_get_interval	161
+#define __NR_nanosleep	162
+#define __NR_mremap	163
+#define __NR_setresuid	164
+#define __NR_getresuid	165
+#define __NR_poll	168
+#define __NR_nfsservctl	169
+#define __NR_setresgid	170
+#define __NR_getresgid	171
+#define __NR_prctl	172
+#define __NR_rt_sigreturn	173
+#define __NR_rt_sigaction	174
+#define __NR_rt_sigprocmask	175
+#define __NR_rt_sigpending	176
+#define __NR_rt_sigtimedwait	177
+#define __NR_rt_sigqueueinfo	178
+#define __NR_rt_sigsuspend	179
+#define __NR_pread64	180
+#define __NR_pwrite64	181
+#define __NR_chown	182
+#define __NR_getcwd	183
+#define __NR_capget	184
+#define __NR_capset	185
+#define __NR_sigaltstack	186
+#define __NR_sendfile	187
+#define __NR_vfork	190
+#define __NR_ugetrlimit	191
+#define __NR_mmap2	192
+#define __NR_truncate64	193
+#define __NR_ftruncate64	194
+#define __NR_stat64	195
+#define __NR_lstat64	196
+#define __NR_fstat64	197
+#define __NR_lchown32	198
+#define __NR_getuid32	199
+#define __NR_getgid32	200
+#define __NR_geteuid32	201
+#define __NR_getegid32	202
+#define __NR_setreuid32	203
+#define __NR_setregid32	204
+#define __NR_getgroups32	205
+#define __NR_setgroups32	206
+#define __NR_fchown32	207
+#define __NR_setresuid32	208
+#define __NR_getresuid32	209
+#define __NR_setresgid32	210
+#define __NR_getresgid32	211
+#define __NR_chown32	212
+#define __NR_setuid32	213
+#define __NR_setgid32	214
+#define __NR_setfsuid32	215
+#define __NR_setfsgid32	216
+#define __NR_getdents64	217
+#define __NR_pivot_root	218
+#define __NR_mincore	219
+#define __NR_madvise	220
+#define __NR_fcntl64	221
+#define __NR_gettid	224
+#define __NR_readahead	225
+#define __NR_setxattr	226
+#define __NR_lsetxattr	227
+#define __NR_fsetxattr	228
+#define __NR_getxattr	229
+#define __NR_lgetxattr	230
+#define __NR_fgetxattr	231
+#define __NR_listxattr	232
+#define __NR_llistxattr	233
+#define __NR_flistxattr	234
+#define __NR_removexattr	235
+#define __NR_lremovexattr	236
+#define __NR_fremovexattr	237
+#define __NR_tkill	238
+#define __NR_sendfile64	239
+#define __NR_futex	240
+#define __NR_sched_setaffinity	241
+#define __NR_sched_getaffinity	242
+#define __NR_io_setup	243
+#define __NR_io_destroy	244
+#define __NR_io_getevents	245
+#define __NR_io_submit	246
+#define __NR_io_cancel	247
+#define __NR_exit_group	248
+#define __NR_lookup_dcookie	249
+#define __NR_epoll_create	250
+#define __NR_epoll_ctl	251
+#define __NR_epoll_wait	252
+#define __NR_remap_file_pages	253
+#define __NR_set_thread_area	254
+#define __NR_get_thread_area	255
+#define __NR_set_tid_address	256
+#define __NR_timer_create	257
+#define __NR_timer_settime32	258
+#define __NR_timer_gettime32	259
+#define __NR_timer_getoverrun	260
+#define __NR_timer_delete	261
+#define __NR_clock_settime32	262
+#define __NR_clock_gettime32	263
+#define __NR_clock_getres_time32	264
+#define __NR_clock_nanosleep_time32	265
+#define __NR_statfs64	266
+#define __NR_fstatfs64	267
+#define __NR_tgkill	268
+#define __NR_utimes	269
+#define __NR_fadvise64_64	270
+#define __NR_arm_fadvise64_64	270
+#define __NR_pciconfig_iobase	271
+#define __NR_pciconfig_read	272
+#define __NR_pciconfig_write	273
+#define __NR_mq_open	274
+#define __NR_mq_unlink	275
+#define __NR_mq_timedsend	276
+#define __NR_mq_timedreceive	277
+#define __NR_mq_notify	278
+#define __NR_mq_getsetattr	279
+#define __NR_waitid	280
+#define __NR_socket	281
+#define __NR_bind	282
+#define __NR_connect	283
+#define __NR_listen	284
+#define __NR_accept	285
+#define __NR_getsockname	286
+#define __NR_getpeername	287
+#define __NR_socketpair	288
+#define __NR_send	289
+#define __NR_sendto	290
+#define __NR_recv	291
+#define __NR_recvfrom	292
+#define __NR_shutdown	293
+#define __NR_setsockopt	294
+#define __NR_getsockopt	295
+#define __NR_sendmsg	296
+#define __NR_recvmsg	297
+#define __NR_semop	298
+#define __NR_semget	299
+#define __NR_semctl	300
+#define __NR_msgsnd	301
+#define __NR_msgrcv	302
+#define __NR_msgget	303
+#define __NR_msgctl	304
+#define __NR_shmat	305
+#define __NR_shmdt	306
+#define __NR_shmget	307
+#define __NR_shmctl	308
+#define __NR_add_key	309
+#define __NR_request_key	310
+#define __NR_keyctl	311
+#define __NR_semtimedop	312
+#define __NR_vserver	313
+#define __NR_ioprio_set	314
+#define __NR_ioprio_get	315
+#define __NR_inotify_init	316
+#define __NR_inotify_add_watch	317
+#define __NR_inotify_rm_watch	318
+#define __NR_mbind	319
+#define __NR_get_mempolicy	320
+#define __NR_set_mempolicy	321
+#define __NR_openat	322
+#define __NR_mkdirat	323
+#define __NR_mknodat	324
+#define __NR_fchownat	325
+#define __NR_futimesat	326
+#define __NR_fstatat64	327
+#define __NR_unlinkat	328
+#define __NR_renameat	329
+#define __NR_linkat	330
+#define __NR_symlinkat	331
+#define __NR_readlinkat	332
+#define __NR_fchmodat	333
+#define __NR_faccessat	334
+#define __NR_pselect6	335
+#define __NR_ppoll	336
+#define __NR_unshare	337
+#define __NR_set_robust_list	338
+#define __NR_get_robust_list	339
+#define __NR_splice	340
+#define __NR_sync_file_range2	341
+#define __NR_arm_sync_file_range	341
+#define __NR_tee	342
+#define __NR_vmsplice	343
+#define __NR_move_pages	344
+#define __NR_getcpu	345
+#define __NR_epoll_pwait	346
+#define __NR_kexec_load	347
+#define __NR_utimensat	348
+#define __NR_signalfd	349
+#define __NR_timerfd_create	350
+#define __NR_eventfd	351
+#define __NR_fallocate	352
+#define __NR_timerfd_settime32	353
+#define __NR_timerfd_gettime32	354
+#define __NR_signalfd4	355
+#define __NR_eventfd2	356
+#define __NR_epoll_create1	357
+#define __NR_dup3	358
+#define __NR_pipe2	359
+#define __NR_inotify_init1	360
+#define __NR_preadv	361
+#define __NR_pwritev	362
+#define __NR_rt_tgsigqueueinfo	363
+#define __NR_perf_event_open	364
+#define __NR_recvmmsg	365
+#define __NR_accept4	366
+#define __NR_fanotify_init	367
+#define __NR_fanotify_mark	368
+#define __NR_prlimit64	369
+#define __NR_name_to_handle_at	370
+#define __NR_open_by_handle_at	371
+#define __NR_clock_adjtime	372
+#define __NR_syncfs	373
+#define __NR_sendmmsg	374
+#define __NR_setns	375
+#define __NR_process_vm_readv	376
+#define __NR_process_vm_writev	377
+#define __NR_kcmp		378
+#define __NR_finit_module	379
+#define __NR_sched_setattr	380
+#define __NR_sched_getattr	381
+#define __NR_renameat2	382
+#define __NR_seccomp	383
+#define __NR_getrandom	384
+#define __NR_memfd_create	385
+#define __NR_bpf	386
+#define __NR_execveat	387
+#define __NR_userfaultfd	388
+#define __NR_membarrier		389
+#define __NR_mlock2		390
+#define __NR_copy_file_range	391
+#define __NR_preadv2	392
+#define __NR_pwritev2	393
+#define __NR_pkey_mprotect	394
+#define __NR_pkey_alloc	395
+#define __NR_pkey_free	396
+#define __NR_statx	397
+#define __NR_rseq	398
+#define __NR_io_pgetevents	399
+#define __NR_migrate_pages	400
+#define __NR_kexec_file_load	401
+#define __NR_pidfd_send_signal	424
+#define __NR_io_uring_setup	425
+#define __NR_io_uring_enter	426
+#define __NR_io_uring_register	427
+#define __NR_open_tree		428
+#define __NR_move_mount		429
+#define __NR_fsopen		430
+#define __NR_fsconfig		431
+#define __NR_fsmount		432
+#define __NR_fspick		433
+#define __NR_pidfd_open		434
+#define __NR_clone3		435
+
+/* OHOS customized syscalls, not compatible with ARM EABI */
+#define __NR_OHOS_BEGIN         500
+#define __NR_pthread_set_detach (__NR_OHOS_BEGIN + 0)
+#define __NR_pthread_join       (__NR_OHOS_BEGIN + 1)
+#define __NR_pthread_deatch     (__NR_OHOS_BEGIN + 2)
+#define __NR_creat_user_thread  (__NR_OHOS_BEGIN + 3)
+#define __NR_processcreat       (__NR_OHOS_BEGIN + 4)
+#define __NR_processtart        (__NR_OHOS_BEGIN + 5)
+#define __NR_printf             (__NR_OHOS_BEGIN + 6)
+#define __NR_dumpmemory         (__NR_OHOS_BEGIN + 13)
+#define __NR_mkfifo             (__NR_OHOS_BEGIN + 14)
+#define __NR_mqclose            (__NR_OHOS_BEGIN + 15)
+#define __NR_realpath           (__NR_OHOS_BEGIN + 16)
+#define __NR_format             (__NR_OHOS_BEGIN + 17)
+#define __NR_shellexec          (__NR_OHOS_BEGIN + 18)
+#define __NR_ohoscapget         (__NR_OHOS_BEGIN + 19)
+#define __NR_ohoscapset         (__NR_OHOS_BEGIN + 20)
+#define __NR_syscallend         (__NR_OHOS_BEGIN + 21)
+
+#define __ARM_NR_breakpoint	0x0f0001
+#define __ARM_NR_cacheflush	0x0f0002
+#define __ARM_NR_usr26		0x0f0003
+#define __ARM_NR_usr32		0x0f0004
+#define __ARM_NR_set_tls	0x0f0005
+#define __ARM_NR_get_tls	0x0f0006
+#define SYS_restart_syscall	0
+#define SYS_exit	1
+#define SYS_fork	2
+#define SYS_read	3
+#define SYS_write	4
+#define SYS_open	5
+#define SYS_close	6
+#define SYS_creat	8
+#define SYS_link	9
+#define SYS_unlink	10
+#define SYS_execve	11
+#define SYS_chdir	12
+#define SYS_mknod	14
+#define SYS_chmod	15
+#define SYS_lchown	16
+#define SYS_lseek	19
+#define SYS_getpid	20
+#define SYS_mount	21
+#define SYS_umount	22
+#define SYS_setuid	23
+#define SYS_getuid	24
+#define SYS_ptrace	26
+#define SYS_pause	29
+#define SYS_access	33
+#define SYS_nice	34
+#define SYS_sync	36
+#define SYS_kill	37
+#define SYS_rename	38
+#define SYS_mkdir	39
+#define SYS_rmdir	40
+#define SYS_dup	41
+#define SYS_pipe	42
+#define SYS_times	43
+#define SYS_brk	45
+#define SYS_setgid	46
+#define SYS_getgid	47
+#define SYS_geteuid	49
+#define SYS_getegid	50
+#define SYS_acct	51
+#define SYS_umount2	52
+#define SYS_ioctl	54
+#define SYS_fcntl	55
+#define SYS_setpgid	57
+#define SYS_umask	60
+#define SYS_chroot	61
+#define SYS_ustat	62
+#define SYS_dup2	63
+#define SYS_getppid	64
+#define SYS_getpgrp	65
+#define SYS_setsid	66
+#define SYS_sigaction	67
+#define SYS_setreuid	70
+#define SYS_setregid	71
+#define SYS_sigsuspend	72
+#define SYS_sigpending	73
+#define SYS_sethostname	74
+#define SYS_setrlimit	75
+#define SYS_getrusage	77
+#define SYS_gettimeofday_time32	78
+#define SYS_settimeofday_time32	79
+#define SYS_getgroups	80
+#define SYS_setgroups	81
+#define SYS_symlink	83
+#define SYS_readlink	85
+#define SYS_uselib	86
+#define SYS_swapon	87
+#define SYS_reboot	88
+#define SYS_munmap	91
+#define SYS_truncate	92
+#define SYS_ftruncate	93
+#define SYS_fchmod	94
+#define SYS_fchown	95
+#define SYS_getpriority	96
+#define SYS_setpriority	97
+#define SYS_statfs	99
+#define SYS_fstatfs	100
+#define SYS_syslog	103
+#define SYS_setitimer	104
+#define SYS_getitimer	105
+#define SYS_stat	106
+#define SYS_lstat	107
+#define SYS_fstat	108
+#define SYS_vhangup	111
+#define SYS_wait4	114
+#define SYS_swapoff	115
+#define SYS_sysinfo	116
+#define SYS_fsync	118
+#define SYS_sigreturn	119
+#define SYS_clone	120
+#define SYS_setdomainname	121
+#define SYS_uname	122
+#define SYS_adjtimex	124
+#define SYS_mprotect	125
+#define SYS_sigprocmask	126
+#define SYS_init_module	128
+#define SYS_delete_module	129
+#define SYS_quotactl	131
+#define SYS_getpgid	132
+#define SYS_fchdir	133
+#define SYS_bdflush	134
+#define SYS_sysfs	135
+#define SYS_personality	136
+#define SYS_setfsuid	138
+#define SYS_setfsgid	139
+#define SYS__llseek	140
+#define SYS_getdents	141
+#define SYS__newselect	142
+#define SYS_flock	143
+#define SYS_msync	144
+#define SYS_readv	145
+#define SYS_writev	146
+#define SYS_getsid	147
+#define SYS_fdatasync	148
+#define SYS__sysctl	149
+#define SYS_mlock	150
+#define SYS_munlock	151
+#define SYS_mlockall	152
+#define SYS_munlockall	153
+#define SYS_sched_setparam	154
+#define SYS_sched_getparam	155
+#define SYS_sched_setscheduler	156
+#define SYS_sched_getscheduler	157
+#define SYS_sched_yield	158
+#define SYS_sched_get_priority_max	159
+#define SYS_sched_get_priority_min	160
+#define SYS_sched_rr_get_interval	161
+#define SYS_nanosleep	162
+#define SYS_mremap	163
+#define SYS_setresuid	164
+#define SYS_getresuid	165
+#define SYS_poll	168
+#define SYS_nfsservctl	169
+#define SYS_setresgid	170
+#define SYS_getresgid	171
+#define SYS_prctl	172
+#define SYS_rt_sigreturn	173
+#define SYS_rt_sigaction	174
+#define SYS_rt_sigprocmask	175
+#define SYS_rt_sigpending	176
+#define SYS_rt_sigtimedwait	177
+#define SYS_rt_sigqueueinfo	178
+#define SYS_rt_sigsuspend	179
+#define SYS_pread64	180
+#define SYS_pwrite64	181
+#define SYS_chown	182
+#define SYS_getcwd	183
+#define SYS_capget	184
+#define SYS_capset	185
+#define SYS_sigaltstack	186
+#define SYS_sendfile	187
+#define SYS_vfork	190
+#define SYS_ugetrlimit	191
+#define SYS_mmap2	192
+#define SYS_truncate64	193
+#define SYS_ftruncate64	194
+#define SYS_stat64	195
+#define SYS_lstat64	196
+#define SYS_fstat64	197
+#define SYS_lchown32	198
+#define SYS_getuid32	199
+#define SYS_getgid32	200
+#define SYS_geteuid32	201
+#define SYS_getegid32	202
+#define SYS_setreuid32	203
+#define SYS_setregid32	204
+#define SYS_getgroups32	205
+#define SYS_setgroups32	206
+#define SYS_fchown32	207
+#define SYS_setresuid32	208
+#define SYS_getresuid32	209
+#define SYS_setresgid32	210
+#define SYS_getresgid32	211
+#define SYS_chown32	212
+#define SYS_setuid32	213
+#define SYS_setgid32	214
+#define SYS_setfsuid32	215
+#define SYS_setfsgid32	216
+#define SYS_getdents64	217
+#define SYS_pivot_root	218
+#define SYS_mincore	219
+#define SYS_madvise	220
+#define SYS_fcntl64	221
+#define SYS_gettid	224
+#define SYS_readahead	225
+#define SYS_setxattr	226
+#define SYS_lsetxattr	227
+#define SYS_fsetxattr	228
+#define SYS_getxattr	229
+#define SYS_lgetxattr	230
+#define SYS_fgetxattr	231
+#define SYS_listxattr	232
+#define SYS_llistxattr	233
+#define SYS_flistxattr	234
+#define SYS_removexattr	235
+#define SYS_lremovexattr	236
+#define SYS_fremovexattr	237
+#define SYS_tkill	238
+#define SYS_sendfile64	239
+#define SYS_futex	240
+#define SYS_sched_setaffinity	241
+#define SYS_sched_getaffinity	242
+#define SYS_io_setup	243
+#define SYS_io_destroy	244
+#define SYS_io_getevents	245
+#define SYS_io_submit	246
+#define SYS_io_cancel	247
+#define SYS_exit_group	248
+#define SYS_lookup_dcookie	249
+#define SYS_epoll_create	250
+#define SYS_epoll_ctl	251
+#define SYS_epoll_wait	252
+#define SYS_remap_file_pages	253
+#define SYS_set_thread_area	254
+#define SYS_get_thread_area	255
+#define SYS_set_tid_address	256
+#define SYS_timer_create	257
+#define SYS_timer_settime32	258
+#define SYS_timer_gettime32	259
+#define SYS_timer_getoverrun	260
+#define SYS_timer_delete	261
+#define SYS_clock_settime32	262
+#define SYS_clock_gettime32	263
+#define SYS_clock_getres_time32	264
+#define SYS_clock_nanosleep_time32	265
+#define SYS_statfs64	266
+#define SYS_fstatfs64	267
+#define SYS_tgkill	268
+#define SYS_utimes	269
+#define SYS_fadvise64_64	270
+#define SYS_arm_fadvise64_64	270
+#define SYS_pciconfig_iobase	271
+#define SYS_pciconfig_read	272
+#define SYS_pciconfig_write	273
+#define SYS_mq_open	274
+#define SYS_mq_unlink	275
+#define SYS_mq_timedsend	276
+#define SYS_mq_timedreceive	277
+#define SYS_mq_notify	278
+#define SYS_mq_getsetattr	279
+#define SYS_waitid	280
+#define SYS_socket	281
+#define SYS_bind	282
+#define SYS_connect	283
+#define SYS_listen	284
+#define SYS_accept	285
+#define SYS_getsockname	286
+#define SYS_getpeername	287
+#define SYS_socketpair	288
+#define SYS_send	289
+#define SYS_sendto	290
+#define SYS_recv	291
+#define SYS_recvfrom	292
+#define SYS_shutdown	293
+#define SYS_setsockopt	294
+#define SYS_getsockopt	295
+#define SYS_sendmsg	296
+#define SYS_recvmsg	297
+#define SYS_semop	298
+#define SYS_semget	299
+#define SYS_semctl	300
+#define SYS_msgsnd	301
+#define SYS_msgrcv	302
+#define SYS_msgget	303
+#define SYS_msgctl	304
+#define SYS_shmat	305
+#define SYS_shmdt	306
+#define SYS_shmget	307
+#define SYS_shmctl	308
+#define SYS_add_key	309
+#define SYS_request_key	310
+#define SYS_keyctl	311
+#define SYS_semtimedop	312
+#define SYS_vserver	313
+#define SYS_ioprio_set	314
+#define SYS_ioprio_get	315
+#define SYS_inotify_init	316
+#define SYS_inotify_add_watch	317
+#define SYS_inotify_rm_watch	318
+#define SYS_mbind	319
+#define SYS_get_mempolicy	320
+#define SYS_set_mempolicy	321
+#define SYS_openat	322
+#define SYS_mkdirat	323
+#define SYS_mknodat	324
+#define SYS_fchownat	325
+#define SYS_futimesat	326
+#define SYS_fstatat64	327
+#define SYS_unlinkat	328
+#define SYS_renameat	329
+#define SYS_linkat	330
+#define SYS_symlinkat	331
+#define SYS_readlinkat	332
+#define SYS_fchmodat	333
+#define SYS_faccessat	334
+#define SYS_pselect6	335
+#define SYS_ppoll	336
+#define SYS_unshare	337
+#define SYS_set_robust_list	338
+#define SYS_get_robust_list	339
+#define SYS_splice	340
+#define SYS_sync_file_range2	341
+#define SYS_arm_sync_file_range	341
+#define SYS_tee	342
+#define SYS_vmsplice	343
+#define SYS_move_pages	344
+#define SYS_getcpu	345
+#define SYS_epoll_pwait	346
+#define SYS_kexec_load	347
+#define SYS_utimensat	348
+#define SYS_signalfd	349
+#define SYS_timerfd_create	350
+#define SYS_eventfd	351
+#define SYS_fallocate	352
+#define SYS_timerfd_settime32	353
+#define SYS_timerfd_gettime32	354
+#define SYS_signalfd4	355
+#define SYS_eventfd2	356
+#define SYS_epoll_create1	357
+#define SYS_dup3	358
+#define SYS_pipe2	359
+#define SYS_inotify_init1	360
+#define SYS_preadv	361
+#define SYS_pwritev	362
+#define SYS_rt_tgsigqueueinfo	363
+#define SYS_perf_event_open	364
+#define SYS_recvmmsg	365
+#define SYS_accept4	366
+#define SYS_fanotify_init	367
+#define SYS_fanotify_mark	368
+#define SYS_prlimit64	369
+#define SYS_name_to_handle_at	370
+#define SYS_open_by_handle_at	371
+#define SYS_clock_adjtime	372
+#define SYS_syncfs	373
+#define SYS_sendmmsg	374
+#define SYS_setns	375
+#define SYS_process_vm_readv	376
+#define SYS_process_vm_writev	377
+#define SYS_kcmp		378
+#define SYS_finit_module	379
+#define SYS_sched_setattr	380
+#define SYS_sched_getattr	381
+#define SYS_renameat2	382
+#define SYS_seccomp	383
+#define SYS_getrandom	384
+#define SYS_memfd_create	385
+#define SYS_bpf	386
+#define SYS_execveat	387
+#define SYS_userfaultfd	388
+#define SYS_membarrier		389
+#define SYS_mlock2		390
+#define SYS_copy_file_range	391
+#define SYS_preadv2	392
+#define SYS_pwritev2	393
+#define SYS_pkey_mprotect	394
+#define SYS_pkey_alloc	395
+#define SYS_pkey_free	396
+#define SYS_statx	397
+#define SYS_rseq	398
+#define SYS_io_pgetevents	399
+#define SYS_migrate_pages	400
+#define SYS_kexec_file_load	401
+#define SYS_pidfd_send_signal	424
+#define SYS_io_uring_setup	425
+#define SYS_io_uring_enter	426
+#define SYS_io_uring_register	427
+#define SYS_open_tree		428
+#define SYS_move_mount		429
+#define SYS_fsopen		430
+#define SYS_fsconfig		431
+#define SYS_fsmount		432
+#define SYS_fspick		433
+#define SYS_pidfd_open		434
+#define SYS_clone3		435
+#define SYS_OHOS_BEGIN         500
+#define SYS_pthread_set_detach (__NR_OHOS_BEGIN + 0)
+#define SYS_pthread_join       (__NR_OHOS_BEGIN + 1)
+#define SYS_pthread_deatch     (__NR_OHOS_BEGIN + 2)
+#define SYS_creat_user_thread  (__NR_OHOS_BEGIN + 3)
+#define SYS_processcreat       (__NR_OHOS_BEGIN + 4)
+#define SYS_processtart        (__NR_OHOS_BEGIN + 5)
+#define SYS_printf             (__NR_OHOS_BEGIN + 6)
+#define SYS_dumpmemory         (__NR_OHOS_BEGIN + 13)
+#define SYS_mkfifo             (__NR_OHOS_BEGIN + 14)
+#define SYS_mqclose            (__NR_OHOS_BEGIN + 15)
+#define SYS_realpath           (__NR_OHOS_BEGIN + 16)
+#define SYS_format             (__NR_OHOS_BEGIN + 17)
+#define SYS_shellexec          (__NR_OHOS_BEGIN + 18)
+#define SYS_ohoscapget         (__NR_OHOS_BEGIN + 19)
+#define SYS_ohoscapset         (__NR_OHOS_BEGIN + 20)
+#define SYS_syscallend         (__NR_OHOS_BEGIN + 21)
diff --git a/third_party/musl/porting/liteos_m/kernel/include/bits/termios.h b/third_party/musl/porting/liteos_m/kernel/include/bits/termios.h
new file mode 100755
index 000000000..124f71d20
--- /dev/null
+++ b/third_party/musl/porting/liteos_m/kernel/include/bits/termios.h
@@ -0,0 +1,166 @@
+struct termios {
+	tcflag_t c_iflag;
+	tcflag_t c_oflag;
+	tcflag_t c_cflag;
+	tcflag_t c_lflag;
+	cc_t c_line;
+	cc_t c_cc[NCCS];
+	speed_t __c_ispeed;
+	speed_t __c_ospeed;
+};
+
+#define VINTR     0
+#define VQUIT     1
+#define VERASE    2
+#define VKILL     3
+#define VEOF      4
+#define VTIME     5
+#define VMIN      6
+#define VSWTC     7
+#define VSTART    8
+#define VSTOP     9
+#define VSUSP    10
+#define VEOL     11
+#define VREPRINT 12
+#define VDISCARD 13
+#define VWERASE  14
+#define VLNEXT   15
+#define VEOL2    16
+
+#define IGNBRK  0000001
+#define BRKINT  0000002
+#define IGNPAR  0000004
+#define PARMRK  0000010
+#define INPCK   0000020
+#define ISTRIP  0000040
+#define INLCR   0000100
+#define IGNCR   0000200
+#define ICRNL   0000400
+#define IUCLC   0001000
+#define IXON    0002000
+#define IXANY   0004000
+#define IXOFF   0010000
+#define IMAXBEL 0020000
+#define IUTF8   0040000
+
+#define OPOST  0000001
+#define OLCUC  0000002
+#define ONLCR  0000004
+#define OCRNL  0000010
+#define ONOCR  0000020
+#define ONLRET 0000040
+#define OFILL  0000100
+#define OFDEL  0000200
+#if defined(_GNU_SOURCE) || defined(_BSD_SOURCE) || defined(_XOPEN_SOURCE)
+#define NLDLY  0000400
+#define NL0    0000000
+#define NL1    0000400
+#define CRDLY  0003000
+#define CR0    0000000
+#define CR1    0001000
+#define CR2    0002000
+#define CR3    0003000
+#define TABDLY 0014000
+#define TAB0   0000000
+#define TAB1   0004000
+#define TAB2   0010000
+#define TAB3   0014000
+#define BSDLY  0020000
+#define BS0    0000000
+#define BS1    0020000
+#define FFDLY  0100000
+#define FF0    0000000
+#define FF1    0100000
+#endif
+
+#define VTDLY  0040000
+#define VT0    0000000
+#define VT1    0040000
+
+#define B0       0000000
+#define B50      0000001
+#define B75      0000002
+#define B110     0000003
+#define B134     0000004
+#define B150     0000005
+#define B200     0000006
+#define B300     0000007
+#define B600     0000010
+#define B1200    0000011
+#define B1800    0000012
+#define B2400    0000013
+#define B4800    0000014
+#define B9600    0000015
+#define B19200   0000016
+#define B38400   0000017
+
+#define B57600   0010001
+#define B115200  0010002
+#define B230400  0010003
+#define B460800  0010004
+#define B500000  0010005
+#define B576000  0010006
+#define B921600  0010007
+#define B1000000 0010010
+#define B1152000 0010011
+#define B1500000 0010012
+#define B2000000 0010013
+#define B2500000 0010014
+#define B3000000 0010015
+#define B3500000 0010016
+#define B4000000 0010017
+
+#define CSIZE  0000060
+#define CS5    0000000
+#define CS6    0000020
+#define CS7    0000040
+#define CS8    0000060
+#define CSTOPB 0000100
+#define CREAD  0000200
+#define PARENB 0000400
+#define PARODD 0001000
+#define HUPCL  0002000
+#define CLOCAL 0004000
+
+#define ISIG   0000001
+#define ICANON 0000002
+#define ECHO   0000010
+#define ECHOE  0000020
+#define ECHOK  0000040
+#define ECHONL 0000100
+#define NOFLSH 0000200
+#define TOSTOP 0000400
+#define IEXTEN 0100000
+
+#define TCOOFF 0
+#define TCOON  1
+#define TCIOFF 2
+#define TCION  3
+
+#define TCIFLUSH  0
+#define TCOFLUSH  1
+#define TCIOFLUSH 2
+
+#define TCSANOW   0
+#define TCSADRAIN 1
+#define TCSAFLUSH 2
+
+#if defined(_GNU_SOURCE) || defined(_BSD_SOURCE)
+#define EXTA    0000016
+#define EXTB    0000017
+#define CBAUD   0010017
+#define CBAUDEX 0010000
+#define CIBAUD  002003600000
+#define CMSPAR  010000000000
+#define CRTSCTS 020000000000
+
+#define XCASE   0000004
+#define ECHOCTL 0001000
+#define ECHOPRT 0002000
+#define ECHOKE  0004000
+#define FLUSHO  0010000
+#define PENDIN  0040000
+#define EXTPROC 0200000
+
+#define XTABS  0014000
+#endif
diff --git a/third_party/musl/porting/liteos_m/kernel/include/bits/user.h b/third_party/musl/porting/liteos_m/kernel/include/bits/user.h
new file mode 100755
index 000000000..3e5a4d21d
--- /dev/null
+++ b/third_party/musl/porting/liteos_m/kernel/include/bits/user.h
@@ -0,0 +1,36 @@
+typedef struct user_fpregs {
+	struct fp_reg {
+		unsigned sign1:1;
+		unsigned unused:15;
+		unsigned sign2:1;
+		unsigned exponent:14;
+		unsigned j:1;
+		unsigned mantissa1:31;
+		unsigned mantissa0:32;
+	} fpregs[8];
+	unsigned fpsr:32;
+	unsigned fpcr:32;
+	unsigned char ftype[8];
+	unsigned int init_flag;
+} elf_fpregset_t;
+
+struct user_regs {
+	unsigned long uregs[18];
+};
+#define ELF_NGREG 18
+typedef unsigned long elf_greg_t, elf_gregset_t[ELF_NGREG];
+
+struct user {
+	struct user_regs regs;
+	int u_fpvalid;
+	unsigned long u_tsize, u_dsize, u_ssize;
+	unsigned long start_code, start_stack;
+	long signal;
+	int reserved;
+	struct user_regs *u_ar0;
+	unsigned long magic;
+	char u_comm[32];
+	int u_debugreg[8];
+	struct user_fpregs u_fp;
+	struct user_fpregs *u_fp0;
+};
diff --git a/third_party/musl/porting/liteos_m/kernel/include/bits/vt.h b/third_party/musl/porting/liteos_m/kernel/include/bits/vt.h
new file mode 100755
index 000000000..834abfbc8
--- /dev/null
+++ b/third_party/musl/porting/liteos_m/kernel/include/bits/vt.h
@@ -0,0 +1 @@
+#include <linux/vt.h>
diff --git a/third_party/musl/porting/liteos_m/kernel/include/byteswap.h b/third_party/musl/porting/liteos_m/kernel/include/byteswap.h
new file mode 100755
index 000000000..00b9df3c9
--- /dev/null
+++ b/third_party/musl/porting/liteos_m/kernel/include/byteswap.h
@@ -0,0 +1,26 @@
+#ifndef _BYTESWAP_H
+#define _BYTESWAP_H
+
+#include <features.h>
+#include <stdint.h>
+
+static __inline uint16_t __bswap_16(uint16_t __x)
+{
+	return __x<<8 | __x>>8;
+}
+
+static __inline uint32_t __bswap_32(uint32_t __x)
+{
+	return __x>>24 | __x>>8&0xff00 | __x<<8&0xff0000 | __x<<24;
+}
+
+static __inline uint64_t __bswap_64(uint64_t __x)
+{
+	return __bswap_32(__x)+0ULL<<32 | __bswap_32(__x>>32);
+}
+
+#define bswap_16(x) __bswap_16(x)
+#define bswap_32(x) __bswap_32(x)
+#define bswap_64(x) __bswap_64(x)
+
+#endif
diff --git a/third_party/musl/porting/liteos_m/kernel/include/complex.h b/third_party/musl/porting/liteos_m/kernel/include/complex.h
new file mode 100755
index 000000000..e56b1c37d
--- /dev/null
+++ b/third_party/musl/porting/liteos_m/kernel/include/complex.h
@@ -0,0 +1,139 @@
+#ifndef _COMPLEX_H
+#define _COMPLEX_H
+
+#ifdef __ICCARM__ /* for iar */
+#include_next <complex.h>
+#else
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#define complex _Complex
+#ifdef __GNUC__
+#define _Complex_I (__extension__ (0.0f+1.0fi))
+#else
+#define _Complex_I (0.0f+1.0fi)
+#endif
+#define I _Complex_I
+
+double complex cacos(double complex);
+float complex cacosf(float complex);
+long double complex cacosl(long double complex);
+
+double complex casin(double complex);
+float complex casinf(float complex);
+long double complex casinl(long double complex);
+
+double complex catan(double complex);
+float complex catanf(float complex);
+long double complex catanl(long double complex);
+
+double complex ccos(double complex);
+float complex ccosf(float complex);
+long double complex ccosl(long double complex);
+
+double complex csin(double complex);
+float complex csinf(float complex);
+long double complex csinl(long double complex);
+
+double complex ctan(double complex);
+float complex ctanf(float complex);
+long double complex ctanl(long double complex);
+
+double complex cacosh(double complex);
+float complex cacoshf(float complex);
+long double complex cacoshl(long double complex);
+
+double complex casinh(double complex);
+float complex casinhf(float complex);
+long double complex casinhl(long double complex);
+
+double complex catanh(double complex);
+float complex catanhf(float complex);
+long double complex catanhl(long double complex);
+
+double complex ccosh(double complex);
+float complex ccoshf(float complex);
+long double complex ccoshl(long double complex);
+
+double complex csinh(double complex);
+float complex csinhf(float complex);
+long double complex csinhl(long double complex);
+
+double complex ctanh(double complex);
+float complex ctanhf(float complex);
+long double complex ctanhl(long double complex);
+
+double complex cexp(double complex);
+float complex cexpf(float complex);
+long double complex cexpl(long double complex);
+
+double complex clog(double complex);
+float complex clogf(float complex);
+long double complex clogl(long double complex);
+
+double cabs(double complex);
+float cabsf(float complex);
+long double cabsl(long double complex);
+
+double complex cpow(double complex, double complex);
+float complex cpowf(float complex, float complex);
+long double complex cpowl(long double complex, long double complex);
+
+double complex csqrt(double complex);
+float complex csqrtf(float complex);
+long double complex csqrtl(long double complex);
+
+double carg(double complex);
+float cargf(float complex);
+long double cargl(long double complex);
+
+double cimag(double complex);
+float cimagf(float complex);
+long double cimagl(long double complex);
+
+double complex conj(double complex);
+float complex conjf(float complex);
+long double complex conjl(long double complex);
+
+double complex cproj(double complex);
+float complex cprojf(float complex);
+long double complex cprojl(long double complex);
+
+double creal(double complex);
+float crealf(float complex);
+long double creall(long double complex);
+
+#ifndef __cplusplus
+#define __CIMAG(x, t) \
+	(+(union { _Complex t __z; t __xy[2]; }){(_Complex t)(x)}.__xy[1])
+
+#define creal(x) ((double)(x))
+#define crealf(x) ((float)(x))
+#define creall(x) ((long double)(x))
+
+#define cimag(x) __CIMAG(x, double)
+#define cimagf(x) __CIMAG(x, float)
+#define cimagl(x) __CIMAG(x, long double)
+#endif
+
+#if __STDC_VERSION__ >= 201112L
+#if defined(_Imaginary_I)
+#define __CMPLX(x, y, t) ((t)(x) + _Imaginary_I*(t)(y))
+#elif defined(__clang__)
+#define __CMPLX(x, y, t) (+(_Complex t){ (t)(x), (t)(y) })
+#else
+#define __CMPLX(x, y, t) (__builtin_complex((t)(x), (t)(y)))
+#endif
+#define CMPLX(x, y) __CMPLX(x, y, double)
+#define CMPLXF(x, y) __CMPLX(x, y, float)
+#define CMPLXL(x, y) __CMPLX(x, y, long double)
+#endif
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* __ICCARM__ */
+#endif
diff --git a/third_party/musl/porting/liteos_m/kernel/include/cpio.h b/third_party/musl/porting/liteos_m/kernel/include/cpio.h
new file mode 100755
index 000000000..39a1f8bba
--- /dev/null
+++ b/third_party/musl/porting/liteos_m/kernel/include/cpio.h
@@ -0,0 +1,29 @@
+#ifndef _CPIO_H
+#define _CPIO_H
+
+#define MAGIC "070707"
+
+#define C_IRUSR  000400
+#define C_IWUSR  000200
+#define C_IXUSR  000100
+#define C_IRGRP  000040
+#define C_IWGRP  000020
+#define C_IXGRP  000010
+#define C_IROTH  000004
+#define C_IWOTH  000002
+#define C_IXOTH  000001
+
+#define C_ISUID  004000
+#define C_ISGID  002000
+#define C_ISVTX  001000
+
+#define C_ISBLK  060000
+#define C_ISCHR  020000
+#define C_ISDIR  040000
+#define C_ISFIFO 010000
+#define C_ISSOCK 0140000
+#define C_ISLNK  0120000
+#define C_ISCTG  0110000
+#define C_ISREG  0100000
+
+#endif
diff --git a/third_party/musl/porting/liteos_m/kernel/include/crypt.h b/third_party/musl/porting/liteos_m/kernel/include/crypt.h
new file mode 100755
index 000000000..07de21698
--- /dev/null
+++ b/third_party/musl/porting/liteos_m/kernel/include/crypt.h
@@ -0,0 +1,20 @@
+#ifndef _CRYPT_H
+#define _CRYPT_H
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+struct crypt_data {
+	int initialized;
+	char __buf[256];
+};
+
+char *crypt(const char *, const char *);
+char *crypt_r(const char *, const char *, struct crypt_data *);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
diff --git a/third_party/musl/porting/liteos_m/kernel/include/ctype.h b/third_party/musl/porting/liteos_m/kernel/include/ctype.h
new file mode 100755
index 000000000..61e826d05
--- /dev/null
+++ b/third_party/musl/porting/liteos_m/kernel/include/ctype.h
@@ -0,0 +1,80 @@
+#ifndef	_CTYPE_H
+#define	_CTYPE_H
+
+#ifdef __ICCARM__ /* for iar */
+#include_next <ctype.h>
+#else
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#include <features.h>
+
+int   isalnum(int);
+int   isalpha(int);
+int   isblank(int);
+int   iscntrl(int);
+int   isdigit(int);
+int   isgraph(int);
+int   islower(int);
+int   isprint(int);
+int   ispunct(int);
+int   isspace(int);
+int   isupper(int);
+int   isxdigit(int);
+int   tolower(int);
+int   toupper(int);
+
+#ifndef __cplusplus
+static __inline int __isspace(int _c)
+{
+	return _c == ' ' || (unsigned)_c-'\t' < 5;
+}
+
+#define isalpha(a) (0 ? isalpha(a) : (((unsigned)(a)|32)-'a') < 26)
+#define isdigit(a) (0 ? isdigit(a) : ((unsigned)(a)-'0') < 10)
+#define islower(a) (0 ? islower(a) : ((unsigned)(a)-'a') < 26)
+#define isupper(a) (0 ? isupper(a) : ((unsigned)(a)-'A') < 26)
+#define isprint(a) (0 ? isprint(a) : ((unsigned)(a)-0x20) < 0x5f)
+#define isgraph(a) (0 ? isgraph(a) : ((unsigned)(a)-0x21) < 0x5e)
+#define isspace(a) __isspace(a)
+#endif
+
+
+#if defined(_POSIX_SOURCE) || defined(_POSIX_C_SOURCE) \
+ || defined(_XOPEN_SOURCE) || defined(_GNU_SOURCE) \
+ || defined(_BSD_SOURCE)
+
+#define __NEED_locale_t
+#include <bits/alltypes.h>
+
+int   isalnum_l(int, locale_t);
+int   isalpha_l(int, locale_t);
+int   isblank_l(int, locale_t);
+int   iscntrl_l(int, locale_t);
+int   isdigit_l(int, locale_t);
+int   isgraph_l(int, locale_t);
+int   islower_l(int, locale_t);
+int   isprint_l(int, locale_t);
+int   ispunct_l(int, locale_t);
+int   isspace_l(int, locale_t);
+int   isupper_l(int, locale_t);
+int   isxdigit_l(int, locale_t);
+int   tolower_l(int, locale_t);
+int   toupper_l(int, locale_t);
+
+int   isascii(int);
+int   toascii(int);
+#define _tolower(a) ((a)|0x20)
+#define _toupper(a) ((a)&0x5f)
+#define isascii(a) (0 ? isascii(a) : (unsigned)(a) < 128)
+
+#endif
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* __ICCARM__ */
+#endif
diff --git a/third_party/musl/porting/liteos_m/kernel/include/dirent.h b/third_party/musl/porting/liteos_m/kernel/include/dirent.h
new file mode 100755
index 000000000..650ecf646
--- /dev/null
+++ b/third_party/musl/porting/liteos_m/kernel/include/dirent.h
@@ -0,0 +1,75 @@
+#ifndef	_DIRENT_H
+#define	_DIRENT_H
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#include <features.h>
+
+#define __NEED_ino_t
+#define __NEED_off_t
+#if defined(_BSD_SOURCE) || defined(_GNU_SOURCE)
+#define __NEED_size_t
+#endif
+
+#include <bits/alltypes.h>
+
+#include <bits/dirent.h>
+
+typedef struct __dirstream DIR;
+
+#define d_fileno d_ino
+
+int            closedir(DIR *);
+DIR           *fdopendir(int);
+DIR           *opendir(const char *);
+struct dirent *readdir(DIR *);
+int            readdir_r(DIR *__restrict, struct dirent *__restrict, struct dirent **__restrict);
+void           rewinddir(DIR *);
+int            dirfd(DIR *);
+
+int alphasort(const struct dirent **, const struct dirent **);
+int scandir(const char *, struct dirent ***, int (*)(const struct dirent *), int (*)(const struct dirent **, const struct dirent **));
+
+#if defined(_XOPEN_SOURCE) || defined(_GNU_SOURCE) || defined(_BSD_SOURCE)
+void           seekdir(DIR *, long);
+long           telldir(DIR *);
+#endif
+
+#if defined(_GNU_SOURCE) || defined(_BSD_SOURCE)
+#define DT_UNKNOWN 0
+#define DT_FIFO 1
+#define DT_CHR 2
+#define DT_DIR 4
+#define DT_BLK 6
+#define DT_REG 8
+#define DT_LNK 10
+#define DT_SOCK 12
+#define DT_WHT 14
+#define IFTODT(x) ((x)>>12 & 017)
+#define DTTOIF(x) ((x)<<12)
+int getdents(int, struct dirent *, size_t);
+#endif
+
+#ifdef _GNU_SOURCE
+int versionsort(const struct dirent **, const struct dirent **);
+#endif
+
+#if defined(_LARGEFILE64_SOURCE) || defined(_GNU_SOURCE)
+#define dirent64 dirent
+#define readdir64 readdir
+#define readdir64_r readdir_r
+#define scandir64 scandir
+#define alphasort64 alphasort
+#define versionsort64 versionsort
+#define off64_t off_t
+#define ino64_t ino_t
+#define getdents64 getdents
+#endif
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
diff --git a/third_party/musl/porting/liteos_m/kernel/include/dlfcn.h b/third_party/musl/porting/liteos_m/kernel/include/dlfcn.h
new file mode 100755
index 000000000..13ab71dd0
--- /dev/null
+++ b/third_party/musl/porting/liteos_m/kernel/include/dlfcn.h
@@ -0,0 +1,46 @@
+#ifndef	_DLFCN_H
+#define	_DLFCN_H
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#include <features.h>
+
+#define RTLD_LAZY   1
+#define RTLD_NOW    2
+#define RTLD_NOLOAD 4
+#define RTLD_NODELETE 4096
+#define RTLD_GLOBAL 256
+#define RTLD_LOCAL  0
+
+#define RTLD_NEXT    ((void *)-1)
+#define RTLD_DEFAULT ((void *)0)
+
+#define RTLD_DI_LINKMAP 2
+
+int    dlclose(void *);
+char  *dlerror(void);
+void  *dlopen(const char *, int);
+void  *dlsym(void *__restrict, const char *__restrict);
+
+#if defined(_GNU_SOURCE) || defined(_BSD_SOURCE)
+typedef struct {
+	const char *dli_fname;
+	void *dli_fbase;
+	const char *dli_sname;
+	void *dli_saddr;
+} Dl_info;
+int dladdr(const void *, Dl_info *);
+int dlinfo(void *, int, void *);
+#endif
+
+#if _REDIR_TIME64
+__REDIR(dlsym, __dlsym_time64);
+#endif
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
diff --git a/third_party/musl/porting/liteos_m/kernel/include/elf.h b/third_party/musl/porting/liteos_m/kernel/include/elf.h
new file mode 100755
index 000000000..549f92c1a
--- /dev/null
+++ b/third_party/musl/porting/liteos_m/kernel/include/elf.h
@@ -0,0 +1,3292 @@
+#ifndef _ELF_H
+#define _ELF_H
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#include <stdint.h>
+
+typedef uint16_t Elf32_Half;
+typedef uint16_t Elf64_Half;
+
+typedef uint32_t Elf32_Word;
+typedef	int32_t  Elf32_Sword;
+typedef uint32_t Elf64_Word;
+typedef	int32_t  Elf64_Sword;
+
+typedef uint64_t Elf32_Xword;
+typedef	int64_t  Elf32_Sxword;
+typedef uint64_t Elf64_Xword;
+typedef	int64_t  Elf64_Sxword;
+
+typedef uint32_t Elf32_Addr;
+typedef uint64_t Elf64_Addr;
+
+typedef uint32_t Elf32_Off;
+typedef uint64_t Elf64_Off;
+
+typedef uint16_t Elf32_Section;
+typedef uint16_t Elf64_Section;
+
+typedef Elf32_Half Elf32_Versym;
+typedef Elf64_Half Elf64_Versym;
+
+#define EI_NIDENT (16)
+
+typedef struct {
+  unsigned char	e_ident[EI_NIDENT];
+  Elf32_Half	e_type;
+  Elf32_Half	e_machine;
+  Elf32_Word	e_version;
+  Elf32_Addr	e_entry;
+  Elf32_Off	e_phoff;
+  Elf32_Off	e_shoff;
+  Elf32_Word	e_flags;
+  Elf32_Half	e_ehsize;
+  Elf32_Half	e_phentsize;
+  Elf32_Half	e_phnum;
+  Elf32_Half	e_shentsize;
+  Elf32_Half	e_shnum;
+  Elf32_Half	e_shstrndx;
+} Elf32_Ehdr;
+
+typedef struct {
+  unsigned char	e_ident[EI_NIDENT];
+  Elf64_Half	e_type;
+  Elf64_Half	e_machine;
+  Elf64_Word	e_version;
+  Elf64_Addr	e_entry;
+  Elf64_Off	e_phoff;
+  Elf64_Off	e_shoff;
+  Elf64_Word	e_flags;
+  Elf64_Half	e_ehsize;
+  Elf64_Half	e_phentsize;
+  Elf64_Half	e_phnum;
+  Elf64_Half	e_shentsize;
+  Elf64_Half	e_shnum;
+  Elf64_Half	e_shstrndx;
+} Elf64_Ehdr;
+
+#define EI_MAG0		0
+#define ELFMAG0		0x7f
+
+#define EI_MAG1		1
+#define ELFMAG1		'E'
+
+#define EI_MAG2		2
+#define ELFMAG2		'L'
+
+#define EI_MAG3		3
+#define ELFMAG3		'F'
+
+
+#define	ELFMAG		"\177ELF"
+#define	SELFMAG		4
+
+#define EI_CLASS	4
+#define ELFCLASSNONE	0
+#define ELFCLASS32	1
+#define ELFCLASS64	2
+#define ELFCLASSNUM	3
+
+#define EI_DATA		5
+#define ELFDATANONE	0
+#define ELFDATA2LSB	1
+#define ELFDATA2MSB	2
+#define ELFDATANUM	3
+
+#define EI_VERSION	6
+
+
+#define EI_OSABI	7
+#define ELFOSABI_NONE		0
+#define ELFOSABI_SYSV		0
+#define ELFOSABI_HPUX		1
+#define ELFOSABI_NETBSD		2
+#define ELFOSABI_LINUX		3
+#define ELFOSABI_GNU		3
+#define ELFOSABI_SOLARIS	6
+#define ELFOSABI_AIX		7
+#define ELFOSABI_IRIX		8
+#define ELFOSABI_FREEBSD	9
+#define ELFOSABI_TRU64		10
+#define ELFOSABI_MODESTO	11
+#define ELFOSABI_OPENBSD	12
+#define ELFOSABI_ARM		97
+#define ELFOSABI_STANDALONE	255
+
+#define EI_ABIVERSION	8
+
+#define EI_PAD		9
+
+
+
+#define ET_NONE		0
+#define ET_REL		1
+#define ET_EXEC		2
+#define ET_DYN		3
+#define ET_CORE		4
+#define	ET_NUM		5
+#define ET_LOOS		0xfe00
+#define ET_HIOS		0xfeff
+#define ET_LOPROC	0xff00
+#define ET_HIPROC	0xffff
+
+
+
+#define EM_NONE		 0
+#define EM_M32		 1
+#define EM_SPARC	 2
+#define EM_386		 3
+#define EM_68K		 4
+#define EM_88K		 5
+#define EM_860		 7
+#define EM_MIPS		 8
+#define EM_S370		 9
+#define EM_MIPS_RS3_LE	10
+
+#define EM_PARISC	15
+#define EM_VPP500	17
+#define EM_SPARC32PLUS	18
+#define EM_960		19
+#define EM_PPC		20
+#define EM_PPC64	21
+#define EM_S390		22
+
+#define EM_V800		36
+#define EM_FR20		37
+#define EM_RH32		38
+#define EM_RCE		39
+#define EM_ARM		40
+#define EM_FAKE_ALPHA	41
+#define EM_SH		42
+#define EM_SPARCV9	43
+#define EM_TRICORE	44
+#define EM_ARC		45
+#define EM_H8_300	46
+#define EM_H8_300H	47
+#define EM_H8S		48
+#define EM_H8_500	49
+#define EM_IA_64	50
+#define EM_MIPS_X	51
+#define EM_COLDFIRE	52
+#define EM_68HC12	53
+#define EM_MMA		54
+#define EM_PCP		55
+#define EM_NCPU		56
+#define EM_NDR1		57
+#define EM_STARCORE	58
+#define EM_ME16		59
+#define EM_ST100	60
+#define EM_TINYJ	61
+#define EM_X86_64	62
+#define EM_PDSP		63
+
+#define EM_FX66		66
+#define EM_ST9PLUS	67
+#define EM_ST7		68
+#define EM_68HC16	69
+#define EM_68HC11	70
+#define EM_68HC08	71
+#define EM_68HC05	72
+#define EM_SVX		73
+#define EM_ST19		74
+#define EM_VAX		75
+#define EM_CRIS		76
+#define EM_JAVELIN	77
+#define EM_FIREPATH	78
+#define EM_ZSP		79
+#define EM_MMIX		80
+#define EM_HUANY	81
+#define EM_PRISM	82
+#define EM_AVR		83
+#define EM_FR30		84
+#define EM_D10V		85
+#define EM_D30V		86
+#define EM_V850		87
+#define EM_M32R		88
+#define EM_MN10300	89
+#define EM_MN10200	90
+#define EM_PJ		91
+#define EM_OR1K		92
+#define EM_OPENRISC	92
+#define EM_ARC_A5	93
+#define EM_ARC_COMPACT	93
+#define EM_XTENSA	94
+#define EM_VIDEOCORE	95
+#define EM_TMM_GPP	96
+#define EM_NS32K	97
+#define EM_TPC		98
+#define EM_SNP1K	99
+#define EM_ST200	100
+#define EM_IP2K		101
+#define EM_MAX		102
+#define EM_CR		103
+#define EM_F2MC16	104
+#define EM_MSP430	105
+#define EM_BLACKFIN	106
+#define EM_SE_C33	107
+#define EM_SEP		108
+#define EM_ARCA		109
+#define EM_UNICORE	110
+#define EM_EXCESS	111
+#define EM_DXP		112
+#define EM_ALTERA_NIOS2 113
+#define EM_CRX		114
+#define EM_XGATE	115
+#define EM_C166		116
+#define EM_M16C		117
+#define EM_DSPIC30F	118
+#define EM_CE		119
+#define EM_M32C		120
+#define EM_TSK3000	131
+#define EM_RS08		132
+#define EM_SHARC	133
+#define EM_ECOG2	134
+#define EM_SCORE7	135
+#define EM_DSP24	136
+#define EM_VIDEOCORE3	137
+#define EM_LATTICEMICO32 138
+#define EM_SE_C17	139
+#define EM_TI_C6000	140
+#define EM_TI_C2000	141
+#define EM_TI_C5500	142
+#define EM_TI_ARP32	143
+#define EM_TI_PRU	144
+#define EM_MMDSP_PLUS	160
+#define EM_CYPRESS_M8C	161
+#define EM_R32C		162
+#define EM_TRIMEDIA	163
+#define EM_QDSP6	164
+#define EM_8051		165
+#define EM_STXP7X	166
+#define EM_NDS32	167
+#define EM_ECOG1X	168
+#define EM_MAXQ30	169
+#define EM_XIMO16	170
+#define EM_MANIK	171
+#define EM_CRAYNV2	172
+#define EM_RX		173
+#define EM_METAG	174
+#define EM_MCST_ELBRUS	175
+#define EM_ECOG16	176
+#define EM_CR16		177
+#define EM_ETPU		178
+#define EM_SLE9X	179
+#define EM_L10M		180
+#define EM_K10M		181
+#define EM_AARCH64	183
+#define EM_AVR32	185
+#define EM_STM8		186
+#define EM_TILE64	187
+#define EM_TILEPRO	188
+#define EM_MICROBLAZE	189
+#define EM_CUDA		190
+#define EM_TILEGX	191
+#define EM_CLOUDSHIELD	192
+#define EM_COREA_1ST	193
+#define EM_COREA_2ND	194
+#define EM_ARC_COMPACT2	195
+#define EM_OPEN8	196
+#define EM_RL78		197
+#define EM_VIDEOCORE5	198
+#define EM_78KOR	199
+#define EM_56800EX	200
+#define EM_BA1		201
+#define EM_BA2		202
+#define EM_XCORE	203
+#define EM_MCHP_PIC	204
+#define EM_KM32		210
+#define EM_KMX32	211
+#define EM_EMX16	212
+#define EM_EMX8		213
+#define EM_KVARC	214
+#define EM_CDP		215
+#define EM_COGE		216
+#define EM_COOL		217
+#define EM_NORC		218
+#define EM_CSR_KALIMBA	219
+#define EM_Z80		220
+#define EM_VISIUM	221
+#define EM_FT32		222
+#define EM_MOXIE	223
+#define EM_AMDGPU	224
+#define EM_RISCV	243
+#define EM_BPF		247
+#define EM_CSKY		252
+#define EM_NUM		253
+
+#define EM_ALPHA	0x9026
+
+#define EV_NONE		0
+#define EV_CURRENT	1
+#define EV_NUM		2
+
+typedef struct {
+  Elf32_Word	sh_name;
+  Elf32_Word	sh_type;
+  Elf32_Word	sh_flags;
+  Elf32_Addr	sh_addr;
+  Elf32_Off	sh_offset;
+  Elf32_Word	sh_size;
+  Elf32_Word	sh_link;
+  Elf32_Word	sh_info;
+  Elf32_Word	sh_addralign;
+  Elf32_Word	sh_entsize;
+} Elf32_Shdr;
+
+typedef struct {
+  Elf64_Word	sh_name;
+  Elf64_Word	sh_type;
+  Elf64_Xword	sh_flags;
+  Elf64_Addr	sh_addr;
+  Elf64_Off	sh_offset;
+  Elf64_Xword	sh_size;
+  Elf64_Word	sh_link;
+  Elf64_Word	sh_info;
+  Elf64_Xword	sh_addralign;
+  Elf64_Xword	sh_entsize;
+} Elf64_Shdr;
+
+
+
+#define SHN_UNDEF	0
+#define SHN_LORESERVE	0xff00
+#define SHN_LOPROC	0xff00
+#define SHN_BEFORE	0xff00
+
+#define SHN_AFTER	0xff01
+
+#define SHN_HIPROC	0xff1f
+#define SHN_LOOS	0xff20
+#define SHN_HIOS	0xff3f
+#define SHN_ABS		0xfff1
+#define SHN_COMMON	0xfff2
+#define SHN_XINDEX	0xffff
+#define SHN_HIRESERVE	0xffff
+
+
+
+#define SHT_NULL	  0
+#define SHT_PROGBITS	  1
+#define SHT_SYMTAB	  2
+#define SHT_STRTAB	  3
+#define SHT_RELA	  4
+#define SHT_HASH	  5
+#define SHT_DYNAMIC	  6
+#define SHT_NOTE	  7
+#define SHT_NOBITS	  8
+#define SHT_REL		  9
+#define SHT_SHLIB	  10
+#define SHT_DYNSYM	  11
+#define SHT_INIT_ARRAY	  14
+#define SHT_FINI_ARRAY	  15
+#define SHT_PREINIT_ARRAY 16
+#define SHT_GROUP	  17
+#define SHT_SYMTAB_SHNDX  18
+#define	SHT_NUM		  19
+#define SHT_LOOS	  0x60000000
+#define SHT_GNU_ATTRIBUTES 0x6ffffff5
+#define SHT_GNU_HASH	  0x6ffffff6
+#define SHT_GNU_LIBLIST	  0x6ffffff7
+#define SHT_CHECKSUM	  0x6ffffff8
+#define SHT_LOSUNW	  0x6ffffffa
+#define SHT_SUNW_move	  0x6ffffffa
+#define SHT_SUNW_COMDAT   0x6ffffffb
+#define SHT_SUNW_syminfo  0x6ffffffc
+#define SHT_GNU_verdef	  0x6ffffffd
+#define SHT_GNU_verneed	  0x6ffffffe
+#define SHT_GNU_versym	  0x6fffffff
+#define SHT_HISUNW	  0x6fffffff
+#define SHT_HIOS	  0x6fffffff
+#define SHT_LOPROC	  0x70000000
+#define SHT_HIPROC	  0x7fffffff
+#define SHT_LOUSER	  0x80000000
+#define SHT_HIUSER	  0x8fffffff
+
+#define SHF_WRITE	     (1 << 0)
+#define SHF_ALLOC	     (1 << 1)
+#define SHF_EXECINSTR	     (1 << 2)
+#define SHF_MERGE	     (1 << 4)
+#define SHF_STRINGS	     (1 << 5)
+#define SHF_INFO_LINK	     (1 << 6)
+#define SHF_LINK_ORDER	     (1 << 7)
+#define SHF_OS_NONCONFORMING (1 << 8)
+
+#define SHF_GROUP	     (1 << 9)
+#define SHF_TLS		     (1 << 10)
+#define SHF_COMPRESSED	     (1 << 11)
+#define SHF_MASKOS	     0x0ff00000
+#define SHF_MASKPROC	     0xf0000000
+#define SHF_ORDERED	     (1 << 30)
+#define SHF_EXCLUDE	     (1U << 31)
+
+typedef struct {
+  Elf32_Word	ch_type;
+  Elf32_Word	ch_size;
+  Elf32_Word	ch_addralign;
+} Elf32_Chdr;
+
+typedef struct {
+  Elf64_Word	ch_type;
+  Elf64_Word	ch_reserved;
+  Elf64_Xword	ch_size;
+  Elf64_Xword	ch_addralign;
+} Elf64_Chdr;
+
+#define ELFCOMPRESS_ZLIB	1
+#define ELFCOMPRESS_LOOS	0x60000000
+#define ELFCOMPRESS_HIOS	0x6fffffff
+#define ELFCOMPRESS_LOPROC	0x70000000
+#define ELFCOMPRESS_HIPROC	0x7fffffff
+
+
+#define GRP_COMDAT	0x1
+
+typedef struct {
+  Elf32_Word	st_name;
+  Elf32_Addr	st_value;
+  Elf32_Word	st_size;
+  unsigned char	st_info;
+  unsigned char	st_other;
+  Elf32_Section	st_shndx;
+} Elf32_Sym;
+
+typedef struct {
+  Elf64_Word	st_name;
+  unsigned char	st_info;
+  unsigned char st_other;
+  Elf64_Section	st_shndx;
+  Elf64_Addr	st_value;
+  Elf64_Xword	st_size;
+} Elf64_Sym;
+
+typedef struct {
+  Elf32_Half si_boundto;
+  Elf32_Half si_flags;
+} Elf32_Syminfo;
+
+typedef struct {
+  Elf64_Half si_boundto;
+  Elf64_Half si_flags;
+} Elf64_Syminfo;
+
+#define SYMINFO_BT_SELF		0xffff
+#define SYMINFO_BT_PARENT	0xfffe
+#define SYMINFO_BT_LOWRESERVE	0xff00
+
+#define SYMINFO_FLG_DIRECT	0x0001
+#define SYMINFO_FLG_PASSTHRU	0x0002
+#define SYMINFO_FLG_COPY	0x0004
+#define SYMINFO_FLG_LAZYLOAD	0x0008
+
+#define SYMINFO_NONE		0
+#define SYMINFO_CURRENT		1
+#define SYMINFO_NUM		2
+
+#define ELF32_ST_BIND(val)		(((unsigned char) (val)) >> 4)
+#define ELF32_ST_TYPE(val)		((val) & 0xf)
+#define ELF32_ST_INFO(bind, type)	(((bind) << 4) + ((type) & 0xf))
+
+#define ELF64_ST_BIND(val)		ELF32_ST_BIND (val)
+#define ELF64_ST_TYPE(val)		ELF32_ST_TYPE (val)
+#define ELF64_ST_INFO(bind, type)	ELF32_ST_INFO ((bind), (type))
+
+#define STB_LOCAL	0
+#define STB_GLOBAL	1
+#define STB_WEAK	2
+#define	STB_NUM		3
+#define STB_LOOS	10
+#define STB_GNU_UNIQUE	10
+#define STB_HIOS	12
+#define STB_LOPROC	13
+#define STB_HIPROC	15
+
+#define STT_NOTYPE	0
+#define STT_OBJECT	1
+#define STT_FUNC	2
+#define STT_SECTION	3
+#define STT_FILE	4
+#define STT_COMMON	5
+#define STT_TLS		6
+#define	STT_NUM		7
+#define STT_LOOS	10
+#define STT_GNU_IFUNC	10
+#define STT_HIOS	12
+#define STT_LOPROC	13
+#define STT_HIPROC	15
+
+#define STN_UNDEF	0
+
+#define ELF32_ST_VISIBILITY(o)	((o) & 0x03)
+#define ELF64_ST_VISIBILITY(o)	ELF32_ST_VISIBILITY (o)
+
+#define STV_DEFAULT	0
+#define STV_INTERNAL	1
+#define STV_HIDDEN	2
+#define STV_PROTECTED	3
+
+
+
+
+typedef struct {
+  Elf32_Addr	r_offset;
+  Elf32_Word	r_info;
+} Elf32_Rel;
+
+typedef struct {
+  Elf64_Addr	r_offset;
+  Elf64_Xword	r_info;
+} Elf64_Rel;
+
+
+
+typedef struct {
+  Elf32_Addr	r_offset;
+  Elf32_Word	r_info;
+  Elf32_Sword	r_addend;
+} Elf32_Rela;
+
+typedef struct {
+  Elf64_Addr	r_offset;
+  Elf64_Xword	r_info;
+  Elf64_Sxword	r_addend;
+} Elf64_Rela;
+
+
+
+#define ELF32_R_SYM(val)		((val) >> 8)
+#define ELF32_R_TYPE(val)		((val) & 0xff)
+#define ELF32_R_INFO(sym, type)		(((sym) << 8) + ((type) & 0xff))
+
+#define ELF64_R_SYM(i)			((i) >> 32)
+#define ELF64_R_TYPE(i)			((i) & 0xffffffff)
+#define ELF64_R_INFO(sym,type)		((((Elf64_Xword) (sym)) << 32) + (type))
+
+
+
+typedef struct {
+  Elf32_Word	p_type;
+  Elf32_Off	p_offset;
+  Elf32_Addr	p_vaddr;
+  Elf32_Addr	p_paddr;
+  Elf32_Word	p_filesz;
+  Elf32_Word	p_memsz;
+  Elf32_Word	p_flags;
+  Elf32_Word	p_align;
+} Elf32_Phdr;
+
+typedef struct {
+  Elf64_Word	p_type;
+  Elf64_Word	p_flags;
+  Elf64_Off	p_offset;
+  Elf64_Addr	p_vaddr;
+  Elf64_Addr	p_paddr;
+  Elf64_Xword	p_filesz;
+  Elf64_Xword	p_memsz;
+  Elf64_Xword	p_align;
+} Elf64_Phdr;
+
+
+
+#define	PT_NULL		0
+#define PT_LOAD		1
+#define PT_DYNAMIC	2
+#define PT_INTERP	3
+#define PT_NOTE		4
+#define PT_SHLIB	5
+#define PT_PHDR		6
+#define PT_TLS		7
+#define	PT_NUM		8
+#define PT_LOOS		0x60000000
+#define PT_GNU_EH_FRAME	0x6474e550
+#define PT_GNU_STACK	0x6474e551
+#define PT_GNU_RELRO	0x6474e552
+#define PT_LOSUNW	0x6ffffffa
+#define PT_SUNWBSS	0x6ffffffa
+#define PT_SUNWSTACK	0x6ffffffb
+#define PT_HISUNW	0x6fffffff
+#define PT_HIOS		0x6fffffff
+#define PT_LOPROC	0x70000000
+#define PT_HIPROC	0x7fffffff
+
+
+#define PN_XNUM 0xffff
+
+
+#define PF_X		(1 << 0)
+#define PF_W		(1 << 1)
+#define PF_R		(1 << 2)
+#define PF_MASKOS	0x0ff00000
+#define PF_MASKPROC	0xf0000000
+
+
+
+#define NT_PRSTATUS	1
+#define NT_PRFPREG	2
+#define NT_FPREGSET	2
+#define NT_PRPSINFO	3
+#define NT_PRXREG	4
+#define NT_TASKSTRUCT	4
+#define NT_PLATFORM	5
+#define NT_AUXV		6
+#define NT_GWINDOWS	7
+#define NT_ASRS		8
+#define NT_PSTATUS	10
+#define NT_PSINFO	13
+#define NT_PRCRED	14
+#define NT_UTSNAME	15
+#define NT_LWPSTATUS	16
+#define NT_LWPSINFO	17
+#define NT_PRFPXREG	20
+#define NT_SIGINFO	0x53494749
+#define NT_FILE		0x46494c45
+#define NT_PRXFPREG	0x46e62b7f
+#define NT_PPC_VMX	0x100
+#define NT_PPC_SPE	0x101
+#define NT_PPC_VSX	0x102
+#define NT_PPC_TAR	0x103
+#define NT_PPC_PPR	0x104
+#define NT_PPC_DSCR	0x105
+#define NT_PPC_EBB	0x106
+#define NT_PPC_PMU	0x107
+#define NT_PPC_TM_CGPR	0x108
+#define NT_PPC_TM_CFPR	0x109
+#define NT_PPC_TM_CVMX	0x10a
+#define NT_PPC_TM_CVSX	0x10b
+#define NT_PPC_TM_SPR	0x10c
+#define NT_PPC_TM_CTAR	0x10d
+#define NT_PPC_TM_CPPR	0x10e
+#define NT_PPC_TM_CDSCR	0x10f
+#define NT_386_TLS	0x200
+#define NT_386_IOPERM	0x201
+#define NT_X86_XSTATE	0x202
+#define NT_S390_HIGH_GPRS	0x300
+#define NT_S390_TIMER	0x301
+#define NT_S390_TODCMP	0x302
+#define NT_S390_TODPREG	0x303
+#define NT_S390_CTRS	0x304
+#define NT_S390_PREFIX	0x305
+#define NT_S390_LAST_BREAK	0x306
+#define NT_S390_SYSTEM_CALL	0x307
+#define NT_S390_TDB	0x308
+#define NT_S390_VXRS_LOW	0x309
+#define NT_S390_VXRS_HIGH	0x30a
+#define NT_S390_GS_CB	0x30b
+#define NT_S390_GS_BC	0x30c
+#define NT_S390_RI_CB	0x30d
+#define NT_ARM_VFP	0x400
+#define NT_ARM_TLS	0x401
+#define NT_ARM_HW_BREAK	0x402
+#define NT_ARM_HW_WATCH	0x403
+#define NT_ARM_SYSTEM_CALL	0x404
+#define NT_ARM_SVE	0x405
+#define NT_ARM_PAC_MASK	0x406
+#define NT_ARM_PACA_KEYS	0x407
+#define NT_ARM_PACG_KEYS	0x408
+#define NT_METAG_CBUF	0x500
+#define NT_METAG_RPIPE	0x501
+#define NT_METAG_TLS	0x502
+#define NT_ARC_V2	0x600
+#define NT_VMCOREDD	0x700
+#define NT_MIPS_DSP	0x800
+#define NT_MIPS_FP_MODE	0x801
+#define NT_MIPS_MSA	0x802
+#define NT_VERSION	1
+
+
+
+
+typedef struct {
+  Elf32_Sword d_tag;
+  union {
+      Elf32_Word d_val;
+      Elf32_Addr d_ptr;
+  } d_un;
+} Elf32_Dyn;
+
+typedef struct {
+  Elf64_Sxword d_tag;
+  union {
+      Elf64_Xword d_val;
+      Elf64_Addr d_ptr;
+  } d_un;
+} Elf64_Dyn;
+
+
+
+#define DT_NULL		0
+#define DT_NEEDED	1
+#define DT_PLTRELSZ	2
+#define DT_PLTGOT	3
+#define DT_HASH		4
+#define DT_STRTAB	5
+#define DT_SYMTAB	6
+#define DT_RELA		7
+#define DT_RELASZ	8
+#define DT_RELAENT	9
+#define DT_STRSZ	10
+#define DT_SYMENT	11
+#define DT_INIT		12
+#define DT_FINI		13
+#define DT_SONAME	14
+#define DT_RPATH	15
+#define DT_SYMBOLIC	16
+#define DT_REL		17
+#define DT_RELSZ	18
+#define DT_RELENT	19
+#define DT_PLTREL	20
+#define DT_DEBUG	21
+#define DT_TEXTREL	22
+#define DT_JMPREL	23
+#define	DT_BIND_NOW	24
+#define	DT_INIT_ARRAY	25
+#define	DT_FINI_ARRAY	26
+#define	DT_INIT_ARRAYSZ	27
+#define	DT_FINI_ARRAYSZ	28
+#define DT_RUNPATH	29
+#define DT_FLAGS	30
+#define DT_ENCODING	32
+#define DT_PREINIT_ARRAY 32
+#define DT_PREINIT_ARRAYSZ 33
+#define DT_SYMTAB_SHNDX	34
+#define	DT_NUM		35
+#define DT_LOOS		0x6000000d
+#define DT_HIOS		0x6ffff000
+#define DT_LOPROC	0x70000000
+#define DT_HIPROC	0x7fffffff
+#define	DT_PROCNUM	DT_MIPS_NUM
+
+#define DT_VALRNGLO	0x6ffffd00
+#define DT_GNU_PRELINKED 0x6ffffdf5
+#define DT_GNU_CONFLICTSZ 0x6ffffdf6
+#define DT_GNU_LIBLISTSZ 0x6ffffdf7
+#define DT_CHECKSUM	0x6ffffdf8
+#define DT_PLTPADSZ	0x6ffffdf9
+#define DT_MOVEENT	0x6ffffdfa
+#define DT_MOVESZ	0x6ffffdfb
+#define DT_FEATURE_1	0x6ffffdfc
+#define DT_POSFLAG_1	0x6ffffdfd
+
+#define DT_SYMINSZ	0x6ffffdfe
+#define DT_SYMINENT	0x6ffffdff
+#define DT_VALRNGHI	0x6ffffdff
+#define DT_VALTAGIDX(tag)	(DT_VALRNGHI - (tag))
+#define DT_VALNUM 12
+
+#define DT_ADDRRNGLO	0x6ffffe00
+#define DT_GNU_HASH	0x6ffffef5
+#define DT_TLSDESC_PLT	0x6ffffef6
+#define DT_TLSDESC_GOT	0x6ffffef7
+#define DT_GNU_CONFLICT	0x6ffffef8
+#define DT_GNU_LIBLIST	0x6ffffef9
+#define DT_CONFIG	0x6ffffefa
+#define DT_DEPAUDIT	0x6ffffefb
+#define DT_AUDIT	0x6ffffefc
+#define	DT_PLTPAD	0x6ffffefd
+#define	DT_MOVETAB	0x6ffffefe
+#define DT_SYMINFO	0x6ffffeff
+#define DT_ADDRRNGHI	0x6ffffeff
+#define DT_ADDRTAGIDX(tag)	(DT_ADDRRNGHI - (tag))
+#define DT_ADDRNUM 11
+
+
+
+#define DT_VERSYM	0x6ffffff0
+
+#define DT_RELACOUNT	0x6ffffff9
+#define DT_RELCOUNT	0x6ffffffa
+
+
+#define DT_FLAGS_1	0x6ffffffb
+#define	DT_VERDEF	0x6ffffffc
+
+#define	DT_VERDEFNUM	0x6ffffffd
+#define	DT_VERNEED	0x6ffffffe
+
+#define	DT_VERNEEDNUM	0x6fffffff
+#define DT_VERSIONTAGIDX(tag)	(DT_VERNEEDNUM - (tag))
+#define DT_VERSIONTAGNUM 16
+
+
+
+#define DT_AUXILIARY    0x7ffffffd
+#define DT_FILTER       0x7fffffff
+#define DT_EXTRATAGIDX(tag)	((Elf32_Word)-((Elf32_Sword) (tag) <<1>>1)-1)
+#define DT_EXTRANUM	3
+
+
+#define DF_ORIGIN	0x00000001
+#define DF_SYMBOLIC	0x00000002
+#define DF_TEXTREL	0x00000004
+#define DF_BIND_NOW	0x00000008
+#define DF_STATIC_TLS	0x00000010
+
+
+
+#define DF_1_NOW	0x00000001
+#define DF_1_GLOBAL	0x00000002
+#define DF_1_GROUP	0x00000004
+#define DF_1_NODELETE	0x00000008
+#define DF_1_LOADFLTR	0x00000010
+#define DF_1_INITFIRST	0x00000020
+#define DF_1_NOOPEN	0x00000040
+#define DF_1_ORIGIN	0x00000080
+#define DF_1_DIRECT	0x00000100
+#define DF_1_TRANS	0x00000200
+#define DF_1_INTERPOSE	0x00000400
+#define DF_1_NODEFLIB	0x00000800
+#define DF_1_NODUMP	0x00001000
+#define DF_1_CONFALT	0x00002000
+#define DF_1_ENDFILTEE	0x00004000
+#define	DF_1_DISPRELDNE	0x00008000
+#define	DF_1_DISPRELPND	0x00010000
+#define	DF_1_NODIRECT	0x00020000
+#define	DF_1_IGNMULDEF	0x00040000
+#define	DF_1_NOKSYMS	0x00080000
+#define	DF_1_NOHDR	0x00100000
+#define	DF_1_EDITED	0x00200000
+#define	DF_1_NORELOC	0x00400000
+#define	DF_1_SYMINTPOSE	0x00800000
+#define	DF_1_GLOBAUDIT	0x01000000
+#define	DF_1_SINGLETON	0x02000000
+#define	DF_1_STUB	0x04000000
+#define	DF_1_PIE	0x08000000
+
+#define DTF_1_PARINIT	0x00000001
+#define DTF_1_CONFEXP	0x00000002
+
+
+#define DF_P1_LAZYLOAD	0x00000001
+#define DF_P1_GROUPPERM	0x00000002
+
+
+
+
+typedef struct {
+  Elf32_Half	vd_version;
+  Elf32_Half	vd_flags;
+  Elf32_Half	vd_ndx;
+  Elf32_Half	vd_cnt;
+  Elf32_Word	vd_hash;
+  Elf32_Word	vd_aux;
+  Elf32_Word	vd_next;
+} Elf32_Verdef;
+
+typedef struct {
+  Elf64_Half	vd_version;
+  Elf64_Half	vd_flags;
+  Elf64_Half	vd_ndx;
+  Elf64_Half	vd_cnt;
+  Elf64_Word	vd_hash;
+  Elf64_Word	vd_aux;
+  Elf64_Word	vd_next;
+} Elf64_Verdef;
+
+
+
+#define VER_DEF_NONE	0
+#define VER_DEF_CURRENT	1
+#define VER_DEF_NUM	2
+
+
+#define VER_FLG_BASE	0x1
+#define VER_FLG_WEAK	0x2
+
+
+#define	VER_NDX_LOCAL		0
+#define	VER_NDX_GLOBAL		1
+#define	VER_NDX_LORESERVE	0xff00
+#define	VER_NDX_ELIMINATE	0xff01
+
+
+
+typedef struct {
+  Elf32_Word	vda_name;
+  Elf32_Word	vda_next;
+} Elf32_Verdaux;
+
+typedef struct {
+  Elf64_Word	vda_name;
+  Elf64_Word	vda_next;
+} Elf64_Verdaux;
+
+
+
+
+typedef struct {
+  Elf32_Half	vn_version;
+  Elf32_Half	vn_cnt;
+  Elf32_Word	vn_file;
+  Elf32_Word	vn_aux;
+  Elf32_Word	vn_next;
+} Elf32_Verneed;
+
+typedef struct {
+  Elf64_Half	vn_version;
+  Elf64_Half	vn_cnt;
+  Elf64_Word	vn_file;
+  Elf64_Word	vn_aux;
+  Elf64_Word	vn_next;
+} Elf64_Verneed;
+
+
+
+#define VER_NEED_NONE	 0
+#define VER_NEED_CURRENT 1
+#define VER_NEED_NUM	 2
+
+
+
+typedef struct {
+  Elf32_Word	vna_hash;
+  Elf32_Half	vna_flags;
+  Elf32_Half	vna_other;
+  Elf32_Word	vna_name;
+  Elf32_Word	vna_next;
+} Elf32_Vernaux;
+
+typedef struct {
+  Elf64_Word	vna_hash;
+  Elf64_Half	vna_flags;
+  Elf64_Half	vna_other;
+  Elf64_Word	vna_name;
+  Elf64_Word	vna_next;
+} Elf64_Vernaux;
+
+
+
+#define VER_FLG_WEAK	0x2
+
+
+
+typedef struct {
+  uint32_t a_type;
+  union {
+      uint32_t a_val;
+  } a_un;
+} Elf32_auxv_t;
+
+typedef struct {
+  uint64_t a_type;
+  union {
+      uint64_t a_val;
+  } a_un;
+} Elf64_auxv_t;
+
+
+
+#define AT_NULL		0
+#define AT_IGNORE	1
+#define AT_EXECFD	2
+#define AT_PHDR		3
+#define AT_PHENT	4
+#define AT_PHNUM	5
+#define AT_PAGESZ	6
+#define AT_BASE		7
+#define AT_FLAGS	8
+#define AT_ENTRY	9
+#define AT_NOTELF	10
+#define AT_UID		11
+#define AT_EUID		12
+#define AT_GID		13
+#define AT_EGID		14
+#define AT_CLKTCK	17
+
+
+#define AT_PLATFORM	15
+#define AT_HWCAP	16
+
+
+
+
+#define AT_FPUCW	18
+
+
+#define AT_DCACHEBSIZE	19
+#define AT_ICACHEBSIZE	20
+#define AT_UCACHEBSIZE	21
+
+
+
+#define AT_IGNOREPPC	22
+
+#define	AT_SECURE	23
+
+#define AT_BASE_PLATFORM 24
+
+#define AT_RANDOM	25
+
+#define AT_HWCAP2	26
+
+#define AT_EXECFN	31
+
+
+
+#define AT_SYSINFO	32
+#define AT_SYSINFO_EHDR	33
+
+
+
+#define AT_L1I_CACHESHAPE	34
+#define AT_L1D_CACHESHAPE	35
+#define AT_L2_CACHESHAPE	36
+#define AT_L3_CACHESHAPE	37
+
+#define AT_L1I_CACHESIZE	40
+#define AT_L1I_CACHEGEOMETRY	41
+#define AT_L1D_CACHESIZE	42
+#define AT_L1D_CACHEGEOMETRY	43
+#define AT_L2_CACHESIZE		44
+#define AT_L2_CACHEGEOMETRY	45
+#define AT_L3_CACHESIZE		46
+#define AT_L3_CACHEGEOMETRY	47
+
+#define AT_MINSIGSTKSZ		51
+
+
+typedef struct {
+  Elf32_Word n_namesz;
+  Elf32_Word n_descsz;
+  Elf32_Word n_type;
+} Elf32_Nhdr;
+
+typedef struct {
+  Elf64_Word n_namesz;
+  Elf64_Word n_descsz;
+  Elf64_Word n_type;
+} Elf64_Nhdr;
+
+
+
+
+#define ELF_NOTE_SOLARIS	"SUNW Solaris"
+
+
+#define ELF_NOTE_GNU		"GNU"
+
+
+
+
+
+#define ELF_NOTE_PAGESIZE_HINT	1
+
+
+#define NT_GNU_ABI_TAG	1
+#define ELF_NOTE_ABI	NT_GNU_ABI_TAG
+
+
+
+#define ELF_NOTE_OS_LINUX	0
+#define ELF_NOTE_OS_GNU		1
+#define ELF_NOTE_OS_SOLARIS2	2
+#define ELF_NOTE_OS_FREEBSD	3
+
+#define NT_GNU_BUILD_ID	3
+#define NT_GNU_GOLD_VERSION	4
+
+
+
+typedef struct {
+  Elf32_Xword m_value;
+  Elf32_Word m_info;
+  Elf32_Word m_poffset;
+  Elf32_Half m_repeat;
+  Elf32_Half m_stride;
+} Elf32_Move;
+
+typedef struct {
+  Elf64_Xword m_value;
+  Elf64_Xword m_info;
+  Elf64_Xword m_poffset;
+  Elf64_Half m_repeat;
+  Elf64_Half m_stride;
+} Elf64_Move;
+
+
+#define ELF32_M_SYM(info)	((info) >> 8)
+#define ELF32_M_SIZE(info)	((unsigned char) (info))
+#define ELF32_M_INFO(sym, size)	(((sym) << 8) + (unsigned char) (size))
+
+#define ELF64_M_SYM(info)	ELF32_M_SYM (info)
+#define ELF64_M_SIZE(info)	ELF32_M_SIZE (info)
+#define ELF64_M_INFO(sym, size)	ELF32_M_INFO (sym, size)
+
+#define EF_CPU32	0x00810000
+
+#define R_68K_NONE	0
+#define R_68K_32	1
+#define R_68K_16	2
+#define R_68K_8		3
+#define R_68K_PC32	4
+#define R_68K_PC16	5
+#define R_68K_PC8	6
+#define R_68K_GOT32	7
+#define R_68K_GOT16	8
+#define R_68K_GOT8	9
+#define R_68K_GOT32O	10
+#define R_68K_GOT16O	11
+#define R_68K_GOT8O	12
+#define R_68K_PLT32	13
+#define R_68K_PLT16	14
+#define R_68K_PLT8	15
+#define R_68K_PLT32O	16
+#define R_68K_PLT16O	17
+#define R_68K_PLT8O	18
+#define R_68K_COPY	19
+#define R_68K_GLOB_DAT	20
+#define R_68K_JMP_SLOT	21
+#define R_68K_RELATIVE	22
+#define R_68K_TLS_GD32	25
+#define R_68K_TLS_GD16	26
+#define R_68K_TLS_GD8	27
+#define R_68K_TLS_LDM32	28
+#define R_68K_TLS_LDM16	29
+#define R_68K_TLS_LDM8	30
+#define R_68K_TLS_LDO32	31
+#define R_68K_TLS_LDO16	32
+#define R_68K_TLS_LDO8	33
+#define R_68K_TLS_IE32	34
+#define R_68K_TLS_IE16	35
+#define R_68K_TLS_IE8	36
+#define R_68K_TLS_LE32	37
+#define R_68K_TLS_LE16	38
+#define R_68K_TLS_LE8	39
+#define R_68K_TLS_DTPMOD32	40
+#define R_68K_TLS_DTPREL32	41
+#define R_68K_TLS_TPREL32	42
+#define R_68K_NUM	43
+
+#define R_386_NONE	   0
+#define R_386_32	   1
+#define R_386_PC32	   2
+#define R_386_GOT32	   3
+#define R_386_PLT32	   4
+#define R_386_COPY	   5
+#define R_386_GLOB_DAT	   6
+#define R_386_JMP_SLOT	   7
+#define R_386_RELATIVE	   8
+#define R_386_GOTOFF	   9
+#define R_386_GOTPC	   10
+#define R_386_32PLT	   11
+#define R_386_TLS_TPOFF	   14
+#define R_386_TLS_IE	   15
+#define R_386_TLS_GOTIE	   16
+#define R_386_TLS_LE	   17
+#define R_386_TLS_GD	   18
+#define R_386_TLS_LDM	   19
+#define R_386_16	   20
+#define R_386_PC16	   21
+#define R_386_8		   22
+#define R_386_PC8	   23
+#define R_386_TLS_GD_32	   24
+#define R_386_TLS_GD_PUSH  25
+#define R_386_TLS_GD_CALL  26
+#define R_386_TLS_GD_POP   27
+#define R_386_TLS_LDM_32   28
+#define R_386_TLS_LDM_PUSH 29
+#define R_386_TLS_LDM_CALL 30
+#define R_386_TLS_LDM_POP  31
+#define R_386_TLS_LDO_32   32
+#define R_386_TLS_IE_32	   33
+#define R_386_TLS_LE_32	   34
+#define R_386_TLS_DTPMOD32 35
+#define R_386_TLS_DTPOFF32 36
+#define R_386_TLS_TPOFF32  37
+#define R_386_SIZE32       38
+#define R_386_TLS_GOTDESC  39
+#define R_386_TLS_DESC_CALL 40
+#define R_386_TLS_DESC     41
+#define R_386_IRELATIVE	   42
+#define R_386_GOT32X	   43
+#define R_386_NUM	   44
+
+
+
+
+
+#define STT_SPARC_REGISTER	13
+
+
+
+#define EF_SPARCV9_MM		3
+#define EF_SPARCV9_TSO		0
+#define EF_SPARCV9_PSO		1
+#define EF_SPARCV9_RMO		2
+#define EF_SPARC_LEDATA		0x800000
+#define EF_SPARC_EXT_MASK	0xFFFF00
+#define EF_SPARC_32PLUS		0x000100
+#define EF_SPARC_SUN_US1	0x000200
+#define EF_SPARC_HAL_R1		0x000400
+#define EF_SPARC_SUN_US3	0x000800
+
+
+
+#define R_SPARC_NONE		0
+#define R_SPARC_8		1
+#define R_SPARC_16		2
+#define R_SPARC_32		3
+#define R_SPARC_DISP8		4
+#define R_SPARC_DISP16		5
+#define R_SPARC_DISP32		6
+#define R_SPARC_WDISP30		7
+#define R_SPARC_WDISP22		8
+#define R_SPARC_HI22		9
+#define R_SPARC_22		10
+#define R_SPARC_13		11
+#define R_SPARC_LO10		12
+#define R_SPARC_GOT10		13
+#define R_SPARC_GOT13		14
+#define R_SPARC_GOT22		15
+#define R_SPARC_PC10		16
+#define R_SPARC_PC22		17
+#define R_SPARC_WPLT30		18
+#define R_SPARC_COPY		19
+#define R_SPARC_GLOB_DAT	20
+#define R_SPARC_JMP_SLOT	21
+#define R_SPARC_RELATIVE	22
+#define R_SPARC_UA32		23
+
+
+
+#define R_SPARC_PLT32		24
+#define R_SPARC_HIPLT22		25
+#define R_SPARC_LOPLT10		26
+#define R_SPARC_PCPLT32		27
+#define R_SPARC_PCPLT22		28
+#define R_SPARC_PCPLT10		29
+#define R_SPARC_10		30
+#define R_SPARC_11		31
+#define R_SPARC_64		32
+#define R_SPARC_OLO10		33
+#define R_SPARC_HH22		34
+#define R_SPARC_HM10		35
+#define R_SPARC_LM22		36
+#define R_SPARC_PC_HH22		37
+#define R_SPARC_PC_HM10		38
+#define R_SPARC_PC_LM22		39
+#define R_SPARC_WDISP16		40
+#define R_SPARC_WDISP19		41
+#define R_SPARC_GLOB_JMP	42
+#define R_SPARC_7		43
+#define R_SPARC_5		44
+#define R_SPARC_6		45
+#define R_SPARC_DISP64		46
+#define R_SPARC_PLT64		47
+#define R_SPARC_HIX22		48
+#define R_SPARC_LOX10		49
+#define R_SPARC_H44		50
+#define R_SPARC_M44		51
+#define R_SPARC_L44		52
+#define R_SPARC_REGISTER	53
+#define R_SPARC_UA64		54
+#define R_SPARC_UA16		55
+#define R_SPARC_TLS_GD_HI22	56
+#define R_SPARC_TLS_GD_LO10	57
+#define R_SPARC_TLS_GD_ADD	58
+#define R_SPARC_TLS_GD_CALL	59
+#define R_SPARC_TLS_LDM_HI22	60
+#define R_SPARC_TLS_LDM_LO10	61
+#define R_SPARC_TLS_LDM_ADD	62
+#define R_SPARC_TLS_LDM_CALL	63
+#define R_SPARC_TLS_LDO_HIX22	64
+#define R_SPARC_TLS_LDO_LOX10	65
+#define R_SPARC_TLS_LDO_ADD	66
+#define R_SPARC_TLS_IE_HI22	67
+#define R_SPARC_TLS_IE_LO10	68
+#define R_SPARC_TLS_IE_LD	69
+#define R_SPARC_TLS_IE_LDX	70
+#define R_SPARC_TLS_IE_ADD	71
+#define R_SPARC_TLS_LE_HIX22	72
+#define R_SPARC_TLS_LE_LOX10	73
+#define R_SPARC_TLS_DTPMOD32	74
+#define R_SPARC_TLS_DTPMOD64	75
+#define R_SPARC_TLS_DTPOFF32	76
+#define R_SPARC_TLS_DTPOFF64	77
+#define R_SPARC_TLS_TPOFF32	78
+#define R_SPARC_TLS_TPOFF64	79
+#define R_SPARC_GOTDATA_HIX22	80
+#define R_SPARC_GOTDATA_LOX10	81
+#define R_SPARC_GOTDATA_OP_HIX22	82
+#define R_SPARC_GOTDATA_OP_LOX10	83
+#define R_SPARC_GOTDATA_OP	84
+#define R_SPARC_H34		85
+#define R_SPARC_SIZE32		86
+#define R_SPARC_SIZE64		87
+#define R_SPARC_GNU_VTINHERIT	250
+#define R_SPARC_GNU_VTENTRY	251
+#define R_SPARC_REV32		252
+
+#define R_SPARC_NUM		253
+
+
+
+#define DT_SPARC_REGISTER 0x70000001
+#define DT_SPARC_NUM	2
+
+
+#define EF_MIPS_NOREORDER   1
+#define EF_MIPS_PIC	    2
+#define EF_MIPS_CPIC	    4
+#define EF_MIPS_XGOT	    8
+#define EF_MIPS_64BIT_WHIRL 16
+#define EF_MIPS_ABI2	    32
+#define EF_MIPS_ABI_ON32    64
+#define EF_MIPS_FP64	    512
+#define EF_MIPS_NAN2008     1024
+#define EF_MIPS_ARCH	    0xf0000000
+
+
+
+#define EF_MIPS_ARCH_1	    0x00000000
+#define EF_MIPS_ARCH_2	    0x10000000
+#define EF_MIPS_ARCH_3	    0x20000000
+#define EF_MIPS_ARCH_4	    0x30000000
+#define EF_MIPS_ARCH_5	    0x40000000
+#define EF_MIPS_ARCH_32     0x50000000
+#define EF_MIPS_ARCH_64     0x60000000
+#define EF_MIPS_ARCH_32R2   0x70000000
+#define EF_MIPS_ARCH_64R2   0x80000000
+
+
+#define E_MIPS_ARCH_1	  0x00000000
+#define E_MIPS_ARCH_2	  0x10000000
+#define E_MIPS_ARCH_3	  0x20000000
+#define E_MIPS_ARCH_4	  0x30000000
+#define E_MIPS_ARCH_5	  0x40000000
+#define E_MIPS_ARCH_32	  0x50000000
+#define E_MIPS_ARCH_64	  0x60000000
+
+
+
+#define SHN_MIPS_ACOMMON    0xff00
+#define SHN_MIPS_TEXT	    0xff01
+#define SHN_MIPS_DATA	    0xff02
+#define SHN_MIPS_SCOMMON    0xff03
+#define SHN_MIPS_SUNDEFINED 0xff04
+
+
+
+#define SHT_MIPS_LIBLIST       0x70000000
+#define SHT_MIPS_MSYM	       0x70000001
+#define SHT_MIPS_CONFLICT      0x70000002
+#define SHT_MIPS_GPTAB	       0x70000003
+#define SHT_MIPS_UCODE	       0x70000004
+#define SHT_MIPS_DEBUG	       0x70000005
+#define SHT_MIPS_REGINFO       0x70000006
+#define SHT_MIPS_PACKAGE       0x70000007
+#define SHT_MIPS_PACKSYM       0x70000008
+#define SHT_MIPS_RELD	       0x70000009
+#define SHT_MIPS_IFACE         0x7000000b
+#define SHT_MIPS_CONTENT       0x7000000c
+#define SHT_MIPS_OPTIONS       0x7000000d
+#define SHT_MIPS_SHDR	       0x70000010
+#define SHT_MIPS_FDESC	       0x70000011
+#define SHT_MIPS_EXTSYM	       0x70000012
+#define SHT_MIPS_DENSE	       0x70000013
+#define SHT_MIPS_PDESC	       0x70000014
+#define SHT_MIPS_LOCSYM	       0x70000015
+#define SHT_MIPS_AUXSYM	       0x70000016
+#define SHT_MIPS_OPTSYM	       0x70000017
+#define SHT_MIPS_LOCSTR	       0x70000018
+#define SHT_MIPS_LINE	       0x70000019
+#define SHT_MIPS_RFDESC	       0x7000001a
+#define SHT_MIPS_DELTASYM      0x7000001b
+#define SHT_MIPS_DELTAINST     0x7000001c
+#define SHT_MIPS_DELTACLASS    0x7000001d
+#define SHT_MIPS_DWARF         0x7000001e
+#define SHT_MIPS_DELTADECL     0x7000001f
+#define SHT_MIPS_SYMBOL_LIB    0x70000020
+#define SHT_MIPS_EVENTS	       0x70000021
+#define SHT_MIPS_TRANSLATE     0x70000022
+#define SHT_MIPS_PIXIE	       0x70000023
+#define SHT_MIPS_XLATE	       0x70000024
+#define SHT_MIPS_XLATE_DEBUG   0x70000025
+#define SHT_MIPS_WHIRL	       0x70000026
+#define SHT_MIPS_EH_REGION     0x70000027
+#define SHT_MIPS_XLATE_OLD     0x70000028
+#define SHT_MIPS_PDR_EXCEPTION 0x70000029
+
+
+
+#define SHF_MIPS_GPREL	 0x10000000
+#define SHF_MIPS_MERGE	 0x20000000
+#define SHF_MIPS_ADDR	 0x40000000
+#define SHF_MIPS_STRINGS 0x80000000
+#define SHF_MIPS_NOSTRIP 0x08000000
+#define SHF_MIPS_LOCAL	 0x04000000
+#define SHF_MIPS_NAMES	 0x02000000
+#define SHF_MIPS_NODUPE	 0x01000000
+
+
+
+
+
+#define STO_MIPS_DEFAULT		0x0
+#define STO_MIPS_INTERNAL		0x1
+#define STO_MIPS_HIDDEN			0x2
+#define STO_MIPS_PROTECTED		0x3
+#define STO_MIPS_PLT			0x8
+#define STO_MIPS_SC_ALIGN_UNUSED	0xff
+
+
+#define STB_MIPS_SPLIT_COMMON		13
+
+
+
+typedef union {
+  struct {
+      Elf32_Word gt_current_g_value;
+      Elf32_Word gt_unused;
+  } gt_header;
+  struct {
+      Elf32_Word gt_g_value;
+      Elf32_Word gt_bytes;
+  } gt_entry;
+} Elf32_gptab;
+
+
+
+typedef struct {
+  Elf32_Word	ri_gprmask;
+  Elf32_Word	ri_cprmask[4];
+  Elf32_Sword	ri_gp_value;
+} Elf32_RegInfo;
+
+
+
+typedef struct {
+  unsigned char kind;
+
+  unsigned char size;
+  Elf32_Section section;
+
+  Elf32_Word info;
+} Elf_Options;
+
+
+
+#define ODK_NULL	0
+#define ODK_REGINFO	1
+#define ODK_EXCEPTIONS	2
+#define ODK_PAD		3
+#define ODK_HWPATCH	4
+#define ODK_FILL	5
+#define ODK_TAGS	6
+#define ODK_HWAND	7
+#define ODK_HWOR	8
+
+
+
+#define OEX_FPU_MIN	0x1f
+#define OEX_FPU_MAX	0x1f00
+#define OEX_PAGE0	0x10000
+#define OEX_SMM		0x20000
+#define OEX_FPDBUG	0x40000
+#define OEX_PRECISEFP	OEX_FPDBUG
+#define OEX_DISMISS	0x80000
+
+#define OEX_FPU_INVAL	0x10
+#define OEX_FPU_DIV0	0x08
+#define OEX_FPU_OFLO	0x04
+#define OEX_FPU_UFLO	0x02
+#define OEX_FPU_INEX	0x01
+
+
+
+#define OHW_R4KEOP	0x1
+#define OHW_R8KPFETCH	0x2
+#define OHW_R5KEOP	0x4
+#define OHW_R5KCVTL	0x8
+
+#define OPAD_PREFIX	0x1
+#define OPAD_POSTFIX	0x2
+#define OPAD_SYMBOL	0x4
+
+
+
+typedef struct {
+  Elf32_Word hwp_flags1;
+  Elf32_Word hwp_flags2;
+} Elf_Options_Hw;
+
+
+
+#define OHWA0_R4KEOP_CHECKED	0x00000001
+#define OHWA1_R4KEOP_CLEAN	0x00000002
+
+
+
+#define R_MIPS_NONE		0
+#define R_MIPS_16		1
+#define R_MIPS_32		2
+#define R_MIPS_REL32		3
+#define R_MIPS_26		4
+#define R_MIPS_HI16		5
+#define R_MIPS_LO16		6
+#define R_MIPS_GPREL16		7
+#define R_MIPS_LITERAL		8
+#define R_MIPS_GOT16		9
+#define R_MIPS_PC16		10
+#define R_MIPS_CALL16		11
+#define R_MIPS_GPREL32		12
+
+#define R_MIPS_SHIFT5		16
+#define R_MIPS_SHIFT6		17
+#define R_MIPS_64		18
+#define R_MIPS_GOT_DISP		19
+#define R_MIPS_GOT_PAGE		20
+#define R_MIPS_GOT_OFST		21
+#define R_MIPS_GOT_HI16		22
+#define R_MIPS_GOT_LO16		23
+#define R_MIPS_SUB		24
+#define R_MIPS_INSERT_A		25
+#define R_MIPS_INSERT_B		26
+#define R_MIPS_DELETE		27
+#define R_MIPS_HIGHER		28
+#define R_MIPS_HIGHEST		29
+#define R_MIPS_CALL_HI16	30
+#define R_MIPS_CALL_LO16	31
+#define R_MIPS_SCN_DISP		32
+#define R_MIPS_REL16		33
+#define R_MIPS_ADD_IMMEDIATE	34
+#define R_MIPS_PJUMP		35
+#define R_MIPS_RELGOT		36
+#define R_MIPS_JALR		37
+#define R_MIPS_TLS_DTPMOD32	38
+#define R_MIPS_TLS_DTPREL32	39
+#define R_MIPS_TLS_DTPMOD64	40
+#define R_MIPS_TLS_DTPREL64	41
+#define R_MIPS_TLS_GD		42
+#define R_MIPS_TLS_LDM		43
+#define R_MIPS_TLS_DTPREL_HI16	44
+#define R_MIPS_TLS_DTPREL_LO16	45
+#define R_MIPS_TLS_GOTTPREL	46
+#define R_MIPS_TLS_TPREL32	47
+#define R_MIPS_TLS_TPREL64	48
+#define R_MIPS_TLS_TPREL_HI16	49
+#define R_MIPS_TLS_TPREL_LO16	50
+#define R_MIPS_GLOB_DAT		51
+#define R_MIPS_COPY		126
+#define R_MIPS_JUMP_SLOT        127
+
+#define R_MIPS_NUM		128
+
+
+
+#define PT_MIPS_REGINFO	0x70000000
+#define PT_MIPS_RTPROC  0x70000001
+#define PT_MIPS_OPTIONS 0x70000002
+#define PT_MIPS_ABIFLAGS 0x70000003
+
+
+
+#define PF_MIPS_LOCAL	0x10000000
+
+
+
+#define DT_MIPS_RLD_VERSION  0x70000001
+#define DT_MIPS_TIME_STAMP   0x70000002
+#define DT_MIPS_ICHECKSUM    0x70000003
+#define DT_MIPS_IVERSION     0x70000004
+#define DT_MIPS_FLAGS	     0x70000005
+#define DT_MIPS_BASE_ADDRESS 0x70000006
+#define DT_MIPS_MSYM	     0x70000007
+#define DT_MIPS_CONFLICT     0x70000008
+#define DT_MIPS_LIBLIST	     0x70000009
+#define DT_MIPS_LOCAL_GOTNO  0x7000000a
+#define DT_MIPS_CONFLICTNO   0x7000000b
+#define DT_MIPS_LIBLISTNO    0x70000010
+#define DT_MIPS_SYMTABNO     0x70000011
+#define DT_MIPS_UNREFEXTNO   0x70000012
+#define DT_MIPS_GOTSYM	     0x70000013
+#define DT_MIPS_HIPAGENO     0x70000014
+#define DT_MIPS_RLD_MAP	     0x70000016
+#define DT_MIPS_DELTA_CLASS  0x70000017
+#define DT_MIPS_DELTA_CLASS_NO    0x70000018
+
+#define DT_MIPS_DELTA_INSTANCE    0x70000019
+#define DT_MIPS_DELTA_INSTANCE_NO 0x7000001a
+
+#define DT_MIPS_DELTA_RELOC  0x7000001b
+#define DT_MIPS_DELTA_RELOC_NO 0x7000001c
+
+#define DT_MIPS_DELTA_SYM    0x7000001d
+
+#define DT_MIPS_DELTA_SYM_NO 0x7000001e
+
+#define DT_MIPS_DELTA_CLASSSYM 0x70000020
+
+#define DT_MIPS_DELTA_CLASSSYM_NO 0x70000021
+
+#define DT_MIPS_CXX_FLAGS    0x70000022
+#define DT_MIPS_PIXIE_INIT   0x70000023
+#define DT_MIPS_SYMBOL_LIB   0x70000024
+#define DT_MIPS_LOCALPAGE_GOTIDX 0x70000025
+#define DT_MIPS_LOCAL_GOTIDX 0x70000026
+#define DT_MIPS_HIDDEN_GOTIDX 0x70000027
+#define DT_MIPS_PROTECTED_GOTIDX 0x70000028
+#define DT_MIPS_OPTIONS	     0x70000029
+#define DT_MIPS_INTERFACE    0x7000002a
+#define DT_MIPS_DYNSTR_ALIGN 0x7000002b
+#define DT_MIPS_INTERFACE_SIZE 0x7000002c
+#define DT_MIPS_RLD_TEXT_RESOLVE_ADDR 0x7000002d
+
+#define DT_MIPS_PERF_SUFFIX  0x7000002e
+
+#define DT_MIPS_COMPACT_SIZE 0x7000002f
+#define DT_MIPS_GP_VALUE     0x70000030
+#define DT_MIPS_AUX_DYNAMIC  0x70000031
+
+#define DT_MIPS_PLTGOT	     0x70000032
+
+#define DT_MIPS_RWPLT        0x70000034
+#define DT_MIPS_RLD_MAP_REL  0x70000035
+#define DT_MIPS_NUM	     0x36
+
+
+
+#define RHF_NONE		   0
+#define RHF_QUICKSTART		   (1 << 0)
+#define RHF_NOTPOT		   (1 << 1)
+#define RHF_NO_LIBRARY_REPLACEMENT (1 << 2)
+#define RHF_NO_MOVE		   (1 << 3)
+#define RHF_SGI_ONLY		   (1 << 4)
+#define RHF_GUARANTEE_INIT	   (1 << 5)
+#define RHF_DELTA_C_PLUS_PLUS	   (1 << 6)
+#define RHF_GUARANTEE_START_INIT   (1 << 7)
+#define RHF_PIXIE		   (1 << 8)
+#define RHF_DEFAULT_DELAY_LOAD	   (1 << 9)
+#define RHF_REQUICKSTART	   (1 << 10)
+#define RHF_REQUICKSTARTED	   (1 << 11)
+#define RHF_CORD		   (1 << 12)
+#define RHF_NO_UNRES_UNDEF	   (1 << 13)
+#define RHF_RLD_ORDER_SAFE	   (1 << 14)
+
+
+
+typedef struct {
+  Elf32_Word l_name;
+  Elf32_Word l_time_stamp;
+  Elf32_Word l_checksum;
+  Elf32_Word l_version;
+  Elf32_Word l_flags;
+} Elf32_Lib;
+
+typedef struct {
+  Elf64_Word l_name;
+  Elf64_Word l_time_stamp;
+  Elf64_Word l_checksum;
+  Elf64_Word l_version;
+  Elf64_Word l_flags;
+} Elf64_Lib;
+
+
+
+
+#define LL_NONE		  0
+#define LL_EXACT_MATCH	  (1 << 0)
+#define LL_IGNORE_INT_VER (1 << 1)
+#define LL_REQUIRE_MINOR  (1 << 2)
+#define LL_EXPORTS	  (1 << 3)
+#define LL_DELAY_LOAD	  (1 << 4)
+#define LL_DELTA	  (1 << 5)
+
+
+
+typedef Elf32_Addr Elf32_Conflict;
+
+typedef struct {
+  Elf32_Half version;
+  unsigned char isa_level;
+  unsigned char isa_rev;
+  unsigned char gpr_size;
+  unsigned char cpr1_size;
+  unsigned char cpr2_size;
+  unsigned char fp_abi;
+  Elf32_Word isa_ext;
+  Elf32_Word ases;
+  Elf32_Word flags1;
+  Elf32_Word flags2;
+} Elf_MIPS_ABIFlags_v0;
+
+#define MIPS_AFL_REG_NONE	0x00
+#define MIPS_AFL_REG_32		0x01
+#define MIPS_AFL_REG_64		0x02
+#define MIPS_AFL_REG_128	0x03
+
+#define MIPS_AFL_ASE_DSP	0x00000001
+#define MIPS_AFL_ASE_DSPR2	0x00000002
+#define MIPS_AFL_ASE_EVA	0x00000004
+#define MIPS_AFL_ASE_MCU	0x00000008
+#define MIPS_AFL_ASE_MDMX	0x00000010
+#define MIPS_AFL_ASE_MIPS3D	0x00000020
+#define MIPS_AFL_ASE_MT		0x00000040
+#define MIPS_AFL_ASE_SMARTMIPS	0x00000080
+#define MIPS_AFL_ASE_VIRT	0x00000100
+#define MIPS_AFL_ASE_MSA	0x00000200
+#define MIPS_AFL_ASE_MIPS16	0x00000400
+#define MIPS_AFL_ASE_MICROMIPS	0x00000800
+#define MIPS_AFL_ASE_XPA	0x00001000
+#define MIPS_AFL_ASE_MASK	0x00001fff
+
+#define MIPS_AFL_EXT_XLR	  1
+#define MIPS_AFL_EXT_OCTEON2	  2
+#define MIPS_AFL_EXT_OCTEONP	  3
+#define MIPS_AFL_EXT_LOONGSON_3A  4
+#define MIPS_AFL_EXT_OCTEON	  5
+#define MIPS_AFL_EXT_5900	  6
+#define MIPS_AFL_EXT_4650	  7
+#define MIPS_AFL_EXT_4010	  8
+#define MIPS_AFL_EXT_4100	  9
+#define MIPS_AFL_EXT_3900	  10
+#define MIPS_AFL_EXT_10000	  11
+#define MIPS_AFL_EXT_SB1	  12
+#define MIPS_AFL_EXT_4111	  13
+#define MIPS_AFL_EXT_4120	  14
+#define MIPS_AFL_EXT_5400	  15
+#define MIPS_AFL_EXT_5500	  16
+#define MIPS_AFL_EXT_LOONGSON_2E  17
+#define MIPS_AFL_EXT_LOONGSON_2F  18
+
+#define MIPS_AFL_FLAGS1_ODDSPREG  1
+
+enum
+{
+  Val_GNU_MIPS_ABI_FP_ANY = 0,
+  Val_GNU_MIPS_ABI_FP_DOUBLE = 1,
+  Val_GNU_MIPS_ABI_FP_SINGLE = 2,
+  Val_GNU_MIPS_ABI_FP_SOFT = 3,
+  Val_GNU_MIPS_ABI_FP_OLD_64 = 4,
+  Val_GNU_MIPS_ABI_FP_XX = 5,
+  Val_GNU_MIPS_ABI_FP_64 = 6,
+  Val_GNU_MIPS_ABI_FP_64A = 7,
+  Val_GNU_MIPS_ABI_FP_MAX = 7
+};
+
+
+
+
+#define EF_PARISC_TRAPNIL	0x00010000
+#define EF_PARISC_EXT		0x00020000
+#define EF_PARISC_LSB		0x00040000
+#define EF_PARISC_WIDE		0x00080000
+#define EF_PARISC_NO_KABP	0x00100000
+
+#define EF_PARISC_LAZYSWAP	0x00400000
+#define EF_PARISC_ARCH		0x0000ffff
+
+
+
+#define EFA_PARISC_1_0		    0x020b
+#define EFA_PARISC_1_1		    0x0210
+#define EFA_PARISC_2_0		    0x0214
+
+
+
+#define SHN_PARISC_ANSI_COMMON	0xff00
+
+#define SHN_PARISC_HUGE_COMMON	0xff01
+
+
+
+#define SHT_PARISC_EXT		0x70000000
+#define SHT_PARISC_UNWIND	0x70000001
+#define SHT_PARISC_DOC		0x70000002
+
+
+
+#define SHF_PARISC_SHORT	0x20000000
+#define SHF_PARISC_HUGE		0x40000000
+#define SHF_PARISC_SBP		0x80000000
+
+
+
+#define STT_PARISC_MILLICODE	13
+
+#define STT_HP_OPAQUE		(STT_LOOS + 0x1)
+#define STT_HP_STUB		(STT_LOOS + 0x2)
+
+
+
+#define R_PARISC_NONE		0
+#define R_PARISC_DIR32		1
+#define R_PARISC_DIR21L		2
+#define R_PARISC_DIR17R		3
+#define R_PARISC_DIR17F		4
+#define R_PARISC_DIR14R		6
+#define R_PARISC_PCREL32	9
+#define R_PARISC_PCREL21L	10
+#define R_PARISC_PCREL17R	11
+#define R_PARISC_PCREL17F	12
+#define R_PARISC_PCREL14R	14
+#define R_PARISC_DPREL21L	18
+#define R_PARISC_DPREL14R	22
+#define R_PARISC_GPREL21L	26
+#define R_PARISC_GPREL14R	30
+#define R_PARISC_LTOFF21L	34
+#define R_PARISC_LTOFF14R	38
+#define R_PARISC_SECREL32	41
+#define R_PARISC_SEGBASE	48
+#define R_PARISC_SEGREL32	49
+#define R_PARISC_PLTOFF21L	50
+#define R_PARISC_PLTOFF14R	54
+#define R_PARISC_LTOFF_FPTR32	57
+#define R_PARISC_LTOFF_FPTR21L	58
+#define R_PARISC_LTOFF_FPTR14R	62
+#define R_PARISC_FPTR64		64
+#define R_PARISC_PLABEL32	65
+#define R_PARISC_PLABEL21L	66
+#define R_PARISC_PLABEL14R	70
+#define R_PARISC_PCREL64	72
+#define R_PARISC_PCREL22F	74
+#define R_PARISC_PCREL14WR	75
+#define R_PARISC_PCREL14DR	76
+#define R_PARISC_PCREL16F	77
+#define R_PARISC_PCREL16WF	78
+#define R_PARISC_PCREL16DF	79
+#define R_PARISC_DIR64		80
+#define R_PARISC_DIR14WR	83
+#define R_PARISC_DIR14DR	84
+#define R_PARISC_DIR16F		85
+#define R_PARISC_DIR16WF	86
+#define R_PARISC_DIR16DF	87
+#define R_PARISC_GPREL64	88
+#define R_PARISC_GPREL14WR	91
+#define R_PARISC_GPREL14DR	92
+#define R_PARISC_GPREL16F	93
+#define R_PARISC_GPREL16WF	94
+#define R_PARISC_GPREL16DF	95
+#define R_PARISC_LTOFF64	96
+#define R_PARISC_LTOFF14WR	99
+#define R_PARISC_LTOFF14DR	100
+#define R_PARISC_LTOFF16F	101
+#define R_PARISC_LTOFF16WF	102
+#define R_PARISC_LTOFF16DF	103
+#define R_PARISC_SECREL64	104
+#define R_PARISC_SEGREL64	112
+#define R_PARISC_PLTOFF14WR	115
+#define R_PARISC_PLTOFF14DR	116
+#define R_PARISC_PLTOFF16F	117
+#define R_PARISC_PLTOFF16WF	118
+#define R_PARISC_PLTOFF16DF	119
+#define R_PARISC_LTOFF_FPTR64	120
+#define R_PARISC_LTOFF_FPTR14WR	123
+#define R_PARISC_LTOFF_FPTR14DR	124
+#define R_PARISC_LTOFF_FPTR16F	125
+#define R_PARISC_LTOFF_FPTR16WF	126
+#define R_PARISC_LTOFF_FPTR16DF	127
+#define R_PARISC_LORESERVE	128
+#define R_PARISC_COPY		128
+#define R_PARISC_IPLT		129
+#define R_PARISC_EPLT		130
+#define R_PARISC_TPREL32	153
+#define R_PARISC_TPREL21L	154
+#define R_PARISC_TPREL14R	158
+#define R_PARISC_LTOFF_TP21L	162
+#define R_PARISC_LTOFF_TP14R	166
+#define R_PARISC_LTOFF_TP14F	167
+#define R_PARISC_TPREL64	216
+#define R_PARISC_TPREL14WR	219
+#define R_PARISC_TPREL14DR	220
+#define R_PARISC_TPREL16F	221
+#define R_PARISC_TPREL16WF	222
+#define R_PARISC_TPREL16DF	223
+#define R_PARISC_LTOFF_TP64	224
+#define R_PARISC_LTOFF_TP14WR	227
+#define R_PARISC_LTOFF_TP14DR	228
+#define R_PARISC_LTOFF_TP16F	229
+#define R_PARISC_LTOFF_TP16WF	230
+#define R_PARISC_LTOFF_TP16DF	231
+#define R_PARISC_GNU_VTENTRY	232
+#define R_PARISC_GNU_VTINHERIT	233
+#define R_PARISC_TLS_GD21L	234
+#define R_PARISC_TLS_GD14R	235
+#define R_PARISC_TLS_GDCALL	236
+#define R_PARISC_TLS_LDM21L	237
+#define R_PARISC_TLS_LDM14R	238
+#define R_PARISC_TLS_LDMCALL	239
+#define R_PARISC_TLS_LDO21L	240
+#define R_PARISC_TLS_LDO14R	241
+#define R_PARISC_TLS_DTPMOD32	242
+#define R_PARISC_TLS_DTPMOD64	243
+#define R_PARISC_TLS_DTPOFF32	244
+#define R_PARISC_TLS_DTPOFF64	245
+#define R_PARISC_TLS_LE21L	R_PARISC_TPREL21L
+#define R_PARISC_TLS_LE14R	R_PARISC_TPREL14R
+#define R_PARISC_TLS_IE21L	R_PARISC_LTOFF_TP21L
+#define R_PARISC_TLS_IE14R	R_PARISC_LTOFF_TP14R
+#define R_PARISC_TLS_TPREL32	R_PARISC_TPREL32
+#define R_PARISC_TLS_TPREL64	R_PARISC_TPREL64
+#define R_PARISC_HIRESERVE	255
+
+
+
+#define PT_HP_TLS		(PT_LOOS + 0x0)
+#define PT_HP_CORE_NONE		(PT_LOOS + 0x1)
+#define PT_HP_CORE_VERSION	(PT_LOOS + 0x2)
+#define PT_HP_CORE_KERNEL	(PT_LOOS + 0x3)
+#define PT_HP_CORE_COMM		(PT_LOOS + 0x4)
+#define PT_HP_CORE_PROC		(PT_LOOS + 0x5)
+#define PT_HP_CORE_LOADABLE	(PT_LOOS + 0x6)
+#define PT_HP_CORE_STACK	(PT_LOOS + 0x7)
+#define PT_HP_CORE_SHM		(PT_LOOS + 0x8)
+#define PT_HP_CORE_MMF		(PT_LOOS + 0x9)
+#define PT_HP_PARALLEL		(PT_LOOS + 0x10)
+#define PT_HP_FASTBIND		(PT_LOOS + 0x11)
+#define PT_HP_OPT_ANNOT		(PT_LOOS + 0x12)
+#define PT_HP_HSL_ANNOT		(PT_LOOS + 0x13)
+#define PT_HP_STACK		(PT_LOOS + 0x14)
+
+#define PT_PARISC_ARCHEXT	0x70000000
+#define PT_PARISC_UNWIND	0x70000001
+
+
+
+#define PF_PARISC_SBP		0x08000000
+
+#define PF_HP_PAGE_SIZE		0x00100000
+#define PF_HP_FAR_SHARED	0x00200000
+#define PF_HP_NEAR_SHARED	0x00400000
+#define PF_HP_CODE		0x01000000
+#define PF_HP_MODIFY		0x02000000
+#define PF_HP_LAZYSWAP		0x04000000
+#define PF_HP_SBP		0x08000000
+
+
+
+
+
+
+#define EF_ALPHA_32BIT		1
+#define EF_ALPHA_CANRELAX	2
+
+
+
+
+#define SHT_ALPHA_DEBUG		0x70000001
+#define SHT_ALPHA_REGINFO	0x70000002
+
+
+
+#define SHF_ALPHA_GPREL		0x10000000
+
+
+#define STO_ALPHA_NOPV		0x80
+#define STO_ALPHA_STD_GPLOAD	0x88
+
+
+
+#define R_ALPHA_NONE		0
+#define R_ALPHA_REFLONG		1
+#define R_ALPHA_REFQUAD		2
+#define R_ALPHA_GPREL32		3
+#define R_ALPHA_LITERAL		4
+#define R_ALPHA_LITUSE		5
+#define R_ALPHA_GPDISP		6
+#define R_ALPHA_BRADDR		7
+#define R_ALPHA_HINT		8
+#define R_ALPHA_SREL16		9
+#define R_ALPHA_SREL32		10
+#define R_ALPHA_SREL64		11
+#define R_ALPHA_GPRELHIGH	17
+#define R_ALPHA_GPRELLOW	18
+#define R_ALPHA_GPREL16		19
+#define R_ALPHA_COPY		24
+#define R_ALPHA_GLOB_DAT	25
+#define R_ALPHA_JMP_SLOT	26
+#define R_ALPHA_RELATIVE	27
+#define R_ALPHA_TLS_GD_HI	28
+#define R_ALPHA_TLSGD		29
+#define R_ALPHA_TLS_LDM		30
+#define R_ALPHA_DTPMOD64	31
+#define R_ALPHA_GOTDTPREL	32
+#define R_ALPHA_DTPREL64	33
+#define R_ALPHA_DTPRELHI	34
+#define R_ALPHA_DTPRELLO	35
+#define R_ALPHA_DTPREL16	36
+#define R_ALPHA_GOTTPREL	37
+#define R_ALPHA_TPREL64		38
+#define R_ALPHA_TPRELHI		39
+#define R_ALPHA_TPRELLO		40
+#define R_ALPHA_TPREL16		41
+
+#define R_ALPHA_NUM		46
+
+
+#define LITUSE_ALPHA_ADDR	0
+#define LITUSE_ALPHA_BASE	1
+#define LITUSE_ALPHA_BYTOFF	2
+#define LITUSE_ALPHA_JSR	3
+#define LITUSE_ALPHA_TLS_GD	4
+#define LITUSE_ALPHA_TLS_LDM	5
+
+
+#define DT_ALPHA_PLTRO		(DT_LOPROC + 0)
+#define DT_ALPHA_NUM		1
+
+
+
+
+#define EF_PPC_EMB		0x80000000
+
+
+#define EF_PPC_RELOCATABLE	0x00010000
+#define EF_PPC_RELOCATABLE_LIB	0x00008000
+
+
+
+#define R_PPC_NONE		0
+#define R_PPC_ADDR32		1
+#define R_PPC_ADDR24		2
+#define R_PPC_ADDR16		3
+#define R_PPC_ADDR16_LO		4
+#define R_PPC_ADDR16_HI		5
+#define R_PPC_ADDR16_HA		6
+#define R_PPC_ADDR14		7
+#define R_PPC_ADDR14_BRTAKEN	8
+#define R_PPC_ADDR14_BRNTAKEN	9
+#define R_PPC_REL24		10
+#define R_PPC_REL14		11
+#define R_PPC_REL14_BRTAKEN	12
+#define R_PPC_REL14_BRNTAKEN	13
+#define R_PPC_GOT16		14
+#define R_PPC_GOT16_LO		15
+#define R_PPC_GOT16_HI		16
+#define R_PPC_GOT16_HA		17
+#define R_PPC_PLTREL24		18
+#define R_PPC_COPY		19
+#define R_PPC_GLOB_DAT		20
+#define R_PPC_JMP_SLOT		21
+#define R_PPC_RELATIVE		22
+#define R_PPC_LOCAL24PC		23
+#define R_PPC_UADDR32		24
+#define R_PPC_UADDR16		25
+#define R_PPC_REL32		26
+#define R_PPC_PLT32		27
+#define R_PPC_PLTREL32		28
+#define R_PPC_PLT16_LO		29
+#define R_PPC_PLT16_HI		30
+#define R_PPC_PLT16_HA		31
+#define R_PPC_SDAREL16		32
+#define R_PPC_SECTOFF		33
+#define R_PPC_SECTOFF_LO	34
+#define R_PPC_SECTOFF_HI	35
+#define R_PPC_SECTOFF_HA	36
+
+
+#define R_PPC_TLS		67
+#define R_PPC_DTPMOD32		68
+#define R_PPC_TPREL16		69
+#define R_PPC_TPREL16_LO	70
+#define R_PPC_TPREL16_HI	71
+#define R_PPC_TPREL16_HA	72
+#define R_PPC_TPREL32		73
+#define R_PPC_DTPREL16		74
+#define R_PPC_DTPREL16_LO	75
+#define R_PPC_DTPREL16_HI	76
+#define R_PPC_DTPREL16_HA	77
+#define R_PPC_DTPREL32		78
+#define R_PPC_GOT_TLSGD16	79
+#define R_PPC_GOT_TLSGD16_LO	80
+#define R_PPC_GOT_TLSGD16_HI	81
+#define R_PPC_GOT_TLSGD16_HA	82
+#define R_PPC_GOT_TLSLD16	83
+#define R_PPC_GOT_TLSLD16_LO	84
+#define R_PPC_GOT_TLSLD16_HI	85
+#define R_PPC_GOT_TLSLD16_HA	86
+#define R_PPC_GOT_TPREL16	87
+#define R_PPC_GOT_TPREL16_LO	88
+#define R_PPC_GOT_TPREL16_HI	89
+#define R_PPC_GOT_TPREL16_HA	90
+#define R_PPC_GOT_DTPREL16	91
+#define R_PPC_GOT_DTPREL16_LO	92
+#define R_PPC_GOT_DTPREL16_HI	93
+#define R_PPC_GOT_DTPREL16_HA	94
+#define R_PPC_TLSGD		95
+#define R_PPC_TLSLD		96
+
+
+#define R_PPC_EMB_NADDR32	101
+#define R_PPC_EMB_NADDR16	102
+#define R_PPC_EMB_NADDR16_LO	103
+#define R_PPC_EMB_NADDR16_HI	104
+#define R_PPC_EMB_NADDR16_HA	105
+#define R_PPC_EMB_SDAI16	106
+#define R_PPC_EMB_SDA2I16	107
+#define R_PPC_EMB_SDA2REL	108
+#define R_PPC_EMB_SDA21		109
+#define R_PPC_EMB_MRKREF	110
+#define R_PPC_EMB_RELSEC16	111
+#define R_PPC_EMB_RELST_LO	112
+#define R_PPC_EMB_RELST_HI	113
+#define R_PPC_EMB_RELST_HA	114
+#define R_PPC_EMB_BIT_FLD	115
+#define R_PPC_EMB_RELSDA	116
+
+
+#define R_PPC_DIAB_SDA21_LO	180
+#define R_PPC_DIAB_SDA21_HI	181
+#define R_PPC_DIAB_SDA21_HA	182
+#define R_PPC_DIAB_RELSDA_LO	183
+#define R_PPC_DIAB_RELSDA_HI	184
+#define R_PPC_DIAB_RELSDA_HA	185
+
+
+#define R_PPC_IRELATIVE		248
+
+
+#define R_PPC_REL16		249
+#define R_PPC_REL16_LO		250
+#define R_PPC_REL16_HI		251
+#define R_PPC_REL16_HA		252
+
+
+
+#define R_PPC_TOC16		255
+
+
+#define DT_PPC_GOT		(DT_LOPROC + 0)
+#define DT_PPC_OPT		(DT_LOPROC + 1)
+#define DT_PPC_NUM		2
+
+#define PPC_OPT_TLS		1
+
+
+#define R_PPC64_NONE		R_PPC_NONE
+#define R_PPC64_ADDR32		R_PPC_ADDR32
+#define R_PPC64_ADDR24		R_PPC_ADDR24
+#define R_PPC64_ADDR16		R_PPC_ADDR16
+#define R_PPC64_ADDR16_LO	R_PPC_ADDR16_LO
+#define R_PPC64_ADDR16_HI	R_PPC_ADDR16_HI
+#define R_PPC64_ADDR16_HA	R_PPC_ADDR16_HA
+#define R_PPC64_ADDR14		R_PPC_ADDR14
+#define R_PPC64_ADDR14_BRTAKEN	R_PPC_ADDR14_BRTAKEN
+#define R_PPC64_ADDR14_BRNTAKEN	R_PPC_ADDR14_BRNTAKEN
+#define R_PPC64_REL24		R_PPC_REL24
+#define R_PPC64_REL14		R_PPC_REL14
+#define R_PPC64_REL14_BRTAKEN	R_PPC_REL14_BRTAKEN
+#define R_PPC64_REL14_BRNTAKEN	R_PPC_REL14_BRNTAKEN
+#define R_PPC64_GOT16		R_PPC_GOT16
+#define R_PPC64_GOT16_LO	R_PPC_GOT16_LO
+#define R_PPC64_GOT16_HI	R_PPC_GOT16_HI
+#define R_PPC64_GOT16_HA	R_PPC_GOT16_HA
+
+#define R_PPC64_COPY		R_PPC_COPY
+#define R_PPC64_GLOB_DAT	R_PPC_GLOB_DAT
+#define R_PPC64_JMP_SLOT	R_PPC_JMP_SLOT
+#define R_PPC64_RELATIVE	R_PPC_RELATIVE
+
+#define R_PPC64_UADDR32		R_PPC_UADDR32
+#define R_PPC64_UADDR16		R_PPC_UADDR16
+#define R_PPC64_REL32		R_PPC_REL32
+#define R_PPC64_PLT32		R_PPC_PLT32
+#define R_PPC64_PLTREL32	R_PPC_PLTREL32
+#define R_PPC64_PLT16_LO	R_PPC_PLT16_LO
+#define R_PPC64_PLT16_HI	R_PPC_PLT16_HI
+#define R_PPC64_PLT16_HA	R_PPC_PLT16_HA
+
+#define R_PPC64_SECTOFF		R_PPC_SECTOFF
+#define R_PPC64_SECTOFF_LO	R_PPC_SECTOFF_LO
+#define R_PPC64_SECTOFF_HI	R_PPC_SECTOFF_HI
+#define R_PPC64_SECTOFF_HA	R_PPC_SECTOFF_HA
+#define R_PPC64_ADDR30		37
+#define R_PPC64_ADDR64		38
+#define R_PPC64_ADDR16_HIGHER	39
+#define R_PPC64_ADDR16_HIGHERA	40
+#define R_PPC64_ADDR16_HIGHEST	41
+#define R_PPC64_ADDR16_HIGHESTA	42
+#define R_PPC64_UADDR64		43
+#define R_PPC64_REL64		44
+#define R_PPC64_PLT64		45
+#define R_PPC64_PLTREL64	46
+#define R_PPC64_TOC16		47
+#define R_PPC64_TOC16_LO	48
+#define R_PPC64_TOC16_HI	49
+#define R_PPC64_TOC16_HA	50
+#define R_PPC64_TOC		51
+#define R_PPC64_PLTGOT16	52
+#define R_PPC64_PLTGOT16_LO	53
+#define R_PPC64_PLTGOT16_HI	54
+#define R_PPC64_PLTGOT16_HA	55
+
+#define R_PPC64_ADDR16_DS	56
+#define R_PPC64_ADDR16_LO_DS	57
+#define R_PPC64_GOT16_DS	58
+#define R_PPC64_GOT16_LO_DS	59
+#define R_PPC64_PLT16_LO_DS	60
+#define R_PPC64_SECTOFF_DS	61
+#define R_PPC64_SECTOFF_LO_DS	62
+#define R_PPC64_TOC16_DS	63
+#define R_PPC64_TOC16_LO_DS	64
+#define R_PPC64_PLTGOT16_DS	65
+#define R_PPC64_PLTGOT16_LO_DS	66
+
+
+#define R_PPC64_TLS		67
+#define R_PPC64_DTPMOD64	68
+#define R_PPC64_TPREL16		69
+#define R_PPC64_TPREL16_LO	70
+#define R_PPC64_TPREL16_HI	71
+#define R_PPC64_TPREL16_HA	72
+#define R_PPC64_TPREL64		73
+#define R_PPC64_DTPREL16	74
+#define R_PPC64_DTPREL16_LO	75
+#define R_PPC64_DTPREL16_HI	76
+#define R_PPC64_DTPREL16_HA	77
+#define R_PPC64_DTPREL64	78
+#define R_PPC64_GOT_TLSGD16	79
+#define R_PPC64_GOT_TLSGD16_LO	80
+#define R_PPC64_GOT_TLSGD16_HI	81
+#define R_PPC64_GOT_TLSGD16_HA	82
+#define R_PPC64_GOT_TLSLD16	83
+#define R_PPC64_GOT_TLSLD16_LO	84
+#define R_PPC64_GOT_TLSLD16_HI	85
+#define R_PPC64_GOT_TLSLD16_HA	86
+#define R_PPC64_GOT_TPREL16_DS	87
+#define R_PPC64_GOT_TPREL16_LO_DS 88
+#define R_PPC64_GOT_TPREL16_HI	89
+#define R_PPC64_GOT_TPREL16_HA	90
+#define R_PPC64_GOT_DTPREL16_DS	91
+#define R_PPC64_GOT_DTPREL16_LO_DS 92
+#define R_PPC64_GOT_DTPREL16_HI	93
+#define R_PPC64_GOT_DTPREL16_HA	94
+#define R_PPC64_TPREL16_DS	95
+#define R_PPC64_TPREL16_LO_DS	96
+#define R_PPC64_TPREL16_HIGHER	97
+#define R_PPC64_TPREL16_HIGHERA	98
+#define R_PPC64_TPREL16_HIGHEST	99
+#define R_PPC64_TPREL16_HIGHESTA 100
+#define R_PPC64_DTPREL16_DS	101
+#define R_PPC64_DTPREL16_LO_DS	102
+#define R_PPC64_DTPREL16_HIGHER	103
+#define R_PPC64_DTPREL16_HIGHERA 104
+#define R_PPC64_DTPREL16_HIGHEST 105
+#define R_PPC64_DTPREL16_HIGHESTA 106
+#define R_PPC64_TLSGD		107
+#define R_PPC64_TLSLD		108
+#define R_PPC64_TOCSAVE		109
+#define R_PPC64_ADDR16_HIGH	110
+#define R_PPC64_ADDR16_HIGHA	111
+#define R_PPC64_TPREL16_HIGH	112
+#define R_PPC64_TPREL16_HIGHA	113
+#define R_PPC64_DTPREL16_HIGH	114
+#define R_PPC64_DTPREL16_HIGHA	115
+
+
+#define R_PPC64_JMP_IREL	247
+#define R_PPC64_IRELATIVE	248
+#define R_PPC64_REL16		249
+#define R_PPC64_REL16_LO	250
+#define R_PPC64_REL16_HI	251
+#define R_PPC64_REL16_HA	252
+
+#define EF_PPC64_ABI	3
+
+#define DT_PPC64_GLINK  (DT_LOPROC + 0)
+#define DT_PPC64_OPD	(DT_LOPROC + 1)
+#define DT_PPC64_OPDSZ	(DT_LOPROC + 2)
+#define DT_PPC64_OPT	(DT_LOPROC + 3)
+#define DT_PPC64_NUM	4
+
+#define PPC64_OPT_TLS		1
+#define PPC64_OPT_MULTI_TOC	2
+#define PPC64_OPT_LOCALENTRY	4
+
+#define STO_PPC64_LOCAL_BIT	5
+#define STO_PPC64_LOCAL_MASK	0xe0
+#define PPC64_LOCAL_ENTRY_OFFSET(x) (1 << (((x)&0xe0)>>5) & 0xfc)
+
+
+#define EF_ARM_RELEXEC		0x01
+#define EF_ARM_HASENTRY		0x02
+#define EF_ARM_INTERWORK	0x04
+#define EF_ARM_APCS_26		0x08
+#define EF_ARM_APCS_FLOAT	0x10
+#define EF_ARM_PIC		0x20
+#define EF_ARM_ALIGN8		0x40
+#define EF_ARM_NEW_ABI		0x80
+#define EF_ARM_OLD_ABI		0x100
+#define EF_ARM_SOFT_FLOAT	0x200
+#define EF_ARM_VFP_FLOAT	0x400
+#define EF_ARM_MAVERICK_FLOAT	0x800
+
+#define EF_ARM_ABI_FLOAT_SOFT	0x200
+#define EF_ARM_ABI_FLOAT_HARD	0x400
+
+
+#define EF_ARM_SYMSARESORTED	0x04
+#define EF_ARM_DYNSYMSUSESEGIDX	0x08
+#define EF_ARM_MAPSYMSFIRST	0x10
+#define EF_ARM_EABIMASK		0XFF000000
+
+
+#define EF_ARM_BE8	    0x00800000
+#define EF_ARM_LE8	    0x00400000
+
+#define EF_ARM_EABI_VERSION(flags)	((flags) & EF_ARM_EABIMASK)
+#define EF_ARM_EABI_UNKNOWN	0x00000000
+#define EF_ARM_EABI_VER1	0x01000000
+#define EF_ARM_EABI_VER2	0x02000000
+#define EF_ARM_EABI_VER3	0x03000000
+#define EF_ARM_EABI_VER4	0x04000000
+#define EF_ARM_EABI_VER5	0x05000000
+
+
+#define STT_ARM_TFUNC		STT_LOPROC
+#define STT_ARM_16BIT		STT_HIPROC
+
+
+#define SHF_ARM_ENTRYSECT	0x10000000
+#define SHF_ARM_COMDEF		0x80000000
+
+
+
+#define PF_ARM_SB		0x10000000
+
+#define PF_ARM_PI		0x20000000
+#define PF_ARM_ABS		0x40000000
+
+
+#define PT_ARM_EXIDX		(PT_LOPROC + 1)
+
+
+#define SHT_ARM_EXIDX		(SHT_LOPROC + 1)
+#define SHT_ARM_PREEMPTMAP	(SHT_LOPROC + 2)
+#define SHT_ARM_ATTRIBUTES	(SHT_LOPROC + 3)
+
+#define R_AARCH64_NONE            0
+#define R_AARCH64_P32_ABS32	1
+#define R_AARCH64_P32_COPY	180
+#define R_AARCH64_P32_GLOB_DAT	181
+#define R_AARCH64_P32_JUMP_SLOT	182
+#define R_AARCH64_P32_RELATIVE	183
+#define R_AARCH64_P32_TLS_DTPMOD 184
+#define R_AARCH64_P32_TLS_DTPREL 185
+#define R_AARCH64_P32_TLS_TPREL	186
+#define R_AARCH64_P32_TLSDESC	187
+#define R_AARCH64_P32_IRELATIVE	188
+#define R_AARCH64_ABS64         257
+#define R_AARCH64_ABS32         258
+#define R_AARCH64_ABS16		259
+#define R_AARCH64_PREL64	260
+#define R_AARCH64_PREL32	261
+#define R_AARCH64_PREL16	262
+#define R_AARCH64_MOVW_UABS_G0	263
+#define R_AARCH64_MOVW_UABS_G0_NC 264
+#define R_AARCH64_MOVW_UABS_G1	265
+#define R_AARCH64_MOVW_UABS_G1_NC 266
+#define R_AARCH64_MOVW_UABS_G2	267
+#define R_AARCH64_MOVW_UABS_G2_NC 268
+#define R_AARCH64_MOVW_UABS_G3	269
+#define R_AARCH64_MOVW_SABS_G0	270
+#define R_AARCH64_MOVW_SABS_G1	271
+#define R_AARCH64_MOVW_SABS_G2	272
+#define R_AARCH64_LD_PREL_LO19	273
+#define R_AARCH64_ADR_PREL_LO21	274
+#define R_AARCH64_ADR_PREL_PG_HI21 275
+#define R_AARCH64_ADR_PREL_PG_HI21_NC 276
+#define R_AARCH64_ADD_ABS_LO12_NC 277
+#define R_AARCH64_LDST8_ABS_LO12_NC 278
+#define R_AARCH64_TSTBR14	279
+#define R_AARCH64_CONDBR19	280
+#define R_AARCH64_JUMP26	282
+#define R_AARCH64_CALL26	283
+#define R_AARCH64_LDST16_ABS_LO12_NC 284
+#define R_AARCH64_LDST32_ABS_LO12_NC 285
+#define R_AARCH64_LDST64_ABS_LO12_NC 286
+#define R_AARCH64_MOVW_PREL_G0	287
+#define R_AARCH64_MOVW_PREL_G0_NC 288
+#define R_AARCH64_MOVW_PREL_G1	289
+#define R_AARCH64_MOVW_PREL_G1_NC 290
+#define R_AARCH64_MOVW_PREL_G2	291
+#define R_AARCH64_MOVW_PREL_G2_NC 292
+#define R_AARCH64_MOVW_PREL_G3	293
+#define R_AARCH64_LDST128_ABS_LO12_NC 299
+#define R_AARCH64_MOVW_GOTOFF_G0 300
+#define R_AARCH64_MOVW_GOTOFF_G0_NC 301
+#define R_AARCH64_MOVW_GOTOFF_G1 302
+#define R_AARCH64_MOVW_GOTOFF_G1_NC 303
+#define R_AARCH64_MOVW_GOTOFF_G2 304
+#define R_AARCH64_MOVW_GOTOFF_G2_NC 305
+#define R_AARCH64_MOVW_GOTOFF_G3 306
+#define R_AARCH64_GOTREL64	307
+#define R_AARCH64_GOTREL32	308
+#define R_AARCH64_GOT_LD_PREL19	309
+#define R_AARCH64_LD64_GOTOFF_LO15 310
+#define R_AARCH64_ADR_GOT_PAGE	311
+#define R_AARCH64_LD64_GOT_LO12_NC 312
+#define R_AARCH64_LD64_GOTPAGE_LO15 313
+#define R_AARCH64_TLSGD_ADR_PREL21 512
+#define R_AARCH64_TLSGD_ADR_PAGE21 513
+#define R_AARCH64_TLSGD_ADD_LO12_NC 514
+#define R_AARCH64_TLSGD_MOVW_G1	515
+#define R_AARCH64_TLSGD_MOVW_G0_NC 516
+#define R_AARCH64_TLSLD_ADR_PREL21 517
+#define R_AARCH64_TLSLD_ADR_PAGE21 518
+#define R_AARCH64_TLSLD_ADD_LO12_NC 519
+#define R_AARCH64_TLSLD_MOVW_G1	520
+#define R_AARCH64_TLSLD_MOVW_G0_NC 521
+#define R_AARCH64_TLSLD_LD_PREL19 522
+#define R_AARCH64_TLSLD_MOVW_DTPREL_G2 523
+#define R_AARCH64_TLSLD_MOVW_DTPREL_G1 524
+#define R_AARCH64_TLSLD_MOVW_DTPREL_G1_NC 525
+#define R_AARCH64_TLSLD_MOVW_DTPREL_G0 526
+#define R_AARCH64_TLSLD_MOVW_DTPREL_G0_NC 527
+#define R_AARCH64_TLSLD_ADD_DTPREL_HI12 528
+#define R_AARCH64_TLSLD_ADD_DTPREL_LO12 529
+#define R_AARCH64_TLSLD_ADD_DTPREL_LO12_NC 530
+#define R_AARCH64_TLSLD_LDST8_DTPREL_LO12 531
+#define R_AARCH64_TLSLD_LDST8_DTPREL_LO12_NC 532
+#define R_AARCH64_TLSLD_LDST16_DTPREL_LO12 533
+#define R_AARCH64_TLSLD_LDST16_DTPREL_LO12_NC 534
+#define R_AARCH64_TLSLD_LDST32_DTPREL_LO12 535
+#define R_AARCH64_TLSLD_LDST32_DTPREL_LO12_NC 536
+#define R_AARCH64_TLSLD_LDST64_DTPREL_LO12 537
+#define R_AARCH64_TLSLD_LDST64_DTPREL_LO12_NC 538
+#define R_AARCH64_TLSIE_MOVW_GOTTPREL_G1 539
+#define R_AARCH64_TLSIE_MOVW_GOTTPREL_G0_NC 540
+#define R_AARCH64_TLSIE_ADR_GOTTPREL_PAGE21 541
+#define R_AARCH64_TLSIE_LD64_GOTTPREL_LO12_NC 542
+#define R_AARCH64_TLSIE_LD_GOTTPREL_PREL19 543
+#define R_AARCH64_TLSLE_MOVW_TPREL_G2 544
+#define R_AARCH64_TLSLE_MOVW_TPREL_G1 545
+#define R_AARCH64_TLSLE_MOVW_TPREL_G1_NC 546
+#define R_AARCH64_TLSLE_MOVW_TPREL_G0 547
+#define R_AARCH64_TLSLE_MOVW_TPREL_G0_NC 548
+#define R_AARCH64_TLSLE_ADD_TPREL_HI12 549
+#define R_AARCH64_TLSLE_ADD_TPREL_LO12 550
+#define R_AARCH64_TLSLE_ADD_TPREL_LO12_NC 551
+#define R_AARCH64_TLSLE_LDST8_TPREL_LO12 552
+#define R_AARCH64_TLSLE_LDST8_TPREL_LO12_NC 553
+#define R_AARCH64_TLSLE_LDST16_TPREL_LO12 554
+#define R_AARCH64_TLSLE_LDST16_TPREL_LO12_NC 555
+#define R_AARCH64_TLSLE_LDST32_TPREL_LO12 556
+#define R_AARCH64_TLSLE_LDST32_TPREL_LO12_NC 557
+#define R_AARCH64_TLSLE_LDST64_TPREL_LO12 558
+#define R_AARCH64_TLSLE_LDST64_TPREL_LO12_NC 559
+#define R_AARCH64_TLSDESC_LD_PREL19 560
+#define R_AARCH64_TLSDESC_ADR_PREL21 561
+#define R_AARCH64_TLSDESC_ADR_PAGE21 562
+#define R_AARCH64_TLSDESC_LD64_LO12 563
+#define R_AARCH64_TLSDESC_ADD_LO12 564
+#define R_AARCH64_TLSDESC_OFF_G1 565
+#define R_AARCH64_TLSDESC_OFF_G0_NC 566
+#define R_AARCH64_TLSDESC_LDR	567
+#define R_AARCH64_TLSDESC_ADD	568
+#define R_AARCH64_TLSDESC_CALL	569
+#define R_AARCH64_TLSLE_LDST128_TPREL_LO12 570
+#define R_AARCH64_TLSLE_LDST128_TPREL_LO12_NC 571
+#define R_AARCH64_TLSLD_LDST128_DTPREL_LO12 572
+#define R_AARCH64_TLSLD_LDST128_DTPREL_LO12_NC 573
+#define R_AARCH64_COPY         1024
+#define R_AARCH64_GLOB_DAT     1025
+#define R_AARCH64_JUMP_SLOT    1026
+#define R_AARCH64_RELATIVE     1027
+#define R_AARCH64_TLS_DTPMOD   1028
+#define R_AARCH64_TLS_DTPMOD64 1028
+#define R_AARCH64_TLS_DTPREL   1029
+#define R_AARCH64_TLS_DTPREL64 1029
+#define R_AARCH64_TLS_TPREL    1030
+#define R_AARCH64_TLS_TPREL64  1030
+#define R_AARCH64_TLSDESC      1031
+
+
+#define R_ARM_NONE		0
+#define R_ARM_PC24		1
+#define R_ARM_ABS32		2
+#define R_ARM_REL32		3
+#define R_ARM_PC13		4
+#define R_ARM_ABS16		5
+#define R_ARM_ABS12		6
+#define R_ARM_THM_ABS5		7
+#define R_ARM_ABS8		8
+#define R_ARM_SBREL32		9
+#define R_ARM_THM_PC22		10
+#define R_ARM_THM_PC8		11
+#define R_ARM_AMP_VCALL9	12
+#define R_ARM_TLS_DESC		13
+#define R_ARM_THM_SWI8		14
+#define R_ARM_XPC25		15
+#define R_ARM_THM_XPC22		16
+#define R_ARM_TLS_DTPMOD32	17
+#define R_ARM_TLS_DTPOFF32	18
+#define R_ARM_TLS_TPOFF32	19
+#define R_ARM_COPY		20
+#define R_ARM_GLOB_DAT		21
+#define R_ARM_JUMP_SLOT		22
+#define R_ARM_RELATIVE		23
+#define R_ARM_GOTOFF		24
+#define R_ARM_GOTPC		25
+#define R_ARM_GOT32		26
+#define R_ARM_PLT32		27
+#define R_ARM_CALL		28
+#define R_ARM_JUMP24		29
+#define R_ARM_THM_JUMP24	30
+#define R_ARM_BASE_ABS		31
+#define R_ARM_ALU_PCREL_7_0	32
+#define R_ARM_ALU_PCREL_15_8	33
+#define R_ARM_ALU_PCREL_23_15	34
+#define R_ARM_LDR_SBREL_11_0	35
+#define R_ARM_ALU_SBREL_19_12	36
+#define R_ARM_ALU_SBREL_27_20	37
+#define R_ARM_TARGET1		38
+#define R_ARM_SBREL31		39
+#define R_ARM_V4BX		40
+#define R_ARM_TARGET2		41
+#define R_ARM_PREL31		42
+#define R_ARM_MOVW_ABS_NC	43
+#define R_ARM_MOVT_ABS		44
+#define R_ARM_MOVW_PREL_NC	45
+#define R_ARM_MOVT_PREL		46
+#define R_ARM_THM_MOVW_ABS_NC	47
+#define R_ARM_THM_MOVT_ABS	48
+#define R_ARM_THM_MOVW_PREL_NC	49
+#define R_ARM_THM_MOVT_PREL	50
+#define R_ARM_THM_JUMP19	51
+#define R_ARM_THM_JUMP6		52
+#define R_ARM_THM_ALU_PREL_11_0	53
+#define R_ARM_THM_PC12		54
+#define R_ARM_ABS32_NOI		55
+#define R_ARM_REL32_NOI		56
+#define R_ARM_ALU_PC_G0_NC	57
+#define R_ARM_ALU_PC_G0		58
+#define R_ARM_ALU_PC_G1_NC	59
+#define R_ARM_ALU_PC_G1		60
+#define R_ARM_ALU_PC_G2		61
+#define R_ARM_LDR_PC_G1		62
+#define R_ARM_LDR_PC_G2		63
+#define R_ARM_LDRS_PC_G0	64
+#define R_ARM_LDRS_PC_G1	65
+#define R_ARM_LDRS_PC_G2	66
+#define R_ARM_LDC_PC_G0		67
+#define R_ARM_LDC_PC_G1		68
+#define R_ARM_LDC_PC_G2		69
+#define R_ARM_ALU_SB_G0_NC	70
+#define R_ARM_ALU_SB_G0		71
+#define R_ARM_ALU_SB_G1_NC	72
+#define R_ARM_ALU_SB_G1		73
+#define R_ARM_ALU_SB_G2		74
+#define R_ARM_LDR_SB_G0		75
+#define R_ARM_LDR_SB_G1		76
+#define R_ARM_LDR_SB_G2		77
+#define R_ARM_LDRS_SB_G0	78
+#define R_ARM_LDRS_SB_G1	79
+#define R_ARM_LDRS_SB_G2	80
+#define R_ARM_LDC_SB_G0		81
+#define R_ARM_LDC_SB_G1		82
+#define R_ARM_LDC_SB_G2		83
+#define R_ARM_MOVW_BREL_NC	84
+#define R_ARM_MOVT_BREL		85
+#define R_ARM_MOVW_BREL		86
+#define R_ARM_THM_MOVW_BREL_NC	87
+#define R_ARM_THM_MOVT_BREL	88
+#define R_ARM_THM_MOVW_BREL	89
+#define R_ARM_TLS_GOTDESC	90
+#define R_ARM_TLS_CALL		91
+#define R_ARM_TLS_DESCSEQ	92
+#define R_ARM_THM_TLS_CALL	93
+#define R_ARM_PLT32_ABS		94
+#define R_ARM_GOT_ABS		95
+#define R_ARM_GOT_PREL		96
+#define R_ARM_GOT_BREL12	97
+#define R_ARM_GOTOFF12		98
+#define R_ARM_GOTRELAX		99
+#define R_ARM_GNU_VTENTRY	100
+#define R_ARM_GNU_VTINHERIT	101
+#define R_ARM_THM_PC11		102
+#define R_ARM_THM_PC9		103
+#define R_ARM_TLS_GD32		104
+
+#define R_ARM_TLS_LDM32		105
+
+#define R_ARM_TLS_LDO32		106
+
+#define R_ARM_TLS_IE32		107
+
+#define R_ARM_TLS_LE32		108
+#define R_ARM_TLS_LDO12		109
+#define R_ARM_TLS_LE12		110
+#define R_ARM_TLS_IE12GP	111
+#define R_ARM_ME_TOO		128
+#define R_ARM_THM_TLS_DESCSEQ	129
+#define R_ARM_THM_TLS_DESCSEQ16	129
+#define R_ARM_THM_TLS_DESCSEQ32	130
+#define R_ARM_THM_GOT_BREL12	131
+#define R_ARM_IRELATIVE		160
+#define R_ARM_RXPC25		249
+#define R_ARM_RSBREL32		250
+#define R_ARM_THM_RPC22		251
+#define R_ARM_RREL32		252
+#define R_ARM_RABS22		253
+#define R_ARM_RPC24		254
+#define R_ARM_RBASE		255
+
+#define R_ARM_NUM		256
+
+
+#define R_CKCORE_NONE               0
+#define R_CKCORE_ADDR32             1
+#define R_CKCORE_PCRELIMM8BY4       2
+#define R_CKCORE_PCRELIMM11BY2      3
+#define R_CKCORE_PCREL32            5
+#define R_CKCORE_PCRELJSR_IMM11BY2  6
+#define R_CKCORE_RELATIVE           9
+#define R_CKCORE_COPY               10
+#define R_CKCORE_GLOB_DAT           11
+#define R_CKCORE_JUMP_SLOT          12
+#define R_CKCORE_GOTOFF             13
+#define R_CKCORE_GOTPC              14
+#define R_CKCORE_GOT32              15
+#define R_CKCORE_PLT32              16
+#define R_CKCORE_ADDRGOT            17
+#define R_CKCORE_ADDRPLT            18
+#define R_CKCORE_PCREL_IMM26BY2     19
+#define R_CKCORE_PCREL_IMM16BY2     20
+#define R_CKCORE_PCREL_IMM16BY4     21
+#define R_CKCORE_PCREL_IMM10BY2     22
+#define R_CKCORE_PCREL_IMM10BY4     23
+#define R_CKCORE_ADDR_HI16          24
+#define R_CKCORE_ADDR_LO16          25
+#define R_CKCORE_GOTPC_HI16         26
+#define R_CKCORE_GOTPC_LO16         27
+#define R_CKCORE_GOTOFF_HI16        28
+#define R_CKCORE_GOTOFF_LO16        29
+#define R_CKCORE_GOT12              30
+#define R_CKCORE_GOT_HI16           31
+#define R_CKCORE_GOT_LO16           32
+#define R_CKCORE_PLT12              33
+#define R_CKCORE_PLT_HI16           34
+#define R_CKCORE_PLT_LO16           35
+#define R_CKCORE_ADDRGOT_HI16       36
+#define R_CKCORE_ADDRGOT_LO16       37
+#define R_CKCORE_ADDRPLT_HI16       38
+#define R_CKCORE_ADDRPLT_LO16       39
+#define R_CKCORE_PCREL_JSR_IMM26BY2 40
+#define R_CKCORE_TOFFSET_LO16       41
+#define R_CKCORE_DOFFSET_LO16       42
+#define R_CKCORE_PCREL_IMM18BY2     43
+#define R_CKCORE_DOFFSET_IMM18      44
+#define R_CKCORE_DOFFSET_IMM18BY2   45
+#define R_CKCORE_DOFFSET_IMM18BY4   46
+#define R_CKCORE_GOT_IMM18BY4       48
+#define R_CKCORE_PLT_IMM18BY4       49
+#define R_CKCORE_PCREL_IMM7BY4      50
+#define R_CKCORE_TLS_LE32           51
+#define R_CKCORE_TLS_IE32           52
+#define R_CKCORE_TLS_GD32           53
+#define R_CKCORE_TLS_LDM32          54
+#define R_CKCORE_TLS_LDO32          55
+#define R_CKCORE_TLS_DTPMOD32       56
+#define R_CKCORE_TLS_DTPOFF32       57
+#define R_CKCORE_TLS_TPOFF32        58
+
+
+#define EF_IA_64_MASKOS		0x0000000f
+#define EF_IA_64_ABI64		0x00000010
+#define EF_IA_64_ARCH		0xff000000
+
+
+#define PT_IA_64_ARCHEXT	(PT_LOPROC + 0)
+#define PT_IA_64_UNWIND		(PT_LOPROC + 1)
+#define PT_IA_64_HP_OPT_ANOT	(PT_LOOS + 0x12)
+#define PT_IA_64_HP_HSL_ANOT	(PT_LOOS + 0x13)
+#define PT_IA_64_HP_STACK	(PT_LOOS + 0x14)
+
+
+#define PF_IA_64_NORECOV	0x80000000
+
+
+#define SHT_IA_64_EXT		(SHT_LOPROC + 0)
+#define SHT_IA_64_UNWIND	(SHT_LOPROC + 1)
+
+
+#define SHF_IA_64_SHORT		0x10000000
+#define SHF_IA_64_NORECOV	0x20000000
+
+
+#define DT_IA_64_PLT_RESERVE	(DT_LOPROC + 0)
+#define DT_IA_64_NUM		1
+
+
+#define R_IA64_NONE		0x00
+#define R_IA64_IMM14		0x21
+#define R_IA64_IMM22		0x22
+#define R_IA64_IMM64		0x23
+#define R_IA64_DIR32MSB		0x24
+#define R_IA64_DIR32LSB		0x25
+#define R_IA64_DIR64MSB		0x26
+#define R_IA64_DIR64LSB		0x27
+#define R_IA64_GPREL22		0x2a
+#define R_IA64_GPREL64I		0x2b
+#define R_IA64_GPREL32MSB	0x2c
+#define R_IA64_GPREL32LSB	0x2d
+#define R_IA64_GPREL64MSB	0x2e
+#define R_IA64_GPREL64LSB	0x2f
+#define R_IA64_LTOFF22		0x32
+#define R_IA64_LTOFF64I		0x33
+#define R_IA64_PLTOFF22		0x3a
+#define R_IA64_PLTOFF64I	0x3b
+#define R_IA64_PLTOFF64MSB	0x3e
+#define R_IA64_PLTOFF64LSB	0x3f
+#define R_IA64_FPTR64I		0x43
+#define R_IA64_FPTR32MSB	0x44
+#define R_IA64_FPTR32LSB	0x45
+#define R_IA64_FPTR64MSB	0x46
+#define R_IA64_FPTR64LSB	0x47
+#define R_IA64_PCREL60B		0x48
+#define R_IA64_PCREL21B		0x49
+#define R_IA64_PCREL21M		0x4a
+#define R_IA64_PCREL21F		0x4b
+#define R_IA64_PCREL32MSB	0x4c
+#define R_IA64_PCREL32LSB	0x4d
+#define R_IA64_PCREL64MSB	0x4e
+#define R_IA64_PCREL64LSB	0x4f
+#define R_IA64_LTOFF_FPTR22	0x52
+#define R_IA64_LTOFF_FPTR64I	0x53
+#define R_IA64_LTOFF_FPTR32MSB	0x54
+#define R_IA64_LTOFF_FPTR32LSB	0x55
+#define R_IA64_LTOFF_FPTR64MSB	0x56
+#define R_IA64_LTOFF_FPTR64LSB	0x57
+#define R_IA64_SEGREL32MSB	0x5c
+#define R_IA64_SEGREL32LSB	0x5d
+#define R_IA64_SEGREL64MSB	0x5e
+#define R_IA64_SEGREL64LSB	0x5f
+#define R_IA64_SECREL32MSB	0x64
+#define R_IA64_SECREL32LSB	0x65
+#define R_IA64_SECREL64MSB	0x66
+#define R_IA64_SECREL64LSB	0x67
+#define R_IA64_REL32MSB		0x6c
+#define R_IA64_REL32LSB		0x6d
+#define R_IA64_REL64MSB		0x6e
+#define R_IA64_REL64LSB		0x6f
+#define R_IA64_LTV32MSB		0x74
+#define R_IA64_LTV32LSB		0x75
+#define R_IA64_LTV64MSB		0x76
+#define R_IA64_LTV64LSB		0x77
+#define R_IA64_PCREL21BI	0x79
+#define R_IA64_PCREL22		0x7a
+#define R_IA64_PCREL64I		0x7b
+#define R_IA64_IPLTMSB		0x80
+#define R_IA64_IPLTLSB		0x81
+#define R_IA64_COPY		0x84
+#define R_IA64_SUB		0x85
+#define R_IA64_LTOFF22X		0x86
+#define R_IA64_LDXMOV		0x87
+#define R_IA64_TPREL14		0x91
+#define R_IA64_TPREL22		0x92
+#define R_IA64_TPREL64I		0x93
+#define R_IA64_TPREL64MSB	0x96
+#define R_IA64_TPREL64LSB	0x97
+#define R_IA64_LTOFF_TPREL22	0x9a
+#define R_IA64_DTPMOD64MSB	0xa6
+#define R_IA64_DTPMOD64LSB	0xa7
+#define R_IA64_LTOFF_DTPMOD22	0xaa
+#define R_IA64_DTPREL14		0xb1
+#define R_IA64_DTPREL22		0xb2
+#define R_IA64_DTPREL64I	0xb3
+#define R_IA64_DTPREL32MSB	0xb4
+#define R_IA64_DTPREL32LSB	0xb5
+#define R_IA64_DTPREL64MSB	0xb6
+#define R_IA64_DTPREL64LSB	0xb7
+#define R_IA64_LTOFF_DTPREL22	0xba
+
+
+#define EF_SH_MACH_MASK		0x1f
+#define EF_SH_UNKNOWN		0x0
+#define EF_SH1			0x1
+#define EF_SH2			0x2
+#define EF_SH3			0x3
+#define EF_SH_DSP		0x4
+#define EF_SH3_DSP		0x5
+#define EF_SH4AL_DSP		0x6
+#define EF_SH3E			0x8
+#define EF_SH4			0x9
+#define EF_SH2E			0xb
+#define EF_SH4A			0xc
+#define EF_SH2A			0xd
+#define EF_SH4_NOFPU		0x10
+#define EF_SH4A_NOFPU		0x11
+#define EF_SH4_NOMMU_NOFPU	0x12
+#define EF_SH2A_NOFPU		0x13
+#define EF_SH3_NOMMU		0x14
+#define EF_SH2A_SH4_NOFPU	0x15
+#define EF_SH2A_SH3_NOFPU	0x16
+#define EF_SH2A_SH4		0x17
+#define EF_SH2A_SH3E		0x18
+
+#define	R_SH_NONE		0
+#define	R_SH_DIR32		1
+#define	R_SH_REL32		2
+#define	R_SH_DIR8WPN		3
+#define	R_SH_IND12W		4
+#define	R_SH_DIR8WPL		5
+#define	R_SH_DIR8WPZ		6
+#define	R_SH_DIR8BP		7
+#define	R_SH_DIR8W		8
+#define	R_SH_DIR8L		9
+#define	R_SH_SWITCH16		25
+#define	R_SH_SWITCH32		26
+#define	R_SH_USES		27
+#define	R_SH_COUNT		28
+#define	R_SH_ALIGN		29
+#define	R_SH_CODE		30
+#define	R_SH_DATA		31
+#define	R_SH_LABEL		32
+#define	R_SH_SWITCH8		33
+#define	R_SH_GNU_VTINHERIT	34
+#define	R_SH_GNU_VTENTRY	35
+#define	R_SH_TLS_GD_32		144
+#define	R_SH_TLS_LD_32		145
+#define	R_SH_TLS_LDO_32		146
+#define	R_SH_TLS_IE_32		147
+#define	R_SH_TLS_LE_32		148
+#define	R_SH_TLS_DTPMOD32	149
+#define	R_SH_TLS_DTPOFF32	150
+#define	R_SH_TLS_TPOFF32	151
+#define	R_SH_GOT32		160
+#define	R_SH_PLT32		161
+#define	R_SH_COPY		162
+#define	R_SH_GLOB_DAT		163
+#define	R_SH_JMP_SLOT		164
+#define	R_SH_RELATIVE		165
+#define	R_SH_GOTOFF		166
+#define	R_SH_GOTPC		167
+#define	R_SH_GOT20		201
+#define	R_SH_GOTOFF20		202
+#define	R_SH_GOTFUNCDESC	203
+#define	R_SH_GOTFUNCDEST20	204
+#define	R_SH_GOTOFFFUNCDESC	205
+#define	R_SH_GOTOFFFUNCDEST20	206
+#define	R_SH_FUNCDESC		207
+#define	R_SH_FUNCDESC_VALUE	208
+
+#define	R_SH_NUM		256
+
+
+
+#define R_390_NONE		0
+#define R_390_8			1
+#define R_390_12		2
+#define R_390_16		3
+#define R_390_32		4
+#define R_390_PC32		5
+#define R_390_GOT12		6
+#define R_390_GOT32		7
+#define R_390_PLT32		8
+#define R_390_COPY		9
+#define R_390_GLOB_DAT		10
+#define R_390_JMP_SLOT		11
+#define R_390_RELATIVE		12
+#define R_390_GOTOFF32		13
+#define R_390_GOTPC		14
+#define R_390_GOT16		15
+#define R_390_PC16		16
+#define R_390_PC16DBL		17
+#define R_390_PLT16DBL		18
+#define R_390_PC32DBL		19
+#define R_390_PLT32DBL		20
+#define R_390_GOTPCDBL		21
+#define R_390_64		22
+#define R_390_PC64		23
+#define R_390_GOT64		24
+#define R_390_PLT64		25
+#define R_390_GOTENT		26
+#define R_390_GOTOFF16		27
+#define R_390_GOTOFF64		28
+#define R_390_GOTPLT12		29
+#define R_390_GOTPLT16		30
+#define R_390_GOTPLT32		31
+#define R_390_GOTPLT64		32
+#define R_390_GOTPLTENT		33
+#define R_390_PLTOFF16		34
+#define R_390_PLTOFF32		35
+#define R_390_PLTOFF64		36
+#define R_390_TLS_LOAD		37
+#define R_390_TLS_GDCALL	38
+
+#define R_390_TLS_LDCALL	39
+
+#define R_390_TLS_GD32		40
+
+#define R_390_TLS_GD64		41
+
+#define R_390_TLS_GOTIE12	42
+
+#define R_390_TLS_GOTIE32	43
+
+#define R_390_TLS_GOTIE64	44
+
+#define R_390_TLS_LDM32		45
+
+#define R_390_TLS_LDM64		46
+
+#define R_390_TLS_IE32		47
+
+#define R_390_TLS_IE64		48
+
+#define R_390_TLS_IEENT		49
+
+#define R_390_TLS_LE32		50
+
+#define R_390_TLS_LE64		51
+
+#define R_390_TLS_LDO32		52
+
+#define R_390_TLS_LDO64		53
+
+#define R_390_TLS_DTPMOD	54
+#define R_390_TLS_DTPOFF	55
+#define R_390_TLS_TPOFF		56
+
+#define R_390_20		57
+#define R_390_GOT20		58
+#define R_390_GOTPLT20		59
+#define R_390_TLS_GOTIE20	60
+
+
+#define R_390_NUM		61
+
+
+
+#define R_CRIS_NONE		0
+#define R_CRIS_8		1
+#define R_CRIS_16		2
+#define R_CRIS_32		3
+#define R_CRIS_8_PCREL		4
+#define R_CRIS_16_PCREL		5
+#define R_CRIS_32_PCREL		6
+#define R_CRIS_GNU_VTINHERIT	7
+#define R_CRIS_GNU_VTENTRY	8
+#define R_CRIS_COPY		9
+#define R_CRIS_GLOB_DAT		10
+#define R_CRIS_JUMP_SLOT	11
+#define R_CRIS_RELATIVE		12
+#define R_CRIS_16_GOT		13
+#define R_CRIS_32_GOT		14
+#define R_CRIS_16_GOTPLT	15
+#define R_CRIS_32_GOTPLT	16
+#define R_CRIS_32_GOTREL	17
+#define R_CRIS_32_PLT_GOTREL	18
+#define R_CRIS_32_PLT_PCREL	19
+
+#define R_CRIS_NUM		20
+
+
+
+#define R_X86_64_NONE		0
+#define R_X86_64_64		1
+#define R_X86_64_PC32		2
+#define R_X86_64_GOT32		3
+#define R_X86_64_PLT32		4
+#define R_X86_64_COPY		5
+#define R_X86_64_GLOB_DAT	6
+#define R_X86_64_JUMP_SLOT	7
+#define R_X86_64_RELATIVE	8
+#define R_X86_64_GOTPCREL	9
+
+#define R_X86_64_32		10
+#define R_X86_64_32S		11
+#define R_X86_64_16		12
+#define R_X86_64_PC16		13
+#define R_X86_64_8		14
+#define R_X86_64_PC8		15
+#define R_X86_64_DTPMOD64	16
+#define R_X86_64_DTPOFF64	17
+#define R_X86_64_TPOFF64	18
+#define R_X86_64_TLSGD		19
+
+#define R_X86_64_TLSLD		20
+
+#define R_X86_64_DTPOFF32	21
+#define R_X86_64_GOTTPOFF	22
+
+#define R_X86_64_TPOFF32	23
+#define R_X86_64_PC64		24
+#define R_X86_64_GOTOFF64	25
+#define R_X86_64_GOTPC32	26
+#define R_X86_64_GOT64		27
+#define R_X86_64_GOTPCREL64	28
+#define R_X86_64_GOTPC64	29
+#define R_X86_64_GOTPLT64	30
+#define R_X86_64_PLTOFF64	31
+#define R_X86_64_SIZE32		32
+#define R_X86_64_SIZE64		33
+
+#define R_X86_64_GOTPC32_TLSDESC 34
+#define R_X86_64_TLSDESC_CALL   35
+
+#define R_X86_64_TLSDESC        36
+#define R_X86_64_IRELATIVE	37
+#define R_X86_64_RELATIVE64	38
+#define R_X86_64_GOTPCRELX	41
+#define R_X86_64_REX_GOTPCRELX	42
+#define R_X86_64_NUM		43
+
+
+
+#define R_MN10300_NONE		0
+#define R_MN10300_32		1
+#define R_MN10300_16		2
+#define R_MN10300_8		3
+#define R_MN10300_PCREL32	4
+#define R_MN10300_PCREL16	5
+#define R_MN10300_PCREL8	6
+#define R_MN10300_GNU_VTINHERIT	7
+#define R_MN10300_GNU_VTENTRY	8
+#define R_MN10300_24		9
+#define R_MN10300_GOTPC32	10
+#define R_MN10300_GOTPC16	11
+#define R_MN10300_GOTOFF32	12
+#define R_MN10300_GOTOFF24	13
+#define R_MN10300_GOTOFF16	14
+#define R_MN10300_PLT32		15
+#define R_MN10300_PLT16		16
+#define R_MN10300_GOT32		17
+#define R_MN10300_GOT24		18
+#define R_MN10300_GOT16		19
+#define R_MN10300_COPY		20
+#define R_MN10300_GLOB_DAT	21
+#define R_MN10300_JMP_SLOT	22
+#define R_MN10300_RELATIVE	23
+
+#define R_MN10300_NUM		24
+
+
+
+#define R_M32R_NONE		0
+#define R_M32R_16		1
+#define R_M32R_32		2
+#define R_M32R_24		3
+#define R_M32R_10_PCREL		4
+#define R_M32R_18_PCREL		5
+#define R_M32R_26_PCREL		6
+#define R_M32R_HI16_ULO		7
+#define R_M32R_HI16_SLO		8
+#define R_M32R_LO16		9
+#define R_M32R_SDA16		10
+#define R_M32R_GNU_VTINHERIT	11
+#define R_M32R_GNU_VTENTRY	12
+
+#define R_M32R_16_RELA		33
+#define R_M32R_32_RELA		34
+#define R_M32R_24_RELA		35
+#define R_M32R_10_PCREL_RELA	36
+#define R_M32R_18_PCREL_RELA	37
+#define R_M32R_26_PCREL_RELA	38
+#define R_M32R_HI16_ULO_RELA	39
+#define R_M32R_HI16_SLO_RELA	40
+#define R_M32R_LO16_RELA	41
+#define R_M32R_SDA16_RELA	42
+#define R_M32R_RELA_GNU_VTINHERIT	43
+#define R_M32R_RELA_GNU_VTENTRY	44
+#define R_M32R_REL32		45
+
+#define R_M32R_GOT24		48
+#define R_M32R_26_PLTREL	49
+#define R_M32R_COPY		50
+#define R_M32R_GLOB_DAT		51
+#define R_M32R_JMP_SLOT		52
+#define R_M32R_RELATIVE		53
+#define R_M32R_GOTOFF		54
+#define R_M32R_GOTPC24		55
+#define R_M32R_GOT16_HI_ULO	56
+
+#define R_M32R_GOT16_HI_SLO	57
+
+#define R_M32R_GOT16_LO		58
+#define R_M32R_GOTPC_HI_ULO	59
+
+#define R_M32R_GOTPC_HI_SLO	60
+
+#define R_M32R_GOTPC_LO		61
+
+#define R_M32R_GOTOFF_HI_ULO	62
+
+#define R_M32R_GOTOFF_HI_SLO	63
+
+#define R_M32R_GOTOFF_LO	64
+#define R_M32R_NUM		256
+
+#define R_MICROBLAZE_NONE 0
+#define R_MICROBLAZE_32 1
+#define R_MICROBLAZE_32_PCREL 2
+#define R_MICROBLAZE_64_PCREL 3
+#define R_MICROBLAZE_32_PCREL_LO 4
+#define R_MICROBLAZE_64 5
+#define R_MICROBLAZE_32_LO 6
+#define R_MICROBLAZE_SRO32 7
+#define R_MICROBLAZE_SRW32 8
+#define R_MICROBLAZE_64_NONE 9
+#define R_MICROBLAZE_32_SYM_OP_SYM 10
+#define R_MICROBLAZE_GNU_VTINHERIT 11
+#define R_MICROBLAZE_GNU_VTENTRY 12
+#define R_MICROBLAZE_GOTPC_64 13
+#define R_MICROBLAZE_GOT_64 14
+#define R_MICROBLAZE_PLT_64 15
+#define R_MICROBLAZE_REL 16
+#define R_MICROBLAZE_JUMP_SLOT 17
+#define R_MICROBLAZE_GLOB_DAT 18
+#define R_MICROBLAZE_GOTOFF_64 19
+#define R_MICROBLAZE_GOTOFF_32 20
+#define R_MICROBLAZE_COPY 21
+#define R_MICROBLAZE_TLS 22
+#define R_MICROBLAZE_TLSGD 23
+#define R_MICROBLAZE_TLSLD 24
+#define R_MICROBLAZE_TLSDTPMOD32 25
+#define R_MICROBLAZE_TLSDTPREL32 26
+#define R_MICROBLAZE_TLSDTPREL64 27
+#define R_MICROBLAZE_TLSGOTTPREL32 28
+#define R_MICROBLAZE_TLSTPREL32	 29
+
+#define DT_NIOS2_GP             0x70000002
+
+#define R_NIOS2_NONE		0
+#define R_NIOS2_S16		1
+#define R_NIOS2_U16		2
+#define R_NIOS2_PCREL16		3
+#define R_NIOS2_CALL26		4
+#define R_NIOS2_IMM5		5
+#define R_NIOS2_CACHE_OPX	6
+#define R_NIOS2_IMM6		7
+#define R_NIOS2_IMM8		8
+#define R_NIOS2_HI16		9
+#define R_NIOS2_LO16		10
+#define R_NIOS2_HIADJ16		11
+#define R_NIOS2_BFD_RELOC_32	12
+#define R_NIOS2_BFD_RELOC_16	13
+#define R_NIOS2_BFD_RELOC_8	14
+#define R_NIOS2_GPREL		15
+#define R_NIOS2_GNU_VTINHERIT	16
+#define R_NIOS2_GNU_VTENTRY	17
+#define R_NIOS2_UJMP		18
+#define R_NIOS2_CJMP		19
+#define R_NIOS2_CALLR		20
+#define R_NIOS2_ALIGN		21
+#define R_NIOS2_GOT16		22
+#define R_NIOS2_CALL16		23
+#define R_NIOS2_GOTOFF_LO	24
+#define R_NIOS2_GOTOFF_HA	25
+#define R_NIOS2_PCREL_LO	26
+#define R_NIOS2_PCREL_HA	27
+#define R_NIOS2_TLS_GD16	28
+#define R_NIOS2_TLS_LDM16	29
+#define R_NIOS2_TLS_LDO16	30
+#define R_NIOS2_TLS_IE16	31
+#define R_NIOS2_TLS_LE16	32
+#define R_NIOS2_TLS_DTPMOD	33
+#define R_NIOS2_TLS_DTPREL	34
+#define R_NIOS2_TLS_TPREL	35
+#define R_NIOS2_COPY		36
+#define R_NIOS2_GLOB_DAT	37
+#define R_NIOS2_JUMP_SLOT	38
+#define R_NIOS2_RELATIVE	39
+#define R_NIOS2_GOTOFF		40
+#define R_NIOS2_CALL26_NOAT	41
+#define R_NIOS2_GOT_LO		42
+#define R_NIOS2_GOT_HA		43
+#define R_NIOS2_CALL_LO		44
+#define R_NIOS2_CALL_HA		45
+
+#define R_OR1K_NONE		0
+#define R_OR1K_32		1
+#define R_OR1K_16		2
+#define R_OR1K_8		3
+#define R_OR1K_LO_16_IN_INSN	4
+#define R_OR1K_HI_16_IN_INSN	5
+#define R_OR1K_INSN_REL_26	6
+#define R_OR1K_GNU_VTENTRY	7
+#define R_OR1K_GNU_VTINHERIT	8
+#define R_OR1K_32_PCREL		9
+#define R_OR1K_16_PCREL		10
+#define R_OR1K_8_PCREL		11
+#define R_OR1K_GOTPC_HI16	12
+#define R_OR1K_GOTPC_LO16	13
+#define R_OR1K_GOT16		14
+#define R_OR1K_PLT26		15
+#define R_OR1K_GOTOFF_HI16	16
+#define R_OR1K_GOTOFF_LO16	17
+#define R_OR1K_COPY		18
+#define R_OR1K_GLOB_DAT		19
+#define R_OR1K_JMP_SLOT		20
+#define R_OR1K_RELATIVE		21
+#define R_OR1K_TLS_GD_HI16	22
+#define R_OR1K_TLS_GD_LO16	23
+#define R_OR1K_TLS_LDM_HI16	24
+#define R_OR1K_TLS_LDM_LO16	25
+#define R_OR1K_TLS_LDO_HI16	26
+#define R_OR1K_TLS_LDO_LO16	27
+#define R_OR1K_TLS_IE_HI16	28
+#define R_OR1K_TLS_IE_LO16	29
+#define R_OR1K_TLS_LE_HI16	30
+#define R_OR1K_TLS_LE_LO16	31
+#define R_OR1K_TLS_TPOFF	32
+#define R_OR1K_TLS_DTPOFF	33
+#define R_OR1K_TLS_DTPMOD	34
+
+#define R_BPF_NONE		0
+#define R_BPF_MAP_FD		1
+
+#define R_RISCV_NONE            0
+#define R_RISCV_32              1
+#define R_RISCV_64              2
+#define R_RISCV_RELATIVE        3
+#define R_RISCV_COPY            4
+#define R_RISCV_JUMP_SLOT       5
+#define R_RISCV_TLS_DTPMOD32    6
+#define R_RISCV_TLS_DTPMOD64    7
+#define R_RISCV_TLS_DTPREL32    8
+#define R_RISCV_TLS_DTPREL64    9
+#define R_RISCV_TLS_TPREL32     10
+#define R_RISCV_TLS_TPREL64     11
+
+#define R_RISCV_BRANCH          16
+#define R_RISCV_JAL             17
+#define R_RISCV_CALL            18
+#define R_RISCV_CALL_PLT        19
+#define R_RISCV_GOT_HI20        20
+#define R_RISCV_TLS_GOT_HI20    21
+#define R_RISCV_TLS_GD_HI20     22
+#define R_RISCV_PCREL_HI20      23
+#define R_RISCV_PCREL_LO12_I    24
+#define R_RISCV_PCREL_LO12_S    25
+#define R_RISCV_HI20            26
+#define R_RISCV_LO12_I          27
+#define R_RISCV_LO12_S          28
+#define R_RISCV_TPREL_HI20      29
+#define R_RISCV_TPREL_LO12_I    30
+#define R_RISCV_TPREL_LO12_S    31
+#define R_RISCV_TPREL_ADD       32
+#define R_RISCV_ADD8            33
+#define R_RISCV_ADD16           34
+#define R_RISCV_ADD32           35
+#define R_RISCV_ADD64           36
+#define R_RISCV_SUB8            37
+#define R_RISCV_SUB16           38
+#define R_RISCV_SUB32           39
+#define R_RISCV_SUB64           40
+#define R_RISCV_GNU_VTINHERIT   41
+#define R_RISCV_GNU_VTENTRY     42
+#define R_RISCV_ALIGN           43
+#define R_RISCV_RVC_BRANCH      44
+#define R_RISCV_RVC_JUMP        45
+#define R_RISCV_RVC_LUI         46
+#define R_RISCV_GPREL_I         47
+#define R_RISCV_GPREL_S         48
+#define R_RISCV_TPREL_I         49
+#define R_RISCV_TPREL_S         50
+#define R_RISCV_RELAX           51
+#define R_RISCV_SUB6            52
+#define R_RISCV_SET6            53
+#define R_RISCV_SET8            54
+#define R_RISCV_SET16           55
+#define R_RISCV_SET32           56
+#define R_RISCV_32_PCREL        57
+
+#ifdef __cplusplus
+}
+#endif
+
+
+#endif
diff --git a/third_party/musl/porting/liteos_m/kernel/include/endian.h b/third_party/musl/porting/liteos_m/kernel/include/endian.h
new file mode 100755
index 000000000..172c43203
--- /dev/null
+++ b/third_party/musl/porting/liteos_m/kernel/include/endian.h
@@ -0,0 +1,80 @@
+#ifndef _ENDIAN_H
+#define _ENDIAN_H
+
+#include <features.h>
+
+#define __NEED_uint16_t
+#define __NEED_uint32_t
+#define __NEED_uint64_t
+
+#include <bits/alltypes.h>
+
+#define __PDP_ENDIAN 3412
+
+#define BIG_ENDIAN __BIG_ENDIAN
+#define LITTLE_ENDIAN __LITTLE_ENDIAN
+#define PDP_ENDIAN __PDP_ENDIAN
+#define BYTE_ORDER __BYTE_ORDER
+
+static __inline uint16_t __bswap16(uint16_t __x)
+{
+	return __x<<8 | __x>>8;
+}
+
+static __inline uint32_t __bswap32(uint32_t __x)
+{
+	return __x>>24 | __x>>8&0xff00 | __x<<8&0xff0000 | __x<<24;
+}
+
+static __inline uint64_t __bswap64(uint64_t __x)
+{
+	return __bswap32(__x)+0ULL<<32 | __bswap32(__x>>32);
+}
+
+#if __BYTE_ORDER == __LITTLE_ENDIAN
+#define htobe16(x) __bswap16(x)
+#define be16toh(x) __bswap16(x)
+#define htobe32(x) __bswap32(x)
+#define be32toh(x) __bswap32(x)
+#define htobe64(x) __bswap64(x)
+#define be64toh(x) __bswap64(x)
+#define htole16(x) (uint16_t)(x)
+#define le16toh(x) (uint16_t)(x)
+#define htole32(x) (uint32_t)(x)
+#define le32toh(x) (uint32_t)(x)
+#define htole64(x) (uint64_t)(x)
+#define le64toh(x) (uint64_t)(x)
+#else
+#define htobe16(x) (uint16_t)(x)
+#define be16toh(x) (uint16_t)(x)
+#define htobe32(x) (uint32_t)(x)
+#define be32toh(x) (uint32_t)(x)
+#define htobe64(x) (uint64_t)(x)
+#define be64toh(x) (uint64_t)(x)
+#define htole16(x) __bswap16(x)
+#define le16toh(x) __bswap16(x)
+#define htole32(x) __bswap32(x)
+#define le32toh(x) __bswap32(x)
+#define htole64(x) __bswap64(x)
+#define le64toh(x) __bswap64(x)
+#endif
+
+#if defined(_GNU_SOURCE) || defined(_BSD_SOURCE)
+#if __BYTE_ORDER == __LITTLE_ENDIAN
+#define betoh16(x) __bswap16(x)
+#define betoh32(x) __bswap32(x)
+#define betoh64(x) __bswap64(x)
+#define letoh16(x) (uint16_t)(x)
+#define letoh32(x) (uint32_t)(x)
+#define letoh64(x) (uint64_t)(x)
+#else
+#define betoh16(x) (uint16_t)(x)
+#define betoh32(x) (uint32_t)(x)
+#define betoh64(x) (uint64_t)(x)
+#define letoh16(x) __bswap16(x)
+#define letoh32(x) __bswap32(x)
+#define letoh64(x) __bswap64(x)
+#endif
+#endif
+
+#endif
diff --git a/third_party/musl/porting/liteos_m/kernel/include/err.h b/third_party/musl/porting/liteos_m/kernel/include/err.h
new file mode 100755
index 000000000..9f5cb6b9e
--- /dev/null
+++ b/third_party/musl/porting/liteos_m/kernel/include/err.h
@@ -0,0 +1,25 @@
+#ifndef _ERR_H
+#define _ERR_H
+
+#include <features.h>
+#include <stdarg.h>
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+void warn(const char *, ...);
+void vwarn(const char *, va_list);
+void warnx(const char *, ...);
+void vwarnx(const char *, va_list);
+
+_Noreturn void err(int, const char *, ...);
+_Noreturn void verr(int, const char *, va_list);
+_Noreturn void errx(int, const char *, ...);
+_Noreturn void verrx(int, const char *, va_list);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
diff --git a/third_party/musl/porting/liteos_m/kernel/include/errno.h b/third_party/musl/porting/liteos_m/kernel/include/errno.h
new file mode 100755
index 000000000..306c02b30
--- /dev/null
+++ b/third_party/musl/porting/liteos_m/kernel/include/errno.h
@@ -0,0 +1,76 @@
+#ifndef	_ERRNO_H
+#define _ERRNO_H
+
+#ifdef __ICCARM__ /* for iar */
+
+#include_next <errno.h>
+
+#ifdef errno
+#undef errno
+#endif
+
+#ifdef EDOM
+#undef EDOM
+#endif
+
+#ifdef ERANGE
+#undef ERANGE
+#endif
+
+#ifdef EFPOS
+#undef EFPOS
+#endif
+
+#ifdef EILSEQ
+#undef EILSEQ
+#endif
+
+#ifdef _NERR
+#undef _NERR
+#endif
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#include <features.h>
+
+#include <bits/errno.h>
+
+#ifdef __GNUC__
+__attribute__((const))
+#endif
+int *__errno_location(void);
+#define errno (*__errno_location())
+
+#ifdef __cplusplus
+}
+#endif
+
+#else
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#include <features.h>
+
+#include <bits/errno.h>
+
+#ifdef __GNUC__
+__attribute__((const))
+#endif
+int *__errno_location(void);
+#define errno (*__errno_location())
+
+#ifdef _GNU_SOURCE
+extern char *program_invocation_short_name, *program_invocation_name;
+#endif
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* __ICCARM__ */
+#endif
+
diff --git a/third_party/musl/porting/liteos_m/kernel/include/fcntl.h b/third_party/musl/porting/liteos_m/kernel/include/fcntl.h
new file mode 100755
index 000000000..b664cdc44
--- /dev/null
+++ b/third_party/musl/porting/liteos_m/kernel/include/fcntl.h
@@ -0,0 +1,216 @@
+#ifndef	_FCNTL_H
+#define	_FCNTL_H
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#include <features.h>
+
+#define __NEED_off_t
+#define __NEED_pid_t
+#define __NEED_mode_t
+
+#ifdef _GNU_SOURCE
+#define __NEED_size_t
+#define __NEED_ssize_t
+#define __NEED_struct_iovec
+#endif
+
+#include <bits/alltypes.h>
+
+#include <bits/fcntl.h>
+
+struct flock {
+	short l_type;
+	short l_whence;
+	off_t l_start;
+	off_t l_len;
+	pid_t l_pid;
+};
+
+int creat(const char *, mode_t);
+int fcntl(int, int, ...);
+int open(const char *, int, ...);
+int openat(int, const char *, int, ...);
+int posix_fadvise(int, off_t, off_t, int);
+int posix_fallocate(int, off_t, off_t);
+
+#define O_SEARCH   O_PATH
+#define O_EXEC     O_PATH
+#define O_TTY_INIT 0
+
+#define O_ACCMODE (03|O_SEARCH)
+#define O_RDONLY  00
+#define O_WRONLY  01
+#define O_RDWR    02
+
+#define F_OFD_GETLK 36
+#define F_OFD_SETLK 37
+#define F_OFD_SETLKW 38
+
+#define F_DUPFD_CLOEXEC 1030
+
+#define F_RDLCK 0
+#define F_WRLCK 1
+#define F_UNLCK 2
+
+#define FD_CLOEXEC 1
+
+#define AT_FDCWD (-100)
+#define AT_SYMLINK_NOFOLLOW 0x100
+#define AT_REMOVEDIR 0x200
+#define AT_SYMLINK_FOLLOW 0x400
+#define AT_EACCESS 0x200
+
+#define POSIX_FADV_NORMAL     0
+#define POSIX_FADV_RANDOM     1
+#define POSIX_FADV_SEQUENTIAL 2
+#define POSIX_FADV_WILLNEED   3
+#ifndef POSIX_FADV_DONTNEED
+#define POSIX_FADV_DONTNEED   4
+#define POSIX_FADV_NOREUSE    5
+#endif
+
+#undef SEEK_SET
+#undef SEEK_CUR
+#undef SEEK_END
+#define SEEK_SET 0
+#define SEEK_CUR 1
+#define SEEK_END 2
+
+#ifndef S_IRUSR
+#define S_ISUID 04000
+#define S_ISGID 02000
+#define S_ISVTX 01000
+#define S_IRUSR 0400
+#define S_IWUSR 0200
+#define S_IXUSR 0100
+#define S_IRWXU 0700
+#define S_IRGRP 0040
+#define S_IWGRP 0020
+#define S_IXGRP 0010
+#define S_IRWXG 0070
+#define S_IROTH 0004
+#define S_IWOTH 0002
+#define S_IXOTH 0001
+#define S_IRWXO 0007
+#endif
+
+#if defined(_GNU_SOURCE) || defined(_BSD_SOURCE)
+#define AT_NO_AUTOMOUNT 0x800
+#define AT_EMPTY_PATH 0x1000
+#define AT_STATX_SYNC_TYPE 0x6000
+#define AT_STATX_SYNC_AS_STAT 0x0000
+#define AT_STATX_FORCE_SYNC 0x2000
+#define AT_STATX_DONT_SYNC 0x4000
+#define AT_RECURSIVE 0x8000
+
+#define FAPPEND O_APPEND
+#define FFSYNC O_SYNC
+#define FASYNC O_ASYNC
+#define FNONBLOCK O_NONBLOCK
+#define FNDELAY O_NDELAY
+
+#define F_OK 0
+#define R_OK 4
+#define W_OK 2
+#define X_OK 1
+#define F_ULOCK 0
+#define F_LOCK  1
+#define F_TLOCK 2
+#define F_TEST  3
+
+#define F_SETLEASE	1024
+#define F_GETLEASE	1025
+#define F_NOTIFY	1026
+#define F_CANCELLK	1029
+#define F_SETPIPE_SZ	1031
+#define F_GETPIPE_SZ	1032
+#define F_ADD_SEALS	1033
+#define F_GET_SEALS	1034
+
+#define F_SEAL_SEAL	0x0001
+#define F_SEAL_SHRINK	0x0002
+#define F_SEAL_GROW	0x0004
+#define F_SEAL_WRITE	0x0008
+#define F_SEAL_FUTURE_WRITE	0x0010
+
+#define F_GET_RW_HINT		1035
+#define F_SET_RW_HINT		1036
+#define F_GET_FILE_RW_HINT	1037
+#define F_SET_FILE_RW_HINT	1038
+
+#define RWF_WRITE_LIFE_NOT_SET	0
+#define RWH_WRITE_LIFE_NONE	1
+#define RWH_WRITE_LIFE_SHORT	2
+#define RWH_WRITE_LIFE_MEDIUM	3
+#define RWH_WRITE_LIFE_LONG	4
+#define RWH_WRITE_LIFE_EXTREME	5
+
+#define DN_ACCESS	0x00000001
+#define DN_MODIFY	0x00000002
+#define DN_CREATE	0x00000004
+#define DN_DELETE	0x00000008
+#define DN_RENAME	0x00000010
+#define DN_ATTRIB	0x00000020
+#define DN_MULTISHOT	0x80000000
+
+int lockf(int, int, off_t);
+#endif
+
+#if defined(_GNU_SOURCE)
+#define F_OWNER_TID 0
+#define F_OWNER_PID 1
+#define F_OWNER_PGRP 2
+#define F_OWNER_GID 2
+struct file_handle {
+	unsigned handle_bytes;
+	int handle_type;
+	unsigned char f_handle[];
+};
+struct f_owner_ex {
+	int type;
+	pid_t pid;
+};
+#define FALLOC_FL_KEEP_SIZE 1
+#define FALLOC_FL_PUNCH_HOLE 2
+#define MAX_HANDLE_SZ 128
+#define SYNC_FILE_RANGE_WAIT_BEFORE 1
+#define SYNC_FILE_RANGE_WRITE 2
+#define SYNC_FILE_RANGE_WAIT_AFTER 4
+#define SPLICE_F_MOVE 1
+#define SPLICE_F_NONBLOCK 2
+#define SPLICE_F_MORE 4
+#define SPLICE_F_GIFT 8
+int fallocate(int, int, off_t, off_t);
+#define fallocate64 fallocate
+int name_to_handle_at(int, const char *, struct file_handle *, int *, int);
+int open_by_handle_at(int, struct file_handle *, int);
+ssize_t readahead(int, off_t, size_t);
+int sync_file_range(int, off_t, off_t, unsigned);
+ssize_t vmsplice(int, const struct iovec *, size_t, unsigned);
+ssize_t splice(int, off_t *, int, off_t *, size_t, unsigned);
+ssize_t tee(int, int, size_t, unsigned);
+#define loff_t off_t
+#endif
+
+#if defined(_LARGEFILE64_SOURCE) || defined(_GNU_SOURCE)
+#define F_GETLK64 F_GETLK
+#define F_SETLK64 F_SETLK
+#define F_SETLKW64 F_SETLKW
+#define flock64 flock
+#define open64 open
+#define openat64 openat
+#define creat64 creat
+#define lockf64 lockf
+#define posix_fadvise64 posix_fadvise
+#define posix_fallocate64 posix_fallocate
+#define off64_t off_t
+#endif
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
diff --git a/third_party/musl/porting/liteos_m/kernel/include/features.h b/third_party/musl/porting/liteos_m/kernel/include/features.h
new file mode 100755
index 000000000..b5fd3184e
--- /dev/null
+++ b/third_party/musl/porting/liteos_m/kernel/include/features.h
@@ -0,0 +1,46 @@
+#ifndef _FEATURES_H
+#define _FEATURES_H
+
+#if defined(_ALL_SOURCE) && !defined(_GNU_SOURCE)
+#define _GNU_SOURCE 1
+#endif
+
+#if defined(_DEFAULT_SOURCE) && !defined(_BSD_SOURCE)
+#define _BSD_SOURCE 1
+#endif
+
+#if !defined(_POSIX_SOURCE) && !defined(_POSIX_C_SOURCE) \
+ && !defined(_XOPEN_SOURCE) && !defined(_GNU_SOURCE) \
+ && !defined(_BSD_SOURCE) && !defined(__STRICT_ANSI__)
+#define _BSD_SOURCE 1
+#define _XOPEN_SOURCE 700
+#endif
+
+#if __STDC_VERSION__ >= 199901L && !defined(__cplusplus)
+#define __restrict restrict
+#elif !defined(__GNUC__)
+#define __restrict
+#endif
+
+#if __STDC_VERSION__ >= 199901L || defined(__cplusplus)
+#define __inline inline
+#elif !defined(__GNUC__)
+#define __inline
+#endif
+
+#if defined(__cplusplus)
+#if __cplusplus >= 201103L
+#define _Noreturn [[ noreturn ]]
+#else
+#define _Noreturn
+#endif
+#elif __STDC_VERSION__ >= 201112L
+#elif defined(__GNUC__)
+#define _Noreturn __attribute__((__noreturn__))
+#else
+#define _Noreturn
+#endif
+
+#define __REDIR(x,y) __typeof__(x) x __asm__(#y)
+
+#endif
diff --git a/third_party/musl/porting/liteos_m/kernel/include/fenv.h b/third_party/musl/porting/liteos_m/kernel/include/fenv.h
new file mode 100755
index 000000000..1fcb2ffd6
--- /dev/null
+++ b/third_party/musl/porting/liteos_m/kernel/include/fenv.h
@@ -0,0 +1,34 @@
+#ifndef _FENV_H
+#define _FENV_H
+
+#ifdef __ICCARM__ /* for iar */
+#include_next <fenv.h>
+#else
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#include <bits/fenv.h>
+
+int feclearexcept(int);
+int fegetexceptflag(fexcept_t *, int);
+int feraiseexcept(int);
+int fesetexceptflag(const fexcept_t *, int);
+int fetestexcept(int);
+
+int fegetround(void);
+int fesetround(int);
+
+int fegetenv(fenv_t *);
+int feholdexcept(fenv_t *);
+int fesetenv(const fenv_t *);
+int feupdateenv(const fenv_t *);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* __ICCARM__ */
+#endif
+
diff --git a/third_party/musl/porting/liteos_m/kernel/include/float.h b/third_party/musl/porting/liteos_m/kernel/include/float.h
new file mode 100755
index 000000000..a4c1b54e9
--- /dev/null
+++ b/third_party/musl/porting/liteos_m/kernel/include/float.h
@@ -0,0 +1,57 @@
+#ifndef _FLOAT_H
+#define _FLOAT_H
+
+#ifdef __ICCARM__ /* for iar */
+#include_next <float.h>
+#else
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+int __flt_rounds(void);
+#define FLT_ROUNDS (__flt_rounds())
+
+#define FLT_RADIX 2
+
+#define FLT_TRUE_MIN 1.40129846432481707092e-45F
+#define FLT_MIN 1.17549435082228750797e-38F
+#define FLT_MAX 3.40282346638528859812e+38F
+#define FLT_EPSILON 1.1920928955078125e-07F
+
+#define FLT_MANT_DIG 24
+#define FLT_MIN_EXP (-125)
+#define FLT_MAX_EXP 128
+#define FLT_HAS_SUBNORM 1
+
+#define FLT_DIG 6
+#define FLT_DECIMAL_DIG 9
+#define FLT_MIN_10_EXP (-37)
+#define FLT_MAX_10_EXP 38
+
+#define DBL_TRUE_MIN 4.94065645841246544177e-324
+#define DBL_MIN 2.22507385850720138309e-308
+#define DBL_MAX 1.79769313486231570815e+308
+#define DBL_EPSILON 2.22044604925031308085e-16
+
+#define DBL_MANT_DIG 53
+#define DBL_MIN_EXP (-1021)
+#define DBL_MAX_EXP 1024
+#define DBL_HAS_SUBNORM 1
+
+#define DBL_DIG 15
+#define DBL_DECIMAL_DIG 17
+#define DBL_MIN_10_EXP (-307)
+#define DBL_MAX_10_EXP 308
+
+#define LDBL_HAS_SUBNORM 1
+#define LDBL_DECIMAL_DIG DECIMAL_DIG
+
+#include <bits/float.h>
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* __ICCARM__ */
+#endif
diff --git a/third_party/musl/porting/liteos_m/kernel/include/fmtmsg.h b/third_party/musl/porting/liteos_m/kernel/include/fmtmsg.h
new file mode 100755
index 000000000..d944b06f8
--- /dev/null
+++ b/third_party/musl/porting/liteos_m/kernel/include/fmtmsg.h
@@ -0,0 +1,47 @@
+#ifndef _FMTMSG_H
+#define _FMTMSG_H
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#define MM_HARD		1
+#define MM_SOFT		2
+#define MM_FIRM		4
+
+#define MM_APPL		8
+#define MM_UTIL		16
+#define MM_OPSYS	32
+
+#define MM_RECOVER	64
+#define MM_NRECOV	128
+
+#define MM_PRINT	256
+#define MM_CONSOLE	512
+
+#define MM_NULLMC	0L
+
+#define MM_HALT		1
+#define MM_ERROR	2
+#define MM_WARNING	3
+#define MM_INFO		4
+#define MM_NOSEV	0
+
+#define MM_OK		0
+#define MM_NOTOK	(-1)
+#define MM_NOMSG	1
+#define MM_NOCON	4
+
+#define MM_NULLLBL	((char*)0)
+#define MM_NULLTXT	((char*)0)
+#define MM_NULLACT	((char*)0)
+#define MM_NULLTAG	((char*)0)
+#define MM_NULLSEV	0
+
+int fmtmsg(long, const char *, int, const char *, const char *, const char *);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
diff --git a/third_party/musl/porting/liteos_m/kernel/include/fnmatch.h b/third_party/musl/porting/liteos_m/kernel/include/fnmatch.h
new file mode 100755
index 000000000..f9593217f
--- /dev/null
+++ b/third_party/musl/porting/liteos_m/kernel/include/fnmatch.h
@@ -0,0 +1,24 @@
+#ifndef	_FNMATCH_H
+#define	_FNMATCH_H
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#define	FNM_PATHNAME 0x1
+#define	FNM_NOESCAPE 0x2
+#define	FNM_PERIOD   0x4
+#define	FNM_LEADING_DIR	0x8           
+#define	FNM_CASEFOLD	0x10
+#define	FNM_FILE_NAME	FNM_PATHNAME
+
+#define	FNM_NOMATCH 1
+#define FNM_NOSYS   (-1)
+
+int fnmatch(const char *, const char *, int);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
diff --git a/third_party/musl/porting/liteos_m/kernel/include/ftw.h b/third_party/musl/porting/liteos_m/kernel/include/ftw.h
new file mode 100755
index 000000000..b15c062a8
--- /dev/null
+++ b/third_party/musl/porting/liteos_m/kernel/include/ftw.h
@@ -0,0 +1,41 @@
+#ifndef _FTW_H
+#define	_FTW_H
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#include <features.h>
+#include <sys/stat.h>
+
+#define FTW_F   1
+#define FTW_D   2
+#define FTW_DNR 3
+#define FTW_NS  4
+#define FTW_SL  5
+#define FTW_DP  6
+#define FTW_SLN 7
+
+#define FTW_PHYS  1
+#define FTW_MOUNT 2
+#define FTW_CHDIR 4
+#define FTW_DEPTH 8
+
+struct FTW {
+	int base;
+	int level;
+};
+
+int ftw(const char *, int (*)(const char *, const struct stat *, int), int);
+int nftw(const char *, int (*)(const char *, const struct stat *, int, struct FTW *), int, int);
+
+#if defined(_LARGEFILE64_SOURCE) || defined(_GNU_SOURCE)
+#define ftw64 ftw
+#define nftw64 nftw
+#endif
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
diff --git a/third_party/musl/porting/liteos_m/kernel/include/getopt.h b/third_party/musl/porting/liteos_m/kernel/include/getopt.h
new file mode 100755
index 000000000..35cbd358b
--- /dev/null
+++ b/third_party/musl/porting/liteos_m/kernel/include/getopt.h
@@ -0,0 +1,30 @@
+#ifndef _GETOPT_H
+#define _GETOPT_H
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+int getopt(int, char * const [], const char *);
+extern char *optarg;
+extern int optind, opterr, optopt, optreset;
+
+struct option {
+	const char *name;
+	int has_arg;
+	int *flag;
+	int val;
+};
+
+int getopt_long(int, char *const *, const char *, const struct option *, int *);
+int getopt_long_only(int, char *const *, const char *, const struct option *, int *);
+
+#define no_argument        0
+#define required_argument  1
+#define optional_argument  2
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
diff --git a/third_party/musl/porting/liteos_m/kernel/include/glob.h b/third_party/musl/porting/liteos_m/kernel/include/glob.h
new file mode 100755
index 000000000..4a562a206
--- /dev/null
+++ b/third_party/musl/porting/liteos_m/kernel/include/glob.h
@@ -0,0 +1,52 @@
+#ifndef	_GLOB_H
+#define	_GLOB_H
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#include <features.h>
+
+#define __NEED_size_t
+
+#include <bits/alltypes.h>
+
+typedef struct {
+	size_t gl_pathc;
+	char **gl_pathv;
+	size_t gl_offs;
+	int __dummy1;
+	void *__dummy2[5];
+} glob_t;
+
+int  glob(const char *__restrict, int, int (*)(const char *, int), glob_t *__restrict);
+void globfree(glob_t *);
+
+#define GLOB_ERR      0x01
+#define GLOB_MARK     0x02
+#define GLOB_NOSORT   0x04
+#define GLOB_DOOFFS   0x08
+#define GLOB_NOCHECK  0x10
+#define GLOB_APPEND   0x20
+#define GLOB_NOESCAPE 0x40
+#define	GLOB_PERIOD   0x80
+
+#define GLOB_TILDE       0x1000
+#define GLOB_TILDE_CHECK 0x4000
+
+#define GLOB_NOSPACE 1
+#define GLOB_ABORTED 2
+#define GLOB_NOMATCH 3
+#define GLOB_NOSYS   4
+
+#if defined(_LARGEFILE64_SOURCE) || defined(_GNU_SOURCE)
+#define glob64 glob
+#define globfree64 globfree
+#define glob64_t glob_t
+#endif
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
diff --git a/third_party/musl/porting/liteos_m/kernel/include/grp.h b/third_party/musl/porting/liteos_m/kernel/include/grp.h
new file mode 100755
index 000000000..27e8c5e6c
--- /dev/null
+++ b/third_party/musl/porting/liteos_m/kernel/include/grp.h
@@ -0,0 +1,53 @@
+#ifndef	_GRP_H
+#define	_GRP_H
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#include <features.h>
+
+#define __NEED_size_t
+#define __NEED_gid_t
+
+#ifdef _GNU_SOURCE
+#define __NEED_FILE
+#endif
+
+#include <bits/alltypes.h>
+
+struct group {
+	char *gr_name;
+	char *gr_passwd;
+	gid_t gr_gid;
+	char **gr_mem;
+};
+
+struct group  *getgrgid(gid_t);
+struct group  *getgrnam(const char *);
+
+int getgrgid_r(gid_t, struct group *, char *, size_t, struct group **);
+int getgrnam_r(const char *, struct group *, char *, size_t, struct group **);
+
+#if defined(_XOPEN_SOURCE) || defined(_GNU_SOURCE) || defined(_BSD_SOURCE)
+struct group  *getgrent(void);
+void           endgrent(void);
+void           setgrent(void);
+#endif
+
+#ifdef _GNU_SOURCE
+struct group  *fgetgrent(FILE *);
+int putgrent(const struct group *, FILE *);
+#endif
+
+#if defined(_GNU_SOURCE) || defined(_BSD_SOURCE)
+int getgrouplist(const char *, gid_t, gid_t *, int *);
+int setgroups(size_t, const gid_t *);
+int initgroups(const char *, gid_t);
+#endif
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
diff --git a/third_party/musl/porting/liteos_m/kernel/include/iconv.h b/third_party/musl/porting/liteos_m/kernel/include/iconv.h
new file mode 100755
index 000000000..ebe9bfda3
--- /dev/null
+++ b/third_party/musl/porting/liteos_m/kernel/include/iconv.h
@@ -0,0 +1,24 @@
+#ifndef _ICONV_H
+#define _ICONV_H
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#include <features.h>
+
+#define __NEED_size_t
+
+#include <bits/alltypes.h>
+
+typedef void *iconv_t;
+
+iconv_t iconv_open(const char *, const char *);
+size_t iconv(iconv_t, char **__restrict, size_t *__restrict, char **__restrict, size_t *__restrict);
+int iconv_close(iconv_t);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
diff --git a/third_party/musl/porting/liteos_m/kernel/include/ifaddrs.h b/third_party/musl/porting/liteos_m/kernel/include/ifaddrs.h
new file mode 100755
index 000000000..c0328a8ea
--- /dev/null
+++ b/third_party/musl/porting/liteos_m/kernel/include/ifaddrs.h
@@ -0,0 +1,35 @@
+#ifndef _IFADDRS_H
+#define _IFADDRS_H
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#include <features.h>
+#include <netinet/in.h>
+#include <sys/socket.h>
+
+struct ifaddrs {
+	struct ifaddrs *ifa_next;
+	char *ifa_name;
+	unsigned ifa_flags;
+	struct sockaddr *ifa_addr;
+	struct sockaddr *ifa_netmask;
+	union {
+		struct sockaddr *ifu_broadaddr;
+		struct sockaddr *ifu_dstaddr;
+	} ifa_ifu;
+	void *ifa_data;
+};
+#define ifa_broadaddr ifa_ifu.ifu_broadaddr
+#define ifa_dstaddr ifa_ifu.ifu_dstaddr
+
+void freeifaddrs(struct ifaddrs *);
+int getifaddrs(struct ifaddrs **);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
+
diff --git a/third_party/musl/porting/liteos_m/kernel/include/inttypes.h b/third_party/musl/porting/liteos_m/kernel/include/inttypes.h
new file mode 100755
index 000000000..d6c5c6ef5
--- /dev/null
+++ b/third_party/musl/porting/liteos_m/kernel/include/inttypes.h
@@ -0,0 +1,234 @@
+#ifndef _INTTYPES_H
+#define _INTTYPES_H
+
+#ifdef __ICCARM__ /* for iar */
+#include_next <inttypes.h>
+#else
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#include <features.h>
+#include <stdint.h>
+
+#define __NEED_wchar_t
+#include <bits/alltypes.h>
+
+typedef struct { intmax_t quot, rem; } imaxdiv_t;
+
+intmax_t imaxabs(intmax_t);
+imaxdiv_t imaxdiv(intmax_t, intmax_t);
+
+intmax_t strtoimax(const char *__restrict, char **__restrict, int);
+uintmax_t strtoumax(const char *__restrict, char **__restrict, int);
+
+intmax_t wcstoimax(const wchar_t *__restrict, wchar_t **__restrict, int);
+uintmax_t wcstoumax(const wchar_t *__restrict, wchar_t **__restrict, int);
+
+#if UINTPTR_MAX == UINT64_MAX
+#define __PRI64  "l"
+#define __PRIPTR "l"
+#else
+#define __PRI64  "ll"
+#define __PRIPTR ""
+#endif
+
+#define PRId8  "d"
+#define PRId16 "d"
+#define PRId32 "d"
+#define PRId64 __PRI64 "d"
+
+#define PRIdLEAST8  "d"
+#define PRIdLEAST16 "d"
+#define PRIdLEAST32 "d"
+#define PRIdLEAST64 __PRI64 "d"
+
+#define PRIdFAST8  "d"
+#define PRIdFAST16 "d"
+#define PRIdFAST32 "d"
+#define PRIdFAST64 __PRI64 "d"
+
+#define PRIi8  "i"
+#define PRIi16 "i"
+#define PRIi32 "i"
+#define PRIi64 __PRI64 "i"
+
+#define PRIiLEAST8  "i"
+#define PRIiLEAST16 "i"
+#define PRIiLEAST32 "i"
+#define PRIiLEAST64 __PRI64 "i"
+
+#define PRIiFAST8  "i"
+#define PRIiFAST16 "i"
+#define PRIiFAST32 "i"
+#define PRIiFAST64 __PRI64 "i"
+
+#define PRIo8  "o"
+#define PRIo16 "o"
+#define PRIo32 "o"
+#define PRIo64 __PRI64 "o"
+
+#define PRIoLEAST8  "o"
+#define PRIoLEAST16 "o"
+#define PRIoLEAST32 "o"
+#define PRIoLEAST64 __PRI64 "o"
+
+#define PRIoFAST8  "o"
+#define PRIoFAST16 "o"
+#define PRIoFAST32 "o"
+#define PRIoFAST64 __PRI64 "o"
+
+#define PRIu8  "u"
+#define PRIu16 "u"
+#define PRIu32 "u"
+#define PRIu64 __PRI64 "u"
+
+#define PRIuLEAST8  "u"
+#define PRIuLEAST16 "u"
+#define PRIuLEAST32 "u"
+#define PRIuLEAST64 __PRI64 "u"
+
+#define PRIuFAST8  "u"
+#define PRIuFAST16 "u"
+#define PRIuFAST32 "u"
+#define PRIuFAST64 __PRI64 "u"
+
+#define PRIx8  "x"
+#define PRIx16 "x"
+#define PRIx32 "x"
+#define PRIx64 __PRI64 "x"
+
+#define PRIxLEAST8  "x"
+#define PRIxLEAST16 "x"
+#define PRIxLEAST32 "x"
+#define PRIxLEAST64 __PRI64 "x"
+
+#define PRIxFAST8  "x"
+#define PRIxFAST16 "x"
+#define PRIxFAST32 "x"
+#define PRIxFAST64 __PRI64 "x"
+
+#define PRIX8  "X"
+#define PRIX16 "X"
+#define PRIX32 "X"
+#define PRIX64 __PRI64 "X"
+
+#define PRIXLEAST8  "X"
+#define PRIXLEAST16 "X"
+#define PRIXLEAST32 "X"
+#define PRIXLEAST64 __PRI64 "X"
+
+#define PRIXFAST8  "X"
+#define PRIXFAST16 "X"
+#define PRIXFAST32 "X"
+#define PRIXFAST64 __PRI64 "X"
+
+#define PRIdMAX __PRI64 "d"
+#define PRIiMAX __PRI64 "i"
+#define PRIoMAX __PRI64 "o"
+#define PRIuMAX __PRI64 "u"
+#define PRIxMAX __PRI64 "x"
+#define PRIXMAX __PRI64 "X"
+
+#define PRIdPTR __PRIPTR "d"
+#define PRIiPTR __PRIPTR "i"
+#define PRIoPTR __PRIPTR "o"
+#define PRIuPTR __PRIPTR "u"
+#define PRIxPTR __PRIPTR "x"
+#define PRIXPTR __PRIPTR "X"
+
+#define SCNd8   "hhd"
+#define SCNd16  "hd"
+#define SCNd32  "d"
+#define SCNd64  __PRI64 "d"
+
+#define SCNdLEAST8  "hhd"
+#define SCNdLEAST16 "hd"
+#define SCNdLEAST32 "d"
+#define SCNdLEAST64 __PRI64 "d"
+
+#define SCNdFAST8  "hhd"
+#define SCNdFAST16 "d"
+#define SCNdFAST32 "d"
+#define SCNdFAST64 __PRI64 "d"
+
+#define SCNi8   "hhi"
+#define SCNi16  "hi"
+#define SCNi32  "i"
+#define SCNi64  __PRI64 "i"
+
+#define SCNiLEAST8  "hhi"
+#define SCNiLEAST16 "hi"
+#define SCNiLEAST32 "i"
+#define SCNiLEAST64 __PRI64 "i"
+
+#define SCNiFAST8  "hhi"
+#define SCNiFAST16 "i"
+#define SCNiFAST32 "i"
+#define SCNiFAST64 __PRI64 "i"
+
+#define SCNu8   "hhu"
+#define SCNu16  "hu"
+#define SCNu32  "u"
+#define SCNu64  __PRI64 "u"
+
+#define SCNuLEAST8  "hhu"
+#define SCNuLEAST16 "hu"
+#define SCNuLEAST32 "u"
+#define SCNuLEAST64 __PRI64 "u"
+
+#define SCNuFAST8 "hhu"
+#define SCNuFAST16 "u"
+#define SCNuFAST32 "u"
+#define SCNuFAST64 __PRI64 "u"
+
+#define SCNo8   "hho"
+#define SCNo16  "ho"
+#define SCNo32  "o"
+#define SCNo64  __PRI64 "o"
+
+#define SCNoLEAST8  "hho"
+#define SCNoLEAST16 "ho"
+#define SCNoLEAST32 "o"
+#define SCNoLEAST64 __PRI64 "o"
+
+#define SCNoFAST8  "hho"
+#define SCNoFAST16 "o"
+#define SCNoFAST32 "o"
+#define SCNoFAST64 __PRI64 "o"
+
+#define SCNx8   "hhx"
+#define SCNx16  "hx"
+#define SCNx32  "x"
+#define SCNx64  __PRI64 "x"
+
+#define SCNxLEAST8  "hhx"
+#define SCNxLEAST16 "hx"
+#define SCNxLEAST32 "x"
+#define SCNxLEAST64 __PRI64 "x"
+
+#define SCNxFAST8  "hhx"
+#define SCNxFAST16 "x"
+#define SCNxFAST32 "x"
+#define SCNxFAST64 __PRI64 "x"
+
+#define SCNdMAX __PRI64 "d"
+#define SCNiMAX __PRI64 "i"
+#define SCNoMAX __PRI64 "o"
+#define SCNuMAX __PRI64 "u"
+#define SCNxMAX __PRI64 "x"
+
+#define SCNdPTR __PRIPTR "d"
+#define SCNiPTR __PRIPTR "i"
+#define SCNoPTR __PRIPTR "o"
+#define SCNuPTR __PRIPTR "u"
+#define SCNxPTR __PRIPTR "x"
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* __ICCARM__ */
+#endif
+
diff --git a/third_party/musl/porting/liteos_m/kernel/include/iso646.h b/third_party/musl/porting/liteos_m/kernel/include/iso646.h
new file mode 100755
index 000000000..10c6eb16d
--- /dev/null
+++ b/third_party/musl/porting/liteos_m/kernel/include/iso646.h
@@ -0,0 +1,25 @@
+#ifndef _ISO646_H
+#define _ISO646_H
+
+#ifdef __ICCARM__ /* for iar */
+#include_next <iso646.h>
+#else
+
+#ifndef __cplusplus
+
+#define and    &&
+#define and_eq &=
+#define bitand &
+#define bitor  |
+#define compl  ~
+#define not    !
+#define not_eq !=
+#define or     ||
+#define or_eq  |=
+#define xor    ^
+#define xor_eq ^=
+
+#endif
+
+#endif /* __ICCARM__ */
+#endif
diff --git a/third_party/musl/porting/liteos_m/kernel/include/langinfo.h b/third_party/musl/porting/liteos_m/kernel/include/langinfo.h
new file mode 100755
index 000000000..519c06129
--- /dev/null
+++ b/third_party/musl/porting/liteos_m/kernel/include/langinfo.h
@@ -0,0 +1,98 @@
+#ifndef _LANGINFO_H
+#define _LANGINFO_H
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#include <features.h>
+#include <nl_types.h>
+
+#define __NEED_locale_t
+
+#include <bits/alltypes.h>
+
+#define ABDAY_1 0x20000
+#define ABDAY_2 0x20001
+#define ABDAY_3 0x20002
+#define ABDAY_4 0x20003
+#define ABDAY_5 0x20004
+#define ABDAY_6 0x20005
+#define ABDAY_7 0x20006
+
+#define DAY_1 0x20007
+#define DAY_2 0x20008
+#define DAY_3 0x20009
+#define DAY_4 0x2000A
+#define DAY_5 0x2000B
+#define DAY_6 0x2000C
+#define DAY_7 0x2000D
+
+#define ABMON_1 0x2000E
+#define ABMON_2 0x2000F
+#define ABMON_3 0x20010
+#define ABMON_4 0x20011
+#define ABMON_5 0x20012
+#define ABMON_6 0x20013
+#define ABMON_7 0x20014
+#define ABMON_8 0x20015
+#define ABMON_9 0x20016
+#define ABMON_10 0x20017
+#define ABMON_11 0x20018
+#define ABMON_12 0x20019
+
+#define MON_1 0x2001A
+#define MON_2 0x2001B
+#define MON_3 0x2001C
+#define MON_4 0x2001D
+#define MON_5 0x2001E
+#define MON_6 0x2001F
+#define MON_7 0x20020
+#define MON_8 0x20021
+#define MON_9 0x20022
+#define MON_10 0x20023
+#define MON_11 0x20024
+#define MON_12 0x20025
+
+#define AM_STR 0x20026
+#define PM_STR 0x20027
+
+#define D_T_FMT 0x20028
+#define D_FMT 0x20029
+#define T_FMT 0x2002A
+#define T_FMT_AMPM 0x2002B
+
+#define ERA 0x2002C
+#define ERA_D_FMT 0x2002E
+#define ALT_DIGITS 0x2002F
+#define ERA_D_T_FMT 0x20030
+#define ERA_T_FMT 0x20031
+
+#define CODESET 14
+
+#define CRNCYSTR 0x4000F
+
+#define RADIXCHAR 0x10000
+#define THOUSEP 0x10001
+#define YESEXPR 0x50000
+#define NOEXPR 0x50001
+
+#define _NL_LOCALE_NAME(cat) (((cat)<<16) | 0xffff)
+
+#if defined(_GNU_SOURCE)
+#define NL_LOCALE_NAME(cat) _NL_LOCALE_NAME(cat)
+#endif
+
+#if defined(_GNU_SOURCE) || defined(_BSD_SOURCE)
+#define YESSTR 0x50002
+#define NOSTR 0x50003
+#endif
+
+char *nl_langinfo(nl_item);
+char *nl_langinfo_l(nl_item, locale_t);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
diff --git a/third_party/musl/porting/liteos_m/kernel/include/lastlog.h b/third_party/musl/porting/liteos_m/kernel/include/lastlog.h
new file mode 100755
index 000000000..5fa45ee47
--- /dev/null
+++ b/third_party/musl/porting/liteos_m/kernel/include/lastlog.h
@@ -0,0 +1 @@
+#include <utmp.h>
diff --git a/third_party/musl/porting/liteos_m/kernel/include/libgen.h b/third_party/musl/porting/liteos_m/kernel/include/libgen.h
new file mode 100755
index 000000000..7c7fd9c6d
--- /dev/null
+++ b/third_party/musl/porting/liteos_m/kernel/include/libgen.h
@@ -0,0 +1,15 @@
+#ifndef _LIBGEN_H
+#define _LIBGEN_H
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+char *dirname(char *);
+char *basename(char *);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
diff --git a/third_party/musl/porting/liteos_m/kernel/include/libintl.h b/third_party/musl/porting/liteos_m/kernel/include/libintl.h
new file mode 100755
index 000000000..6a707bf0f
--- /dev/null
+++ b/third_party/musl/porting/liteos_m/kernel/include/libintl.h
@@ -0,0 +1,33 @@
+#ifndef _LIBINTL_H
+#define _LIBINTL_H
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#define __USE_GNU_GETTEXT 1
+#define __GNU_GETTEXT_SUPPORTED_REVISION(major) ((major) == 0 ? 1 : -1)
+
+#if __GNUC__ >= 3
+#define __fa(n) __attribute__ ((__format_arg__ (n)))
+#else
+#define __fa(n)
+#endif
+
+char *gettext(const char *) __fa(1);
+char *dgettext(const char *, const char *) __fa(2);
+char *dcgettext(const char *, const char *, int) __fa(2);
+char *ngettext(const char *, const char *, unsigned long) __fa(1) __fa(2);
+char *dngettext(const char *, const char *, const char *, unsigned long) __fa(2) __fa(3);
+char *dcngettext(const char *, const char *, const char *, unsigned long, int) __fa(2) __fa(3);
+char *textdomain(const char *);
+char *bindtextdomain (const char *, const char *);
+char *bind_textdomain_codeset(const char *, const char *);
+
+#undef __fa
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
diff --git a/third_party/musl/porting/liteos_m/kernel/include/limits.h b/third_party/musl/porting/liteos_m/kernel/include/limits.h
new file mode 100755
index 000000000..eefb24723
--- /dev/null
+++ b/third_party/musl/porting/liteos_m/kernel/include/limits.h
@@ -0,0 +1,178 @@
+#ifndef _LIMITS_H
+#define _LIMITS_H
+
+#include "los_config.h"
+
+#ifdef __ICCARM__ /* for iar */
+#define PATH_MAX 256
+#define MQ_PRIO_MAX 1
+#define PTHREAD_STACK_MIN LOSCFG_BASE_CORE_TSK_MIN_STACK_SIZE
+#define IOV_MAX 1024
+#define SSIZE_MAX LONG_MAX
+#include_next <limits.h>
+#else
+
+#include <features.h>
+
+#include <bits/alltypes.h> /* __LONG_MAX */
+
+/* Support signed or unsigned plain-char */
+
+#if '\xff' > 0
+#define CHAR_MIN 0
+#define CHAR_MAX 255
+#else
+#define CHAR_MIN (-128)
+#define CHAR_MAX 127
+#endif
+
+#define CHAR_BIT 8
+#define SCHAR_MIN (-128)
+#define SCHAR_MAX 127
+#define UCHAR_MAX 255
+#define SHRT_MIN  (-1-0x7fff)
+#define SHRT_MAX  0x7fff
+#define USHRT_MAX 0xffff
+#define INT_MIN  (-1-0x7fffffff)
+#define INT_MAX  0x7fffffff
+#define UINT_MAX 0xffffffffU
+#define LONG_MIN (-LONG_MAX-1)
+#define LONG_MAX __LONG_MAX
+#define ULONG_MAX (2UL*LONG_MAX+1)
+#define LLONG_MIN (-LLONG_MAX-1)
+#define LLONG_MAX  0x7fffffffffffffffLL
+#define ULLONG_MAX (2ULL*LLONG_MAX+1)
+
+#define MB_LEN_MAX 4
+
+#if defined(_POSIX_SOURCE) || defined(_POSIX_C_SOURCE) \
+ || defined(_XOPEN_SOURCE) || defined(_GNU_SOURCE) || defined(_BSD_SOURCE)
+
+#include <bits/limits.h>
+
+#define PIPE_BUF 4096
+#define FILESIZEBITS 64
+#ifndef NAME_MAX
+#define NAME_MAX 255
+#endif
+#define PATH_MAX 256
+#define NGROUPS_MAX 32
+#define ARG_MAX 131072
+#define IOV_MAX 1024
+#define SYMLOOP_MAX 40
+#define WORD_BIT 32
+#define SSIZE_MAX LONG_MAX
+#define TZNAME_MAX 6
+#define TTY_NAME_MAX 32
+#define HOST_NAME_MAX 255
+
+#if LONG_MAX == 0x7fffffffL
+#define LONG_BIT 32
+#else
+#define LONG_BIT 64
+#endif
+
+/* Implementation choices... */
+
+#define PTHREAD_KEYS_MAX 128
+#define PTHREAD_STACK_MIN LOSCFG_BASE_CORE_TSK_MIN_STACK_SIZE
+#define PTHREAD_DESTRUCTOR_ITERATIONS 4
+#define SEM_VALUE_MAX OS_SEM_COUNTING_MAX_COUNT
+#define SEM_NSEMS_MAX LOSCFG_BASE_IPC_SEM_LIMIT
+#define DELAYTIMER_MAX 32
+#define MQ_PRIO_MAX 1
+#define LOGIN_NAME_MAX 256
+
+/* Arbitrary numbers... */
+
+#define BC_BASE_MAX 99
+#define BC_DIM_MAX 2048
+#define BC_SCALE_MAX 99
+#define BC_STRING_MAX 1000
+#define CHARCLASS_NAME_MAX 14
+#define COLL_WEIGHTS_MAX 2
+#define EXPR_NEST_MAX 32
+#define LINE_MAX 4096
+#define RE_DUP_MAX 255
+
+#define NL_ARGMAX 9
+#define NL_MSGMAX 32767
+#define NL_SETMAX 255
+#define NL_TEXTMAX 2048
+
+#endif
+
+#if defined(_GNU_SOURCE) || defined(_BSD_SOURCE) || defined(_XOPEN_SOURCE)
+
+#ifdef PAGESIZE
+#define PAGE_SIZE PAGESIZE
+#endif
+#define NZERO 20
+#define NL_LANGMAX 32
+
+#endif
+
+#if defined(_GNU_SOURCE) || defined(_BSD_SOURCE) \
+ || (defined(_XOPEN_SOURCE) && _XOPEN_SOURCE+0 < 700)
+
+#define NL_NMAX 16
+
+#endif
+
+/* POSIX/SUS requirements follow. These numbers come directly
+ * from SUS and have nothing to do with the host system. */
+
+#define _POSIX_AIO_LISTIO_MAX   2
+#define _POSIX_AIO_MAX          1
+#define _POSIX_ARG_MAX          4096
+#define _POSIX_CHILD_MAX        25
+#define _POSIX_CLOCKRES_MIN     20000000
+#define _POSIX_DELAYTIMER_MAX   32
+#define _POSIX_HOST_NAME_MAX    255
+#define _POSIX_LINK_MAX         8
+#define _POSIX_LOGIN_NAME_MAX   9
+#define _POSIX_MAX_CANON        255
+#define _POSIX_MAX_INPUT        255
+#define _POSIX_MQ_OPEN_MAX      8
+#define _POSIX_MQ_PRIO_MAX      32
+#define _POSIX_NAME_MAX         14
+#define _POSIX_NGROUPS_MAX      8
+#define _POSIX_OPEN_MAX         20
+#define _POSIX_PATH_MAX         256
+#define _POSIX_PIPE_BUF         512
+#define _POSIX_RE_DUP_MAX       255
+#define _POSIX_RTSIG_MAX        8
+#define _POSIX_SEM_NSEMS_MAX    256
+#define _POSIX_SEM_VALUE_MAX    32767
+#define _POSIX_SIGQUEUE_MAX     32
+#define _POSIX_SSIZE_MAX        32767
+#define _POSIX_STREAM_MAX       8
+#define _POSIX_SS_REPL_MAX      4
+#define _POSIX_SYMLINK_MAX      255
+#define _POSIX_SYMLOOP_MAX      8
+#define _POSIX_THREAD_DESTRUCTOR_ITERATIONS 4
+#define _POSIX_THREAD_KEYS_MAX  128
+#define _POSIX_THREAD_THREADS_MAX 64
+#define _POSIX_TIMER_MAX        32
+#define _POSIX_TRACE_EVENT_NAME_MAX 30
+#define _POSIX_TRACE_NAME_MAX   8
+#define _POSIX_TRACE_SYS_MAX    8
+#define _POSIX_TRACE_USER_EVENT_MAX 32
+#define _POSIX_TTY_NAME_MAX     9
+#define _POSIX_TZNAME_MAX       6
+#define _POSIX2_BC_BASE_MAX     99
+#define _POSIX2_BC_DIM_MAX      2048
+#define _POSIX2_BC_SCALE_MAX    99
+#define _POSIX2_BC_STRING_MAX   1000
+#define _POSIX2_CHARCLASS_NAME_MAX 14
+#define _POSIX2_COLL_WEIGHTS_MAX 2
+#define _POSIX2_EXPR_NEST_MAX   32
+#define _POSIX2_LINE_MAX        2048
+#define _POSIX2_RE_DUP_MAX      255
+
+#define _XOPEN_IOV_MAX          16
+#define _XOPEN_NAME_MAX         255
+#define _XOPEN_PATH_MAX         1024
+
+#endif /* __ICCARM__ */
+#endif
diff --git a/third_party/musl/porting/liteos_m/kernel/include/link.h b/third_party/musl/porting/liteos_m/kernel/include/link.h
new file mode 100755
index 000000000..815018594
--- /dev/null
+++ b/third_party/musl/porting/liteos_m/kernel/include/link.h
@@ -0,0 +1,53 @@
+#ifndef _LINK_H
+#define _LINK_H
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#include <elf.h>
+#define __NEED_size_t
+#define __NEED_uint32_t
+#include <bits/alltypes.h>
+
+#if UINTPTR_MAX > 0xffffffff
+#define ElfW(type) Elf64_ ## type
+#else
+#define ElfW(type) Elf32_ ## type
+#endif
+
+#include <bits/link.h>
+
+struct dl_phdr_info {
+	ElfW(Addr) dlpi_addr;
+	const char *dlpi_name;
+	const ElfW(Phdr) *dlpi_phdr;
+	ElfW(Half) dlpi_phnum;
+	unsigned long long int dlpi_adds;
+	unsigned long long int dlpi_subs;
+	size_t dlpi_tls_modid;
+	void *dlpi_tls_data;
+};
+
+struct link_map {
+	ElfW(Addr) l_addr;
+	char *l_name;
+	ElfW(Dyn) *l_ld;
+	struct link_map *l_next, *l_prev;
+};
+
+struct r_debug {
+	int r_version;
+	struct link_map *r_map;
+	ElfW(Addr) r_brk;
+	enum { RT_CONSISTENT, RT_ADD, RT_DELETE } r_state;
+	ElfW(Addr) r_ldbase;
+};
+
+int dl_iterate_phdr(int (*)(struct dl_phdr_info *, size_t, void *), void *);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
diff --git a/third_party/musl/porting/liteos_m/kernel/include/locale.h b/third_party/musl/porting/liteos_m/kernel/include/locale.h
new file mode 100755
index 000000000..0e1fa87fd
--- /dev/null
+++ b/third_party/musl/porting/liteos_m/kernel/include/locale.h
@@ -0,0 +1,91 @@
+#ifndef	_LOCALE_H
+#define	_LOCALE_H
+
+#ifdef __ICCARM__ /* for iar */
+#include_next <locale.h>
+#else
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#include <features.h>
+
+#ifdef __cplusplus
+#define NULL 0L
+#else
+#define NULL ((void*)0)
+#endif
+
+#define LC_CTYPE    0
+#define LC_NUMERIC  1
+#define LC_TIME     2
+#define LC_COLLATE  3
+#define LC_MONETARY 4
+#define LC_MESSAGES 5
+#define LC_ALL      6
+
+struct lconv {
+	char *decimal_point;
+	char *thousands_sep;
+	char *grouping;
+
+	char *int_curr_symbol;
+	char *currency_symbol;
+	char *mon_decimal_point;
+	char *mon_thousands_sep;
+	char *mon_grouping;
+	char *positive_sign;
+	char *negative_sign;
+	char int_frac_digits;
+	char frac_digits;
+	char p_cs_precedes;
+	char p_sep_by_space;
+	char n_cs_precedes;
+	char n_sep_by_space;
+	char p_sign_posn;
+	char n_sign_posn;
+	char int_p_cs_precedes;
+	char int_p_sep_by_space;
+	char int_n_cs_precedes;
+	char int_n_sep_by_space;
+	char int_p_sign_posn;
+	char int_n_sign_posn;
+};
+
+
+char *setlocale (int, const char *);
+struct lconv *localeconv(void);
+
+
+#if defined(_POSIX_SOURCE) || defined(_POSIX_C_SOURCE) \
+ || defined(_XOPEN_SOURCE) || defined(_GNU_SOURCE) || defined(_BSD_SOURCE)
+
+#define __NEED_locale_t
+
+#include <bits/alltypes.h>
+
+#define LC_GLOBAL_LOCALE ((locale_t)-1)
+
+#define LC_CTYPE_MASK    (1<<LC_CTYPE)
+#define LC_NUMERIC_MASK  (1<<LC_NUMERIC)
+#define LC_TIME_MASK     (1<<LC_TIME)
+#define LC_COLLATE_MASK  (1<<LC_COLLATE)
+#define LC_MONETARY_MASK (1<<LC_MONETARY)
+#define LC_MESSAGES_MASK (1<<LC_MESSAGES)
+#define LC_ALL_MASK      0x7fffffff
+
+locale_t duplocale(locale_t);
+void freelocale(locale_t);
+locale_t newlocale(int, const char *, locale_t);
+locale_t uselocale(locale_t);
+
+#endif
+
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* __ICCARM__ */
+#endif
diff --git a/third_party/musl/porting/liteos_m/kernel/include/malloc.h b/third_party/musl/porting/liteos_m/kernel/include/malloc.h
new file mode 100755
index 000000000..35f8b19c2
--- /dev/null
+++ b/third_party/musl/porting/liteos_m/kernel/include/malloc.h
@@ -0,0 +1,25 @@
+#ifndef _MALLOC_H
+#define _MALLOC_H
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#define __NEED_size_t
+
+#include <bits/alltypes.h>
+
+void *malloc (size_t);
+void *calloc (size_t, size_t);
+void *realloc (void *, size_t);
+void free (void *);
+void *valloc (size_t);
+void *memalign(size_t, size_t);
+
+size_t malloc_usable_size(void *);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
diff --git a/third_party/musl/porting/liteos_m/kernel/include/math.h b/third_party/musl/porting/liteos_m/kernel/include/math.h
new file mode 100755
index 000000000..74a4e7f77
--- /dev/null
+++ b/third_party/musl/porting/liteos_m/kernel/include/math.h
@@ -0,0 +1,447 @@
+#ifndef _MATH_H
+#define _MATH_H
+
+#ifdef __ICCARM__ /* for iar */
+#include_next <math.h>
+#else
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#include <features.h>
+
+#define __NEED_float_t
+#define __NEED_double_t
+#include <bits/alltypes.h>
+
+#if 100*__GNUC__+__GNUC_MINOR__ >= 303
+#define NAN       __builtin_nanf("")
+#define INFINITY  __builtin_inff()
+#else
+#define NAN       (0.0f/0.0f)
+#define INFINITY  1e5000f
+#endif
+
+#define HUGE_VALF INFINITY
+#define HUGE_VAL  ((double)INFINITY)
+#define HUGE_VALL ((long double)INFINITY)
+
+#define MATH_ERRNO  1
+#define MATH_ERREXCEPT 2
+#define math_errhandling 2
+
+#define FP_ILOGBNAN (-1-0x7fffffff)
+#define FP_ILOGB0 FP_ILOGBNAN
+
+#define FP_NAN       0
+#define FP_INFINITE  1
+#define FP_ZERO      2
+#define FP_SUBNORMAL 3
+#define FP_NORMAL    4
+
+#ifdef __FP_FAST_FMA
+#define FP_FAST_FMA 1
+#endif
+
+#ifdef __FP_FAST_FMAF
+#define FP_FAST_FMAF 1
+#endif
+
+#ifdef __FP_FAST_FMAL
+#define FP_FAST_FMAL 1
+#endif
+
+int __fpclassify(double);
+int __fpclassifyf(float);
+int __fpclassifyl(long double);
+
+static __inline unsigned __FLOAT_BITS(float __f)
+{
+	union {float __f; unsigned __i;} __u;
+	__u.__f = __f;
+	return __u.__i;
+}
+static __inline unsigned long long __DOUBLE_BITS(double __f)
+{
+	union {double __f; unsigned long long __i;} __u;
+	__u.__f = __f;
+	return __u.__i;
+}
+
+#define fpclassify(x) ( \
+	sizeof(x) == sizeof(float) ? __fpclassifyf(x) : \
+	sizeof(x) == sizeof(double) ? __fpclassify(x) : \
+	__fpclassifyl(x) )
+
+#define isinf(x) ( \
+	sizeof(x) == sizeof(float) ? (__FLOAT_BITS(x) & 0x7fffffff) == 0x7f800000 : \
+	sizeof(x) == sizeof(double) ? (__DOUBLE_BITS(x) & -1ULL>>1) == 0x7ffULL<<52 : \
+	__fpclassifyl(x) == FP_INFINITE)
+
+#define isnan(x) ( \
+	sizeof(x) == sizeof(float) ? (__FLOAT_BITS(x) & 0x7fffffff) > 0x7f800000 : \
+	sizeof(x) == sizeof(double) ? (__DOUBLE_BITS(x) & -1ULL>>1) > 0x7ffULL<<52 : \
+	__fpclassifyl(x) == FP_NAN)
+
+#define isnormal(x) ( \
+	sizeof(x) == sizeof(float) ? ((__FLOAT_BITS(x)+0x00800000) & 0x7fffffff) >= 0x01000000 : \
+	sizeof(x) == sizeof(double) ? ((__DOUBLE_BITS(x)+(1ULL<<52)) & -1ULL>>1) >= 1ULL<<53 : \
+	__fpclassifyl(x) == FP_NORMAL)
+
+#define isfinite(x) ( \
+	sizeof(x) == sizeof(float) ? (__FLOAT_BITS(x) & 0x7fffffff) < 0x7f800000 : \
+	sizeof(x) == sizeof(double) ? (__DOUBLE_BITS(x) & -1ULL>>1) < 0x7ffULL<<52 : \
+	__fpclassifyl(x) > FP_INFINITE)
+
+int __signbit(double);
+int __signbitf(float);
+int __signbitl(long double);
+
+#define signbit(x) ( \
+	sizeof(x) == sizeof(float) ? (int)(__FLOAT_BITS(x)>>31) : \
+	sizeof(x) == sizeof(double) ? (int)(__DOUBLE_BITS(x)>>63) : \
+	__signbitl(x) )
+
+#define isunordered(x,y) (isnan((x)) ? ((void)(y),1) : isnan((y)))
+
+#define __ISREL_DEF(rel, op, type) \
+static __inline int __is##rel(type __x, type __y) \
+{ return !isunordered(__x,__y) && __x op __y; }
+
+__ISREL_DEF(lessf, <, float_t)
+__ISREL_DEF(less, <, double_t)
+__ISREL_DEF(lessl, <, long double)
+__ISREL_DEF(lessequalf, <=, float_t)
+__ISREL_DEF(lessequal, <=, double_t)
+__ISREL_DEF(lessequall, <=, long double)
+__ISREL_DEF(lessgreaterf, !=, float_t)
+__ISREL_DEF(lessgreater, !=, double_t)
+__ISREL_DEF(lessgreaterl, !=, long double)
+__ISREL_DEF(greaterf, >, float_t)
+__ISREL_DEF(greater, >, double_t)
+__ISREL_DEF(greaterl, >, long double)
+__ISREL_DEF(greaterequalf, >=, float_t)
+__ISREL_DEF(greaterequal, >=, double_t)
+__ISREL_DEF(greaterequall, >=, long double)
+
+#define __tg_pred_2(x, y, p) ( \
+	sizeof((x)+(y)) == sizeof(float) ? p##f(x, y) : \
+	sizeof((x)+(y)) == sizeof(double) ? p(x, y) : \
+	p##l(x, y) )
+
+#define isless(x, y)            __tg_pred_2(x, y, __isless)
+#define islessequal(x, y)       __tg_pred_2(x, y, __islessequal)
+#define islessgreater(x, y)     __tg_pred_2(x, y, __islessgreater)
+#define isgreater(x, y)         __tg_pred_2(x, y, __isgreater)
+#define isgreaterequal(x, y)    __tg_pred_2(x, y, __isgreaterequal)
+
+double      acos(double);
+float       acosf(float);
+long double acosl(long double);
+
+double      acosh(double);
+float       acoshf(float);
+long double acoshl(long double);
+
+double      asin(double);
+float       asinf(float);
+long double asinl(long double);
+
+double      asinh(double);
+float       asinhf(float);
+long double asinhl(long double);
+
+double      atan(double);
+float       atanf(float);
+long double atanl(long double);
+
+double      atan2(double, double);
+float       atan2f(float, float);
+long double atan2l(long double, long double);
+
+double      atanh(double);
+float       atanhf(float);
+long double atanhl(long double);
+
+double      cbrt(double);
+float       cbrtf(float);
+long double cbrtl(long double);
+
+double      ceil(double);
+float       ceilf(float);
+long double ceill(long double);
+
+double      copysign(double, double);
+float       copysignf(float, float);
+long double copysignl(long double, long double);
+
+double      cos(double);
+float       cosf(float);
+long double cosl(long double);
+
+double      cosh(double);
+float       coshf(float);
+long double coshl(long double);
+
+double      erf(double);
+float       erff(float);
+long double erfl(long double);
+
+double      erfc(double);
+float       erfcf(float);
+long double erfcl(long double);
+
+double      exp(double);
+float       expf(float);
+long double expl(long double);
+
+double      exp2(double);
+float       exp2f(float);
+long double exp2l(long double);
+
+double      expm1(double);
+float       expm1f(float);
+long double expm1l(long double);
+
+double      fabs(double);
+float       fabsf(float);
+long double fabsl(long double);
+
+double      fdim(double, double);
+float       fdimf(float, float);
+long double fdiml(long double, long double);
+
+double      floor(double);
+float       floorf(float);
+long double floorl(long double);
+
+double      fma(double, double, double);
+float       fmaf(float, float, float);
+long double fmal(long double, long double, long double);
+
+double      fmax(double, double);
+float       fmaxf(float, float);
+long double fmaxl(long double, long double);
+
+double      fmin(double, double);
+float       fminf(float, float);
+long double fminl(long double, long double);
+
+double      fmod(double, double);
+float       fmodf(float, float);
+long double fmodl(long double, long double);
+
+double      frexp(double, int *);
+float       frexpf(float, int *);
+long double frexpl(long double, int *);
+
+double      hypot(double, double);
+float       hypotf(float, float);
+long double hypotl(long double, long double);
+
+int         ilogb(double);
+int         ilogbf(float);
+int         ilogbl(long double);
+
+double      ldexp(double, int);
+float       ldexpf(float, int);
+long double ldexpl(long double, int);
+
+double      lgamma(double);
+float       lgammaf(float);
+long double lgammal(long double);
+
+long long   llrint(double);
+long long   llrintf(float);
+long long   llrintl(long double);
+
+long long   llround(double);
+long long   llroundf(float);
+long long   llroundl(long double);
+
+double      log(double);
+float       logf(float);
+long double logl(long double);
+
+double      log10(double);
+float       log10f(float);
+long double log10l(long double);
+
+double      log1p(double);
+float       log1pf(float);
+long double log1pl(long double);
+
+double      log2(double);
+float       log2f(float);
+long double log2l(long double);
+
+double      logb(double);
+float       logbf(float);
+long double logbl(long double);
+
+long        lrint(double);
+long        lrintf(float);
+long        lrintl(long double);
+
+long        lround(double);
+long        lroundf(float);
+long        lroundl(long double);
+
+double      modf(double, double *);
+float       modff(float, float *);
+long double modfl(long double, long double *);
+
+double      nan(const char *);
+float       nanf(const char *);
+long double nanl(const char *);
+
+double      nearbyint(double);
+float       nearbyintf(float);
+long double nearbyintl(long double);
+
+double      nextafter(double, double);
+float       nextafterf(float, float);
+long double nextafterl(long double, long double);
+
+double      nexttoward(double, long double);
+float       nexttowardf(float, long double);
+long double nexttowardl(long double, long double);
+
+double      pow(double, double);
+float       powf(float, float);
+long double powl(long double, long double);
+
+double      remainder(double, double);
+float       remainderf(float, float);
+long double remainderl(long double, long double);
+
+double      remquo(double, double, int *);
+float       remquof(float, float, int *);
+long double remquol(long double, long double, int *);
+
+double      rint(double);
+float       rintf(float);
+long double rintl(long double);
+
+double      round(double);
+float       roundf(float);
+long double roundl(long double);
+
+double      scalbln(double, long);
+float       scalblnf(float, long);
+long double scalblnl(long double, long);
+
+double      scalbn(double, int);
+float       scalbnf(float, int);
+long double scalbnl(long double, int);
+
+double      sin(double);
+float       sinf(float);
+long double sinl(long double);
+
+double      sinh(double);
+float       sinhf(float);
+long double sinhl(long double);
+
+double      sqrt(double);
+float       sqrtf(float);
+long double sqrtl(long double);
+
+double      tan(double);
+float       tanf(float);
+long double tanl(long double);
+
+double      tanh(double);
+float       tanhf(float);
+long double tanhl(long double);
+
+double      tgamma(double);
+float       tgammaf(float);
+long double tgammal(long double);
+
+double      trunc(double);
+float       truncf(float);
+long double truncl(long double);
+
+
+#if defined(_XOPEN_SOURCE) || defined(_BSD_SOURCE)
+#undef  MAXFLOAT
+#define MAXFLOAT        3.40282346638528859812e+38F
+#endif
+
+#if defined(_XOPEN_SOURCE) || defined(_GNU_SOURCE) || defined(_BSD_SOURCE)
+#define M_E             2.7182818284590452354   /* e */
+#define M_LOG2E         1.4426950408889634074   /* log_2 e */
+#define M_LOG10E        0.43429448190325182765  /* log_10 e */
+#define M_LN2           0.69314718055994530942  /* log_e 2 */
+#define M_LN10          2.30258509299404568402  /* log_e 10 */
+#define M_PI            3.14159265358979323846  /* pi */
+#define M_PI_2          1.57079632679489661923  /* pi/2 */
+#define M_PI_4          0.78539816339744830962  /* pi/4 */
+#define M_1_PI          0.31830988618379067154  /* 1/pi */
+#define M_2_PI          0.63661977236758134308  /* 2/pi */
+#define M_2_SQRTPI      1.12837916709551257390  /* 2/sqrt(pi) */
+#define M_SQRT2         1.41421356237309504880  /* sqrt(2) */
+#define M_SQRT1_2       0.70710678118654752440  /* 1/sqrt(2) */
+
+extern int signgam;
+
+double      j0(double);
+double      j1(double);
+double      jn(int, double);
+
+double      y0(double);
+double      y1(double);
+double      yn(int, double);
+#endif
+
+#if defined(_GNU_SOURCE) || defined(_BSD_SOURCE)
+#define HUGE            3.40282346638528859812e+38F
+
+double      drem(double, double);
+float       dremf(float, float);
+
+int         finite(double);
+int         finitef(float);
+
+double      scalb(double, double);
+float       scalbf(float, float);
+
+double      significand(double);
+float       significandf(float);
+
+double      lgamma_r(double, int*);
+float       lgammaf_r(float, int*);
+
+float       j0f(float);
+float       j1f(float);
+float       jnf(int, float);
+
+float       y0f(float);
+float       y1f(float);
+float       ynf(int, float);
+#endif
+
+#ifdef _GNU_SOURCE
+long double lgammal_r(long double, int*);
+
+void        sincos(double, double*, double*);
+void        sincosf(float, float*, float*);
+void        sincosl(long double, long double*, long double*);
+
+double      exp10(double);
+float       exp10f(float);
+long double exp10l(long double);
+
+double      pow10(double);
+float       pow10f(float);
+long double pow10l(long double);
+#endif
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* __ICCARM__ */
+#endif
diff --git a/third_party/musl/porting/liteos_m/kernel/include/memory.h b/third_party/musl/porting/liteos_m/kernel/include/memory.h
new file mode 100755
index 000000000..3b2f59002
--- /dev/null
+++ b/third_party/musl/porting/liteos_m/kernel/include/memory.h
@@ -0,0 +1 @@
+#include <string.h>
diff --git a/third_party/musl/porting/liteos_m/kernel/include/mntent.h b/third_party/musl/porting/liteos_m/kernel/include/mntent.h
new file mode 100755
index 000000000..3492a1d6d
--- /dev/null
+++ b/third_party/musl/porting/liteos_m/kernel/include/mntent.h
@@ -0,0 +1,43 @@
+#ifndef _MNTENT_H
+#define _MNTENT_H
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#define __NEED_FILE
+#include <bits/alltypes.h>
+
+#define MOUNTED "/etc/mtab"
+
+#define MNTTYPE_IGNORE	"ignore"
+#define MNTTYPE_NFS	"nfs"
+#define MNTTYPE_SWAP	"swap"
+#define MNTOPT_DEFAULTS	"defaults"
+#define MNTOPT_RO	"ro"
+#define MNTOPT_RW	"rw"
+#define MNTOPT_SUID	"suid"
+#define MNTOPT_NOSUID	"nosuid"
+#define MNTOPT_NOAUTO	"noauto"
+
+struct mntent {
+	char *mnt_fsname;
+	char *mnt_dir;
+	char *mnt_type;
+	char *mnt_opts;
+	int mnt_freq;
+	int mnt_passno;
+};
+
+FILE *setmntent(const char *, const char *);
+int endmntent(FILE *);
+struct mntent *getmntent(FILE *);
+struct mntent *getmntent_r(FILE *, struct mntent *, char *, int);
+int addmntent(FILE *, const struct mntent *);
+char *hasmntopt(const struct mntent *, const char *);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
diff --git a/third_party/musl/porting/liteos_m/kernel/include/monetary.h b/third_party/musl/porting/liteos_m/kernel/include/monetary.h
new file mode 100755
index 000000000..a91fa5655
--- /dev/null
+++ b/third_party/musl/porting/liteos_m/kernel/include/monetary.h
@@ -0,0 +1,23 @@
+#ifndef _MONETARY_H
+#define _MONETARY_H
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#include <features.h>
+
+#define __NEED_ssize_t
+#define __NEED_size_t
+#define __NEED_locale_t
+
+#include <bits/alltypes.h>
+
+ssize_t strfmon(char *__restrict, size_t, const char *__restrict, ...);
+ssize_t strfmon_l(char *__restrict, size_t, locale_t, const char *__restrict, ...);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
diff --git a/third_party/musl/porting/liteos_m/kernel/include/mqueue.h b/third_party/musl/porting/liteos_m/kernel/include/mqueue.h
new file mode 100755
index 000000000..0c807ea0c
--- /dev/null
+++ b/third_party/musl/porting/liteos_m/kernel/include/mqueue.h
@@ -0,0 +1,41 @@
+#ifndef _MQUEUE_H
+#define _MQUEUE_H
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#include <features.h>
+
+#define __NEED_size_t
+#define __NEED_ssize_t
+#define __NEED_pthread_attr_t
+#define __NEED_time_t
+#define __NEED_struct_timespec
+#include <bits/alltypes.h>
+
+typedef int mqd_t;
+struct mq_attr {
+	long mq_flags, mq_maxmsg, mq_msgsize, mq_curmsgs, __unused[4];
+};
+struct sigevent;
+
+int mq_close(mqd_t);
+int mq_getattr(mqd_t, struct mq_attr *);
+int mq_notify(mqd_t, const struct sigevent *);
+mqd_t mq_open(const char *, int, ...);
+ssize_t mq_receive(mqd_t, char *, size_t, unsigned *);
+int mq_send(mqd_t, const char *, size_t, unsigned);
+int mq_setattr(mqd_t, const struct mq_attr *__restrict, struct mq_attr *__restrict);
+ssize_t mq_timedreceive(mqd_t, char *__restrict, size_t, unsigned *__restrict, const struct timespec *__restrict);
+int mq_timedsend(mqd_t, const char *, size_t, unsigned, const struct timespec *);
+int mq_unlink(const char *);
+
+#if _REDIR_TIME64
+__REDIR(mq_timedreceive, __mq_timedreceive_time64);
+__REDIR(mq_timedsend, __mq_timedsend_time64);
+#endif
+
+#ifdef __cplusplus
+}
+#endif
+#endif
diff --git a/third_party/musl/porting/liteos_m/kernel/include/net/ethernet.h b/third_party/musl/porting/liteos_m/kernel/include/net/ethernet.h
new file mode 100755
index 000000000..c8d4177fd
--- /dev/null
+++ b/third_party/musl/porting/liteos_m/kernel/include/net/ethernet.h
@@ -0,0 +1,55 @@
+#ifndef _NET_ETHERNET_H
+#define _NET_ETHERNET_H
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#include <stdint.h>
+#include <sys/types.h>
+#include <netinet/if_ether.h>
+
+struct ether_addr {
+	uint8_t ether_addr_octet[ETH_ALEN];
+};
+
+struct ether_header {
+	uint8_t  ether_dhost[ETH_ALEN];
+	uint8_t  ether_shost[ETH_ALEN];
+	uint16_t ether_type;
+};
+
+#define	ETHERTYPE_PUP		0x0200
+#define ETHERTYPE_SPRITE	0x0500
+#define	ETHERTYPE_IP		0x0800
+#define	ETHERTYPE_ARP		0x0806
+#define	ETHERTYPE_REVARP	0x8035
+#define ETHERTYPE_AT		0x809B
+#define ETHERTYPE_AARP		0x80F3
+#define	ETHERTYPE_VLAN		0x8100
+#define ETHERTYPE_IPX		0x8137
+#define	ETHERTYPE_IPV6		0x86dd
+#define ETHERTYPE_LOOPBACK	0x9000
+
+
+#define	ETHER_ADDR_LEN	ETH_ALEN
+#define	ETHER_TYPE_LEN	2
+#define	ETHER_CRC_LEN	4
+#define	ETHER_HDR_LEN	ETH_HLEN
+#define	ETHER_MIN_LEN	(ETH_ZLEN + ETHER_CRC_LEN)
+#define	ETHER_MAX_LEN	(ETH_FRAME_LEN + ETHER_CRC_LEN)
+
+#define	ETHER_IS_VALID_LEN(foo)	\
+	((foo) >= ETHER_MIN_LEN && (foo) <= ETHER_MAX_LEN)
+
+#define	ETHERTYPE_TRAIL		0x1000
+#define	ETHERTYPE_NTRAILER	16
+
+#define	ETHERMTU	ETH_DATA_LEN
+#define	ETHERMIN	(ETHER_MIN_LEN - ETHER_HDR_LEN - ETHER_CRC_LEN)
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
diff --git a/third_party/musl/porting/liteos_m/kernel/include/net/if.h b/third_party/musl/porting/liteos_m/kernel/include/net/if.h
new file mode 100755
index 000000000..774cbff0b
--- /dev/null
+++ b/third_party/musl/porting/liteos_m/kernel/include/net/if.h
@@ -0,0 +1,141 @@
+#ifndef _NET_IF_H
+#define _NET_IF_H
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#include <features.h>
+
+#define IF_NAMESIZE 16
+
+struct if_nameindex {
+	unsigned int if_index;
+	char *if_name;
+};
+
+unsigned int if_nametoindex (const char *);
+char *if_indextoname (unsigned int, char *);
+struct if_nameindex *if_nameindex (void);
+void if_freenameindex (struct if_nameindex *);
+
+
+
+
+#if defined(_GNU_SOURCE) || defined(_BSD_SOURCE)
+
+#include <sys/socket.h>
+
+#define IFF_UP	0x1
+#define IFF_BROADCAST 0x2
+#define IFF_DEBUG 0x4
+#define IFF_LOOPBACK 0x8
+#define IFF_POINTOPOINT 0x10
+#define IFF_NOTRAILERS 0x20
+#define IFF_RUNNING 0x40
+#define IFF_NOARP 0x80
+#define IFF_PROMISC 0x100
+#define IFF_ALLMULTI 0x200
+#define IFF_MASTER 0x400
+#define IFF_SLAVE 0x800
+#define IFF_MULTICAST 0x1000
+#define IFF_PORTSEL 0x2000
+#define IFF_AUTOMEDIA 0x4000
+#define IFF_DYNAMIC 0x8000
+#define IFF_LOWER_UP 0x10000
+#define IFF_DORMANT 0x20000
+#define IFF_ECHO 0x40000
+#define IFF_VOLATILE (IFF_LOOPBACK|IFF_POINTOPOINT|IFF_BROADCAST| \
+        IFF_ECHO|IFF_MASTER|IFF_SLAVE|IFF_RUNNING|IFF_LOWER_UP|IFF_DORMANT)
+
+struct ifaddr {
+	struct sockaddr ifa_addr;
+	union {
+		struct sockaddr	ifu_broadaddr;
+		struct sockaddr	ifu_dstaddr;
+	} ifa_ifu;
+	struct iface *ifa_ifp;
+	struct ifaddr *ifa_next;
+};
+
+#define ifa_broadaddr	ifa_ifu.ifu_broadaddr
+#define ifa_dstaddr	ifa_ifu.ifu_dstaddr
+
+struct ifmap {
+	unsigned long int mem_start;
+	unsigned long int mem_end;
+	unsigned short int base_addr;
+	unsigned char irq;
+	unsigned char dma;
+	unsigned char port;
+};
+
+#define IFHWADDRLEN	6
+#define IFNAMSIZ	IF_NAMESIZE
+
+struct ifreq {
+	union {
+		char ifrn_name[IFNAMSIZ];
+	} ifr_ifrn;
+	union {
+		struct sockaddr ifru_addr;
+		struct sockaddr ifru_dstaddr;
+		struct sockaddr ifru_broadaddr;
+		struct sockaddr ifru_netmask;
+		struct sockaddr ifru_hwaddr;
+		short int ifru_flags;
+		int ifru_ivalue;
+		int ifru_mtu;
+		struct ifmap ifru_map;
+		char ifru_slave[IFNAMSIZ];
+		char ifru_newname[IFNAMSIZ];
+		char *ifru_data;
+	} ifr_ifru;
+};
+
+#define ifr_name	ifr_ifrn.ifrn_name
+#define ifr_hwaddr	ifr_ifru.ifru_hwaddr
+#define ifr_addr	ifr_ifru.ifru_addr
+#define ifr_dstaddr	ifr_ifru.ifru_dstaddr
+#define ifr_broadaddr	ifr_ifru.ifru_broadaddr
+#define ifr_netmask	ifr_ifru.ifru_netmask
+#define ifr_flags	ifr_ifru.ifru_flags
+#define ifr_metric	ifr_ifru.ifru_ivalue
+#define ifr_mtu		ifr_ifru.ifru_mtu
+#define ifr_map		ifr_ifru.ifru_map
+#define ifr_slave	ifr_ifru.ifru_slave
+#define ifr_data	ifr_ifru.ifru_data
+#define ifr_ifindex	ifr_ifru.ifru_ivalue
+#define ifr_bandwidth	ifr_ifru.ifru_ivalue
+#define ifr_qlen	ifr_ifru.ifru_ivalue
+#define ifr_newname	ifr_ifru.ifru_newname
+#define _IOT_ifreq	_IOT(_IOTS(char),IFNAMSIZ,_IOTS(char),16,0,0)
+#define _IOT_ifreq_short _IOT(_IOTS(char),IFNAMSIZ,_IOTS(short),1,0,0)
+#define _IOT_ifreq_int	_IOT(_IOTS(char),IFNAMSIZ,_IOTS(int),1,0,0)
+
+struct ifconf {
+	int ifc_len;		
+	union {
+		char *ifcu_buf;
+		struct ifreq *ifcu_req;
+	} ifc_ifcu;
+};
+
+#define ifc_buf		ifc_ifcu.ifcu_buf
+#define ifc_req		ifc_ifcu.ifcu_req
+#define _IOT_ifconf _IOT(_IOTS(struct ifconf),1,0,0,0,0)
+
+#define __UAPI_DEF_IF_IFCONF                                    0
+#define __UAPI_DEF_IF_IFMAP                                     0
+#define __UAPI_DEF_IF_IFNAMSIZ                                  0
+#define __UAPI_DEF_IF_IFREQ                                     0
+#define __UAPI_DEF_IF_NET_DEVICE_FLAGS                          0
+#define __UAPI_DEF_IF_NET_DEVICE_FLAGS_LOWER_UP_DORMANT_ECHO    0
+
+#endif
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
diff --git a/third_party/musl/porting/liteos_m/kernel/include/net/if_arp.h b/third_party/musl/porting/liteos_m/kernel/include/net/if_arp.h
new file mode 100755
index 000000000..27becc835
--- /dev/null
+++ b/third_party/musl/porting/liteos_m/kernel/include/net/if_arp.h
@@ -0,0 +1,142 @@
+/* Nonstandard header */
+#ifndef _NET_IF_ARP_H
+#define _NET_IF_ARP_H
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#include <inttypes.h>
+#include <sys/types.h>
+#include <sys/socket.h>
+
+#define MAX_ADDR_LEN	7
+
+#define	ARPOP_REQUEST	1
+#define	ARPOP_REPLY	2
+#define	ARPOP_RREQUEST	3
+#define	ARPOP_RREPLY	4
+#define	ARPOP_InREQUEST	8
+#define	ARPOP_InREPLY	9
+#define	ARPOP_NAK	10
+
+struct arphdr {
+	uint16_t ar_hrd;
+	uint16_t ar_pro;
+	uint8_t ar_hln;
+	uint8_t ar_pln;
+	uint16_t ar_op;
+};
+
+
+#define ARPHRD_NETROM	0
+#define ARPHRD_ETHER 	1
+#define	ARPHRD_EETHER	2
+#define	ARPHRD_AX25	3
+#define	ARPHRD_PRONET	4
+#define	ARPHRD_CHAOS	5
+#define	ARPHRD_IEEE802	6
+#define	ARPHRD_ARCNET	7
+#define	ARPHRD_APPLETLK	8
+#define	ARPHRD_DLCI	15
+#define	ARPHRD_ATM	19
+#define	ARPHRD_METRICOM	23
+#define ARPHRD_IEEE1394	24
+#define ARPHRD_EUI64		27
+#define ARPHRD_INFINIBAND	32
+#define ARPHRD_SLIP	256
+#define ARPHRD_CSLIP	257
+#define ARPHRD_SLIP6	258
+#define ARPHRD_CSLIP6	259
+#define ARPHRD_RSRVD	260
+#define ARPHRD_ADAPT	264
+#define ARPHRD_ROSE	270
+#define ARPHRD_X25	271
+#define ARPHRD_HWX25	272
+#define ARPHRD_CAN	280
+#define ARPHRD_PPP	512
+#define ARPHRD_CISCO	513
+#define ARPHRD_HDLC	ARPHRD_CISCO
+#define ARPHRD_LAPB	516
+#define ARPHRD_DDCMP	517
+#define	ARPHRD_RAWHDLC	518
+#define ARPHRD_RAWIP	519
+
+#define ARPHRD_TUNNEL	768
+#define ARPHRD_TUNNEL6	769
+#define ARPHRD_FRAD	770
+#define ARPHRD_SKIP	771
+#define ARPHRD_LOOPBACK	772
+#define ARPHRD_LOCALTLK 773
+#define ARPHRD_FDDI	774
+#define ARPHRD_BIF	775
+#define ARPHRD_SIT	776
+#define ARPHRD_IPDDP	777
+#define ARPHRD_IPGRE	778
+#define ARPHRD_PIMREG	779
+#define ARPHRD_HIPPI	780
+#define ARPHRD_ASH	781
+#define ARPHRD_ECONET	782
+#define ARPHRD_IRDA	783
+#define ARPHRD_FCPP	784
+#define ARPHRD_FCAL	785
+#define ARPHRD_FCPL	786
+#define ARPHRD_FCFABRIC 787
+#define ARPHRD_IEEE802_TR 800
+#define ARPHRD_IEEE80211 801
+#define ARPHRD_IEEE80211_PRISM 802
+#define ARPHRD_IEEE80211_RADIOTAP 803
+#define ARPHRD_IEEE802154 804
+#define ARPHRD_IEEE802154_MONITOR 805
+#define ARPHRD_PHONET 820
+#define ARPHRD_PHONET_PIPE 821
+#define ARPHRD_CAIF 822
+#define ARPHRD_IP6GRE 823
+#define ARPHRD_NETLINK 824
+#define ARPHRD_6LOWPAN 825
+#define ARPHRD_VSOCKMON 826
+
+#define ARPHRD_VOID	  0xFFFF
+#define ARPHRD_NONE	  0xFFFE
+
+struct arpreq {
+	struct sockaddr arp_pa;
+	struct sockaddr arp_ha;
+	int arp_flags;
+	struct sockaddr arp_netmask;
+	char arp_dev[16];
+};
+
+struct arpreq_old {
+	struct sockaddr arp_pa;
+	struct sockaddr arp_ha;
+	int arp_flags;
+	struct sockaddr arp_netmask;
+};
+
+#define ATF_COM		0x02
+#define	ATF_PERM	0x04
+#define	ATF_PUBL	0x08
+#define	ATF_USETRAILERS	0x10
+#define ATF_NETMASK     0x20
+#define ATF_DONTPUB	0x40
+#define ATF_MAGIC	0x80
+
+#define ARPD_UPDATE	0x01
+#define ARPD_LOOKUP	0x02
+#define ARPD_FLUSH	0x03
+
+struct arpd_request {
+	unsigned short req;
+	uint32_t ip;
+	unsigned long dev;
+	unsigned long stamp;
+	unsigned long updated;
+	unsigned char ha[MAX_ADDR_LEN];
+};
+
+
+
+#ifdef __cplusplus
+}
+#endif
+#endif
diff --git a/third_party/musl/porting/liteos_m/kernel/include/net/route.h b/third_party/musl/porting/liteos_m/kernel/include/net/route.h
new file mode 100755
index 000000000..96ff48e01
--- /dev/null
+++ b/third_party/musl/porting/liteos_m/kernel/include/net/route.h
@@ -0,0 +1,124 @@
+#ifndef _NET_ROUTE_H
+#define _NET_ROUTE_H
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#include <stdint.h>
+#include <sys/socket.h>
+#include <sys/types.h>
+#include <netinet/in.h>
+
+
+struct rtentry {
+	unsigned long int rt_pad1;
+	struct sockaddr rt_dst;
+	struct sockaddr rt_gateway;
+	struct sockaddr rt_genmask;
+	unsigned short int rt_flags;
+	short int rt_pad2;
+	unsigned long int rt_pad3;
+	unsigned char rt_tos;
+	unsigned char rt_class;
+	short int rt_pad4[sizeof(long)/2-1];
+	short int rt_metric;
+	char *rt_dev;
+	unsigned long int rt_mtu;
+	unsigned long int rt_window;
+	unsigned short int rt_irtt;
+};
+
+#define rt_mss	rt_mtu
+
+
+struct in6_rtmsg {
+	struct in6_addr rtmsg_dst;
+	struct in6_addr rtmsg_src;
+	struct in6_addr rtmsg_gateway;
+	uint32_t rtmsg_type;
+	uint16_t rtmsg_dst_len;
+	uint16_t rtmsg_src_len;
+	uint32_t rtmsg_metric;
+	unsigned long int rtmsg_info;
+	uint32_t rtmsg_flags;
+	int rtmsg_ifindex;
+};
+
+
+#define	RTF_UP		0x0001
+#define	RTF_GATEWAY	0x0002
+
+#define	RTF_HOST	0x0004
+#define RTF_REINSTATE	0x0008
+#define	RTF_DYNAMIC	0x0010
+#define	RTF_MODIFIED	0x0020
+#define RTF_MTU		0x0040
+#define RTF_MSS		RTF_MTU
+#define RTF_WINDOW	0x0080
+#define RTF_IRTT	0x0100
+#define RTF_REJECT	0x0200
+#define	RTF_STATIC	0x0400
+#define	RTF_XRESOLVE	0x0800
+#define RTF_NOFORWARD   0x1000
+#define RTF_THROW	0x2000
+#define RTF_NOPMTUDISC  0x4000
+
+#define RTF_DEFAULT	0x00010000
+#define RTF_ALLONLINK	0x00020000
+#define RTF_ADDRCONF	0x00040000
+
+#define RTF_LINKRT	0x00100000
+#define RTF_NONEXTHOP	0x00200000
+
+#define RTF_CACHE	0x01000000
+#define RTF_FLOW	0x02000000
+#define RTF_POLICY	0x04000000
+
+#define RTCF_VALVE	0x00200000
+#define RTCF_MASQ	0x00400000
+#define RTCF_NAT	0x00800000
+#define RTCF_DOREDIRECT 0x01000000
+#define RTCF_LOG	0x02000000
+#define RTCF_DIRECTSRC	0x04000000
+
+#define RTF_LOCAL	0x80000000
+#define RTF_INTERFACE	0x40000000
+#define RTF_MULTICAST	0x20000000
+#define RTF_BROADCAST	0x10000000
+#define RTF_NAT		0x08000000
+
+#define RTF_ADDRCLASSMASK	0xF8000000
+#define RT_ADDRCLASS(flags)	((uint32_t) flags >> 23)
+
+#define RT_TOS(tos)		((tos) & IPTOS_TOS_MASK)
+
+#define RT_LOCALADDR(flags)	((flags & RTF_ADDRCLASSMASK) \
+				 == (RTF_LOCAL|RTF_INTERFACE))
+
+#define RT_CLASS_UNSPEC		0
+#define RT_CLASS_DEFAULT	253
+
+#define RT_CLASS_MAIN		254
+#define RT_CLASS_LOCAL		255
+#define RT_CLASS_MAX		255
+
+
+#define RTMSG_ACK		NLMSG_ACK
+#define RTMSG_OVERRUN		NLMSG_OVERRUN
+
+#define RTMSG_NEWDEVICE		0x11
+#define RTMSG_DELDEVICE		0x12
+#define RTMSG_NEWROUTE		0x21
+#define RTMSG_DELROUTE		0x22
+#define RTMSG_NEWRULE		0x31
+#define RTMSG_DELRULE		0x32
+#define RTMSG_CONTROL		0x40
+
+#define RTMSG_AR_FAILED		0x51
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
diff --git a/third_party/musl/porting/liteos_m/kernel/include/netdb.h b/third_party/musl/porting/liteos_m/kernel/include/netdb.h
new file mode 100755
index 000000000..d096c7818
--- /dev/null
+++ b/third_party/musl/porting/liteos_m/kernel/include/netdb.h
@@ -0,0 +1,156 @@
+#ifndef	_NETDB_H
+#define	_NETDB_H
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#include <features.h>
+#include <netinet/in.h>
+
+#if defined(_GNU_SOURCE) || defined(_BSD_SOURCE)
+#define __NEED_size_t
+#include <bits/alltypes.h>
+#endif
+
+struct addrinfo {
+	int ai_flags;
+	int ai_family;
+	int ai_socktype;
+	int ai_protocol;
+	socklen_t ai_addrlen;
+	struct sockaddr *ai_addr;
+	char *ai_canonname;
+	struct addrinfo *ai_next;
+};
+
+#define AI_PASSIVE      0x01
+#define AI_CANONNAME    0x02
+#define AI_NUMERICHOST  0x04
+#define AI_V4MAPPED     0x08
+#define AI_ALL          0x10
+#define AI_ADDRCONFIG   0x20
+#define AI_NUMERICSERV  0x400
+
+
+#define NI_NUMERICHOST  0x01
+#define NI_NUMERICSERV  0x02
+#define NI_NOFQDN       0x04
+#define NI_NAMEREQD     0x08
+#define NI_DGRAM        0x10
+#define NI_NUMERICSCOPE 0x100
+
+#define EAI_BADFLAGS   -1
+#define EAI_NONAME     -2
+#define EAI_AGAIN      -3
+#define EAI_FAIL       -4
+#define EAI_FAMILY     -6
+#define EAI_SOCKTYPE   -7
+#define EAI_SERVICE    -8
+#define EAI_MEMORY     -10
+#define EAI_SYSTEM     -11
+#define EAI_OVERFLOW   -12
+
+int getaddrinfo (const char *__restrict, const char *__restrict, const struct addrinfo *__restrict, struct addrinfo **__restrict);
+void freeaddrinfo (struct addrinfo *);
+int getnameinfo (const struct sockaddr *__restrict, socklen_t, char *__restrict, socklen_t, char *__restrict, socklen_t, int);
+const char *gai_strerror(int);
+
+
+/* Legacy functions follow (marked OBsolete in SUS) */
+
+struct netent {
+	char *n_name;
+	char **n_aliases;
+	int n_addrtype;
+	uint32_t n_net;
+};
+
+struct hostent {
+	char *h_name;
+	char **h_aliases;
+	int h_addrtype;
+	int h_length;
+	char **h_addr_list;
+};
+#define h_addr h_addr_list[0]
+
+struct servent {
+	char *s_name;
+	char **s_aliases;
+	int s_port;
+	char *s_proto;
+};
+
+struct protoent {
+	char *p_name;
+	char **p_aliases;
+	int p_proto;
+};
+
+void sethostent (int);
+void endhostent (void);
+struct hostent *gethostent (void);
+
+void setnetent (int);
+void endnetent (void);
+struct netent *getnetent (void);
+struct netent *getnetbyaddr (uint32_t, int);
+struct netent *getnetbyname (const char *);
+
+void setservent (int);
+void endservent (void);
+struct servent *getservent (void);
+struct servent *getservbyname (const char *, const char *);
+struct servent *getservbyport (int, const char *);
+
+void setprotoent (int);
+void endprotoent (void);
+struct protoent *getprotoent (void);
+struct protoent *getprotobyname (const char *);
+struct protoent *getprotobynumber (int);
+
+#if defined(_GNU_SOURCE) || defined(_BSD_SOURCE) || defined(_POSIX_SOURCE) \
+ || (defined(_POSIX_C_SOURCE) && _POSIX_C_SOURCE+0 < 200809L) \
+ || (defined(_XOPEN_SOURCE) && _XOPEN_SOURCE+0 < 700)
+struct hostent *gethostbyname (const char *);
+struct hostent *gethostbyaddr (const void *, socklen_t, int);
+#ifdef __GNUC__
+__attribute__((const))
+#endif
+int *__h_errno_location(void);
+#define h_errno (*__h_errno_location())
+#define HOST_NOT_FOUND 1
+#define TRY_AGAIN      2
+#define NO_RECOVERY    3
+#define NO_DATA        4
+#define NO_ADDRESS     NO_DATA
+#endif
+
+#if defined(_GNU_SOURCE) || defined(_BSD_SOURCE)
+void herror(const char *);
+const char *hstrerror(int);
+int gethostbyname_r(const char *, struct hostent *, char *, size_t, struct hostent **, int *);
+int gethostbyname2_r(const char *, int, struct hostent *, char *, size_t, struct hostent **, int *);
+struct hostent *gethostbyname2(const char *, int);
+int gethostbyaddr_r(const void *, socklen_t, int, struct hostent *, char *, size_t, struct hostent **, int *);
+int getservbyport_r(int, const char *, struct servent *, char *, size_t, struct servent **);
+int getservbyname_r(const char *, const char *, struct servent *, char *, size_t, struct servent **);
+#define EAI_NODATA     -5
+#define EAI_ADDRFAMILY -9
+#define EAI_INPROGRESS -100
+#define EAI_CANCELED   -101
+#define EAI_NOTCANCELED -102
+#define EAI_ALLDONE    -103
+#define EAI_INTR       -104
+#define EAI_IDN_ENCODE -105
+#define NI_MAXHOST 255
+#define NI_MAXSERV 32
+#endif
+
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
diff --git a/third_party/musl/porting/liteos_m/kernel/include/netinet/ether.h b/third_party/musl/porting/liteos_m/kernel/include/netinet/ether.h
new file mode 100755
index 000000000..eec7e53ca
--- /dev/null
+++ b/third_party/musl/porting/liteos_m/kernel/include/netinet/ether.h
@@ -0,0 +1,22 @@
+#ifndef _NETINET_ETHER_H
+#define _NETINET_ETHER_H
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#include <netinet/if_ether.h>
+
+char *ether_ntoa (const struct ether_addr *);
+struct ether_addr *ether_aton (const char *);
+char *ether_ntoa_r (const struct ether_addr *, char *);
+struct ether_addr *ether_aton_r (const char *, struct ether_addr *);
+int ether_line(const char *, struct ether_addr *, char *);
+int ether_ntohost(char *, const struct ether_addr *);
+int ether_hostton(const char *, struct ether_addr *);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
diff --git a/third_party/musl/porting/liteos_m/kernel/include/netinet/icmp6.h b/third_party/musl/porting/liteos_m/kernel/include/netinet/icmp6.h
new file mode 100755
index 000000000..01269e7d4
--- /dev/null
+++ b/third_party/musl/porting/liteos_m/kernel/include/netinet/icmp6.h
@@ -0,0 +1,305 @@
+#ifndef _NETINET_ICMP6_H
+#define _NETINET_ICMP6_H
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#include <stdint.h>
+#include <string.h>
+#include <sys/types.h>
+#include <netinet/in.h>
+
+#define ICMP6_FILTER 1
+
+#define ICMP6_FILTER_BLOCK		1
+#define ICMP6_FILTER_PASS		2
+#define ICMP6_FILTER_BLOCKOTHERS	3
+#define ICMP6_FILTER_PASSONLY		4
+
+struct icmp6_filter {
+	uint32_t icmp6_filt[8];
+};
+
+struct icmp6_hdr {
+	uint8_t     icmp6_type;
+	uint8_t     icmp6_code;
+	uint16_t    icmp6_cksum;
+	union {
+		uint32_t  icmp6_un_data32[1];
+		uint16_t  icmp6_un_data16[2];
+		uint8_t   icmp6_un_data8[4];
+	} icmp6_dataun;
+};
+
+#define icmp6_data32    icmp6_dataun.icmp6_un_data32
+#define icmp6_data16    icmp6_dataun.icmp6_un_data16
+#define icmp6_data8     icmp6_dataun.icmp6_un_data8
+#define icmp6_pptr      icmp6_data32[0]
+#define icmp6_mtu       icmp6_data32[0]
+#define icmp6_id        icmp6_data16[0]
+#define icmp6_seq       icmp6_data16[1]
+#define icmp6_maxdelay  icmp6_data16[0]
+
+#define ICMP6_DST_UNREACH             1
+#define ICMP6_PACKET_TOO_BIG          2
+#define ICMP6_TIME_EXCEEDED           3
+#define ICMP6_PARAM_PROB              4
+
+#define ICMP6_INFOMSG_MASK  0x80
+
+#define ICMP6_ECHO_REQUEST          128
+#define ICMP6_ECHO_REPLY            129
+#define MLD_LISTENER_QUERY          130
+#define MLD_LISTENER_REPORT         131
+#define MLD_LISTENER_REDUCTION      132
+
+#define ICMP6_DST_UNREACH_NOROUTE     0
+#define ICMP6_DST_UNREACH_ADMIN       1
+#define ICMP6_DST_UNREACH_BEYONDSCOPE 2
+#define ICMP6_DST_UNREACH_ADDR        3
+#define ICMP6_DST_UNREACH_NOPORT      4
+
+#define ICMP6_TIME_EXCEED_TRANSIT     0
+#define ICMP6_TIME_EXCEED_REASSEMBLY  1
+
+#define ICMP6_PARAMPROB_HEADER        0
+#define ICMP6_PARAMPROB_NEXTHEADER    1
+#define ICMP6_PARAMPROB_OPTION        2
+
+#define ICMP6_FILTER_WILLPASS(type, filterp) \
+	((((filterp)->icmp6_filt[(type) >> 5]) & (1 << ((type) & 31))) == 0)
+
+#define ICMP6_FILTER_WILLBLOCK(type, filterp) \
+	((((filterp)->icmp6_filt[(type) >> 5]) & (1 << ((type) & 31))) != 0)
+
+#define ICMP6_FILTER_SETPASS(type, filterp) \
+	((((filterp)->icmp6_filt[(type) >> 5]) &= ~(1 << ((type) & 31))))
+
+#define ICMP6_FILTER_SETBLOCK(type, filterp) \
+	((((filterp)->icmp6_filt[(type) >> 5]) |=  (1 << ((type) & 31))))
+
+#define ICMP6_FILTER_SETPASSALL(filterp) \
+	memset (filterp, 0, sizeof (struct icmp6_filter));
+
+#define ICMP6_FILTER_SETBLOCKALL(filterp) \
+	memset (filterp, 0xFF, sizeof (struct icmp6_filter));
+
+#define ND_ROUTER_SOLICIT           133
+#define ND_ROUTER_ADVERT            134
+#define ND_NEIGHBOR_SOLICIT         135
+#define ND_NEIGHBOR_ADVERT          136
+#define ND_REDIRECT                 137
+
+struct nd_router_solicit {
+	struct icmp6_hdr  nd_rs_hdr;
+};
+
+#define nd_rs_type               nd_rs_hdr.icmp6_type
+#define nd_rs_code               nd_rs_hdr.icmp6_code
+#define nd_rs_cksum              nd_rs_hdr.icmp6_cksum
+#define nd_rs_reserved           nd_rs_hdr.icmp6_data32[0]
+
+struct nd_router_advert {
+	struct icmp6_hdr  nd_ra_hdr;
+	uint32_t   nd_ra_reachable;
+	uint32_t   nd_ra_retransmit;
+};
+
+#define nd_ra_type               nd_ra_hdr.icmp6_type
+#define nd_ra_code               nd_ra_hdr.icmp6_code
+#define nd_ra_cksum              nd_ra_hdr.icmp6_cksum
+#define nd_ra_curhoplimit        nd_ra_hdr.icmp6_data8[0]
+#define nd_ra_flags_reserved     nd_ra_hdr.icmp6_data8[1]
+#define ND_RA_FLAG_MANAGED       0x80
+#define ND_RA_FLAG_OTHER         0x40
+#define ND_RA_FLAG_HOME_AGENT    0x20
+#define nd_ra_router_lifetime    nd_ra_hdr.icmp6_data16[1]
+
+struct nd_neighbor_solicit {
+	struct icmp6_hdr  nd_ns_hdr;
+	struct in6_addr   nd_ns_target;
+};
+
+#define nd_ns_type               nd_ns_hdr.icmp6_type
+#define nd_ns_code               nd_ns_hdr.icmp6_code
+#define nd_ns_cksum              nd_ns_hdr.icmp6_cksum
+#define nd_ns_reserved           nd_ns_hdr.icmp6_data32[0]
+
+struct nd_neighbor_advert {
+	struct icmp6_hdr  nd_na_hdr;
+	struct in6_addr   nd_na_target;
+};
+
+#define nd_na_type               nd_na_hdr.icmp6_type
+#define nd_na_code               nd_na_hdr.icmp6_code
+#define nd_na_cksum              nd_na_hdr.icmp6_cksum
+#define nd_na_flags_reserved     nd_na_hdr.icmp6_data32[0]
+#if     __BYTE_ORDER == __BIG_ENDIAN
+#define ND_NA_FLAG_ROUTER        0x80000000
+#define ND_NA_FLAG_SOLICITED     0x40000000
+#define ND_NA_FLAG_OVERRIDE      0x20000000
+#else
+#define ND_NA_FLAG_ROUTER        0x00000080
+#define ND_NA_FLAG_SOLICITED     0x00000040
+#define ND_NA_FLAG_OVERRIDE      0x00000020
+#endif
+
+struct nd_redirect {
+	struct icmp6_hdr  nd_rd_hdr;
+	struct in6_addr   nd_rd_target;
+	struct in6_addr   nd_rd_dst;
+};
+
+#define nd_rd_type               nd_rd_hdr.icmp6_type
+#define nd_rd_code               nd_rd_hdr.icmp6_code
+#define nd_rd_cksum              nd_rd_hdr.icmp6_cksum
+#define nd_rd_reserved           nd_rd_hdr.icmp6_data32[0]
+
+struct nd_opt_hdr {
+	uint8_t  nd_opt_type;
+	uint8_t  nd_opt_len;
+};
+
+#define ND_OPT_SOURCE_LINKADDR		1
+#define ND_OPT_TARGET_LINKADDR		2
+#define ND_OPT_PREFIX_INFORMATION	3
+#define ND_OPT_REDIRECTED_HEADER	4
+#define ND_OPT_MTU			5
+#define ND_OPT_RTR_ADV_INTERVAL		7
+#define ND_OPT_HOME_AGENT_INFO		8
+
+struct nd_opt_prefix_info {
+	uint8_t   nd_opt_pi_type;
+	uint8_t   nd_opt_pi_len;
+	uint8_t   nd_opt_pi_prefix_len;
+	uint8_t   nd_opt_pi_flags_reserved;
+	uint32_t  nd_opt_pi_valid_time;
+	uint32_t  nd_opt_pi_preferred_time;
+	uint32_t  nd_opt_pi_reserved2;
+	struct in6_addr  nd_opt_pi_prefix;
+};
+
+#define ND_OPT_PI_FLAG_ONLINK	0x80
+#define ND_OPT_PI_FLAG_AUTO	0x40
+#define ND_OPT_PI_FLAG_RADDR	0x20
+
+struct nd_opt_rd_hdr {
+	uint8_t   nd_opt_rh_type;
+	uint8_t   nd_opt_rh_len;
+	uint16_t  nd_opt_rh_reserved1;
+	uint32_t  nd_opt_rh_reserved2;
+};
+
+struct nd_opt_mtu {
+	uint8_t   nd_opt_mtu_type;
+	uint8_t   nd_opt_mtu_len;
+	uint16_t  nd_opt_mtu_reserved;
+	uint32_t  nd_opt_mtu_mtu;
+};
+
+struct mld_hdr {
+	struct icmp6_hdr    mld_icmp6_hdr;
+	struct in6_addr     mld_addr;
+};
+
+#define mld_type        mld_icmp6_hdr.icmp6_type
+#define mld_code        mld_icmp6_hdr.icmp6_code
+#define mld_cksum       mld_icmp6_hdr.icmp6_cksum
+#define mld_maxdelay    mld_icmp6_hdr.icmp6_data16[0]
+#define mld_reserved    mld_icmp6_hdr.icmp6_data16[1]
+
+#define ICMP6_ROUTER_RENUMBERING    138
+
+struct icmp6_router_renum {
+	struct icmp6_hdr    rr_hdr;
+	uint8_t             rr_segnum;
+	uint8_t             rr_flags;
+	uint16_t            rr_maxdelay;
+	uint32_t            rr_reserved;
+};
+
+#define rr_type		rr_hdr.icmp6_type
+#define rr_code         rr_hdr.icmp6_code
+#define rr_cksum        rr_hdr.icmp6_cksum
+#define rr_seqnum       rr_hdr.icmp6_data32[0]
+
+#define ICMP6_RR_FLAGS_TEST             0x80
+#define ICMP6_RR_FLAGS_REQRESULT        0x40
+#define ICMP6_RR_FLAGS_FORCEAPPLY       0x20
+#define ICMP6_RR_FLAGS_SPECSITE         0x10
+#define ICMP6_RR_FLAGS_PREVDONE         0x08
+
+struct rr_pco_match {
+	uint8_t             rpm_code;
+	uint8_t             rpm_len;
+	uint8_t             rpm_ordinal;
+	uint8_t             rpm_matchlen;
+	uint8_t             rpm_minlen;
+	uint8_t             rpm_maxlen;
+	uint16_t            rpm_reserved;
+	struct in6_addr     rpm_prefix;
+};
+
+#define RPM_PCO_ADD             1
+#define RPM_PCO_CHANGE          2
+#define RPM_PCO_SETGLOBAL       3
+
+struct rr_pco_use {
+	uint8_t             rpu_uselen;
+	uint8_t             rpu_keeplen;
+	uint8_t             rpu_ramask;
+	uint8_t             rpu_raflags;
+	uint32_t            rpu_vltime;
+	uint32_t            rpu_pltime;
+	uint32_t            rpu_flags;
+	struct in6_addr     rpu_prefix;
+};
+
+#define ICMP6_RR_PCOUSE_RAFLAGS_ONLINK  0x20
+#define ICMP6_RR_PCOUSE_RAFLAGS_AUTO    0x10
+
+#if __BYTE_ORDER == __BIG_ENDIAN
+#define ICMP6_RR_PCOUSE_FLAGS_DECRVLTIME 0x80000000
+#define ICMP6_RR_PCOUSE_FLAGS_DECRPLTIME 0x40000000
+#else
+#define ICMP6_RR_PCOUSE_FLAGS_DECRVLTIME 0x80
+#define ICMP6_RR_PCOUSE_FLAGS_DECRPLTIME 0x40
+#endif
+
+struct rr_result {
+	uint16_t            rrr_flags;
+	uint8_t             rrr_ordinal;
+	uint8_t             rrr_matchedlen;
+	uint32_t            rrr_ifid;
+	struct in6_addr     rrr_prefix;
+};
+
+#if __BYTE_ORDER == __BIG_ENDIAN
+#define ICMP6_RR_RESULT_FLAGS_OOB       0x0002
+#define ICMP6_RR_RESULT_FLAGS_FORBIDDEN 0x0001
+#else
+#define ICMP6_RR_RESULT_FLAGS_OOB       0x0200
+#define ICMP6_RR_RESULT_FLAGS_FORBIDDEN 0x0100
+#endif
+
+struct nd_opt_adv_interval {
+	uint8_t   nd_opt_adv_interval_type;
+	uint8_t   nd_opt_adv_interval_len;
+	uint16_t  nd_opt_adv_interval_reserved;
+	uint32_t  nd_opt_adv_interval_ival;
+};
+
+struct nd_opt_home_agent_info {
+	uint8_t   nd_opt_home_agent_info_type;
+	uint8_t   nd_opt_home_agent_info_len;
+	uint16_t  nd_opt_home_agent_info_reserved;
+	uint16_t  nd_opt_home_agent_info_preference;
+	uint16_t  nd_opt_home_agent_info_lifetime;
+};
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
diff --git a/third_party/musl/porting/liteos_m/kernel/include/netinet/if_ether.h b/third_party/musl/porting/liteos_m/kernel/include/netinet/if_ether.h
new file mode 100755
index 000000000..a08485e7f
--- /dev/null
+++ b/third_party/musl/porting/liteos_m/kernel/include/netinet/if_ether.h
@@ -0,0 +1,147 @@
+#ifndef _NETINET_IF_ETHER_H
+#define _NETINET_IF_ETHER_H
+
+#include <stdint.h>
+#include <sys/types.h>
+
+#define ETH_ALEN	6
+#define ETH_TLEN	2
+#define ETH_HLEN	14
+#define ETH_ZLEN	60
+#define ETH_DATA_LEN	1500
+#define ETH_FRAME_LEN	1514
+#define ETH_FCS_LEN	4
+#define ETH_MIN_MTU	68
+#define ETH_MAX_MTU	0xFFFFU
+
+#define ETH_P_LOOP	0x0060
+#define ETH_P_PUP	0x0200
+#define ETH_P_PUPAT	0x0201
+#define ETH_P_TSN	0x22F0
+#define ETH_P_ERSPAN2	0x22EB
+#define ETH_P_IP	0x0800
+#define ETH_P_X25	0x0805
+#define ETH_P_ARP	0x0806
+#define	ETH_P_BPQ	0x08FF
+#define ETH_P_IEEEPUP	0x0a00
+#define ETH_P_IEEEPUPAT	0x0a01
+#define ETH_P_BATMAN	0x4305
+#define ETH_P_DEC       0x6000
+#define ETH_P_DNA_DL    0x6001
+#define ETH_P_DNA_RC    0x6002
+#define ETH_P_DNA_RT    0x6003
+#define ETH_P_LAT       0x6004
+#define ETH_P_DIAG      0x6005
+#define ETH_P_CUST      0x6006
+#define ETH_P_SCA       0x6007
+#define ETH_P_TEB	0x6558
+#define ETH_P_RARP      0x8035
+#define ETH_P_ATALK	0x809B
+#define ETH_P_AARP	0x80F3
+#define ETH_P_8021Q	0x8100
+#define ETH_P_IPX	0x8137
+#define ETH_P_IPV6	0x86DD
+#define ETH_P_PAUSE	0x8808
+#define ETH_P_SLOW	0x8809
+#define ETH_P_WCCP	0x883E
+#define ETH_P_MPLS_UC	0x8847
+#define ETH_P_MPLS_MC	0x8848
+#define ETH_P_ATMMPOA	0x884c
+#define ETH_P_PPP_DISC	0x8863
+#define ETH_P_PPP_SES	0x8864
+#define ETH_P_LINK_CTL	0x886c
+#define ETH_P_ATMFATE	0x8884
+#define ETH_P_PAE	0x888E
+#define ETH_P_AOE	0x88A2
+#define ETH_P_8021AD	0x88A8
+#define ETH_P_802_EX1	0x88B5
+#define ETH_P_ERSPAN	0x88BE
+#define ETH_P_PREAUTH	0x88C7
+#define ETH_P_TIPC	0x88CA
+#define ETH_P_LLDP	0x88CC
+#define ETH_P_MACSEC	0x88E5
+#define ETH_P_8021AH	0x88E7
+#define ETH_P_MVRP	0x88F5
+#define ETH_P_1588	0x88F7
+#define ETH_P_NCSI	0x88F8
+#define ETH_P_PRP	0x88FB
+#define ETH_P_FCOE	0x8906
+#define ETH_P_TDLS	0x890D
+#define ETH_P_FIP	0x8914
+#define ETH_P_IBOE	0x8915
+#define ETH_P_80221	0x8917
+#define ETH_P_HSR	0x892F
+#define ETH_P_NSH	0x894F
+#define ETH_P_LOOPBACK	0x9000
+#define ETH_P_QINQ1	0x9100
+#define ETH_P_QINQ2	0x9200
+#define ETH_P_QINQ3	0x9300
+#define ETH_P_EDSA	0xDADA
+#define ETH_P_DSA_8021Q	0xDADB
+#define ETH_P_IFE	0xED3E
+#define ETH_P_AF_IUCV	0xFBFB
+
+#define ETH_P_802_3_MIN	0x0600
+
+#define ETH_P_802_3	0x0001
+#define ETH_P_AX25	0x0002
+#define ETH_P_ALL	0x0003
+#define ETH_P_802_2	0x0004
+#define ETH_P_SNAP	0x0005
+#define ETH_P_DDCMP     0x0006
+#define ETH_P_WAN_PPP   0x0007
+#define ETH_P_PPP_MP    0x0008
+#define ETH_P_LOCALTALK 0x0009
+#define ETH_P_CAN	0x000C
+#define ETH_P_CANFD	0x000D
+#define ETH_P_PPPTALK	0x0010
+#define ETH_P_TR_802_2	0x0011
+#define ETH_P_MOBITEX	0x0015
+#define ETH_P_CONTROL	0x0016
+#define ETH_P_IRDA	0x0017
+#define ETH_P_ECONET	0x0018
+#define ETH_P_HDLC	0x0019
+#define ETH_P_ARCNET	0x001A
+#define ETH_P_DSA	0x001B
+#define ETH_P_TRAILER	0x001C
+#define ETH_P_PHONET	0x00F5
+#define ETH_P_IEEE802154 0x00F6
+#define ETH_P_CAIF	0x00F7
+#define ETH_P_XDSA	0x00F8
+#define ETH_P_MAP	0x00F9
+
+struct ethhdr {
+	uint8_t h_dest[ETH_ALEN];
+	uint8_t h_source[ETH_ALEN];
+	uint16_t h_proto;
+};
+
+#include <net/ethernet.h>
+#include <net/if_arp.h>
+
+struct	ether_arp {
+	struct	arphdr ea_hdr;
+	uint8_t arp_sha[ETH_ALEN];
+	uint8_t arp_spa[4];
+	uint8_t arp_tha[ETH_ALEN];
+	uint8_t arp_tpa[4];
+};
+#define	arp_hrd	ea_hdr.ar_hrd
+#define	arp_pro	ea_hdr.ar_pro
+#define	arp_hln	ea_hdr.ar_hln
+#define	arp_pln	ea_hdr.ar_pln
+#define	arp_op	ea_hdr.ar_op
+
+#define ETHER_MAP_IP_MULTICAST(ipaddr, enaddr) \
+do { \
+	(enaddr)[0] = 0x01; \
+	(enaddr)[1] = 0x00; \
+	(enaddr)[2] = 0x5e; \
+	(enaddr)[3] = ((uint8_t *)ipaddr)[1] & 0x7f; \
+	(enaddr)[4] = ((uint8_t *)ipaddr)[2]; \
+	(enaddr)[5] = ((uint8_t *)ipaddr)[3]; \
+} while(0)
+
+#define __UAPI_DEF_ETHHDR       0
+
+#endif
diff --git a/third_party/musl/porting/liteos_m/kernel/include/netinet/igmp.h b/third_party/musl/porting/liteos_m/kernel/include/netinet/igmp.h
new file mode 100755
index 000000000..bbe8206a1
--- /dev/null
+++ b/third_party/musl/porting/liteos_m/kernel/include/netinet/igmp.h
@@ -0,0 +1,45 @@
+#ifndef _NETINET_IGMP_H
+#define _NETINET_IGMP_H
+
+#include <stdint.h>
+#include <netinet/in.h>
+
+struct igmp {
+	uint8_t igmp_type;
+	uint8_t igmp_code;
+	uint16_t igmp_cksum;
+	struct in_addr igmp_group;
+};
+
+#define IGMP_MINLEN			8
+
+#define IGMP_MEMBERSHIP_QUERY   	0x11
+#define IGMP_V1_MEMBERSHIP_REPORT	0x12
+#define IGMP_V2_MEMBERSHIP_REPORT	0x16
+#define IGMP_V2_LEAVE_GROUP		0x17
+
+#define IGMP_DVMRP			0x13
+#define IGMP_PIM			0x14
+#define IGMP_TRACE			0x15
+
+#define IGMP_MTRACE_RESP		0x1e
+#define IGMP_MTRACE			0x1f
+
+#define IGMP_MAX_HOST_REPORT_DELAY	10
+#define IGMP_TIMER_SCALE		10
+
+#define IGMP_DELAYING_MEMBER	1
+#define IGMP_IDLE_MEMBER	2
+#define IGMP_LAZY_MEMBER	3
+#define IGMP_SLEEPING_MEMBER	4
+#define IGMP_AWAKENING_MEMBER	5
+
+#define IGMP_v1_ROUTER		1
+#define IGMP_v2_ROUTER		2
+
+#define IGMP_HOST_MEMBERSHIP_QUERY	IGMP_MEMBERSHIP_QUERY
+#define IGMP_HOST_MEMBERSHIP_REPORT	IGMP_V1_MEMBERSHIP_REPORT
+#define IGMP_HOST_NEW_MEMBERSHIP_REPORT	IGMP_V2_MEMBERSHIP_REPORT
+#define IGMP_HOST_LEAVE_MESSAGE		IGMP_V2_LEAVE_GROUP
+
+#endif
diff --git a/third_party/musl/porting/liteos_m/kernel/include/netinet/in.h b/third_party/musl/porting/liteos_m/kernel/include/netinet/in.h
new file mode 100755
index 000000000..5b8b21e64
--- /dev/null
+++ b/third_party/musl/porting/liteos_m/kernel/include/netinet/in.h
@@ -0,0 +1,415 @@
+#ifndef	_NETINET_IN_H
+#define	_NETINET_IN_H
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#include <features.h>
+#include <inttypes.h>
+#include <sys/socket.h>
+
+typedef uint16_t in_port_t;
+typedef uint32_t in_addr_t;
+struct in_addr { in_addr_t s_addr; };
+
+struct sockaddr_in {
+	sa_family_t sin_family;
+	in_port_t sin_port;
+	struct in_addr sin_addr;
+	uint8_t sin_zero[8];
+};
+
+struct in6_addr {
+	union {
+		uint8_t __s6_addr[16];
+		uint16_t __s6_addr16[8];
+		uint32_t __s6_addr32[4];
+	} __in6_union;
+};
+#define s6_addr __in6_union.__s6_addr
+#define s6_addr16 __in6_union.__s6_addr16
+#define s6_addr32 __in6_union.__s6_addr32
+
+struct sockaddr_in6 {
+	sa_family_t     sin6_family;
+	in_port_t       sin6_port;
+	uint32_t        sin6_flowinfo;
+	struct in6_addr sin6_addr;
+	uint32_t        sin6_scope_id;
+};
+
+struct ipv6_mreq {
+	struct in6_addr ipv6mr_multiaddr;
+	unsigned        ipv6mr_interface;
+};
+
+#define INADDR_ANY        ((in_addr_t) 0x00000000)
+#define INADDR_BROADCAST  ((in_addr_t) 0xffffffff)
+#define INADDR_NONE       ((in_addr_t) 0xffffffff)
+#define INADDR_LOOPBACK   ((in_addr_t) 0x7f000001)
+
+#define INADDR_UNSPEC_GROUP     ((in_addr_t) 0xe0000000)
+#define INADDR_ALLHOSTS_GROUP   ((in_addr_t) 0xe0000001)
+#define INADDR_ALLRTRS_GROUP    ((in_addr_t) 0xe0000002)
+#define INADDR_ALLSNOOPERS_GROUP ((in_addr_t) 0xe000006a)
+#define INADDR_MAX_LOCAL_GROUP  ((in_addr_t) 0xe00000ff)
+
+#define IN6ADDR_ANY_INIT      { { { 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 } } }
+#define IN6ADDR_LOOPBACK_INIT { { { 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1 } } }
+
+extern const struct in6_addr in6addr_any, in6addr_loopback;
+
+#undef INET_ADDRSTRLEN
+#undef INET6_ADDRSTRLEN
+#define INET_ADDRSTRLEN  16
+#define INET6_ADDRSTRLEN 46
+
+uint32_t htonl(uint32_t);
+uint16_t htons(uint16_t);
+uint32_t ntohl(uint32_t);
+uint16_t ntohs(uint16_t);
+
+#define IPPORT_RESERVED 1024
+
+#define IPPROTO_IP       0
+#define IPPROTO_HOPOPTS  0
+#define IPPROTO_ICMP     1
+#define IPPROTO_IGMP     2
+#define IPPROTO_IPIP     4
+#define IPPROTO_TCP      6
+#define IPPROTO_EGP      8
+#define IPPROTO_PUP      12
+#define IPPROTO_UDP      17
+#define IPPROTO_IDP      22
+#define IPPROTO_TP       29
+#define IPPROTO_DCCP     33
+#define IPPROTO_IPV6     41
+#define IPPROTO_ROUTING  43
+#define IPPROTO_FRAGMENT 44
+#define IPPROTO_RSVP     46
+#define IPPROTO_GRE      47
+#define IPPROTO_ESP      50
+#define IPPROTO_AH       51
+#define IPPROTO_ICMPV6   58
+#define IPPROTO_NONE     59
+#define IPPROTO_DSTOPTS  60
+#define IPPROTO_MTP      92
+#define IPPROTO_BEETPH   94
+#define IPPROTO_ENCAP    98
+#define IPPROTO_PIM      103
+#define IPPROTO_COMP     108
+#define IPPROTO_SCTP     132
+#define IPPROTO_MH       135
+#define IPPROTO_UDPLITE  136
+#define IPPROTO_MPLS     137
+#define IPPROTO_RAW      255
+#define IPPROTO_MAX      256
+
+#define IN6_IS_ADDR_UNSPECIFIED(a) \
+        (((uint32_t *) (a))[0] == 0 && ((uint32_t *) (a))[1] == 0 && \
+         ((uint32_t *) (a))[2] == 0 && ((uint32_t *) (a))[3] == 0)
+
+#define IN6_IS_ADDR_LOOPBACK(a) \
+        (((uint32_t *) (a))[0] == 0 && ((uint32_t *) (a))[1] == 0 && \
+         ((uint32_t *) (a))[2] == 0 && \
+         ((uint8_t *) (a))[12] == 0 && ((uint8_t *) (a))[13] == 0 && \
+         ((uint8_t *) (a))[14] == 0 && ((uint8_t *) (a))[15] == 1 )
+
+#define IN6_IS_ADDR_MULTICAST(a) (((uint8_t *) (a))[0] == 0xff)
+
+#define IN6_IS_ADDR_LINKLOCAL(a) \
+        ((((uint8_t *) (a))[0]) == 0xfe && (((uint8_t *) (a))[1] & 0xc0) == 0x80)
+
+#define IN6_IS_ADDR_SITELOCAL(a) \
+        ((((uint8_t *) (a))[0]) == 0xfe && (((uint8_t *) (a))[1] & 0xc0) == 0xc0)
+
+#define IN6_IS_ADDR_V4MAPPED(a) \
+        (((uint32_t *) (a))[0] == 0 && ((uint32_t *) (a))[1] == 0 && \
+         ((uint8_t *) (a))[8] == 0 && ((uint8_t *) (a))[9] == 0 && \
+         ((uint8_t *) (a))[10] == 0xff && ((uint8_t *) (a))[11] == 0xff)
+
+#define IN6_IS_ADDR_V4COMPAT(a) \
+        (((uint32_t *) (a))[0] == 0 && ((uint32_t *) (a))[1] == 0 && \
+         ((uint32_t *) (a))[2] == 0 && ((uint8_t *) (a))[15] > 1)
+
+#define IN6_IS_ADDR_MC_NODELOCAL(a) \
+        (IN6_IS_ADDR_MULTICAST(a) && ((((uint8_t *) (a))[1] & 0xf) == 0x1))
+
+#define IN6_IS_ADDR_MC_LINKLOCAL(a) \
+        (IN6_IS_ADDR_MULTICAST(a) && ((((uint8_t *) (a))[1] & 0xf) == 0x2))
+
+#define IN6_IS_ADDR_MC_SITELOCAL(a) \
+        (IN6_IS_ADDR_MULTICAST(a) && ((((uint8_t *) (a))[1] & 0xf) == 0x5))
+
+#define IN6_IS_ADDR_MC_ORGLOCAL(a) \
+        (IN6_IS_ADDR_MULTICAST(a) && ((((uint8_t *) (a))[1] & 0xf) == 0x8))
+
+#define IN6_IS_ADDR_MC_GLOBAL(a) \
+        (IN6_IS_ADDR_MULTICAST(a) && ((((uint8_t *) (a))[1] & 0xf) == 0xe))
+
+#define __ARE_4_EQUAL(a,b) \
+	(!( (0[a]-0[b]) | (1[a]-1[b]) | (2[a]-2[b]) | (3[a]-3[b]) ))
+#define IN6_ARE_ADDR_EQUAL(a,b) \
+	__ARE_4_EQUAL((const uint32_t *)(a), (const uint32_t *)(b))
+
+#define	IN_CLASSA(a)		((((in_addr_t)(a)) & 0x80000000) == 0)
+#define	IN_CLASSA_NET		0xff000000
+#define	IN_CLASSA_NSHIFT	24
+#define	IN_CLASSA_HOST		(0xffffffff & ~IN_CLASSA_NET)
+#define	IN_CLASSA_MAX		128
+#define	IN_CLASSB(a)		((((in_addr_t)(a)) & 0xc0000000) == 0x80000000)
+#define	IN_CLASSB_NET		0xffff0000
+#define	IN_CLASSB_NSHIFT	16
+#define	IN_CLASSB_HOST		(0xffffffff & ~IN_CLASSB_NET)
+#define	IN_CLASSB_MAX		65536
+#define	IN_CLASSC(a)		((((in_addr_t)(a)) & 0xe0000000) == 0xc0000000)
+#define	IN_CLASSC_NET		0xffffff00
+#define	IN_CLASSC_NSHIFT	8
+#define	IN_CLASSC_HOST		(0xffffffff & ~IN_CLASSC_NET)
+#define	IN_CLASSD(a)		((((in_addr_t)(a)) & 0xf0000000) == 0xe0000000)
+#define	IN_MULTICAST(a)		IN_CLASSD(a)
+#define	IN_EXPERIMENTAL(a)	((((in_addr_t)(a)) & 0xe0000000) == 0xe0000000)
+#define	IN_BADCLASS(a)		((((in_addr_t)(a)) & 0xf0000000) == 0xf0000000)
+
+#define IN_LOOPBACKNET 127
+
+
+#define IP_TOS             1
+#define IP_TTL             2
+#define IP_HDRINCL         3
+#define IP_OPTIONS         4
+#define IP_ROUTER_ALERT    5
+#define IP_RECVOPTS        6
+#define IP_RETOPTS         7
+#define IP_PKTINFO         8
+#define IP_PKTOPTIONS      9
+#define IP_PMTUDISC        10
+#define IP_MTU_DISCOVER    10
+#define IP_RECVERR         11
+#define IP_RECVTTL         12
+#define IP_RECVTOS         13
+#define IP_MTU             14
+#define IP_FREEBIND        15
+#define IP_IPSEC_POLICY    16
+#define IP_XFRM_POLICY     17
+#define IP_PASSSEC         18
+#define IP_TRANSPARENT     19
+#define IP_ORIGDSTADDR     20
+#define IP_RECVORIGDSTADDR IP_ORIGDSTADDR
+#define IP_MINTTL          21
+#define IP_NODEFRAG        22
+#define IP_CHECKSUM        23
+#define IP_BIND_ADDRESS_NO_PORT 24
+#define IP_RECVFRAGSIZE    25
+#define IP_MULTICAST_IF    32
+#define IP_MULTICAST_TTL   33
+#define IP_MULTICAST_LOOP  34
+#define IP_ADD_MEMBERSHIP  35
+#define IP_DROP_MEMBERSHIP 36
+#define IP_UNBLOCK_SOURCE  37
+#define IP_BLOCK_SOURCE    38
+#define IP_ADD_SOURCE_MEMBERSHIP  39
+#define IP_DROP_SOURCE_MEMBERSHIP 40
+#define IP_MSFILTER        41
+#define IP_MULTICAST_ALL   49
+#define IP_UNICAST_IF      50
+
+#define IP_RECVRETOPTS IP_RETOPTS
+
+#define IP_PMTUDISC_DONT   0
+#define IP_PMTUDISC_WANT   1
+#define IP_PMTUDISC_DO     2
+#define IP_PMTUDISC_PROBE  3
+#define IP_PMTUDISC_INTERFACE 4
+#define IP_PMTUDISC_OMIT   5
+
+#define IP_DEFAULT_MULTICAST_TTL        1
+#define IP_DEFAULT_MULTICAST_LOOP       1
+#define IP_MAX_MEMBERSHIPS              20
+
+struct ip_opts {
+	struct in_addr ip_dst;
+	char ip_opts[40];
+};
+
+#if defined(_GNU_SOURCE) || defined(_BSD_SOURCE)
+
+#define MCAST_JOIN_GROUP   42
+#define MCAST_BLOCK_SOURCE 43
+#define MCAST_UNBLOCK_SOURCE      44
+#define MCAST_LEAVE_GROUP  45
+#define MCAST_JOIN_SOURCE_GROUP   46
+#define MCAST_LEAVE_SOURCE_GROUP  47
+#define MCAST_MSFILTER     48
+
+#define MCAST_EXCLUDE 0
+#define MCAST_INCLUDE 1
+
+struct ip_mreq {
+	struct in_addr imr_multiaddr;
+	struct in_addr imr_interface;
+};
+
+struct ip_mreqn {
+	struct in_addr imr_multiaddr;
+	struct in_addr imr_address;
+	int imr_ifindex;
+};
+
+struct ip_mreq_source {
+	struct in_addr imr_multiaddr;
+	struct in_addr imr_interface;
+	struct in_addr imr_sourceaddr;
+};
+
+struct ip_msfilter {
+	struct in_addr imsf_multiaddr;
+	struct in_addr imsf_interface;
+	uint32_t imsf_fmode;
+	uint32_t imsf_numsrc;
+	struct in_addr imsf_slist[1];
+};
+#define IP_MSFILTER_SIZE(numsrc) \
+	(sizeof(struct ip_msfilter) - sizeof(struct in_addr) \
+	+ (numsrc) * sizeof(struct in_addr))
+
+struct group_req {
+	uint32_t gr_interface;
+	struct sockaddr_storage gr_group;
+};
+
+struct group_source_req {
+	uint32_t gsr_interface;
+	struct sockaddr_storage gsr_group;
+	struct sockaddr_storage gsr_source;
+};
+
+struct group_filter {
+	uint32_t gf_interface;
+	struct sockaddr_storage gf_group;
+	uint32_t gf_fmode;
+	uint32_t gf_numsrc;
+	struct sockaddr_storage gf_slist[1];
+};
+#define GROUP_FILTER_SIZE(numsrc) \
+	(sizeof(struct group_filter) - sizeof(struct sockaddr_storage) \
+	+ (numsrc) * sizeof(struct sockaddr_storage))
+
+struct in_pktinfo {
+	int ipi_ifindex;
+	struct in_addr ipi_spec_dst;
+	struct in_addr ipi_addr;
+};
+
+struct in6_pktinfo {
+	struct in6_addr ipi6_addr;
+	unsigned ipi6_ifindex;
+};
+
+struct ip6_mtuinfo {
+	struct sockaddr_in6 ip6m_addr;
+	uint32_t ip6m_mtu;
+};
+#endif
+
+#define IPV6_ADDRFORM           1
+#define IPV6_2292PKTINFO        2
+#define IPV6_2292HOPOPTS        3
+#define IPV6_2292DSTOPTS        4
+#define IPV6_2292RTHDR          5
+#define IPV6_2292PKTOPTIONS     6
+#define IPV6_CHECKSUM           7
+#define IPV6_2292HOPLIMIT       8
+#define IPV6_NEXTHOP            9
+#define IPV6_AUTHHDR            10
+#define IPV6_UNICAST_HOPS       16
+#define IPV6_MULTICAST_IF       17
+#define IPV6_MULTICAST_HOPS     18
+#define IPV6_MULTICAST_LOOP     19
+#define IPV6_JOIN_GROUP         20
+#define IPV6_LEAVE_GROUP        21
+#define IPV6_ROUTER_ALERT       22
+#define IPV6_MTU_DISCOVER       23
+#define IPV6_MTU                24
+#define IPV6_RECVERR            25
+#define IPV6_V6ONLY             26
+#define IPV6_JOIN_ANYCAST       27
+#define IPV6_LEAVE_ANYCAST      28
+#define IPV6_MULTICAST_ALL      29
+#define IPV6_ROUTER_ALERT_ISOLATE 30
+#define IPV6_IPSEC_POLICY       34
+#define IPV6_XFRM_POLICY        35
+#define IPV6_HDRINCL            36
+
+#define IPV6_RECVPKTINFO        49
+#define IPV6_PKTINFO            50
+#define IPV6_RECVHOPLIMIT       51
+#define IPV6_HOPLIMIT           52
+#define IPV6_RECVHOPOPTS        53
+#define IPV6_HOPOPTS            54
+#define IPV6_RTHDRDSTOPTS       55
+#define IPV6_RECVRTHDR          56
+#define IPV6_RTHDR              57
+#define IPV6_RECVDSTOPTS        58
+#define IPV6_DSTOPTS            59
+#define IPV6_RECVPATHMTU        60
+#define IPV6_PATHMTU            61
+#define IPV6_DONTFRAG           62
+#define IPV6_RECVTCLASS         66
+#define IPV6_TCLASS             67
+#define IPV6_AUTOFLOWLABEL      70
+#define IPV6_ADDR_PREFERENCES   72
+#define IPV6_MINHOPCOUNT        73
+#define IPV6_ORIGDSTADDR        74
+#define IPV6_RECVORIGDSTADDR    IPV6_ORIGDSTADDR
+#define IPV6_TRANSPARENT        75
+#define IPV6_UNICAST_IF         76
+#define IPV6_RECVFRAGSIZE       77
+#define IPV6_FREEBIND           78
+
+#define IPV6_ADD_MEMBERSHIP     IPV6_JOIN_GROUP
+#define IPV6_DROP_MEMBERSHIP    IPV6_LEAVE_GROUP
+#define IPV6_RXHOPOPTS          IPV6_HOPOPTS
+#define IPV6_RXDSTOPTS          IPV6_DSTOPTS
+
+#define IPV6_PMTUDISC_DONT      0
+#define IPV6_PMTUDISC_WANT      1
+#define IPV6_PMTUDISC_DO        2
+#define IPV6_PMTUDISC_PROBE     3
+#define IPV6_PMTUDISC_INTERFACE 4
+#define IPV6_PMTUDISC_OMIT      5
+
+#define IPV6_PREFER_SRC_TMP            0x0001
+#define IPV6_PREFER_SRC_PUBLIC         0x0002
+#define IPV6_PREFER_SRC_PUBTMP_DEFAULT 0x0100
+#define IPV6_PREFER_SRC_COA            0x0004
+#define IPV6_PREFER_SRC_HOME           0x0400
+#define IPV6_PREFER_SRC_CGA            0x0008
+#define IPV6_PREFER_SRC_NONCGA         0x0800
+
+#define IPV6_RTHDR_LOOSE        0
+#define IPV6_RTHDR_STRICT       1
+
+#define IPV6_RTHDR_TYPE_0       0
+
+#define __UAPI_DEF_IN_ADDR      0
+#define __UAPI_DEF_IN_IPPROTO   0
+#define __UAPI_DEF_IN_PKTINFO   0
+#define __UAPI_DEF_IP_MREQ      0
+#define __UAPI_DEF_SOCKADDR_IN  0
+#define __UAPI_DEF_IN_CLASS     0
+#define __UAPI_DEF_IN6_ADDR     0
+#define __UAPI_DEF_IN6_ADDR_ALT 0
+#define __UAPI_DEF_SOCKADDR_IN6 0
+#define __UAPI_DEF_IPV6_MREQ    0
+#define __UAPI_DEF_IPPROTO_V6   0
+#define __UAPI_DEF_IPV6_OPTIONS 0
+#define __UAPI_DEF_IN6_PKTINFO  0
+#define __UAPI_DEF_IP6_MTUINFO  0
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
diff --git a/third_party/musl/porting/liteos_m/kernel/include/netinet/in_systm.h b/third_party/musl/porting/liteos_m/kernel/include/netinet/in_systm.h
new file mode 100755
index 000000000..a7b417722
--- /dev/null
+++ b/third_party/musl/porting/liteos_m/kernel/include/netinet/in_systm.h
@@ -0,0 +1,9 @@
+#ifndef _NETINET_IN_SYSTM_H
+#define _NETINET_IN_SYSTM_H
+
+#include <stdint.h>
+
+typedef uint16_t n_short;
+typedef uint32_t n_long, n_time;
+
+#endif
diff --git a/third_party/musl/porting/liteos_m/kernel/include/netinet/ip.h b/third_party/musl/porting/liteos_m/kernel/include/netinet/ip.h
new file mode 100755
index 000000000..0ae132a58
--- /dev/null
+++ b/third_party/musl/porting/liteos_m/kernel/include/netinet/ip.h
@@ -0,0 +1,199 @@
+#ifndef _NETINET_IP_H
+#define _NETINET_IP_H
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#include <stdint.h>
+#include <netinet/in.h>
+
+struct timestamp {
+	uint8_t len;
+	uint8_t ptr;
+#if __BYTE_ORDER == __LITTLE_ENDIAN
+	unsigned int flags:4;
+	unsigned int overflow:4;
+#else
+	unsigned int overflow:4;
+	unsigned int flags:4;
+#endif
+	uint32_t data[9];
+  };
+
+struct iphdr {
+#if __BYTE_ORDER == __LITTLE_ENDIAN
+	unsigned int ihl:4;
+	unsigned int version:4;
+#else
+	unsigned int version:4;
+	unsigned int ihl:4;
+#endif
+	uint8_t tos;
+	uint16_t tot_len;
+	uint16_t id;
+	uint16_t frag_off;
+	uint8_t ttl;
+	uint8_t protocol;
+	uint16_t check;
+	uint32_t saddr;
+	uint32_t daddr;
+};
+
+struct ip {
+#if __BYTE_ORDER == __LITTLE_ENDIAN
+	unsigned int ip_hl:4;
+	unsigned int ip_v:4;
+#else
+	unsigned int ip_v:4;
+	unsigned int ip_hl:4;
+#endif
+	uint8_t ip_tos;
+	uint16_t ip_len;
+	uint16_t ip_id;
+	uint16_t ip_off;
+	uint8_t ip_ttl;
+	uint8_t ip_p;
+	uint16_t ip_sum;
+	struct in_addr ip_src, ip_dst;
+};
+
+#define	IP_RF 0x8000
+#define	IP_DF 0x4000
+#define	IP_MF 0x2000
+#define	IP_OFFMASK 0x1fff
+
+struct ip_timestamp {
+	uint8_t ipt_code;
+	uint8_t ipt_len;
+	uint8_t ipt_ptr;
+#if __BYTE_ORDER == __LITTLE_ENDIAN
+	unsigned int ipt_flg:4;
+	unsigned int ipt_oflw:4;
+#else
+	unsigned int ipt_oflw:4;
+	unsigned int ipt_flg:4;
+#endif
+	uint32_t data[9];
+};
+
+#define	IPVERSION	4
+#define	IP_MAXPACKET	65535
+
+#define	IPTOS_ECN_MASK		0x03
+#define	IPTOS_ECN(x)		((x) & IPTOS_ECN_MASK)
+#define	IPTOS_ECN_NOT_ECT	0x00
+#define	IPTOS_ECN_ECT1		0x01
+#define	IPTOS_ECN_ECT0		0x02
+#define	IPTOS_ECN_CE		0x03
+
+#define	IPTOS_DSCP_MASK		0xfc
+#define	IPTOS_DSCP(x)		((x) & IPTOS_DSCP_MASK)
+#define	IPTOS_DSCP_AF11		0x28
+#define	IPTOS_DSCP_AF12		0x30
+#define	IPTOS_DSCP_AF13		0x38
+#define	IPTOS_DSCP_AF21		0x48
+#define	IPTOS_DSCP_AF22		0x50
+#define	IPTOS_DSCP_AF23		0x58
+#define	IPTOS_DSCP_AF31		0x68
+#define	IPTOS_DSCP_AF32		0x70
+#define	IPTOS_DSCP_AF33		0x78
+#define	IPTOS_DSCP_AF41		0x88
+#define	IPTOS_DSCP_AF42		0x90
+#define	IPTOS_DSCP_AF43		0x98
+#define	IPTOS_DSCP_EF		0xb8
+
+#define	IPTOS_CLASS_MASK	0xe0
+#define	IPTOS_CLASS(x)		((x) & IPTOS_CLASS_MASK)
+#define	IPTOS_CLASS_CS0		0x00
+#define	IPTOS_CLASS_CS1		0x20
+#define	IPTOS_CLASS_CS2		0x40
+#define	IPTOS_CLASS_CS3		0x60
+#define	IPTOS_CLASS_CS4		0x80
+#define	IPTOS_CLASS_CS5		0xa0
+#define	IPTOS_CLASS_CS6		0xc0
+#define	IPTOS_CLASS_CS7		0xe0
+#define	IPTOS_CLASS_DEFAULT	IPTOS_CLASS_CS0
+
+#define	IPTOS_TOS_MASK		0x1E
+#define	IPTOS_TOS(tos)		((tos) & IPTOS_TOS_MASK)
+#define	IPTOS_LOWDELAY		0x10
+#define	IPTOS_THROUGHPUT	0x08
+#define	IPTOS_RELIABILITY	0x04
+#define	IPTOS_LOWCOST		0x02
+#define	IPTOS_MINCOST		IPTOS_LOWCOST
+
+#define	IPTOS_PREC_MASK			0xe0
+#define	IPTOS_PREC(tos)                ((tos) & IPTOS_PREC_MASK)
+#define	IPTOS_PREC_NETCONTROL		0xe0
+#define	IPTOS_PREC_INTERNETCONTROL	0xc0
+#define	IPTOS_PREC_CRITIC_ECP		0xa0
+#define	IPTOS_PREC_FLASHOVERRIDE	0x80
+#define	IPTOS_PREC_FLASH		0x60
+#define	IPTOS_PREC_IMMEDIATE		0x40
+#define	IPTOS_PREC_PRIORITY		0x20
+#define	IPTOS_PREC_ROUTINE		0x00
+
+#define	IPOPT_COPY		0x80
+#define	IPOPT_CLASS_MASK	0x60
+#define	IPOPT_NUMBER_MASK	0x1f
+
+#define	IPOPT_COPIED(o)		((o) & IPOPT_COPY)
+#define	IPOPT_CLASS(o)		((o) & IPOPT_CLASS_MASK)
+#define	IPOPT_NUMBER(o)		((o) & IPOPT_NUMBER_MASK)
+
+#define	IPOPT_CONTROL		0x00
+#define	IPOPT_RESERVED1		0x20
+#define	IPOPT_DEBMEAS		0x40
+#define	IPOPT_MEASUREMENT       IPOPT_DEBMEAS
+#define	IPOPT_RESERVED2		0x60
+
+#define	IPOPT_EOL		0
+#define	IPOPT_END		IPOPT_EOL
+#define	IPOPT_NOP		1
+#define	IPOPT_NOOP		IPOPT_NOP
+
+#define	IPOPT_RR		7
+#define	IPOPT_TS		68
+#define	IPOPT_TIMESTAMP		IPOPT_TS
+#define	IPOPT_SECURITY		130
+#define	IPOPT_SEC		IPOPT_SECURITY
+#define	IPOPT_LSRR		131
+#define	IPOPT_SATID		136
+#define	IPOPT_SID		IPOPT_SATID
+#define	IPOPT_SSRR		137
+#define	IPOPT_RA		148
+
+#define	IPOPT_OPTVAL		0
+#define	IPOPT_OLEN		1
+#define	IPOPT_OFFSET		2
+#define	IPOPT_MINOFF		4
+
+#define	MAX_IPOPTLEN		40
+
+#define	IPOPT_TS_TSONLY		0
+#define	IPOPT_TS_TSANDADDR	1
+#define	IPOPT_TS_PRESPEC	3
+
+#define	IPOPT_SECUR_UNCLASS	0x0000
+#define	IPOPT_SECUR_CONFID	0xf135
+#define	IPOPT_SECUR_EFTO	0x789a
+#define	IPOPT_SECUR_MMMM	0xbc4d
+#define	IPOPT_SECUR_RESTR	0xaf13
+#define	IPOPT_SECUR_SECRET	0xd788
+#define	IPOPT_SECUR_TOPSECRET	0x6bc5
+
+#define	MAXTTL		255
+#define	IPDEFTTL	64
+#define	IPFRAGTTL	60
+#define	IPTTLDEC	1
+
+#define	IP_MSS		576
+
+#define __UAPI_DEF_IPHDR	0
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
diff --git a/third_party/musl/porting/liteos_m/kernel/include/netinet/ip6.h b/third_party/musl/porting/liteos_m/kernel/include/netinet/ip6.h
new file mode 100755
index 000000000..50c626a69
--- /dev/null
+++ b/third_party/musl/porting/liteos_m/kernel/include/netinet/ip6.h
@@ -0,0 +1,141 @@
+#ifndef _NETINET_IP6_H
+#define _NETINET_IP6_H
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#include <stdint.h>
+#include <netinet/in.h>
+
+struct ip6_hdr {
+	union {
+		struct ip6_hdrctl {
+			uint32_t ip6_un1_flow;
+			uint16_t ip6_un1_plen;
+			uint8_t  ip6_un1_nxt;
+			uint8_t  ip6_un1_hlim;
+		} ip6_un1;
+		uint8_t ip6_un2_vfc;
+	} ip6_ctlun;
+	struct in6_addr ip6_src;
+	struct in6_addr ip6_dst;
+};
+
+#define ip6_vfc   ip6_ctlun.ip6_un2_vfc
+#define ip6_flow  ip6_ctlun.ip6_un1.ip6_un1_flow
+#define ip6_plen  ip6_ctlun.ip6_un1.ip6_un1_plen
+#define ip6_nxt   ip6_ctlun.ip6_un1.ip6_un1_nxt
+#define ip6_hlim  ip6_ctlun.ip6_un1.ip6_un1_hlim
+#define ip6_hops  ip6_ctlun.ip6_un1.ip6_un1_hlim
+
+struct ip6_ext {
+	uint8_t  ip6e_nxt;
+	uint8_t  ip6e_len;
+};
+
+struct ip6_hbh {
+	uint8_t  ip6h_nxt;
+	uint8_t  ip6h_len;
+};
+
+struct ip6_dest {
+	uint8_t  ip6d_nxt;
+	uint8_t  ip6d_len;
+};
+
+struct ip6_rthdr {
+	uint8_t  ip6r_nxt;
+	uint8_t  ip6r_len;
+	uint8_t  ip6r_type;
+	uint8_t  ip6r_segleft;
+};
+
+struct ip6_rthdr0 {
+	uint8_t  ip6r0_nxt;
+	uint8_t  ip6r0_len;
+	uint8_t  ip6r0_type;
+	uint8_t  ip6r0_segleft;
+	uint8_t  ip6r0_reserved;
+	uint8_t  ip6r0_slmap[3];
+	struct in6_addr ip6r0_addr[];
+};
+
+struct ip6_frag {
+	uint8_t   ip6f_nxt;
+	uint8_t   ip6f_reserved;
+	uint16_t  ip6f_offlg;
+	uint32_t  ip6f_ident;
+};
+
+#if __BYTE_ORDER == __BIG_ENDIAN
+#define IP6F_OFF_MASK       0xfff8
+#define IP6F_RESERVED_MASK  0x0006
+#define IP6F_MORE_FRAG      0x0001
+#else
+#define IP6F_OFF_MASK       0xf8ff
+#define IP6F_RESERVED_MASK  0x0600
+#define IP6F_MORE_FRAG      0x0100
+#endif
+
+struct ip6_opt {
+	uint8_t  ip6o_type;
+	uint8_t  ip6o_len;
+};
+
+#define IP6OPT_TYPE(o)		((o) & 0xc0)
+#define IP6OPT_TYPE_SKIP	0x00
+#define IP6OPT_TYPE_DISCARD	0x40
+#define IP6OPT_TYPE_FORCEICMP	0x80
+#define IP6OPT_TYPE_ICMP	0xc0
+#define IP6OPT_TYPE_MUTABLE	0x20
+
+#define IP6OPT_PAD1	0
+#define IP6OPT_PADN	1
+
+#define IP6OPT_JUMBO		0xc2
+#define IP6OPT_NSAP_ADDR	0xc3
+#define IP6OPT_TUNNEL_LIMIT	0x04
+#define IP6OPT_ROUTER_ALERT	0x05
+
+struct ip6_opt_jumbo {
+	uint8_t  ip6oj_type;
+	uint8_t  ip6oj_len;
+	uint8_t  ip6oj_jumbo_len[4];
+};
+#define IP6OPT_JUMBO_LEN	6
+
+struct ip6_opt_nsap {
+	uint8_t  ip6on_type;
+	uint8_t  ip6on_len;
+	uint8_t  ip6on_src_nsap_len;
+	uint8_t  ip6on_dst_nsap_len;
+};
+
+struct ip6_opt_tunnel {
+	uint8_t  ip6ot_type;
+	uint8_t  ip6ot_len;
+	uint8_t  ip6ot_encap_limit;
+};
+
+struct ip6_opt_router {
+	uint8_t  ip6or_type;
+	uint8_t  ip6or_len;
+	uint8_t  ip6or_value[2];
+};
+
+#if __BYTE_ORDER == __BIG_ENDIAN
+#define IP6_ALERT_MLD	0x0000
+#define IP6_ALERT_RSVP	0x0001
+#define IP6_ALERT_AN	0x0002
+#else
+#define IP6_ALERT_MLD	0x0000
+#define IP6_ALERT_RSVP	0x0100
+#define IP6_ALERT_AN	0x0200
+#endif
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
diff --git a/third_party/musl/porting/liteos_m/kernel/include/netinet/ip_icmp.h b/third_party/musl/porting/liteos_m/kernel/include/netinet/ip_icmp.h
new file mode 100755
index 000000000..b9e0df899
--- /dev/null
+++ b/third_party/musl/porting/liteos_m/kernel/include/netinet/ip_icmp.h
@@ -0,0 +1,193 @@
+#ifndef _NETINET_IP_ICMP_H
+#define _NETINET_IP_ICMP_H
+
+#include <stdint.h>
+#include <netinet/in.h>
+#include <netinet/ip.h>
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+struct icmphdr {
+	uint8_t type;
+	uint8_t code;
+	uint16_t checksum;
+	union {
+		struct {
+			uint16_t id;
+			uint16_t sequence;
+		} echo;
+		uint32_t gateway;
+		struct {
+			uint16_t __unused;
+			uint16_t mtu;
+		} frag;
+		uint8_t reserved[4];
+	} un;
+};
+
+#define ICMP_ECHOREPLY		0
+#define ICMP_DEST_UNREACH	3
+#define ICMP_SOURCE_QUENCH	4
+#define ICMP_REDIRECT		5
+#define ICMP_ECHO		8
+#define ICMP_TIME_EXCEEDED	11
+#define ICMP_PARAMETERPROB	12
+#define ICMP_TIMESTAMP		13
+#define ICMP_TIMESTAMPREPLY	14
+#define ICMP_INFO_REQUEST	15
+#define ICMP_INFO_REPLY		16
+#define ICMP_ADDRESS		17
+#define ICMP_ADDRESSREPLY	18
+#define NR_ICMP_TYPES		18
+
+
+#define ICMP_NET_UNREACH	0
+#define ICMP_HOST_UNREACH	1
+#define ICMP_PROT_UNREACH	2
+#define ICMP_PORT_UNREACH	3
+#define ICMP_FRAG_NEEDED	4
+#define ICMP_SR_FAILED		5
+#define ICMP_NET_UNKNOWN	6
+#define ICMP_HOST_UNKNOWN	7
+#define ICMP_HOST_ISOLATED	8
+#define ICMP_NET_ANO		9
+#define ICMP_HOST_ANO		10
+#define ICMP_NET_UNR_TOS	11
+#define ICMP_HOST_UNR_TOS	12
+#define ICMP_PKT_FILTERED	13
+#define ICMP_PREC_VIOLATION	14
+#define ICMP_PREC_CUTOFF	15
+#define NR_ICMP_UNREACH		15
+
+#define ICMP_REDIR_NET		0
+#define ICMP_REDIR_HOST		1
+#define ICMP_REDIR_NETTOS	2
+#define ICMP_REDIR_HOSTTOS	3
+
+#define ICMP_EXC_TTL		0
+#define ICMP_EXC_FRAGTIME	1
+
+
+struct icmp_ra_addr {
+	uint32_t ira_addr;
+	uint32_t ira_preference;
+};
+
+struct icmp {
+	uint8_t  icmp_type;
+	uint8_t  icmp_code;
+	uint16_t icmp_cksum;
+	union {
+		uint8_t ih_pptr;
+		struct in_addr ih_gwaddr;
+		struct ih_idseq {
+			uint16_t icd_id;
+			uint16_t icd_seq;
+		} ih_idseq;
+		uint32_t ih_void;
+
+		struct ih_pmtu {
+			uint16_t ipm_void;
+			uint16_t ipm_nextmtu;
+		} ih_pmtu;
+
+		struct ih_rtradv {
+			uint8_t irt_num_addrs;
+			uint8_t irt_wpa;
+			uint16_t irt_lifetime;
+		} ih_rtradv;
+	} icmp_hun;
+	union {
+		struct {
+			uint32_t its_otime;
+			uint32_t its_rtime;
+			uint32_t its_ttime;
+		} id_ts;
+		struct {
+			struct ip idi_ip;
+		} id_ip;
+		struct icmp_ra_addr id_radv;
+		uint32_t   id_mask;
+		uint8_t    id_data[1];
+	} icmp_dun;
+};
+
+#define	icmp_pptr	icmp_hun.ih_pptr
+#define	icmp_gwaddr	icmp_hun.ih_gwaddr
+#define	icmp_id		icmp_hun.ih_idseq.icd_id
+#define	icmp_seq	icmp_hun.ih_idseq.icd_seq
+#define	icmp_void	icmp_hun.ih_void
+#define	icmp_pmvoid	icmp_hun.ih_pmtu.ipm_void
+#define	icmp_nextmtu	icmp_hun.ih_pmtu.ipm_nextmtu
+#define	icmp_num_addrs	icmp_hun.ih_rtradv.irt_num_addrs
+#define	icmp_wpa	icmp_hun.ih_rtradv.irt_wpa
+#define	icmp_lifetime	icmp_hun.ih_rtradv.irt_lifetime
+#define	icmp_otime	icmp_dun.id_ts.its_otime
+#define	icmp_rtime	icmp_dun.id_ts.its_rtime
+#define	icmp_ttime	icmp_dun.id_ts.its_ttime
+#define	icmp_ip		icmp_dun.id_ip.idi_ip
+#define	icmp_radv	icmp_dun.id_radv
+#define	icmp_mask	icmp_dun.id_mask
+#define	icmp_data	icmp_dun.id_data
+
+#define	ICMP_MINLEN	8
+#define	ICMP_TSLEN	(8 + 3 * sizeof (n_time))
+#define	ICMP_MASKLEN	12
+#define	ICMP_ADVLENMIN	(8 + sizeof (struct ip) + 8)
+#define	ICMP_ADVLEN(p)	(8 + ((p)->icmp_ip.ip_hl << 2) + 8)
+
+#define	ICMP_UNREACH		3
+#define	ICMP_SOURCEQUENCH	4
+#define	ICMP_ROUTERADVERT	9
+#define	ICMP_ROUTERSOLICIT	10
+#define	ICMP_TIMXCEED		11
+#define	ICMP_PARAMPROB		12
+#define	ICMP_TSTAMP		13
+#define	ICMP_TSTAMPREPLY	14
+#define	ICMP_IREQ		15
+#define	ICMP_IREQREPLY		16
+#define	ICMP_MASKREQ		17
+#define	ICMP_MASKREPLY		18
+#define	ICMP_MAXTYPE		18
+
+#define	ICMP_UNREACH_NET	        0
+#define	ICMP_UNREACH_HOST	        1
+#define	ICMP_UNREACH_PROTOCOL	        2
+#define	ICMP_UNREACH_PORT	        3
+#define	ICMP_UNREACH_NEEDFRAG	        4
+#define	ICMP_UNREACH_SRCFAIL	        5
+#define	ICMP_UNREACH_NET_UNKNOWN        6
+#define	ICMP_UNREACH_HOST_UNKNOWN       7
+#define	ICMP_UNREACH_ISOLATED	        8
+#define	ICMP_UNREACH_NET_PROHIB	        9
+#define	ICMP_UNREACH_HOST_PROHIB        10
+#define	ICMP_UNREACH_TOSNET	        11
+#define	ICMP_UNREACH_TOSHOST	        12
+#define	ICMP_UNREACH_FILTER_PROHIB      13
+#define	ICMP_UNREACH_HOST_PRECEDENCE    14
+#define	ICMP_UNREACH_PRECEDENCE_CUTOFF  15
+
+#define	ICMP_REDIRECT_NET	0
+#define	ICMP_REDIRECT_HOST	1
+#define	ICMP_REDIRECT_TOSNET	2
+#define	ICMP_REDIRECT_TOSHOST	3
+
+#define	ICMP_TIMXCEED_INTRANS	0
+#define	ICMP_TIMXCEED_REASS	1
+
+#define	ICMP_PARAMPROB_OPTABSENT 1
+
+#define	ICMP_INFOTYPE(type) \
+	((type) == ICMP_ECHOREPLY || (type) == ICMP_ECHO || \
+	(type) == ICMP_ROUTERADVERT || (type) == ICMP_ROUTERSOLICIT || \
+	(type) == ICMP_TSTAMP || (type) == ICMP_TSTAMPREPLY || \
+	(type) == ICMP_IREQ || (type) == ICMP_IREQREPLY || \
+	(type) == ICMP_MASKREQ || (type) == ICMP_MASKREPLY)
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
diff --git a/third_party/musl/porting/liteos_m/kernel/include/netinet/tcp.h b/third_party/musl/porting/liteos_m/kernel/include/netinet/tcp.h
new file mode 100755
index 000000000..44a007aaf
--- /dev/null
+++ b/third_party/musl/porting/liteos_m/kernel/include/netinet/tcp.h
@@ -0,0 +1,282 @@
+#ifndef _NETINET_TCP_H
+#define _NETINET_TCP_H
+
+#include <features.h>
+
+#define TCP_NODELAY 1
+#define TCP_MAXSEG	 2
+#define TCP_CORK	 3
+#define TCP_KEEPIDLE	 4
+#define TCP_KEEPINTVL	 5
+#define TCP_KEEPCNT	 6
+#define TCP_SYNCNT	 7
+#define TCP_LINGER2	 8
+#define TCP_DEFER_ACCEPT 9
+#define TCP_WINDOW_CLAMP 10
+#define TCP_INFO	 11
+#define	TCP_QUICKACK	 12
+#define TCP_CONGESTION	 13
+#define TCP_MD5SIG	 14
+#define TCP_THIN_LINEAR_TIMEOUTS 16
+#define TCP_THIN_DUPACK  17
+#define TCP_USER_TIMEOUT 18
+#define TCP_REPAIR       19
+#define TCP_REPAIR_QUEUE 20
+#define TCP_QUEUE_SEQ    21
+#define TCP_REPAIR_OPTIONS 22
+#define TCP_FASTOPEN     23
+#define TCP_TIMESTAMP    24
+#define TCP_NOTSENT_LOWAT 25
+#define TCP_CC_INFO      26
+#define TCP_SAVE_SYN     27
+#define TCP_SAVED_SYN    28
+#define TCP_REPAIR_WINDOW 29
+#define TCP_FASTOPEN_CONNECT 30
+#define TCP_ULP          31
+#define TCP_MD5SIG_EXT   32
+#define TCP_FASTOPEN_KEY 33
+#define TCP_FASTOPEN_NO_COOKIE 34
+#define TCP_ZEROCOPY_RECEIVE   35
+#define TCP_INQ          36
+#define TCP_TX_DELAY     37
+
+#define TCP_CM_INQ TCP_INQ
+
+#define TCP_ESTABLISHED  1
+#define TCP_SYN_SENT     2
+#define TCP_SYN_RECV     3
+#define TCP_FIN_WAIT1    4
+#define TCP_FIN_WAIT2    5
+#define TCP_TIME_WAIT    6
+#define TCP_CLOSE        7
+#define TCP_CLOSE_WAIT   8
+#define TCP_LAST_ACK     9
+#define TCP_LISTEN       10
+#define TCP_CLOSING      11
+
+enum {
+	TCP_NLA_PAD,
+	TCP_NLA_BUSY,
+	TCP_NLA_RWND_LIMITED,
+	TCP_NLA_SNDBUF_LIMITED,
+	TCP_NLA_DATA_SEGS_OUT,
+	TCP_NLA_TOTAL_RETRANS,
+	TCP_NLA_PACING_RATE,
+	TCP_NLA_DELIVERY_RATE,
+	TCP_NLA_SND_CWND,
+	TCP_NLA_REORDERING,
+	TCP_NLA_MIN_RTT,
+	TCP_NLA_RECUR_RETRANS,
+	TCP_NLA_DELIVERY_RATE_APP_LMT,
+	TCP_NLA_SNDQ_SIZE,
+	TCP_NLA_CA_STATE,
+	TCP_NLA_SND_SSTHRESH,
+	TCP_NLA_DELIVERED,
+	TCP_NLA_DELIVERED_CE,
+	TCP_NLA_BYTES_SENT,
+	TCP_NLA_BYTES_RETRANS,
+	TCP_NLA_DSACK_DUPS,
+	TCP_NLA_REORD_SEEN,
+	TCP_NLA_SRTT,
+};
+
+#if defined(_GNU_SOURCE) || defined(_BSD_SOURCE)
+#define TCPOPT_EOL              0
+#define TCPOPT_NOP              1
+#define TCPOPT_MAXSEG           2
+#define TCPOPT_WINDOW           3
+#define TCPOPT_SACK_PERMITTED   4
+#define TCPOPT_SACK             5
+#define TCPOPT_TIMESTAMP        8
+#define TCPOLEN_SACK_PERMITTED  2
+#define TCPOLEN_WINDOW          3
+#define TCPOLEN_MAXSEG          4
+#define TCPOLEN_TIMESTAMP       10
+
+#define SOL_TCP 6
+
+#include <sys/types.h>
+#include <sys/socket.h>
+#include <stdint.h>
+
+typedef uint32_t tcp_seq;
+
+#define TH_FIN 0x01
+#define TH_SYN 0x02
+#define TH_RST 0x04
+#define TH_PUSH 0x08
+#define TH_ACK 0x10
+#define TH_URG 0x20
+
+struct tcphdr {
+#ifdef _GNU_SOURCE
+#ifdef __GNUC__
+	__extension__
+#endif
+	union { struct {
+
+	uint16_t source;
+	uint16_t dest;
+	uint32_t seq;
+	uint32_t ack_seq;
+#if __BYTE_ORDER == __LITTLE_ENDIAN
+	uint16_t res1:4;
+	uint16_t doff:4;
+	uint16_t fin:1;
+	uint16_t syn:1;
+	uint16_t rst:1;
+	uint16_t psh:1;
+	uint16_t ack:1;
+	uint16_t urg:1;
+	uint16_t res2:2;
+#else
+	uint16_t doff:4;
+	uint16_t res1:4;
+	uint16_t res2:2;
+	uint16_t urg:1;
+	uint16_t ack:1;
+	uint16_t psh:1;
+	uint16_t rst:1;
+	uint16_t syn:1;
+	uint16_t fin:1;
+#endif
+	uint16_t window;
+	uint16_t check;
+	uint16_t urg_ptr;
+
+	}; struct {
+#endif
+
+	uint16_t th_sport;
+	uint16_t th_dport;
+	uint32_t th_seq;
+	uint32_t th_ack;
+#if __BYTE_ORDER == __LITTLE_ENDIAN
+	uint8_t th_x2:4;
+	uint8_t th_off:4;
+#else
+	uint8_t th_off:4;
+	uint8_t th_x2:4;
+#endif
+	uint8_t th_flags;
+	uint16_t th_win;
+	uint16_t th_sum;
+	uint16_t th_urp;
+
+#ifdef _GNU_SOURCE
+	}; };
+#endif
+};
+#endif
+
+#ifdef _GNU_SOURCE
+#define TCPI_OPT_TIMESTAMPS	1
+#define TCPI_OPT_SACK		2
+#define TCPI_OPT_WSCALE		4
+#define TCPI_OPT_ECN		8
+
+#define TCP_CA_Open		0
+#define TCP_CA_Disorder		1
+#define TCP_CA_CWR		2
+#define TCP_CA_Recovery		3
+#define TCP_CA_Loss		4
+
+struct tcp_info {
+	uint8_t tcpi_state;
+	uint8_t tcpi_ca_state;
+	uint8_t tcpi_retransmits;
+	uint8_t tcpi_probes;
+	uint8_t tcpi_backoff;
+	uint8_t tcpi_options;
+	uint8_t tcpi_snd_wscale : 4, tcpi_rcv_wscale : 4;
+	uint8_t tcpi_delivery_rate_app_limited : 1;
+	uint32_t tcpi_rto;
+	uint32_t tcpi_ato;
+	uint32_t tcpi_snd_mss;
+	uint32_t tcpi_rcv_mss;
+	uint32_t tcpi_unacked;
+	uint32_t tcpi_sacked;
+	uint32_t tcpi_lost;
+	uint32_t tcpi_retrans;
+	uint32_t tcpi_fackets;
+	uint32_t tcpi_last_data_sent;
+	uint32_t tcpi_last_ack_sent;
+	uint32_t tcpi_last_data_recv;
+	uint32_t tcpi_last_ack_recv;
+	uint32_t tcpi_pmtu;
+	uint32_t tcpi_rcv_ssthresh;
+	uint32_t tcpi_rtt;
+	uint32_t tcpi_rttvar;
+	uint32_t tcpi_snd_ssthresh;
+	uint32_t tcpi_snd_cwnd;
+	uint32_t tcpi_advmss;
+	uint32_t tcpi_reordering;
+	uint32_t tcpi_rcv_rtt;
+	uint32_t tcpi_rcv_space;
+	uint32_t tcpi_total_retrans;
+	uint64_t tcpi_pacing_rate;
+	uint64_t tcpi_max_pacing_rate;
+	uint64_t tcpi_bytes_acked;
+	uint64_t tcpi_bytes_received;
+	uint32_t tcpi_segs_out;
+	uint32_t tcpi_segs_in;
+	uint32_t tcpi_notsent_bytes;
+	uint32_t tcpi_min_rtt;
+	uint32_t tcpi_data_segs_in;
+	uint32_t tcpi_data_segs_out;
+	uint64_t tcpi_delivery_rate;
+	uint64_t tcpi_busy_time;
+	uint64_t tcpi_rwnd_limited;
+	uint64_t tcpi_sndbuf_limited;
+	uint32_t tcpi_delivered;
+	uint32_t tcpi_delivered_ce;
+	uint64_t tcpi_bytes_sent;
+	uint64_t tcpi_bytes_retrans;
+	uint32_t tcpi_dsack_dups;
+	uint32_t tcpi_reord_seen;
+	uint32_t tcpi_rcv_ooopack;
+	uint32_t tcpi_snd_wnd;
+};
+
+#define TCP_MD5SIG_MAXKEYLEN    80
+
+#define TCP_MD5SIG_FLAG_PREFIX  1
+
+struct tcp_md5sig {
+	struct sockaddr_storage tcpm_addr;
+	uint8_t tcpm_flags;
+	uint8_t tcpm_prefixlen;
+	uint16_t tcpm_keylen;
+	uint32_t __tcpm_pad;
+	uint8_t tcpm_key[TCP_MD5SIG_MAXKEYLEN];
+};
+
+struct tcp_diag_md5sig {
+	uint8_t tcpm_family;
+	uint8_t tcpm_prefixlen;
+	uint16_t tcpm_keylen;
+	uint32_t tcpm_addr[4];
+	uint8_t tcpm_key[TCP_MD5SIG_MAXKEYLEN];
+};
+
+#define TCP_REPAIR_ON		1
+#define TCP_REPAIR_OFF		0
+#define TCP_REPAIR_OFF_NO_WP	-1
+
+struct tcp_repair_window {
+	uint32_t snd_wl1;
+	uint32_t snd_wnd;
+	uint32_t max_window;
+	uint32_t rcv_wnd;
+	uint32_t rcv_wup;
+};
+
+struct tcp_zerocopy_receive {
+	uint64_t address;
+	uint32_t length;
+	uint32_t recv_skip_hint;
+};
+
+#endif
+
+#endif
diff --git a/third_party/musl/porting/liteos_m/kernel/include/netinet/udp.h b/third_party/musl/porting/liteos_m/kernel/include/netinet/udp.h
new file mode 100755
index 000000000..ffd890796
--- /dev/null
+++ b/third_party/musl/porting/liteos_m/kernel/include/netinet/udp.h
@@ -0,0 +1,45 @@
+#ifndef _NETINET_UDP_H
+#define _NETINET_UDP_H
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#include <features.h>
+#include <stdint.h>
+
+#ifdef _GNU_SOURCE
+#define uh_sport source
+#define uh_dport dest
+#define uh_ulen len
+#define uh_sum check
+#endif
+
+struct udphdr {
+	uint16_t uh_sport;
+	uint16_t uh_dport;
+	uint16_t uh_ulen;
+	uint16_t uh_sum;
+};
+
+#define UDP_CORK	1
+#define UDP_ENCAP	100
+#define UDP_NO_CHECK6_TX 101
+#define UDP_NO_CHECK6_RX 102
+#define UDP_SEGMENT	103
+#define UDP_GRO		104
+
+#define UDP_ENCAP_ESPINUDP_NON_IKE 1
+#define UDP_ENCAP_ESPINUDP	2
+#define UDP_ENCAP_L2TPINUDP	3
+#define UDP_ENCAP_GTP0		4
+#define UDP_ENCAP_GTP1U		5
+#define UDP_ENCAP_RXRPC		6
+
+#define SOL_UDP            17
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
diff --git a/third_party/musl/porting/liteos_m/kernel/include/netpacket/packet.h b/third_party/musl/porting/liteos_m/kernel/include/netpacket/packet.h
new file mode 100755
index 000000000..b36e092ad
--- /dev/null
+++ b/third_party/musl/porting/liteos_m/kernel/include/netpacket/packet.h
@@ -0,0 +1,62 @@
+#ifndef _NETPACKET_PACKET_H
+#define _NETPACKET_PACKET_H
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+struct sockaddr_ll {
+	unsigned short sll_family, sll_protocol;
+	int sll_ifindex;
+	unsigned short sll_hatype;
+	unsigned char sll_pkttype, sll_halen;
+	unsigned char sll_addr[8];
+};
+
+struct packet_mreq {
+	int mr_ifindex;
+	unsigned short int mr_type,  mr_alen;
+	unsigned char mr_address[8];
+};
+
+#define PACKET_HOST		0
+#define PACKET_BROADCAST	1
+#define PACKET_MULTICAST	2
+#define PACKET_OTHERHOST	3
+#define PACKET_OUTGOING		4
+#define PACKET_LOOPBACK		5
+#define PACKET_FASTROUTE	6
+
+#define PACKET_ADD_MEMBERSHIP		1
+#define PACKET_DROP_MEMBERSHIP		2
+#define	PACKET_RECV_OUTPUT		3
+#define	PACKET_RX_RING			5
+#define	PACKET_STATISTICS		6
+#define PACKET_COPY_THRESH		7
+#define PACKET_AUXDATA			8
+#define PACKET_ORIGDEV			9
+#define PACKET_VERSION			10
+#define PACKET_HDRLEN			11
+#define PACKET_RESERVE			12
+#define PACKET_TX_RING			13
+#define PACKET_LOSS			14
+#define PACKET_VNET_HDR			15
+#define PACKET_TX_TIMESTAMP		16
+#define PACKET_TIMESTAMP		17
+#define PACKET_FANOUT			18
+#define PACKET_TX_HAS_OFF		19
+#define PACKET_QDISC_BYPASS		20
+#define PACKET_ROLLOVER_STATS		21
+#define PACKET_FANOUT_DATA		22
+#define PACKET_IGNORE_OUTGOING		23
+
+#define PACKET_MR_MULTICAST	0
+#define PACKET_MR_PROMISC	1
+#define PACKET_MR_ALLMULTI	2
+#define PACKET_MR_UNICAST	3
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
diff --git a/third_party/musl/porting/liteos_m/kernel/include/nl_types.h b/third_party/musl/porting/liteos_m/kernel/include/nl_types.h
new file mode 100755
index 000000000..7c2d48e0f
--- /dev/null
+++ b/third_party/musl/porting/liteos_m/kernel/include/nl_types.h
@@ -0,0 +1,22 @@
+#ifndef _NL_TYPES_H
+#define _NL_TYPES_H
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#define NL_SETD 1
+#define NL_CAT_LOCALE 1
+
+typedef int nl_item;
+typedef void *nl_catd;
+
+nl_catd catopen (const char *, int);
+char *catgets (nl_catd, int, int, const char *);
+int catclose (nl_catd);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
diff --git a/third_party/musl/porting/liteos_m/kernel/include/paths.h b/third_party/musl/porting/liteos_m/kernel/include/paths.h
new file mode 100755
index 000000000..67de6b3c3
--- /dev/null
+++ b/third_party/musl/porting/liteos_m/kernel/include/paths.h
@@ -0,0 +1,31 @@
+#ifndef _PATHS_H
+#define _PATHS_H
+
+#define	_PATH_DEFPATH "/usr/local/bin:/bin:/usr/bin"
+#define	_PATH_STDPATH "/bin:/usr/bin:/sbin:/usr/sbin"
+
+#define	_PATH_BSHELL	"/bin/sh"
+#define	_PATH_CONSOLE	"/dev/console"
+#define	_PATH_DEVNULL	"/dev/null"
+#define	_PATH_KLOG	"/proc/kmsg"
+#define	_PATH_LASTLOG	"/var/log/lastlog"
+#define	_PATH_MAILDIR	"/var/mail"
+#define	_PATH_MAN	"/usr/share/man"
+#define	_PATH_MNTTAB	"/etc/fstab"
+#define	_PATH_MOUNTED	"/etc/mtab"
+#define	_PATH_NOLOGIN	"/etc/nologin"
+#define	_PATH_SENDMAIL	"/usr/sbin/sendmail"
+#define	_PATH_SHADOW	"/etc/shadow"
+#define	_PATH_SHELLS	"/etc/shells"
+#define	_PATH_TTY	"/dev/tty"
+#define _PATH_UTMP	"/dev/null/utmp"
+#define	_PATH_VI	"/usr/bin/vi"
+#define _PATH_WTMP	"/dev/null/wtmp"
+
+#define	_PATH_DEV	"/dev/"
+#define	_PATH_TMP	"/tmp/"
+#define	_PATH_VARDB	"/var/lib/misc/"
+#define	_PATH_VARRUN	"/var/run/"
+#define	_PATH_VARTMP	"/var/tmp/"
+
+#endif
diff --git a/third_party/musl/porting/liteos_m/kernel/include/poll.h b/third_party/musl/porting/liteos_m/kernel/include/poll.h
new file mode 100755
index 000000000..472e4b847
--- /dev/null
+++ b/third_party/musl/porting/liteos_m/kernel/include/poll.h
@@ -0,0 +1,57 @@
+#ifndef	_POLL_H
+#define	_POLL_H
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#include <features.h>
+
+#include <bits/poll.h>
+
+#define POLLIN     0x001
+#define POLLPRI    0x002
+#define POLLOUT    0x004
+#define POLLERR    0x008
+#define POLLHUP    0x010
+#define POLLNVAL   0x020
+#define POLLRDNORM 0x040
+#define POLLRDBAND 0x080
+#ifndef POLLWRNORM
+#define POLLWRNORM 0x100
+#define POLLWRBAND 0x200
+#endif
+#ifndef POLLMSG
+#define POLLMSG    0x400
+#define POLLRDHUP  0x2000
+#endif
+
+typedef unsigned long nfds_t;
+
+struct pollfd {
+	int fd;
+	short events;
+	short revents;
+};
+
+int poll (struct pollfd *, nfds_t, int);
+
+#ifdef _GNU_SOURCE
+#define __NEED_time_t
+#define __NEED_struct_timespec
+#define __NEED_sigset_t
+#include <bits/alltypes.h>
+int ppoll(struct pollfd *, nfds_t, const struct timespec *, const sigset_t *);
+#endif
+
+#if _REDIR_TIME64
+#ifdef _GNU_SOURCE
+__REDIR(ppoll, __ppoll_time64);
+#endif
+#endif
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
diff --git a/third_party/musl/kernel_m/include/pthread.h b/third_party/musl/porting/liteos_m/kernel/include/pthread.h
similarity index 99%
rename from third_party/musl/kernel_m/include/pthread.h
rename to third_party/musl/porting/liteos_m/kernel/include/pthread.h
index 5dd71ec02..8291cdef2 100755
--- a/third_party/musl/kernel_m/include/pthread.h
+++ b/third_party/musl/porting/liteos_m/kernel/include/pthread.h
@@ -26,7 +26,6 @@ extern "C" {
 #define __NEED_size_t
 
 #include <bits/alltypes.h>
-
 #include <sched.h>
 #include <time.h>
 
@@ -82,7 +81,7 @@ extern "C" {
 
 int pthread_create(pthread_t *__restrict, const pthread_attr_t *__restrict, void *(*)(void *), void *__restrict);
 int pthread_detach(pthread_t);
-_Noreturn void pthread_exit(void *);
+void pthread_exit(void *);
 int pthread_join(pthread_t, void **);
 
 #ifdef __GNUC__
diff --git a/third_party/musl/porting/liteos_m/kernel/include/pty.h b/third_party/musl/porting/liteos_m/kernel/include/pty.h
new file mode 100755
index 000000000..db6385341
--- /dev/null
+++ b/third_party/musl/porting/liteos_m/kernel/include/pty.h
@@ -0,0 +1,18 @@
+#ifndef	_PTY_H
+#define	_PTY_H
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#include <termios.h>
+#include <sys/ioctl.h>
+
+int openpty(int *, int *, char *, const struct termios *, const struct winsize *);
+int forkpty(int *, char *, const struct termios *, const struct winsize *);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
diff --git a/third_party/musl/porting/liteos_m/kernel/include/pwd.h b/third_party/musl/porting/liteos_m/kernel/include/pwd.h
new file mode 100755
index 000000000..4f470b558
--- /dev/null
+++ b/third_party/musl/porting/liteos_m/kernel/include/pwd.h
@@ -0,0 +1,50 @@
+#ifndef _PWD_H
+#define _PWD_H
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#include <features.h>
+
+#define __NEED_size_t
+#define __NEED_uid_t
+#define __NEED_gid_t
+
+#ifdef _GNU_SOURCE
+#define __NEED_FILE
+#endif
+
+#include <bits/alltypes.h>
+
+struct passwd {
+	char *pw_name;
+	char *pw_passwd;
+	uid_t pw_uid;
+	gid_t pw_gid;
+	char *pw_gecos;
+	char *pw_dir;
+	char *pw_shell;
+};
+
+#if defined(_XOPEN_SOURCE) || defined(_GNU_SOURCE) || defined(_BSD_SOURCE)
+void setpwent (void);
+void endpwent (void);
+struct passwd *getpwent (void);
+#endif
+
+struct passwd *getpwuid (uid_t);
+struct passwd *getpwnam (const char *);
+int getpwuid_r (uid_t, struct passwd *, char *, size_t, struct passwd **);
+int getpwnam_r (const char *, struct passwd *, char *, size_t, struct passwd **);
+
+#ifdef _GNU_SOURCE
+struct passwd *fgetpwent(FILE *);
+int putpwent(const struct passwd *, FILE *);
+#endif
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
diff --git a/third_party/musl/porting/liteos_m/kernel/include/regex.h b/third_party/musl/porting/liteos_m/kernel/include/regex.h
new file mode 100755
index 000000000..dce217718
--- /dev/null
+++ b/third_party/musl/porting/liteos_m/kernel/include/regex.h
@@ -0,0 +1,62 @@
+#ifndef _REGEX_H
+#define _REGEX_H
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#include <features.h>
+
+#define __NEED_regoff_t
+#define __NEED_size_t
+
+#include <bits/alltypes.h>
+
+typedef struct re_pattern_buffer {
+	size_t re_nsub;
+	void *__opaque, *__padding[4];
+	size_t __nsub2;
+	char __padding2;
+} regex_t;
+
+typedef struct {
+	regoff_t rm_so;
+	regoff_t rm_eo;
+} regmatch_t;
+
+#define REG_EXTENDED    1
+#define REG_ICASE       2
+#define REG_NEWLINE     4
+#define REG_NOSUB       8
+
+#define REG_NOTBOL      1
+#define REG_NOTEOL      2
+
+#define REG_OK          0
+#define REG_NOMATCH     1
+#define REG_BADPAT      2
+#define REG_ECOLLATE    3
+#define REG_ECTYPE      4
+#define REG_EESCAPE     5
+#define REG_ESUBREG     6
+#define REG_EBRACK      7
+#define REG_EPAREN      8
+#define REG_EBRACE      9
+#define REG_BADBR       10
+#define REG_ERANGE      11
+#define REG_ESPACE      12
+#define REG_BADRPT      13
+
+#define REG_ENOSYS      -1
+
+int regcomp(regex_t *__restrict, const char *__restrict, int);
+int regexec(const regex_t *__restrict, const char *__restrict, size_t, regmatch_t *__restrict, int);
+void regfree(regex_t *);
+
+size_t regerror(int, const regex_t *__restrict, char *__restrict, size_t);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
diff --git a/third_party/musl/porting/liteos_m/kernel/include/resolv.h b/third_party/musl/porting/liteos_m/kernel/include/resolv.h
new file mode 100755
index 000000000..8b23ad66c
--- /dev/null
+++ b/third_party/musl/porting/liteos_m/kernel/include/resolv.h
@@ -0,0 +1,142 @@
+#ifndef _RESOLV_H
+#define _RESOLV_H
+
+#include <stdint.h>
+#include <arpa/nameser.h>
+#include <netinet/in.h>
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#define MAXNS			3
+#define MAXDFLSRCH		3
+#define MAXDNSRCH		6
+#define LOCALDOMAINPARTS	2
+
+#define RES_TIMEOUT		5
+#define MAXRESOLVSORT		10
+#define RES_MAXNDOTS		15
+#define RES_MAXRETRANS		30
+#define RES_MAXRETRY		5
+#define RES_DFLRETRY		2
+#define RES_MAXTIME		65535
+
+/* unused; purely for broken apps */
+typedef struct __res_state {
+	int retrans;
+	int retry;
+	unsigned long options;
+	int nscount;
+	struct sockaddr_in nsaddr_list[MAXNS];
+# define nsaddr	nsaddr_list[0]
+	unsigned short id;
+	char *dnsrch[MAXDNSRCH+1];
+	char defdname[256];
+	unsigned long pfcode;
+	unsigned ndots:4;
+	unsigned nsort:4;
+	unsigned ipv6_unavail:1;
+	unsigned unused:23;
+	struct {
+		struct in_addr addr;
+		uint32_t mask;
+	} sort_list[MAXRESOLVSORT];
+	void *qhook;
+	void *rhook;
+	int res_h_errno;
+	int _vcsock;
+	unsigned _flags;
+	union {
+		char pad[52];
+		struct {
+			uint16_t		nscount;
+			uint16_t		nsmap[MAXNS];
+			int			nssocks[MAXNS];
+			uint16_t		nscount6;
+			uint16_t		nsinit;
+			struct sockaddr_in6	*nsaddrs[MAXNS];
+			unsigned int		_initstamp[2];
+		} _ext;
+	} _u;
+} *res_state;
+
+#define	__RES	19960801
+
+#ifndef _PATH_RESCONF
+#define _PATH_RESCONF        "/etc/resolv.conf"
+#endif
+
+struct res_sym {
+	int number;
+	char *name;
+	char *humanname;
+};
+
+#define	RES_F_VC	0x00000001
+#define	RES_F_CONN	0x00000002
+#define RES_F_EDNS0ERR	0x00000004
+
+#define	RES_EXHAUSTIVE	0x00000001
+
+#define RES_INIT	0x00000001
+#define RES_DEBUG	0x00000002
+#define RES_AAONLY	0x00000004
+#define RES_USEVC	0x00000008
+#define RES_PRIMARY	0x00000010
+#define RES_IGNTC	0x00000020
+#define RES_RECURSE	0x00000040
+#define RES_DEFNAMES	0x00000080
+#define RES_STAYOPEN	0x00000100
+#define RES_DNSRCH	0x00000200
+#define	RES_INSECURE1	0x00000400
+#define	RES_INSECURE2	0x00000800
+#define	RES_NOALIASES	0x00001000
+#define	RES_USE_INET6	0x00002000
+#define RES_ROTATE	0x00004000
+#define	RES_NOCHECKNAME	0x00008000
+#define	RES_KEEPTSIG	0x00010000
+#define	RES_BLAST	0x00020000
+#define RES_USEBSTRING	0x00040000
+#define RES_NOIP6DOTINT	0x00080000
+#define RES_USE_EDNS0	0x00100000
+#define RES_SNGLKUP	0x00200000
+#define RES_SNGLKUPREOP	0x00400000
+#define RES_USE_DNSSEC	0x00800000
+
+#define RES_DEFAULT	(RES_RECURSE|RES_DEFNAMES|RES_DNSRCH|RES_NOIP6DOTINT)
+
+#define RES_PRF_STATS	0x00000001
+#define RES_PRF_UPDATE	0x00000002
+#define RES_PRF_CLASS   0x00000004
+#define RES_PRF_CMD	0x00000008
+#define RES_PRF_QUES	0x00000010
+#define RES_PRF_ANS	0x00000020
+#define RES_PRF_AUTH	0x00000040
+#define RES_PRF_ADD	0x00000080
+#define RES_PRF_HEAD1	0x00000100
+#define RES_PRF_HEAD2	0x00000200
+#define RES_PRF_TTLID	0x00000400
+#define RES_PRF_HEADX	0x00000800
+#define RES_PRF_QUERY	0x00001000
+#define RES_PRF_REPLY	0x00002000
+#define RES_PRF_INIT	0x00004000
+
+struct __res_state *__res_state(void);
+#define _res (*__res_state())
+
+int res_init(void);
+int res_query(const char *, int, int, unsigned char *, int);
+int res_querydomain(const char *, const char *, int, int, unsigned char *, int);
+int res_search(const char *, int, int, unsigned char *, int);
+int res_mkquery(int, const char *, int, int, const unsigned char *, int, const unsigned char*, unsigned char *, int);
+int res_send(const unsigned char *, int, unsigned char *, int);
+int dn_comp(const char *, unsigned char *, int, unsigned char **, unsigned char **);
+int dn_expand(const unsigned char *, const unsigned char *, const unsigned char *, char *, int);
+int dn_skipname(const unsigned char *, const unsigned char *);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
diff --git a/third_party/musl/porting/liteos_m/kernel/include/sched.h b/third_party/musl/porting/liteos_m/kernel/include/sched.h
new file mode 100755
index 000000000..605bf91b5
--- /dev/null
+++ b/third_party/musl/porting/liteos_m/kernel/include/sched.h
@@ -0,0 +1,134 @@
+#ifndef _SCHED_H
+#define _SCHED_H
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#include <features.h>
+
+#define __NEED_struct_timespec
+#define __NEED_pid_t
+#define __NEED_time_t
+#define __NEED_sched_param
+
+#ifdef _GNU_SOURCE
+#define __NEED_size_t
+#endif
+
+#include <bits/alltypes.h>
+
+int    sched_get_priority_max(int);
+int    sched_get_priority_min(int);
+int    sched_getparam(pid_t, struct sched_param *);
+int    sched_getscheduler(pid_t);
+int    sched_rr_get_interval(pid_t, struct timespec *);
+int    sched_setparam(pid_t, const struct sched_param *);
+int    sched_setscheduler(pid_t, int, const struct sched_param *);
+int     sched_yield(void);
+
+#define SCHED_OTHER 0
+#define SCHED_FIFO 1
+#define SCHED_RR 2
+#define SCHED_BATCH 3
+#define SCHED_IDLE 5
+#define SCHED_DEADLINE 6
+#define SCHED_RESET_ON_FORK 0x40000000
+
+#ifdef _GNU_SOURCE
+#define CSIGNAL		0x000000ff
+#define CLONE_VM	0x00000100
+#define CLONE_FS	0x00000200
+#define CLONE_FILES	0x00000400
+#define CLONE_SIGHAND	0x00000800
+#define CLONE_PIDFD	0x00001000
+#define CLONE_PTRACE	0x00002000
+#define CLONE_VFORK	0x00004000
+#define CLONE_PARENT	0x00008000
+#define CLONE_THREAD	0x00010000
+#define CLONE_NEWNS	0x00020000
+#define CLONE_SYSVSEM	0x00040000
+#define CLONE_SETTLS	0x00080000
+#define CLONE_PARENT_SETTID	0x00100000
+#define CLONE_CHILD_CLEARTID	0x00200000
+#define CLONE_DETACHED	0x00400000
+#define CLONE_UNTRACED	0x00800000
+#define CLONE_CHILD_SETTID	0x01000000
+#define CLONE_NEWCGROUP	0x02000000
+#define CLONE_NEWUTS	0x04000000
+#define CLONE_NEWIPC	0x08000000
+#define CLONE_NEWUSER	0x10000000
+#define CLONE_NEWPID	0x20000000
+#define CLONE_NEWNET	0x40000000
+#define CLONE_IO	0x80000000
+int clone (int (*)(void *), void *, int, void *, ...);
+int unshare(int);
+int setns(int, int);
+
+void *memcpy(void *__restrict, const void *__restrict, size_t);
+int memcmp(const void *, const void *, size_t);
+void *memset (void *, int, size_t);
+void *calloc(size_t, size_t);
+void free(void *);
+
+typedef struct cpu_set_t { unsigned long __bits[128/sizeof(long)]; } cpu_set_t;
+int __sched_cpucount(size_t, const cpu_set_t *);
+int sched_getcpu(void);
+int sched_getaffinity(pid_t, size_t, cpu_set_t *);
+int sched_setaffinity(pid_t, size_t, const cpu_set_t *);
+
+#define __CPU_op_S(i, size, set, op) ( (i)/8U >= (size) ? 0 : \
+	(((unsigned long *)(set))[(i)/8/sizeof(long)] op (1UL<<((i)%(8*sizeof(long))))) )
+
+#define CPU_SET_S(i, size, set) __CPU_op_S(i, size, set, |=)
+#define CPU_CLR_S(i, size, set) __CPU_op_S(i, size, set, &=~)
+#define CPU_ISSET_S(i, size, set) __CPU_op_S(i, size, set, &)
+
+#define __CPU_op_func_S(func, op) \
+static __inline void __CPU_##func##_S(size_t __size, cpu_set_t *__dest, \
+	const cpu_set_t *__src1, const cpu_set_t *__src2) \
+{ \
+	size_t __i; \
+	for (__i=0; __i<__size/sizeof(long); __i++) \
+		((unsigned long *)__dest)[__i] = ((unsigned long *)__src1)[__i] \
+			op ((unsigned long *)__src2)[__i] ; \
+}
+
+__CPU_op_func_S(AND, &)
+__CPU_op_func_S(OR, |)
+__CPU_op_func_S(XOR, ^)
+
+#define CPU_AND_S(a,b,c,d) __CPU_AND_S(a,b,c,d)
+#define CPU_OR_S(a,b,c,d) __CPU_OR_S(a,b,c,d)
+#define CPU_XOR_S(a,b,c,d) __CPU_XOR_S(a,b,c,d)
+
+#define CPU_COUNT_S(size,set) __sched_cpucount(size,set)
+#define CPU_ZERO_S(size,set) memset(set,0,size)
+#define CPU_EQUAL_S(size,set1,set2) (!memcmp(set1,set2,size))
+
+#define CPU_ALLOC_SIZE(n) (sizeof(long) * ( (n)/(8*sizeof(long)) \
+	+ ((n)%(8*sizeof(long)) + 8*sizeof(long)-1)/(8*sizeof(long)) ) )
+#define CPU_ALLOC(n) ((cpu_set_t *)calloc(1,CPU_ALLOC_SIZE(n)))
+#define CPU_FREE(set) free(set)
+
+#define CPU_SETSIZE 128
+
+#define CPU_SET(i, set) CPU_SET_S(i,sizeof(cpu_set_t),set)
+#define CPU_CLR(i, set) CPU_CLR_S(i,sizeof(cpu_set_t),set)
+#define CPU_ISSET(i, set) CPU_ISSET_S(i,sizeof(cpu_set_t),set)
+#define CPU_AND(d,s1,s2) CPU_AND_S(sizeof(cpu_set_t),d,s1,s2)
+#define CPU_OR(d,s1,s2) CPU_OR_S(sizeof(cpu_set_t),d,s1,s2)
+#define CPU_XOR(d,s1,s2) CPU_XOR_S(sizeof(cpu_set_t),d,s1,s2)
+#define CPU_COUNT(set) CPU_COUNT_S(sizeof(cpu_set_t),set)
+#define CPU_ZERO(set) CPU_ZERO_S(sizeof(cpu_set_t),set)
+#define CPU_EQUAL(s1,s2) CPU_EQUAL_S(sizeof(cpu_set_t),s1,s2)
+
+#endif
+
+#if _REDIR_TIME64
+__REDIR(sched_rr_get_interval, __sched_rr_get_interval_time64);
+#endif
+
+#ifdef __cplusplus
+}
+#endif
+#endif
diff --git a/third_party/musl/porting/liteos_m/kernel/include/scsi/scsi.h b/third_party/musl/porting/liteos_m/kernel/include/scsi/scsi.h
new file mode 100755
index 000000000..8837f5875
--- /dev/null
+++ b/third_party/musl/porting/liteos_m/kernel/include/scsi/scsi.h
@@ -0,0 +1,150 @@
+#ifndef _SCSI_SCSI_H
+#define _SCSI_SCSI_H
+
+#define TEST_UNIT_READY 0x00
+#define REZERO_UNIT 0x01
+#define REQUEST_SENSE 0x03
+#define FORMAT_UNIT 0x04
+#define READ_BLOCK_LIMITS 0x05
+#define REASSIGN_BLOCKS 0x07
+#define READ_6 0x08
+#define WRITE_6 0x0a
+#define SEEK_6 0x0b
+#define READ_REVERSE 0x0f
+#define WRITE_FILEMARKS 0x10
+#define SPACE 0x11
+#define INQUIRY 0x12
+#define RECOVER_BUFFERED_DATA 0x14
+#define MODE_SELECT 0x15
+#define RESERVE 0x16
+#define RELEASE 0x17
+#define COPY 0x18
+#define ERASE 0x19
+#define MODE_SENSE 0x1a
+#define START_STOP 0x1b
+#define RECEIVE_DIAGNOSTIC 0x1c
+#define SEND_DIAGNOSTIC 0x1d
+#define ALLOW_MEDIUM_REMOVAL 0x1e
+#define SET_WINDOW 0x24
+#define READ_CAPACITY 0x25
+#define READ_10 0x28
+#define WRITE_10 0x2a
+#define SEEK_10 0x2b
+#define WRITE_VERIFY 0x2e
+#define VERIFY 0x2f
+#define SEARCH_HIGH 0x30
+#define SEARCH_EQUAL 0x31
+#define SEARCH_LOW 0x32
+#define SET_LIMITS 0x33
+#define PRE_FETCH 0x34
+#define READ_POSITION 0x34
+#define SYNCHRONIZE_CACHE 0x35
+#define LOCK_UNLOCK_CACHE 0x36
+#define READ_DEFECT_DATA 0x37
+#define MEDIUM_SCAN 0x38
+#define COMPARE 0x39
+#define COPY_VERIFY 0x3a
+#define WRITE_BUFFER 0x3b
+#define READ_BUFFER 0x3c
+#define UPDATE_BLOCK 0x3d
+#define READ_LONG 0x3e
+#define WRITE_LONG 0x3f
+#define CHANGE_DEFINITION 0x40
+#define WRITE_SAME 0x41
+#define READ_TOC 0x43
+#define LOG_SELECT 0x4c
+#define LOG_SENSE 0x4d
+#define MODE_SELECT_10 0x55
+#define RESERVE_10 0x56
+#define RELEASE_10 0x57
+#define MODE_SENSE_10 0x5a
+#define PERSISTENT_RESERVE_IN 0x5e
+#define PERSISTENT_RESERVE_OUT 0x5f
+#define MOVE_MEDIUM 0xa5
+#define READ_12 0xa8
+#define WRITE_12 0xaa
+#define WRITE_VERIFY_12 0xae
+#define SEARCH_HIGH_12 0xb0
+#define SEARCH_EQUAL_12 0xb1
+#define SEARCH_LOW_12 0xb2
+#define READ_ELEMENT_STATUS 0xb8
+#define SEND_VOLUME_TAG 0xb6
+#define WRITE_LONG_2 0xea
+#define GOOD 0x00
+#define CHECK_CONDITION 0x01
+#define CONDITION_GOOD 0x02
+#define BUSY 0x04
+#define INTERMEDIATE_GOOD 0x08
+#define INTERMEDIATE_C_GOOD 0x0a
+#define RESERVATION_CONFLICT 0x0c
+#define COMMAND_TERMINATED 0x11
+#define QUEUE_FULL 0x14
+#define STATUS_MASK 0x3e
+#define NO_SENSE 0x00
+#define RECOVERED_ERROR 0x01
+#define NOT_READY 0x02
+#define MEDIUM_ERROR 0x03
+#define HARDWARE_ERROR 0x04
+#define ILLEGAL_REQUEST 0x05
+#define UNIT_ATTENTION 0x06
+#define DATA_PROTECT 0x07
+#define BLANK_CHECK 0x08
+#define COPY_ABORTED 0x0a
+#define ABORTED_COMMAND 0x0b
+#define VOLUME_OVERFLOW 0x0d
+#define MISCOMPARE 0x0e
+#define TYPE_DISK 0x00
+#define TYPE_TAPE 0x01
+#define TYPE_PROCESSOR 0x03
+#define TYPE_WORM 0x04
+#define TYPE_ROM 0x05
+#define TYPE_SCANNER 0x06
+#define TYPE_MOD 0x07
+#define TYPE_MEDIUM_CHANGER 0x08
+#define TYPE_ENCLOSURE 0x0d
+#define TYPE_NO_LUN 0x7f
+#define COMMAND_COMPLETE 0x00
+#define EXTENDED_MESSAGE 0x01
+#define EXTENDED_MODIFY_DATA_POINTER 0x00
+#define EXTENDED_SDTR 0x01
+#define EXTENDED_EXTENDED_IDENTIFY 0x02
+#define EXTENDED_WDTR 0x03
+#define SAVE_POINTERS 0x02
+#define RESTORE_POINTERS 0x03
+#define DISCONNECT 0x04
+#define INITIATOR_ERROR 0x05
+#define ABORT 0x06
+#define MESSAGE_REJECT 0x07
+#define NOP 0x08
+#define MSG_PARITY_ERROR 0x09
+#define LINKED_CMD_COMPLETE 0x0a
+#define LINKED_FLG_CMD_COMPLETE 0x0b
+#define BUS_DEVICE_RESET 0x0c
+#define INITIATE_RECOVERY 0x0f
+#define RELEASE_RECOVERY 0x10
+#define SIMPLE_QUEUE_TAG 0x20
+#define HEAD_OF_QUEUE_TAG 0x21
+#define ORDERED_QUEUE_TAG 0x22
+#define SCSI_IOCTL_GET_IDLUN 0x5382
+#define SCSI_IOCTL_TAGGED_ENABLE 0x5383
+#define SCSI_IOCTL_TAGGED_DISABLE 0x5384
+#define SCSI_IOCTL_PROBE_HOST 0x5385
+#define SCSI_IOCTL_GET_BUS_NUMBER 0x5386
+
+struct ccs_modesel_head {
+	unsigned char _r1;
+	unsigned char medium;
+	unsigned char _r2;
+	unsigned char block_desc_length;
+	unsigned char density;
+	unsigned char number_blocks_hi;
+	unsigned char number_blocks_med;
+	unsigned char number_blocks_lo;
+	unsigned char _r3;
+	unsigned char block_length_hi;
+	unsigned char block_length_med;
+	unsigned char block_length_lo;
+};
+
+#endif
+
diff --git a/third_party/musl/porting/liteos_m/kernel/include/scsi/scsi_ioctl.h b/third_party/musl/porting/liteos_m/kernel/include/scsi/scsi_ioctl.h
new file mode 100755
index 000000000..22df7feff
--- /dev/null
+++ b/third_party/musl/porting/liteos_m/kernel/include/scsi/scsi_ioctl.h
@@ -0,0 +1,11 @@
+#ifndef _SCSI_IOCTL_H
+#define _SCSI_IOCTL_H
+#define SCSI_IOCTL_SEND_COMMAND 1
+#define SCSI_IOCTL_TEST_UNIT_READY 2
+#define SCSI_IOCTL_BENCHMARK_COMMAND 3
+#define SCSI_IOCTL_SYNC 4
+#define SCSI_IOCTL_START_UNIT 5
+#define SCSI_IOCTL_STOP_UNIT 6
+#define SCSI_IOCTL_DOORLOCK 0x5380
+#define SCSI_IOCTL_DOORUNLOCK 0x5381
+#endif
diff --git a/third_party/musl/porting/liteos_m/kernel/include/scsi/sg.h b/third_party/musl/porting/liteos_m/kernel/include/scsi/sg.h
new file mode 100755
index 000000000..a7ac247e3
--- /dev/null
+++ b/third_party/musl/porting/liteos_m/kernel/include/scsi/sg.h
@@ -0,0 +1,129 @@
+#ifndef _SCSI_SG_H
+#define _SCSI_SG_H
+
+#define SG_DXFER_NONE -1
+#define SG_DXFER_TO_DEV -2
+#define SG_DXFER_FROM_DEV -3
+#define SG_DXFER_TO_FROM_DEV -4
+#define SG_FLAG_DIRECT_IO 1
+#define SG_FLAG_LUN_INHIBIT 2
+#define SG_FLAG_NO_DXFER 0x10000
+#define SG_INFO_OK_MASK 0x1
+#define SG_INFO_OK 0x0
+#define SG_INFO_CHECK 0x1
+#define SG_INFO_DIRECT_IO_MASK 0x6
+#define SG_INFO_INDIRECT_IO 0x0
+#define SG_INFO_DIRECT_IO 0x2
+#define SG_INFO_MIXED_IO 0x4
+#define SG_EMULATED_HOST 0x2203
+#define SG_SET_TRANSFORM 0x2204
+#define SG_GET_TRANSFORM 0x2205
+#define SG_SET_RESERVED_SIZE 0x2275
+#define SG_GET_RESERVED_SIZE 0x2272
+#define SG_GET_SCSI_ID 0x2276
+#define SG_SET_FORCE_LOW_DMA 0x2279
+#define SG_GET_LOW_DMA 0x227a
+#define SG_SET_FORCE_PACK_ID 0x227b
+#define SG_GET_PACK_ID 0x227c
+#define SG_GET_NUM_WAITING 0x227d
+#define SG_GET_SG_TABLESIZE 0x227F
+#define SG_GET_VERSION_NUM 0x2282
+#define SG_SCSI_RESET 0x2284
+#define SG_SCSI_RESET_NOTHING 0
+#define SG_SCSI_RESET_DEVICE 1
+#define SG_SCSI_RESET_BUS 2
+#define SG_SCSI_RESET_HOST 3
+#define SG_IO 0x2285
+#define SG_GET_REQUEST_TABLE 0x2286
+#define SG_SET_KEEP_ORPHAN 0x2287
+#define SG_GET_KEEP_ORPHAN 0x2288
+#define SG_SCATTER_SZ (8 * 4096)
+#define SG_DEFAULT_RETRIES 1
+#define SG_DEF_FORCE_LOW_DMA 0
+#define SG_DEF_FORCE_PACK_ID 0
+#define SG_DEF_KEEP_ORPHAN 0
+#define SG_DEF_RESERVED_SIZE SG_SCATTER_SZ
+#define SG_MAX_QUEUE 16
+#define SG_BIG_BUFF SG_DEF_RESERVED_SIZE
+#define SG_MAX_SENSE 16
+#define SG_SET_TIMEOUT 0x2201
+#define SG_GET_TIMEOUT 0x2202
+#define SG_GET_COMMAND_Q 0x2270
+#define SG_SET_COMMAND_Q 0x2271
+#define SG_SET_DEBUG 0x227e
+#define SG_NEXT_CMD_LEN 0x2283
+#define SG_DEFAULT_TIMEOUT (60*100) /* 60*HZ */
+#define SG_DEF_COMMAND_Q 0
+#define SG_DEF_UNDERRUN_FLAG 0
+
+typedef struct sg_iovec {
+	void *iov_base;
+	unsigned long iov_len;
+} sg_iovec_t;
+
+typedef struct sg_io_hdr { 
+	int interface_id; 
+	int dxfer_direction; 
+	unsigned char cmd_len;
+	unsigned char mx_sb_len;
+	unsigned short iovec_count;
+	unsigned dxfer_len;
+	void *dxferp;
+	unsigned char *cmdp;
+	unsigned char *sbp;
+	unsigned timeout;
+	unsigned flags;
+	int pack_id;
+	void *usr_ptr;
+	unsigned char status;
+	unsigned char masked_status;
+	unsigned char msg_status;
+	unsigned char sb_len_wr;
+	unsigned short host_status;
+	unsigned short driver_status;
+	int resid; 
+	unsigned int duration;
+	unsigned int info;
+} sg_io_hdr_t;
+
+struct sg_scsi_id {
+	int host_no;
+	int channel;
+	int scsi_id;
+	int lun;
+	int scsi_type;
+	short h_cmd_per_lun;
+	short d_queue_depth;
+	int unused[2];
+};
+
+typedef struct sg_req_info {
+	char req_state;
+	char orphan;
+	char sg_io_owned;
+	char problem;
+	int pack_id;
+	void *usr_ptr;
+	unsigned duration; 
+	int unused; 
+} sg_req_info_t;
+
+typedef struct sg_io_hdr Sg_io_hdr;
+typedef struct sg_io_vec Sg_io_vec;
+typedef struct sg_scsi_id Sg_scsi_id;
+typedef struct sg_req_info Sg_req_info;
+
+struct sg_header {
+	int pack_len;
+	int reply_len;
+	int pack_id;
+	int result;
+	unsigned twelve_byte:1;
+	unsigned target_status:5;
+	unsigned host_status:8;
+	unsigned driver_status:8;
+	unsigned other_flags:10;
+	unsigned char sense_buffer[SG_MAX_SENSE];
+};
+
+#endif
diff --git a/third_party/musl/porting/liteos_m/kernel/include/search.h b/third_party/musl/porting/liteos_m/kernel/include/search.h
new file mode 100755
index 000000000..02e407e3c
--- /dev/null
+++ b/third_party/musl/porting/liteos_m/kernel/include/search.h
@@ -0,0 +1,63 @@
+#ifndef _SEARCH_H
+#define _SEARCH_H
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#include <features.h>
+
+#define __NEED_size_t
+#include <bits/alltypes.h>
+
+typedef enum { FIND, ENTER } ACTION;
+typedef enum { preorder, postorder, endorder, leaf } VISIT;
+
+typedef struct entry {
+	char *key;
+	void *data;
+} ENTRY;
+
+int hcreate(size_t);
+void hdestroy(void);
+ENTRY *hsearch(ENTRY, ACTION);
+
+#ifdef _GNU_SOURCE
+struct hsearch_data {
+	struct __tab *__tab;
+	unsigned int __unused1;
+	unsigned int __unused2;
+};
+
+int hcreate_r(size_t, struct hsearch_data *);
+void hdestroy_r(struct hsearch_data *);
+int hsearch_r(ENTRY, ACTION, ENTRY **, struct hsearch_data *);
+#endif
+
+void insque(void *, void *);
+void remque(void *);
+
+void *lsearch(const void *, void *, size_t *, size_t,
+	int (*)(const void *, const void *));
+void *lfind(const void *, const void *, size_t *, size_t,
+	int (*)(const void *, const void *));
+
+void *tdelete(const void *__restrict, void **__restrict, int(*)(const void *, const void *));
+void *tfind(const void *, void *const *, int(*)(const void *, const void *));
+void *tsearch(const void *, void **, int (*)(const void *, const void *));
+void twalk(const void *, void (*)(const void *, VISIT, int));
+
+#ifdef _GNU_SOURCE
+struct qelem {
+	struct qelem *q_forw, *q_back;
+	char q_data[1];
+};
+
+void tdestroy(void *, void (*)(void *));
+#endif
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
diff --git a/third_party/musl/porting/liteos_m/kernel/include/semaphore.h b/third_party/musl/porting/liteos_m/kernel/include/semaphore.h
new file mode 100755
index 000000000..3690f4960
--- /dev/null
+++ b/third_party/musl/porting/liteos_m/kernel/include/semaphore.h
@@ -0,0 +1,39 @@
+#ifndef _SEMAPHORE_H
+#define _SEMAPHORE_H
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#include <features.h>
+
+#define __NEED_time_t
+#define __NEED_struct_timespec
+#include <bits/alltypes.h>
+
+#include <fcntl.h>
+
+#define SEM_FAILED ((sem_t *)0)
+
+typedef struct {
+	volatile int __val[4*sizeof(long)/sizeof(int)];
+} sem_t;
+
+int    sem_close(sem_t *);
+int    sem_destroy(sem_t *);
+int    sem_getvalue(sem_t *__restrict, int *__restrict);
+int    sem_init(sem_t *, int, unsigned);
+sem_t *sem_open(const char *, int, ...);
+int    sem_post(sem_t *);
+int    sem_timedwait(sem_t *__restrict, const struct timespec *__restrict);
+int    sem_trywait(sem_t *);
+int    sem_unlink(const char *);
+int    sem_wait(sem_t *);
+
+#if _REDIR_TIME64
+__REDIR(sem_timedwait, __sem_timedwait_time64);
+#endif
+
+#ifdef __cplusplus
+}
+#endif
+#endif
diff --git a/third_party/musl/porting/liteos_m/kernel/include/setjmp.h b/third_party/musl/porting/liteos_m/kernel/include/setjmp.h
new file mode 100755
index 000000000..0d22f5f4f
--- /dev/null
+++ b/third_party/musl/porting/liteos_m/kernel/include/setjmp.h
@@ -0,0 +1,46 @@
+#ifndef	_SETJMP_H
+#define	_SETJMP_H
+
+#ifdef __ICCARM__ /* for iar */
+#include_next <setjmp.h>
+#else
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#include <features.h>
+
+#include <bits/setjmp.h>
+
+typedef struct __jmp_buf_tag {
+	__jmp_buf __jb;
+	unsigned long __fl;
+	unsigned long __ss[128/sizeof(long)];
+} jmp_buf[1];
+
+#if defined(_POSIX_SOURCE) || defined(_POSIX_C_SOURCE) \
+ || defined(_XOPEN_SOURCE) || defined(_GNU_SOURCE) \
+ || defined(_BSD_SOURCE)
+typedef jmp_buf sigjmp_buf;
+int sigsetjmp (sigjmp_buf, int);
+_Noreturn void siglongjmp (sigjmp_buf, int);
+#endif
+
+#if defined(_XOPEN_SOURCE) || defined(_GNU_SOURCE) \
+ || defined(_BSD_SOURCE)
+int _setjmp (jmp_buf);
+_Noreturn void _longjmp (jmp_buf, int);
+#endif
+
+int setjmp (jmp_buf);
+_Noreturn void longjmp (jmp_buf, int);
+
+#define setjmp setjmp
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* __ICCARM__ */
+#endif
diff --git a/third_party/musl/porting/liteos_m/kernel/include/shadow.h b/third_party/musl/porting/liteos_m/kernel/include/shadow.h
new file mode 100755
index 000000000..2b1be413f
--- /dev/null
+++ b/third_party/musl/porting/liteos_m/kernel/include/shadow.h
@@ -0,0 +1,44 @@
+#ifndef _SHADOW_H
+#define _SHADOW_H
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#define	__NEED_FILE
+#define __NEED_size_t
+
+#include <bits/alltypes.h>
+
+#define	SHADOW "/etc/shadow"
+
+struct spwd {
+	char *sp_namp;
+	char *sp_pwdp;
+	long sp_lstchg;
+	long sp_min;
+	long sp_max;
+	long sp_warn;
+	long sp_inact;
+	long sp_expire;
+	unsigned long sp_flag;
+};
+
+void setspent(void);
+void endspent(void);
+struct spwd *getspent(void);
+struct spwd *fgetspent(FILE *);
+struct spwd *sgetspent(const char *);
+int putspent(const struct spwd *, FILE *);
+
+struct spwd *getspnam(const char *);
+int getspnam_r(const char *, struct spwd *, char *, size_t, struct spwd **);
+
+int lckpwdf(void);
+int ulckpwdf(void);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
diff --git a/third_party/musl/porting/liteos_m/kernel/include/signal.h b/third_party/musl/porting/liteos_m/kernel/include/signal.h
new file mode 100755
index 000000000..c3848a988
--- /dev/null
+++ b/third_party/musl/porting/liteos_m/kernel/include/signal.h
@@ -0,0 +1,324 @@
+#ifndef _SIGNAL_H
+#define _SIGNAL_H
+
+#ifdef __ICCARM__ /* for iar */
+
+#include_next <signal.h>
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#define __NEED_pthread_attr_t
+#define __NEED_time_t
+
+#include <bits/alltypes.h>
+
+union sigval {
+	int sival_int;
+	void *sival_ptr;
+};
+
+struct sigevent {
+	union sigval sigev_value;
+	int sigev_signo;
+	int sigev_notify;
+	void (*sigev_notify_function)(union sigval);
+	pthread_attr_t *sigev_notify_attributes;
+	char __pad[56-3*sizeof(long)];
+};
+
+#define SIGEV_SIGNAL 0
+#define SIGEV_NONE 1
+#define SIGEV_THREAD 2
+
+#ifdef __cplusplus
+}
+#endif
+
+#else
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#include <features.h>
+
+#if defined(_POSIX_SOURCE) || defined(_POSIX_C_SOURCE) \
+ || defined(_XOPEN_SOURCE) || defined(_GNU_SOURCE) \
+ || defined(_BSD_SOURCE)
+
+#ifdef _GNU_SOURCE
+#define __ucontext ucontext
+#endif
+
+#define __NEED_size_t
+#define __NEED_pid_t
+#define __NEED_uid_t
+#define __NEED_struct_timespec
+#define __NEED_pthread_t
+#define __NEED_pthread_attr_t
+#define __NEED_time_t
+#define __NEED_clock_t
+#define __NEED_sigset_t
+
+#include <bits/alltypes.h>
+
+#define SIG_BLOCK     0
+#define SIG_UNBLOCK   1
+#define SIG_SETMASK   2
+
+#define SI_ASYNCNL (-60)
+#define SI_TKILL (-6)
+#define SI_SIGIO (-5)
+#define SI_ASYNCIO (-4)
+#define SI_MESGQ (-3)
+#define SI_TIMER (-2)
+#define SI_QUEUE (-1)
+#define SI_USER 0
+#define SI_KERNEL 128
+
+typedef struct sigaltstack stack_t;
+
+#endif
+
+#include <bits/signal.h>
+
+#if defined(_POSIX_SOURCE) || defined(_POSIX_C_SOURCE) \
+ || defined(_XOPEN_SOURCE) || defined(_GNU_SOURCE) \
+ || defined(_BSD_SOURCE)
+
+#define SIG_HOLD ((void (*)(int)) 2)
+
+#define FPE_INTDIV 1
+#define FPE_INTOVF 2
+#define FPE_FLTDIV 3
+#define FPE_FLTOVF 4
+#define FPE_FLTUND 5
+#define FPE_FLTRES 6
+#define FPE_FLTINV 7
+#define FPE_FLTSUB 8
+
+#define ILL_ILLOPC 1
+#define ILL_ILLOPN 2
+#define ILL_ILLADR 3
+#define ILL_ILLTRP 4
+#define ILL_PRVOPC 5
+#define ILL_PRVREG 6
+#define ILL_COPROC 7
+#define ILL_BADSTK 8
+
+#define SEGV_MAPERR 1
+#define SEGV_ACCERR 2
+#define SEGV_BNDERR 3
+#define SEGV_PKUERR 4
+
+#define BUS_ADRALN 1
+#define BUS_ADRERR 2
+#define BUS_OBJERR 3
+#define BUS_MCEERR_AR 4
+#define BUS_MCEERR_AO 5
+
+#define CLD_EXITED 1
+#define CLD_KILLED 2
+#define CLD_DUMPED 3
+#define CLD_TRAPPED 4
+#define CLD_STOPPED 5
+#define CLD_CONTINUED 6
+
+union sigval {
+	int sival_int;
+	void *sival_ptr;
+};
+
+typedef struct {
+#ifdef __SI_SWAP_ERRNO_CODE
+	int si_signo, si_code, si_errno;
+#else
+	int si_signo, si_errno, si_code;
+#endif
+	union {
+		char __pad[128 - 2*sizeof(int) - sizeof(long)];
+		struct {
+			union {
+				struct {
+					pid_t si_pid;
+					uid_t si_uid;
+				} __piduid;
+				struct {
+					int si_timerid;
+					int si_overrun;
+				} __timer;
+			} __first;
+			union {
+				union sigval si_value;
+				struct {
+					int si_status;
+					clock_t si_utime, si_stime;
+				} __sigchld;
+			} __second;
+		} __si_common;
+		struct {
+			void *si_addr;
+			short si_addr_lsb;
+			union {
+				struct {
+					void *si_lower;
+					void *si_upper;
+				} __addr_bnd;
+				unsigned si_pkey;
+			} __first;
+		} __sigfault;
+		struct {
+			long si_band;
+			int si_fd;
+		} __sigpoll;
+		struct {
+			void *si_call_addr;
+			int si_syscall;
+			unsigned si_arch;
+		} __sigsys;
+	} __si_fields;
+} siginfo_t;
+#define si_pid     __si_fields.__si_common.__first.__piduid.si_pid
+#define si_uid     __si_fields.__si_common.__first.__piduid.si_uid
+#define si_status  __si_fields.__si_common.__second.__sigchld.si_status
+#define si_utime   __si_fields.__si_common.__second.__sigchld.si_utime
+#define si_stime   __si_fields.__si_common.__second.__sigchld.si_stime
+#define si_value   __si_fields.__si_common.__second.si_value
+#define si_addr    __si_fields.__sigfault.si_addr
+#define si_addr_lsb __si_fields.__sigfault.si_addr_lsb
+#define si_lower   __si_fields.__sigfault.__first.__addr_bnd.si_lower
+#define si_upper   __si_fields.__sigfault.__first.__addr_bnd.si_upper
+#define si_pkey    __si_fields.__sigfault.__first.si_pkey
+#define si_band    __si_fields.__sigpoll.si_band
+#define si_fd      __si_fields.__sigpoll.si_fd
+#define si_timerid __si_fields.__si_common.__first.__timer.si_timerid
+#define si_overrun __si_fields.__si_common.__first.__timer.si_overrun
+#define si_ptr     si_value.sival_ptr
+#define si_int     si_value.sival_int
+#define si_call_addr __si_fields.__sigsys.si_call_addr
+#define si_syscall __si_fields.__sigsys.si_syscall
+#define si_arch    __si_fields.__sigsys.si_arch
+
+struct sigaction {
+	union {
+		void (*sa_handler)(int);
+		void (*sa_sigaction)(int, siginfo_t *, void *);
+	} __sa_handler;
+	sigset_t sa_mask;
+	int sa_flags;
+	void (*sa_restorer)(void);
+};
+#define sa_handler   __sa_handler.sa_handler
+#define sa_sigaction __sa_handler.sa_sigaction
+
+struct sigevent {
+	union sigval sigev_value;
+	int sigev_signo;
+	int sigev_notify;
+	void (*sigev_notify_function)(union sigval);
+	pthread_attr_t *sigev_notify_attributes;
+	char __pad[56-3*sizeof(long)];
+};
+
+#define SIGEV_SIGNAL 0
+#define SIGEV_NONE 1
+#define SIGEV_THREAD 2
+
+int __libc_current_sigrtmin(void);
+int __libc_current_sigrtmax(void);
+
+#define SIGRTMIN  (__libc_current_sigrtmin())
+#define SIGRTMAX  (__libc_current_sigrtmax())
+
+int kill(pid_t, int);
+
+int sigemptyset(sigset_t *);
+int sigfillset(sigset_t *);
+int sigaddset(sigset_t *, int);
+int sigdelset(sigset_t *, int);
+int sigismember(const sigset_t *, int);
+
+int sigprocmask(int, const sigset_t *__restrict, sigset_t *__restrict);
+int sigsuspend(const sigset_t *);
+int sigaction(int, const struct sigaction *__restrict, struct sigaction *__restrict);
+int sigpending(sigset_t *);
+int sigwait(const sigset_t *__restrict, int *__restrict);
+int sigwaitinfo(const sigset_t *__restrict, siginfo_t *__restrict);
+int sigtimedwait(const sigset_t *__restrict, siginfo_t *__restrict, const struct timespec *__restrict);
+int sigqueue(pid_t, int, union sigval);
+
+int pthread_sigmask(int, const sigset_t *__restrict, sigset_t *__restrict);
+int pthread_kill(pthread_t, int);
+
+void psiginfo(const siginfo_t *, const char *);
+void psignal(int, const char *);
+
+#endif
+
+#if defined(_XOPEN_SOURCE) || defined(_BSD_SOURCE) || defined(_GNU_SOURCE)
+int killpg(pid_t, int);
+int sigaltstack(const stack_t *__restrict, stack_t *__restrict);
+int sighold(int);
+int sigignore(int);
+int siginterrupt(int, int);
+int sigpause(int);
+int sigrelse(int);
+void (*sigset(int, void (*)(int)))(int);
+#define TRAP_BRKPT 1
+#define TRAP_TRACE 2
+#define TRAP_BRANCH 3
+#define TRAP_HWBKPT 4
+#define TRAP_UNK 5
+#define POLL_IN 1
+#define POLL_OUT 2
+#define POLL_MSG 3
+#define POLL_ERR 4
+#define POLL_PRI 5
+#define POLL_HUP 6
+#define SS_ONSTACK    1
+#define SS_DISABLE    2
+#define SS_AUTODISARM (1U << 31)
+#define SS_FLAG_BITS SS_AUTODISARM
+#endif
+
+#if defined(_BSD_SOURCE) || defined(_GNU_SOURCE)
+#define NSIG _NSIG
+typedef void (*sig_t)(int);
+#endif
+
+#ifdef _GNU_SOURCE
+typedef void (*sighandler_t)(int);
+void (*bsd_signal(int, void (*)(int)))(int);
+int sigisemptyset(const sigset_t *);
+int sigorset (sigset_t *, const sigset_t *, const sigset_t *);
+int sigandset(sigset_t *, const sigset_t *, const sigset_t *);
+
+#define SA_NOMASK SA_NODEFER
+#define SA_ONESHOT SA_RESETHAND
+#endif
+
+#define SIG_ERR  ((void (*)(int))-1)
+#define SIG_DFL  ((void (*)(int)) 0)
+#define SIG_IGN  ((void (*)(int)) 1)
+
+typedef int sig_atomic_t;
+
+void (*signal(int, void (*)(int)))(int);
+int raise(int);
+
+#if _REDIR_TIME64
+#if defined(_POSIX_SOURCE) || defined(_POSIX_C_SOURCE) \
+ || defined(_XOPEN_SOURCE) || defined(_GNU_SOURCE) \
+ || defined(_BSD_SOURCE)
+__REDIR(sigtimedwait, __sigtimedwait_time64);
+#endif
+#endif
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* __ICCARM__ */
+#endif
diff --git a/third_party/musl/porting/liteos_m/kernel/include/spawn.h b/third_party/musl/porting/liteos_m/kernel/include/spawn.h
new file mode 100755
index 000000000..8eb73e003
--- /dev/null
+++ b/third_party/musl/porting/liteos_m/kernel/include/spawn.h
@@ -0,0 +1,83 @@
+#ifndef _SPAWN_H
+#define _SPAWN_H
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#include <features.h>
+
+#define __NEED_mode_t
+#define __NEED_pid_t
+#define __NEED_sigset_t
+
+#include <bits/alltypes.h>
+
+struct sched_param;
+
+#define POSIX_SPAWN_RESETIDS 1
+#define POSIX_SPAWN_SETPGROUP 2
+#define POSIX_SPAWN_SETSIGDEF 4
+#define POSIX_SPAWN_SETSIGMASK 8
+#define POSIX_SPAWN_SETSCHEDPARAM 16
+#define POSIX_SPAWN_SETSCHEDULER 32
+#define POSIX_SPAWN_USEVFORK 64
+#define POSIX_SPAWN_SETSID 128
+
+typedef struct {
+	int __flags;
+	pid_t __pgrp;
+	sigset_t __def, __mask;
+	int __prio, __pol;
+	void *__fn;
+	char __pad[64-sizeof(void *)];
+} posix_spawnattr_t;
+
+typedef struct {
+	int __pad0[2];
+	void *__actions;
+	int __pad[16];
+} posix_spawn_file_actions_t;
+
+int posix_spawn(pid_t *__restrict, const char *__restrict, const posix_spawn_file_actions_t *,
+	const posix_spawnattr_t *__restrict, char *const *__restrict, char *const *__restrict);
+int posix_spawnp(pid_t *__restrict, const char *__restrict, const posix_spawn_file_actions_t *,
+	const posix_spawnattr_t *__restrict, char *const *__restrict, char *const *__restrict);
+
+int posix_spawnattr_init(posix_spawnattr_t *);
+int posix_spawnattr_destroy(posix_spawnattr_t *);
+
+int posix_spawnattr_setflags(posix_spawnattr_t *, short);
+int posix_spawnattr_getflags(const posix_spawnattr_t *__restrict, short *__restrict);
+
+int posix_spawnattr_setpgroup(posix_spawnattr_t *, pid_t);
+int posix_spawnattr_getpgroup(const posix_spawnattr_t *__restrict, pid_t *__restrict);
+
+int posix_spawnattr_setsigmask(posix_spawnattr_t *__restrict, const sigset_t *__restrict);
+int posix_spawnattr_getsigmask(const posix_spawnattr_t *__restrict, sigset_t *__restrict);
+
+int posix_spawnattr_setsigdefault(posix_spawnattr_t *__restrict, const sigset_t *__restrict);
+int posix_spawnattr_getsigdefault(const posix_spawnattr_t *__restrict, sigset_t *__restrict);
+
+int posix_spawnattr_setschedparam(posix_spawnattr_t *__restrict, const struct sched_param *__restrict);
+int posix_spawnattr_getschedparam(const posix_spawnattr_t *__restrict, struct sched_param *__restrict);
+int posix_spawnattr_setschedpolicy(posix_spawnattr_t *, int);
+int posix_spawnattr_getschedpolicy(const posix_spawnattr_t *__restrict, int *__restrict);
+
+int posix_spawn_file_actions_init(posix_spawn_file_actions_t *);
+int posix_spawn_file_actions_destroy(posix_spawn_file_actions_t *);
+
+int posix_spawn_file_actions_addopen(posix_spawn_file_actions_t *__restrict, int, const char *__restrict, int, mode_t);
+int posix_spawn_file_actions_addclose(posix_spawn_file_actions_t *, int);
+int posix_spawn_file_actions_adddup2(posix_spawn_file_actions_t *, int, int);
+
+#if defined(_BSD_SOURCE) || defined(_GNU_SOURCE)
+int posix_spawn_file_actions_addchdir_np(posix_spawn_file_actions_t *__restrict, const char *__restrict);
+int posix_spawn_file_actions_addfchdir_np(posix_spawn_file_actions_t *, int);
+#endif
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
diff --git a/third_party/musl/porting/liteos_m/kernel/include/stdalign.h b/third_party/musl/porting/liteos_m/kernel/include/stdalign.h
new file mode 100755
index 000000000..428e85338
--- /dev/null
+++ b/third_party/musl/porting/liteos_m/kernel/include/stdalign.h
@@ -0,0 +1,25 @@
+#ifndef _STDALIGN_H
+#define _STDALIGN_H
+
+#ifdef __ICCARM__ /* for iar */
+#include_next <stdalign.h>
+#else
+
+#ifndef __cplusplus
+
+/* this whole header only works in C11 or with compiler extensions */
+#if __STDC_VERSION__ < 201112L && defined( __GNUC__)
+#define _Alignas(t) __attribute__((__aligned__(t)))
+#define _Alignof(t) __alignof__(t)
+#endif
+
+#define alignas _Alignas
+#define alignof _Alignof
+
+#endif
+
+#define __alignas_is_defined 1
+#define __alignof_is_defined 1
+
+#endif /* __ICCARM__ */
+#endif
diff --git a/third_party/musl/porting/liteos_m/kernel/include/stdarg.h b/third_party/musl/porting/liteos_m/kernel/include/stdarg.h
new file mode 100755
index 000000000..e29626680
--- /dev/null
+++ b/third_party/musl/porting/liteos_m/kernel/include/stdarg.h
@@ -0,0 +1,26 @@
+#ifndef _STDARG_H
+#define _STDARG_H
+
+#ifdef __ICCARM__ /* for iar */
+#include_next <stdarg.h>
+#else
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#define __NEED_va_list
+
+#include <bits/alltypes.h>
+
+#define va_start(v,l)   __builtin_va_start(v,l)
+#define va_end(v)       __builtin_va_end(v)
+#define va_arg(v,l)     __builtin_va_arg(v,l)
+#define va_copy(d,s)    __builtin_va_copy(d,s)
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* __ICCARM__ */
+#endif
diff --git a/third_party/musl/porting/liteos_m/kernel/include/stdbool.h b/third_party/musl/porting/liteos_m/kernel/include/stdbool.h
new file mode 100755
index 000000000..cc849df46
--- /dev/null
+++ b/third_party/musl/porting/liteos_m/kernel/include/stdbool.h
@@ -0,0 +1,19 @@
+#ifndef _STDBOOL_H
+#define _STDBOOL_H
+
+#ifdef __ICCARM__ /* for iar */
+#include_next <stdbool.h>
+#else
+
+#ifndef __cplusplus
+
+#define true 1
+#define false 0
+#define bool _Bool
+
+#endif
+
+#define __bool_true_false_are_defined 1
+
+#endif /* __ICCARM__ */
+#endif
diff --git a/third_party/musl/porting/liteos_m/kernel/include/stdc-predef.h b/third_party/musl/porting/liteos_m/kernel/include/stdc-predef.h
new file mode 100755
index 000000000..f8cd4b891
--- /dev/null
+++ b/third_party/musl/porting/liteos_m/kernel/include/stdc-predef.h
@@ -0,0 +1,10 @@
+#ifndef _STDC_PREDEF_H
+#define _STDC_PREDEF_H
+
+#define __STDC_ISO_10646__ 201206L
+
+#if !defined(__GCC_IEC_559) || __GCC_IEC_559 > 0
+#define __STDC_IEC_559__ 1
+#endif
+
+#endif
diff --git a/third_party/musl/porting/liteos_m/kernel/include/stddef.h b/third_party/musl/porting/liteos_m/kernel/include/stddef.h
new file mode 100755
index 000000000..27b5a9ad7
--- /dev/null
+++ b/third_party/musl/porting/liteos_m/kernel/include/stddef.h
@@ -0,0 +1,30 @@
+#ifndef _STDDEF_H
+#define _STDDEF_H
+
+#ifdef __ICCARM__ /* for iar */
+#include_next <stddef.h>
+#else
+
+#ifdef __cplusplus
+#define NULL 0L
+#else
+#define NULL ((void*)0)
+#endif
+
+#define __NEED_ptrdiff_t
+#define __NEED_size_t
+#define __NEED_wchar_t
+#if __STDC_VERSION__ >= 201112L || __cplusplus >= 201103L
+#define __NEED_max_align_t
+#endif
+
+#include <bits/alltypes.h>
+
+#if __GNUC__ > 3
+#define offsetof(type, member) __builtin_offsetof(type, member)
+#else
+#define offsetof(type, member) ((size_t)( (char *)&(((type *)0)->member) - (char *)0 ))
+#endif
+
+#endif /* __ICCARM__ */
+#endif
diff --git a/third_party/musl/porting/liteos_m/kernel/include/stdint.h b/third_party/musl/porting/liteos_m/kernel/include/stdint.h
new file mode 100755
index 000000000..7f8bdd37d
--- /dev/null
+++ b/third_party/musl/porting/liteos_m/kernel/include/stdint.h
@@ -0,0 +1,122 @@
+#ifndef _STDINT_H
+#define _STDINT_H
+
+#ifdef __ICCARM__ /* for iar */
+#include_next <stdint.h>
+#else
+
+#define __NEED_int8_t
+#define __NEED_int16_t
+#define __NEED_int32_t
+#define __NEED_int64_t
+
+#define __NEED_uint8_t
+#define __NEED_uint16_t
+#define __NEED_uint32_t
+#define __NEED_uint64_t
+
+#define __NEED_intptr_t
+#define __NEED_uintptr_t
+
+#define __NEED_intmax_t
+#define __NEED_uintmax_t
+
+#include <bits/alltypes.h>
+
+typedef int8_t int_fast8_t;
+typedef int64_t int_fast64_t;
+
+typedef int8_t  int_least8_t;
+typedef int16_t int_least16_t;
+typedef int32_t int_least32_t;
+typedef int64_t int_least64_t;
+
+typedef uint8_t uint_fast8_t;
+typedef uint64_t uint_fast64_t;
+
+typedef uint8_t  uint_least8_t;
+typedef uint16_t uint_least16_t;
+typedef uint32_t uint_least32_t;
+typedef uint64_t uint_least64_t;
+
+#define INT8_MIN   (-1-0x7f)
+#define INT16_MIN  (-1-0x7fff)
+#define INT32_MIN  (-1-0x7fffffff)
+#define INT64_MIN  (-1-0x7fffffffffffffff)
+
+#define INT8_MAX   (0x7f)
+#define INT16_MAX  (0x7fff)
+#define INT32_MAX  (0x7fffffff)
+#define INT64_MAX  (0x7fffffffffffffff)
+
+#define UINT8_MAX  (0xff)
+#define UINT16_MAX (0xffff)
+#define UINT32_MAX (0xffffffffu)
+#define UINT64_MAX (0xffffffffffffffffu)
+
+#define INT_FAST8_MIN   INT8_MIN
+#define INT_FAST64_MIN  INT64_MIN
+
+#define INT_LEAST8_MIN   INT8_MIN
+#define INT_LEAST16_MIN  INT16_MIN
+#define INT_LEAST32_MIN  INT32_MIN
+#define INT_LEAST64_MIN  INT64_MIN
+
+#define INT_FAST8_MAX   INT8_MAX
+#define INT_FAST64_MAX  INT64_MAX
+
+#define INT_LEAST8_MAX   INT8_MAX
+#define INT_LEAST16_MAX  INT16_MAX
+#define INT_LEAST32_MAX  INT32_MAX
+#define INT_LEAST64_MAX  INT64_MAX
+
+#define UINT_FAST8_MAX  UINT8_MAX
+#define UINT_FAST64_MAX UINT64_MAX
+
+#define UINT_LEAST8_MAX  UINT8_MAX
+#define UINT_LEAST16_MAX UINT16_MAX
+#define UINT_LEAST32_MAX UINT32_MAX
+#define UINT_LEAST64_MAX UINT64_MAX
+
+#define INTMAX_MIN  INT64_MIN
+#define INTMAX_MAX  INT64_MAX
+#define UINTMAX_MAX UINT64_MAX
+
+#define WINT_MIN 0U
+#define WINT_MAX UINT32_MAX
+
+#if L'\0'-1 > 0
+#define WCHAR_MAX (0xffffffffu+L'\0')
+#define WCHAR_MIN (0+L'\0')
+#else
+#define WCHAR_MAX (0x7fffffff+L'\0')
+#define WCHAR_MIN (-1-0x7fffffff+L'\0')
+#endif
+
+#define SIG_ATOMIC_MIN  INT32_MIN
+#define SIG_ATOMIC_MAX  INT32_MAX
+
+#include <bits/stdint.h>
+
+#define INT8_C(c)  c
+#define INT16_C(c) c
+#define INT32_C(c) c
+
+#define UINT8_C(c)  c
+#define UINT16_C(c) c
+#define UINT32_C(c) c ## U
+
+#if UINTPTR_MAX == UINT64_MAX
+#define INT64_C(c) c ## L
+#define UINT64_C(c) c ## UL
+#define INTMAX_C(c)  c ## L
+#define UINTMAX_C(c) c ## UL
+#else
+#define INT64_C(c) c ## LL
+#define UINT64_C(c) c ## ULL
+#define INTMAX_C(c)  c ## LL
+#define UINTMAX_C(c) c ## ULL
+#endif
+
+#endif /* __ICCARM__ */
+#endif
diff --git a/third_party/musl/porting/liteos_m/kernel/include/stdio.h b/third_party/musl/porting/liteos_m/kernel/include/stdio.h
new file mode 100755
index 000000000..fb5539ff5
--- /dev/null
+++ b/third_party/musl/porting/liteos_m/kernel/include/stdio.h
@@ -0,0 +1,228 @@
+#ifndef _STDIO_H
+#define _STDIO_H
+
+#ifdef __ICCARM__ /* for iar */
+#include_next <stdio.h>
+int rename(const char *, const char *);
+#else
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#include <features.h>
+
+#define __NEED_FILE
+#define __NEED___isoc_va_list
+#define __NEED_size_t
+
+#if __STDC_VERSION__ < 201112L
+#define __NEED_struct__IO_FILE
+#endif
+
+#if defined(_POSIX_SOURCE) || defined(_POSIX_C_SOURCE) \
+ || defined(_XOPEN_SOURCE) || defined(_GNU_SOURCE) \
+ || defined(_BSD_SOURCE)
+#define __NEED_ssize_t
+#define __NEED_off_t
+#define __NEED_va_list
+#endif
+
+#include <bits/alltypes.h>
+
+#ifdef __cplusplus
+#define NULL 0L
+#else
+#define NULL ((void*)0)
+#endif
+
+#undef EOF
+#define EOF (-1)
+
+#undef SEEK_SET
+#undef SEEK_CUR
+#undef SEEK_END
+#define SEEK_SET 0
+#define SEEK_CUR 1
+#define SEEK_END 2
+
+#define _IOFBF 0
+#define _IOLBF 1
+#define _IONBF 2
+
+#define BUFSIZ 1024
+#define FILENAME_MAX 4096
+#define FOPEN_MAX 1000
+#define TMP_MAX 10000
+#define L_tmpnam 20
+
+typedef union _G_fpos64_t {
+	char __opaque[16];
+	long long __lldata;
+	double __align;
+} fpos_t;
+
+extern FILE *const stdin;
+extern FILE *const stdout;
+extern FILE *const stderr;
+
+#define stdin  (stdin)
+#define stdout (stdout)
+#define stderr (stderr)
+
+FILE *fopen(const char *__restrict, const char *__restrict);
+FILE *freopen(const char *__restrict, const char *__restrict, FILE *__restrict);
+int fclose(FILE *);
+
+int remove(const char *);
+int rename(const char *, const char *);
+
+int feof(FILE *);
+int ferror(FILE *);
+int fflush(FILE *);
+void clearerr(FILE *);
+
+int fseek(FILE *, long, int);
+long ftell(FILE *);
+void rewind(FILE *);
+
+int fgetpos(FILE *__restrict, fpos_t *__restrict);
+int fsetpos(FILE *, const fpos_t *);
+
+size_t fread(void *__restrict, size_t, size_t, FILE *__restrict);
+size_t fwrite(const void *__restrict, size_t, size_t, FILE *__restrict);
+
+int fgetc(FILE *);
+int getc(FILE *);
+int getchar(void);
+int ungetc(int, FILE *);
+
+int fputc(int, FILE *);
+int putc(int, FILE *);
+int putchar(int);
+
+char *fgets(char *__restrict, int, FILE *__restrict);
+#if __STDC_VERSION__ < 201112L
+char *gets(char *);
+#endif
+
+int fputs(const char *__restrict, FILE *__restrict);
+int puts(const char *);
+
+int printf(const char *__restrict, ...);
+int fprintf(FILE *__restrict, const char *__restrict, ...);
+int sprintf(char *__restrict, const char *__restrict, ...);
+int snprintf(char *__restrict, size_t, const char *__restrict, ...);
+
+int vprintf(const char *__restrict, __isoc_va_list);
+int vfprintf(FILE *__restrict, const char *__restrict, __isoc_va_list);
+int vsprintf(char *__restrict, const char *__restrict, __isoc_va_list);
+int vsnprintf(char *__restrict, size_t, const char *__restrict, __isoc_va_list);
+
+int scanf(const char *__restrict, ...);
+int fscanf(FILE *__restrict, const char *__restrict, ...);
+int sscanf(const char *__restrict, const char *__restrict, ...);
+int vscanf(const char *__restrict, __isoc_va_list);
+int vfscanf(FILE *__restrict, const char *__restrict, __isoc_va_list);
+int vsscanf(const char *__restrict, const char *__restrict, __isoc_va_list);
+
+void perror(const char *);
+
+int setvbuf(FILE *__restrict, char *__restrict, int, size_t);
+void setbuf(FILE *__restrict, char *__restrict);
+
+char *tmpnam(char *);
+FILE *tmpfile(void);
+
+#if defined(_POSIX_SOURCE) || defined(_POSIX_C_SOURCE) \
+ || defined(_XOPEN_SOURCE) || defined(_GNU_SOURCE) \
+ || defined(_BSD_SOURCE)
+FILE *fmemopen(void *__restrict, size_t, const char *__restrict);
+FILE *open_memstream(char **, size_t *);
+FILE *fdopen(int, const char *);
+FILE *popen(const char *, const char *);
+int pclose(FILE *);
+int fileno(FILE *);
+int fseeko(FILE *, off_t, int);
+off_t ftello(FILE *);
+int dprintf(int, const char *__restrict, ...);
+int vdprintf(int, const char *__restrict, __isoc_va_list);
+void flockfile(FILE *);
+int ftrylockfile(FILE *);
+void funlockfile(FILE *);
+int getc_unlocked(FILE *);
+int getchar_unlocked(void);
+int putc_unlocked(int, FILE *);
+int putchar_unlocked(int);
+ssize_t getdelim(char **__restrict, size_t *__restrict, int, FILE *__restrict);
+ssize_t getline(char **__restrict, size_t *__restrict, FILE *__restrict);
+int renameat(int, const char *, int, const char *);
+char *ctermid(char *);
+#define L_ctermid 20
+#endif
+
+
+#if defined(_XOPEN_SOURCE) || defined(_GNU_SOURCE) \
+ || defined(_BSD_SOURCE)
+#define P_tmpdir "/tmp"
+char *tempnam(const char *, const char *);
+#endif
+
+#if defined(_GNU_SOURCE) || defined(_BSD_SOURCE)
+#define L_cuserid 20
+char *cuserid(char *);
+void setlinebuf(FILE *);
+void setbuffer(FILE *, char *, size_t);
+int fgetc_unlocked(FILE *);
+int fputc_unlocked(int, FILE *);
+int fflush_unlocked(FILE *);
+size_t fread_unlocked(void *, size_t, size_t, FILE *);
+size_t fwrite_unlocked(const void *, size_t, size_t, FILE *);
+void clearerr_unlocked(FILE *);
+int feof_unlocked(FILE *);
+int ferror_unlocked(FILE *);
+int fileno_unlocked(FILE *);
+int getw(FILE *);
+int putw(int, FILE *);
+char *fgetln(FILE *, size_t *);
+int asprintf(char **, const char *, ...);
+int vasprintf(char **, const char *, __isoc_va_list);
+#endif
+
+#ifdef _GNU_SOURCE
+char *fgets_unlocked(char *, int, FILE *);
+int fputs_unlocked(const char *, FILE *);
+
+typedef ssize_t (cookie_read_function_t)(void *, char *, size_t);
+typedef ssize_t (cookie_write_function_t)(void *, const char *, size_t);
+typedef int (cookie_seek_function_t)(void *, off_t *, int);
+typedef int (cookie_close_function_t)(void *);
+
+typedef struct _IO_cookie_io_functions_t {
+	cookie_read_function_t *read;
+	cookie_write_function_t *write;
+	cookie_seek_function_t *seek;
+	cookie_close_function_t *close;
+} cookie_io_functions_t;
+
+FILE *fopencookie(void *, const char *, cookie_io_functions_t);
+#endif
+
+#if defined(_LARGEFILE64_SOURCE) || defined(_GNU_SOURCE)
+#define tmpfile64 tmpfile
+#define fopen64 fopen
+#define freopen64 freopen
+#define fseeko64 fseeko
+#define ftello64 ftello
+#define fgetpos64 fgetpos
+#define fsetpos64 fsetpos
+#define fpos64_t fpos_t
+#define off64_t off_t
+#endif
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* __ICCARM__ */
+#endif
diff --git a/third_party/musl/porting/liteos_m/kernel/include/stdio_ext.h b/third_party/musl/porting/liteos_m/kernel/include/stdio_ext.h
new file mode 100755
index 000000000..e3ab7fd4f
--- /dev/null
+++ b/third_party/musl/porting/liteos_m/kernel/include/stdio_ext.h
@@ -0,0 +1,34 @@
+#ifndef _STDIO_EXT_H
+#define _STDIO_EXT_H
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#include <stdio.h>
+
+#define FSETLOCKING_QUERY 0
+#define FSETLOCKING_INTERNAL 1
+#define FSETLOCKING_BYCALLER 2
+
+void _flushlbf(void);
+int __fsetlocking(FILE *, int);
+int __fwriting(FILE *);
+int __freading(FILE *);
+int __freadable(FILE *);
+int __fwritable(FILE *);
+int __flbf(FILE *);
+size_t __fbufsize(FILE *);
+size_t __fpending(FILE *);
+int __fpurge(FILE *);
+
+size_t __freadahead(FILE *);
+const char *__freadptr(FILE *, size_t *);
+void __freadptrinc(FILE *, size_t);
+void __fseterr(FILE *);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
diff --git a/third_party/musl/porting/liteos_m/kernel/include/stdlib.h b/third_party/musl/porting/liteos_m/kernel/include/stdlib.h
new file mode 100755
index 000000000..9c9b76cab
--- /dev/null
+++ b/third_party/musl/porting/liteos_m/kernel/include/stdlib.h
@@ -0,0 +1,182 @@
+#ifndef _STDLIB_H
+#define _STDLIB_H
+
+#ifdef __ICCARM__ /* for iar */
+#include_next <stdlib.h>
+#else
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#include <features.h>
+
+#ifdef __cplusplus
+#define NULL 0L
+#else
+#define NULL ((void*)0)
+#endif
+
+#define __NEED_size_t
+#define __NEED_wchar_t
+
+#include <bits/alltypes.h>
+
+int atoi (const char *);
+long atol (const char *);
+long long atoll (const char *);
+double atof (const char *);
+
+float strtof (const char *__restrict, char **__restrict);
+double strtod (const char *__restrict, char **__restrict);
+long double strtold (const char *__restrict, char **__restrict);
+
+long strtol (const char *__restrict, char **__restrict, int);
+unsigned long strtoul (const char *__restrict, char **__restrict, int);
+long long strtoll (const char *__restrict, char **__restrict, int);
+unsigned long long strtoull (const char *__restrict, char **__restrict, int);
+
+int rand (void);
+void srand (unsigned);
+
+void *malloc (size_t);
+void *calloc (size_t, size_t);
+void *realloc (void *, size_t);
+void free (void *);
+void *aligned_alloc(size_t, size_t);
+
+_Noreturn void abort (void);
+int atexit (void (*) (void));
+_Noreturn void exit (int);
+_Noreturn void _Exit (int);
+int at_quick_exit (void (*) (void));
+_Noreturn void quick_exit (int);
+
+char *getenv (const char *);
+
+int system (const char *);
+
+void *bsearch (const void *, const void *, size_t, size_t, int (*)(const void *, const void *));
+void qsort (void *, size_t, size_t, int (*)(const void *, const void *));
+
+int abs (int);
+long labs (long);
+long long llabs (long long);
+
+#ifndef ARM_NONE_EABI
+typedef struct { int quot, rem; } div_t;
+typedef struct { long quot, rem; } ldiv_t;
+typedef struct { long long quot, rem; } lldiv_t;
+
+div_t div (int, int);
+ldiv_t ldiv (long, long);
+lldiv_t lldiv (long long, long long);
+#endif
+
+int mblen (const char *, size_t);
+int mbtowc (wchar_t *__restrict, const char *__restrict, size_t);
+int wctomb (char *, wchar_t);
+size_t mbstowcs (wchar_t *__restrict, const char *__restrict, size_t);
+size_t wcstombs (char *__restrict, const wchar_t *__restrict, size_t);
+
+#define EXIT_FAILURE 1
+#define EXIT_SUCCESS 0
+
+size_t __ctype_get_mb_cur_max(void);
+#define MB_CUR_MAX (__ctype_get_mb_cur_max())
+
+#define RAND_MAX (0x7fffffff)
+
+
+#if defined(_POSIX_SOURCE) || defined(_POSIX_C_SOURCE) \
+ || defined(_XOPEN_SOURCE) || defined(_GNU_SOURCE) \
+ || defined(_BSD_SOURCE)
+
+#define WNOHANG    1
+#define WUNTRACED  2
+
+#define WEXITSTATUS(s) (((s) & 0xff00) >> 8)
+#define WTERMSIG(s) ((s) & 0x7f)
+#define WSTOPSIG(s) WEXITSTATUS(s)
+#define WIFEXITED(s) (!WTERMSIG(s))
+#define WIFSTOPPED(s) ((short)((((s)&0xffff)*0x10001)>>8) > 0x7f00)
+#define WIFSIGNALED(s) (((s)&0xffff)-1U < 0xffu)
+
+int posix_memalign (void **, size_t, size_t);
+int setenv (const char *, const char *, int);
+int unsetenv (const char *);
+int mkstemp (char *);
+int mkostemp (char *, int);
+char *mkdtemp (char *);
+int getsubopt (char **, char *const *, char **);
+int rand_r (unsigned *);
+
+#endif
+
+
+#if defined(_XOPEN_SOURCE) || defined(_GNU_SOURCE) \
+ || defined(_BSD_SOURCE)
+char *realpath (const char *__restrict, char *__restrict);
+long int random (void);
+void srandom (unsigned int);
+char *initstate (unsigned int, char *, size_t);
+char *setstate (char *);
+int putenv (char *);
+int posix_openpt (int);
+int grantpt (int);
+int unlockpt (int);
+char *ptsname (int);
+char *l64a (long);
+long a64l (const char *);
+void setkey (const char *);
+double drand48 (void);
+double erand48 (unsigned short [3]);
+long int lrand48 (void);
+long int nrand48 (unsigned short [3]);
+long mrand48 (void);
+long jrand48 (unsigned short [3]);
+void srand48 (long);
+unsigned short *seed48 (unsigned short [3]);
+void lcong48 (unsigned short [7]);
+#endif
+
+#if defined(_GNU_SOURCE) || defined(_BSD_SOURCE)
+#include <alloca.h>
+char *mktemp (char *);
+int mkstemps (char *, int);
+int mkostemps (char *, int, int);
+void *valloc (size_t);
+void *memalign(size_t, size_t);
+int getloadavg(double *, int);
+int clearenv(void);
+#define WCOREDUMP(s) ((s) & 0x80)
+#define WIFCONTINUED(s) ((s) == 0xffff)
+#endif
+
+#ifdef _GNU_SOURCE
+int ptsname_r(int, char *, size_t);
+char *ecvt(double, int, int *, int *);
+char *fcvt(double, int, int *, int *);
+char *gcvt(double, int, char *);
+char *secure_getenv(const char *);
+struct __locale_struct;
+float strtof_l(const char *__restrict, char **__restrict, struct __locale_struct *);
+double strtod_l(const char *__restrict, char **__restrict, struct __locale_struct *);
+long double strtold_l(const char *__restrict, char **__restrict, struct __locale_struct *);
+#endif
+
+#if defined(_LARGEFILE64_SOURCE) || defined(_GNU_SOURCE)
+#define mkstemp64 mkstemp
+#define mkostemp64 mkostemp
+#if defined(_GNU_SOURCE) || defined(_BSD_SOURCE)
+#define mkstemps64 mkstemps
+#define mkostemps64 mkostemps
+#endif
+#endif
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* __ICCARM__ */
+#endif
diff --git a/third_party/musl/porting/liteos_m/kernel/include/stdnoreturn.h b/third_party/musl/porting/liteos_m/kernel/include/stdnoreturn.h
new file mode 100755
index 000000000..8fc256bf0
--- /dev/null
+++ b/third_party/musl/porting/liteos_m/kernel/include/stdnoreturn.h
@@ -0,0 +1,14 @@
+#ifndef _STDNORETURN_H
+#define _STDNORETURN_H
+
+#ifdef __ICCARM__ /* for iar */
+#include_next <stdnoreturn.h>
+#else
+
+#ifndef __cplusplus
+#include <features.h>
+#define noreturn _Noreturn
+#endif
+
+#endif /* __ICCARM__ */
+#endif
diff --git a/third_party/musl/porting/liteos_m/kernel/include/string.h b/third_party/musl/porting/liteos_m/kernel/include/string.h
new file mode 100755
index 000000000..56b204f6a
--- /dev/null
+++ b/third_party/musl/porting/liteos_m/kernel/include/string.h
@@ -0,0 +1,110 @@
+#ifndef	_STRING_H
+#define	_STRING_H
+
+#ifdef __ICCARM__ /* for iar */
+#include_next <string.h>
+#else
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#include <features.h>
+
+#ifdef __cplusplus
+#define NULL 0L
+#else
+#define NULL ((void*)0)
+#endif
+
+#define __NEED_size_t
+#if defined(_POSIX_SOURCE) || defined(_POSIX_C_SOURCE) \
+ || defined(_XOPEN_SOURCE) || defined(_GNU_SOURCE) \
+ || defined(_BSD_SOURCE)
+#define __NEED_locale_t
+#endif
+
+#include <bits/alltypes.h>
+
+void *memcpy (void *__restrict, const void *__restrict, size_t);
+void *memmove (void *, const void *, size_t);
+void *memset (void *, int, size_t);
+int memcmp (const void *, const void *, size_t);
+void *memchr (const void *, int, size_t);
+
+char *strcpy (char *__restrict, const char *__restrict);
+char *strncpy (char *__restrict, const char *__restrict, size_t);
+
+char *strcat (char *__restrict, const char *__restrict);
+char *strncat (char *__restrict, const char *__restrict, size_t);
+
+int strcmp (const char *, const char *);
+int strncmp (const char *, const char *, size_t);
+
+int strcoll (const char *, const char *);
+size_t strxfrm (char *__restrict, const char *__restrict, size_t);
+
+char *strchr (const char *, int);
+char *strrchr (const char *, int);
+
+size_t strcspn (const char *, const char *);
+size_t strspn (const char *, const char *);
+char *strpbrk (const char *, const char *);
+char *strstr (const char *, const char *);
+char *strtok (char *__restrict, const char *__restrict);
+
+size_t strlen (const char *);
+
+char *strerror (int);
+
+#if defined(_BSD_SOURCE) || defined(_GNU_SOURCE)
+#include <strings.h>
+#endif
+
+#if defined(_POSIX_SOURCE) || defined(_POSIX_C_SOURCE) \
+ || defined(_XOPEN_SOURCE) || defined(_GNU_SOURCE) \
+ || defined(_BSD_SOURCE)
+char *strtok_r (char *__restrict, const char *__restrict, char **__restrict);
+int strerror_r (int, char *, size_t);
+char *stpcpy(char *__restrict, const char *__restrict);
+char *stpncpy(char *__restrict, const char *__restrict, size_t);
+size_t strnlen (const char *, size_t);
+char *strdup (const char *);
+char *strndup (const char *, size_t);
+char *strsignal(int);
+char *strerror_l (int, locale_t);
+int strcoll_l (const char *, const char *, locale_t);
+size_t strxfrm_l (char *__restrict, const char *__restrict, size_t, locale_t);
+#endif
+
+#if defined(_XOPEN_SOURCE) || defined(_GNU_SOURCE) \
+ || defined(_BSD_SOURCE)
+void *memccpy (void *__restrict, const void *__restrict, int, size_t);
+#endif
+
+#if defined(_GNU_SOURCE) || defined(_BSD_SOURCE)
+char *strsep(char **, const char *);
+size_t strlcat (char *, const char *, size_t);
+size_t strlcpy (char *, const char *, size_t);
+void explicit_bzero (void *, size_t);
+#endif
+
+#ifdef _GNU_SOURCE
+#define	strdupa(x)	strcpy(alloca(strlen(x)+1),x)
+int strverscmp (const char *, const char *);
+char *strchrnul(const char *, int);
+char *strcasestr(const char *, const char *);
+void *memmem(const void *, size_t, const void *, size_t);
+void *memrchr(const void *, int, size_t);
+void *mempcpy(void *, const void *, size_t);
+#ifndef __cplusplus
+char *basename();
+#endif
+#endif
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* __ICCARM__ */
+#endif
\ No newline at end of file
diff --git a/third_party/musl/porting/liteos_m/kernel/include/strings.h b/third_party/musl/porting/liteos_m/kernel/include/strings.h
new file mode 100755
index 000000000..db0960b4e
--- /dev/null
+++ b/third_party/musl/porting/liteos_m/kernel/include/strings.h
@@ -0,0 +1,39 @@
+#ifndef	_STRINGS_H
+#define	_STRINGS_H
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+
+#define __NEED_size_t
+#define __NEED_locale_t
+#include <bits/alltypes.h>
+
+#if defined(_GNU_SOURCE) || defined(_BSD_SOURCE) || defined(_POSIX_SOURCE) \
+ || (defined(_POSIX_C_SOURCE) && _POSIX_C_SOURCE+0 < 200809L) \
+ || (defined(_XOPEN_SOURCE) && _XOPEN_SOURCE+0 < 700)
+int bcmp (const void *, const void *, size_t);
+void bcopy (const void *, void *, size_t);
+void bzero (void *, size_t);
+char *index (const char *, int);
+char *rindex (const char *, int);
+#endif
+
+#if defined(_XOPEN_SOURCE) || defined(_GNU_SOURCE)  || defined(_BSD_SOURCE)
+int ffs (int);
+int ffsl (long);
+int ffsll (long long);
+#endif
+
+int strcasecmp (const char *, const char *);
+int strncasecmp (const char *, const char *, size_t);
+
+int strcasecmp_l (const char *, const char *, locale_t);
+int strncasecmp_l (const char *, const char *, size_t, locale_t);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
diff --git a/third_party/musl/porting/liteos_m/kernel/include/stropts.h b/third_party/musl/porting/liteos_m/kernel/include/stropts.h
new file mode 100755
index 000000000..c99c922e3
--- /dev/null
+++ b/third_party/musl/porting/liteos_m/kernel/include/stropts.h
@@ -0,0 +1,139 @@
+#ifndef _STROPTS_H
+#define _STROPTS_H
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#define __SID		('S' << 8)
+
+#define I_NREAD		(__SID | 1)
+#define I_PUSH		(__SID | 2)
+#define I_POP		(__SID | 3)
+#define I_LOOK		(__SID | 4)
+#define I_FLUSH		(__SID | 5)
+#define I_SRDOPT	(__SID | 6)
+#define I_GRDOPT	(__SID | 7)
+#define I_STR		(__SID | 8)
+#define I_SETSIG	(__SID | 9)
+#define I_GETSIG	(__SID |10)
+#define I_FIND		(__SID |11)
+#define I_LINK		(__SID |12)
+#define I_UNLINK	(__SID |13)
+#define I_PEEK		(__SID |15)
+#define I_FDINSERT	(__SID |16)
+#define I_SENDFD	(__SID |17)
+#define I_RECVFD	(__SID |14)
+#define I_SWROPT	(__SID |19)
+#define I_GWROPT	(__SID |20)
+#define I_LIST		(__SID |21)
+#define I_PLINK		(__SID |22)
+#define I_PUNLINK	(__SID |23)
+#define I_FLUSHBAND	(__SID |28)
+#define I_CKBAND	(__SID |29)
+#define I_GETBAND	(__SID |30)
+#define I_ATMARK	(__SID |31)
+#define I_SETCLTIME	(__SID |32)
+#define I_GETCLTIME	(__SID |33)
+#define I_CANPUT	(__SID |34)
+
+#define FMNAMESZ	8
+
+#define FLUSHR		0x01
+#define FLUSHW		0x02
+#define FLUSHRW		0x03
+#define FLUSHBAND	0x04
+
+#define S_INPUT		0x0001
+#define S_HIPRI		0x0002
+#define S_OUTPUT	0x0004
+#define S_MSG		0x0008
+#define S_ERROR		0x0010
+#define S_HANGUP	0x0020
+#define S_RDNORM	0x0040
+#define S_WRNORM	S_OUTPUT
+#define S_RDBAND	0x0080
+#define S_WRBAND	0x0100
+#define S_BANDURG	0x0200
+
+#define RS_HIPRI	0x01
+
+#define RNORM		0x0000
+#define RMSGD		0x0001
+#define RMSGN		0x0002
+#define RPROTDAT	0x0004
+#define RPROTDIS	0x0008
+#define RPROTNORM	0x0010
+#define RPROTMASK	0x001C
+
+#define SNDZERO		0x001
+#define SNDPIPE		0x002
+
+#define ANYMARK		0x01
+#define LASTMARK	0x02
+
+#define MUXID_ALL	(-1)
+
+#define MSG_HIPRI	0x01
+#define MSG_ANY		0x02
+#define MSG_BAND	0x04
+
+#define MORECTL		1
+#define MOREDATA	2
+
+struct bandinfo {
+	unsigned char bi_pri;
+	int bi_flag;
+};
+
+struct strbuf {
+	int maxlen;
+	int len;
+	char *buf;
+};
+
+struct strpeek {
+	struct strbuf ctlbuf;
+	struct strbuf databuf;
+	unsigned flags;
+};
+
+struct strfdinsert {
+	struct strbuf ctlbuf;
+	struct strbuf databuf;
+	unsigned flags;
+	int fildes;
+	int offset;
+};
+
+struct strioctl {
+	int ic_cmd;
+	int ic_timout;
+	int ic_len;
+	char *ic_dp;
+};
+
+struct strrecvfd {
+	int fd;
+	int uid;
+	int gid;
+	char __fill[8];
+};
+
+struct str_mlist {
+	char l_name[FMNAMESZ + 1];
+};
+
+struct str_list {
+	int sl_nmods;
+	struct str_mlist *sl_modlist;
+};
+
+int isastream(int);
+int ioctl(int, int, ...);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
diff --git a/third_party/musl/porting/liteos_m/kernel/include/sys/acct.h b/third_party/musl/porting/liteos_m/kernel/include/sys/acct.h
new file mode 100755
index 000000000..fae9d0508
--- /dev/null
+++ b/third_party/musl/porting/liteos_m/kernel/include/sys/acct.h
@@ -0,0 +1,72 @@
+#ifndef _SYS_ACCT_H
+#define _SYS_ACCT_H
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#include <features.h>
+#include <time.h>
+#include <stdint.h>
+
+#define ACCT_COMM 16
+
+typedef uint16_t comp_t;
+
+struct acct {
+	char ac_flag;
+	uint16_t ac_uid;
+	uint16_t ac_gid;
+	uint16_t ac_tty;
+	uint32_t ac_btime;
+	comp_t ac_utime;
+	comp_t ac_stime;
+	comp_t ac_etime;
+	comp_t ac_mem;
+	comp_t ac_io;
+	comp_t ac_rw;
+	comp_t ac_minflt;
+	comp_t ac_majflt;
+	comp_t ac_swaps;
+	uint32_t ac_exitcode;
+	char ac_comm[ACCT_COMM+1];
+	char ac_pad[10];
+};
+
+
+struct acct_v3 {
+	char ac_flag;
+	char ac_version;
+	uint16_t ac_tty;
+	uint32_t ac_exitcode;
+	uint32_t ac_uid;
+	uint32_t ac_gid;
+	uint32_t ac_pid;
+	uint32_t ac_ppid;
+	uint32_t ac_btime;
+	float ac_etime;
+	comp_t ac_utime;
+	comp_t ac_stime;
+	comp_t ac_mem;
+	comp_t ac_io;
+	comp_t ac_rw;
+	comp_t ac_minflt;
+	comp_t ac_majflt;
+	comp_t ac_swaps;
+	char ac_comm[ACCT_COMM];
+};
+
+#define AFORK 1
+#define ASU 2
+#define ACORE 8
+#define AXSIG 16
+#define ACCT_BYTEORDER (128*(__BYTE_ORDER==__BIG_ENDIAN))
+#define AHZ 100
+
+int acct(const char *);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
diff --git a/third_party/musl/porting/liteos_m/kernel/include/sys/auxv.h b/third_party/musl/porting/liteos_m/kernel/include/sys/auxv.h
new file mode 100755
index 000000000..ddccf57ff
--- /dev/null
+++ b/third_party/musl/porting/liteos_m/kernel/include/sys/auxv.h
@@ -0,0 +1,17 @@
+#ifndef _SYS_AUXV_H
+#define _SYS_AUXV_H
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#include <elf.h>
+#include <bits/hwcap.h>
+
+unsigned long getauxval(unsigned long);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
diff --git a/third_party/musl/porting/liteos_m/kernel/include/sys/cachectl.h b/third_party/musl/porting/liteos_m/kernel/include/sys/cachectl.h
new file mode 100755
index 000000000..f3b896a8e
--- /dev/null
+++ b/third_party/musl/porting/liteos_m/kernel/include/sys/cachectl.h
@@ -0,0 +1,22 @@
+#ifndef _SYS_CACHECTL_H
+#define _SYS_CACHECTL_H
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#define ICACHE (1<<0)
+#define DCACHE (1<<1)
+#define BCACHE (ICACHE|DCACHE)
+#define CACHEABLE 0
+#define UNCACHEABLE 1
+ 
+int cachectl(void *, int, int);
+int cacheflush(void *, int, int);
+int _flush_cache(void *, int, int);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
diff --git a/third_party/musl/porting/liteos_m/kernel/include/sys/dir.h b/third_party/musl/porting/liteos_m/kernel/include/sys/dir.h
new file mode 100755
index 000000000..9ba1c79e2
--- /dev/null
+++ b/third_party/musl/porting/liteos_m/kernel/include/sys/dir.h
@@ -0,0 +1,2 @@
+#include <dirent.h>
+#define direct dirent
diff --git a/third_party/musl/porting/liteos_m/kernel/include/sys/epoll.h b/third_party/musl/porting/liteos_m/kernel/include/sys/epoll.h
new file mode 100755
index 000000000..ac81a8418
--- /dev/null
+++ b/third_party/musl/porting/liteos_m/kernel/include/sys/epoll.h
@@ -0,0 +1,69 @@
+#ifndef	_SYS_EPOLL_H
+#define	_SYS_EPOLL_H
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#include <stdint.h>
+#include <sys/types.h>
+#include <fcntl.h>
+
+#define __NEED_sigset_t
+
+#include <bits/alltypes.h>
+
+#define EPOLL_CLOEXEC O_CLOEXEC
+#define EPOLL_NONBLOCK O_NONBLOCK
+
+enum EPOLL_EVENTS { __EPOLL_DUMMY };
+#define EPOLLIN 0x001
+#define EPOLLPRI 0x002
+#define EPOLLOUT 0x004
+#define EPOLLRDNORM 0x040
+#define EPOLLNVAL 0x020
+#define EPOLLRDBAND 0x080
+#define EPOLLWRNORM 0x100
+#define EPOLLWRBAND 0x200
+#define EPOLLMSG 0x400
+#define EPOLLERR 0x008
+#define EPOLLHUP 0x010
+#define EPOLLRDHUP 0x2000
+#define EPOLLEXCLUSIVE (1U<<28)
+#define EPOLLWAKEUP (1U<<29)
+#define EPOLLONESHOT (1U<<30)
+#define EPOLLET (1U<<31)
+
+#define EPOLL_CTL_ADD 1
+#define EPOLL_CTL_DEL 2
+#define EPOLL_CTL_MOD 3
+
+typedef union epoll_data {
+	void *ptr;
+	int fd;
+	uint32_t u32;
+	uint64_t u64;
+} epoll_data_t;
+
+struct epoll_event {
+	uint32_t events;
+	epoll_data_t data;
+}
+#ifdef __x86_64__
+__attribute__ ((__packed__))
+#endif
+;
+
+
+int epoll_create(int);
+int epoll_create1(int);
+int epoll_ctl(int, int, int, struct epoll_event *);
+int epoll_wait(int, struct epoll_event *, int, int);
+int epoll_pwait(int, struct epoll_event *, int, int, const sigset_t *);
+
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* sys/epoll.h */
diff --git a/third_party/musl/porting/liteos_m/kernel/include/sys/errno.h b/third_party/musl/porting/liteos_m/kernel/include/sys/errno.h
new file mode 100755
index 000000000..35a3e5a2a
--- /dev/null
+++ b/third_party/musl/porting/liteos_m/kernel/include/sys/errno.h
@@ -0,0 +1,2 @@
+#warning redirecting incorrect #include <sys/errno.h> to <errno.h>
+#include <errno.h>
diff --git a/third_party/musl/porting/liteos_m/kernel/include/sys/eventfd.h b/third_party/musl/porting/liteos_m/kernel/include/sys/eventfd.h
new file mode 100755
index 000000000..dc5c88f04
--- /dev/null
+++ b/third_party/musl/porting/liteos_m/kernel/include/sys/eventfd.h
@@ -0,0 +1,26 @@
+#ifndef _SYS_EVENTFD_H
+#define _SYS_EVENTFD_H
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#include <stdint.h>
+#include <fcntl.h>
+
+typedef uint64_t eventfd_t;
+
+#define EFD_SEMAPHORE 1
+#define EFD_CLOEXEC O_CLOEXEC
+#define EFD_NONBLOCK O_NONBLOCK
+
+int eventfd(unsigned int, int);
+int eventfd_read(int, eventfd_t *);
+int eventfd_write(int, eventfd_t);
+
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* sys/eventfd.h */
diff --git a/third_party/musl/porting/liteos_m/kernel/include/sys/fanotify.h b/third_party/musl/porting/liteos_m/kernel/include/sys/fanotify.h
new file mode 100755
index 000000000..b637c8f58
--- /dev/null
+++ b/third_party/musl/porting/liteos_m/kernel/include/sys/fanotify.h
@@ -0,0 +1,105 @@
+#ifndef _FANOTIFY_H
+#define _FANOTIFY_H
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#include <sys/statfs.h>
+
+struct fanotify_event_metadata {
+	unsigned event_len;
+	unsigned char vers;
+	unsigned char reserved;
+	unsigned short metadata_len;
+	unsigned long long mask
+#ifdef __GNUC__
+	__attribute__((__aligned__(8)))
+#endif
+	;
+	int fd;
+	int pid;
+};
+
+struct fanotify_event_info_header {
+	unsigned char info_type;
+	unsigned char pad;
+	unsigned short len;
+};
+
+struct fanotify_event_info_fid {
+	struct fanotify_event_info_header hdr;
+	fsid_t fsid;
+	unsigned char handle[];
+};
+
+struct fanotify_response {
+	int fd;
+	unsigned response;
+};
+
+#define FAN_ACCESS 0x01
+#define FAN_MODIFY 0x02
+#define FAN_ATTRIB 0x04
+#define FAN_CLOSE_WRITE 0x08
+#define FAN_CLOSE_NOWRITE 0x10
+#define FAN_OPEN 0x20
+#define FAN_MOVED_FROM 0x40
+#define FAN_MOVED_TO 0x80
+#define FAN_CREATE 0x100
+#define FAN_DELETE 0x200
+#define FAN_DELETE_SELF 0x400
+#define FAN_MOVE_SELF 0x800
+#define FAN_OPEN_EXEC 0x1000
+#define FAN_Q_OVERFLOW 0x4000
+#define FAN_OPEN_PERM 0x10000
+#define FAN_ACCESS_PERM 0x20000
+#define FAN_OPEN_EXEC_PERM 0x40000
+#define FAN_ONDIR 0x40000000
+#define FAN_EVENT_ON_CHILD 0x08000000
+#define FAN_CLOSE (FAN_CLOSE_WRITE | FAN_CLOSE_NOWRITE)
+#define FAN_MOVE (FAN_MOVED_FROM | FAN_MOVED_TO)
+#define FAN_CLOEXEC 0x01
+#define FAN_NONBLOCK 0x02
+#define FAN_CLASS_NOTIF 0
+#define FAN_CLASS_CONTENT 0x04
+#define FAN_CLASS_PRE_CONTENT 0x08
+#define FAN_ALL_CLASS_BITS (FAN_CLASS_NOTIF | FAN_CLASS_CONTENT | FAN_CLASS_PRE_CONTENT)
+#define FAN_UNLIMITED_QUEUE 0x10
+#define FAN_UNLIMITED_MARKS 0x20
+#define FAN_ENABLE_AUDIT 0x40
+#define FAN_REPORT_TID 0x100
+#define FAN_REPORT_FID 0x200
+#define FAN_ALL_INIT_FLAGS (FAN_CLOEXEC | FAN_NONBLOCK | FAN_ALL_CLASS_BITS | FAN_UNLIMITED_QUEUE | FAN_UNLIMITED_MARKS)
+#define FAN_MARK_ADD 0x01
+#define FAN_MARK_REMOVE 0x02
+#define FAN_MARK_DONT_FOLLOW 0x04
+#define FAN_MARK_ONLYDIR 0x08
+#define FAN_MARK_IGNORED_MASK 0x20
+#define FAN_MARK_IGNORED_SURV_MODIFY 0x40
+#define FAN_MARK_FLUSH 0x80
+#define FAN_MARK_INODE 0x00
+#define FAN_MARK_MOUNT 0x10
+#define FAN_MARK_FILESYSTEM 0x100
+#define FAN_MARK_TYPE_MASK (FAN_MARK_INODE | FAN_MARK_MOUNT | FAN_MARK_FILESYSTEM)
+#define FAN_ALL_MARK_FLAGS (FAN_MARK_ADD | FAN_MARK_REMOVE | FAN_MARK_DONT_FOLLOW | FAN_MARK_ONLYDIR | FAN_MARK_MOUNT | FAN_MARK_IGNORED_MASK | FAN_MARK_IGNORED_SURV_MODIFY | FAN_MARK_FLUSH)
+#define FAN_ALL_EVENTS (FAN_ACCESS | FAN_MODIFY | FAN_CLOSE | FAN_OPEN)
+#define FAN_ALL_PERM_EVENTS (FAN_OPEN_PERM | FAN_ACCESS_PERM)
+#define FAN_ALL_OUTGOING_EVENTS (FAN_ALL_EVENTS | FAN_ALL_PERM_EVENTS | FAN_Q_OVERFLOW)
+#define FANOTIFY_METADATA_VERSION 3
+#define FAN_EVENT_INFO_TYPE_FID 1
+#define FAN_ALLOW 0x01
+#define FAN_DENY 0x02
+#define FAN_AUDIT 0x10
+#define FAN_NOFD -1
+#define FAN_EVENT_METADATA_LEN (sizeof(struct fanotify_event_metadata))
+#define FAN_EVENT_NEXT(meta, len) ((len) -= (meta)->event_len, (struct fanotify_event_metadata*)(((char *)(meta)) + (meta)->event_len))
+#define FAN_EVENT_OK(meta, len) ((long)(len) >= (long)FAN_EVENT_METADATA_LEN && (long)(meta)->event_len >= (long)FAN_EVENT_METADATA_LEN && (long)(meta)->event_len <= (long)(len))
+
+int fanotify_init(unsigned, unsigned);
+int fanotify_mark(int, unsigned, unsigned long long, int, const char *);
+
+#ifdef __cplusplus
+}
+#endif
+#endif
diff --git a/third_party/musl/porting/liteos_m/kernel/include/sys/fcntl.h b/third_party/musl/porting/liteos_m/kernel/include/sys/fcntl.h
new file mode 100755
index 000000000..3dd928ef6
--- /dev/null
+++ b/third_party/musl/porting/liteos_m/kernel/include/sys/fcntl.h
@@ -0,0 +1,2 @@
+#warning redirecting incorrect #include <sys/fcntl.h> to <fcntl.h>
+#include <fcntl.h>
diff --git a/third_party/musl/porting/liteos_m/kernel/include/sys/file.h b/third_party/musl/porting/liteos_m/kernel/include/sys/file.h
new file mode 100755
index 000000000..4fc83b981
--- /dev/null
+++ b/third_party/musl/porting/liteos_m/kernel/include/sys/file.h
@@ -0,0 +1,21 @@
+#ifndef _SYS_FILE_H
+#define _SYS_FILE_H
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#define LOCK_SH	1
+#define LOCK_EX	2
+#define LOCK_NB	4
+#define LOCK_UN	8
+
+#define L_SET 0
+#define L_INCR 1
+#define L_XTND 2
+
+int flock(int, int);
+
+#ifdef __cplusplus
+}
+#endif
+#endif
diff --git a/third_party/musl/porting/liteos_m/kernel/include/sys/fsuid.h b/third_party/musl/porting/liteos_m/kernel/include/sys/fsuid.h
new file mode 100755
index 000000000..c7a9b8faa
--- /dev/null
+++ b/third_party/musl/porting/liteos_m/kernel/include/sys/fsuid.h
@@ -0,0 +1,20 @@
+#ifndef _SYS_FSUID_H
+#define _SYS_FSUID_H
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#define __NEED_uid_t
+#define __NEED_gid_t
+
+#include <bits/alltypes.h>
+
+int setfsuid(uid_t);
+int setfsgid(gid_t);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
diff --git a/third_party/musl/porting/liteos_m/kernel/include/sys/inotify.h b/third_party/musl/porting/liteos_m/kernel/include/sys/inotify.h
new file mode 100755
index 000000000..69b586319
--- /dev/null
+++ b/third_party/musl/porting/liteos_m/kernel/include/sys/inotify.h
@@ -0,0 +1,58 @@
+#ifndef _SYS_INOTIFY_H
+#define _SYS_INOTIFY_H
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#include <stdint.h>
+#include <fcntl.h>
+
+struct inotify_event {
+	int wd;
+	uint32_t mask, cookie, len;
+	char name[];
+};
+
+#define IN_CLOEXEC O_CLOEXEC
+#define IN_NONBLOCK O_NONBLOCK
+
+#define IN_ACCESS        0x00000001
+#define IN_MODIFY        0x00000002
+#define IN_ATTRIB        0x00000004
+#define IN_CLOSE_WRITE   0x00000008
+#define IN_CLOSE_NOWRITE 0x00000010
+#define IN_CLOSE         (IN_CLOSE_WRITE | IN_CLOSE_NOWRITE)
+#define IN_OPEN          0x00000020
+#define IN_MOVED_FROM    0x00000040
+#define IN_MOVED_TO      0x00000080
+#define IN_MOVE          (IN_MOVED_FROM | IN_MOVED_TO)
+#define IN_CREATE        0x00000100
+#define IN_DELETE        0x00000200
+#define IN_DELETE_SELF   0x00000400
+#define IN_MOVE_SELF     0x00000800
+#define IN_ALL_EVENTS    0x00000fff
+
+#define IN_UNMOUNT       0x00002000
+#define IN_Q_OVERFLOW    0x00004000
+#define IN_IGNORED       0x00008000
+
+#define IN_ONLYDIR       0x01000000
+#define IN_DONT_FOLLOW   0x02000000
+#define IN_EXCL_UNLINK   0x04000000
+#define IN_MASK_CREATE   0x10000000
+#define IN_MASK_ADD      0x20000000
+
+#define IN_ISDIR         0x40000000
+#define IN_ONESHOT       0x80000000
+
+int inotify_init(void);
+int inotify_init1(int);
+int inotify_add_watch(int, const char *, uint32_t);
+int inotify_rm_watch(int, int);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
diff --git a/third_party/musl/porting/liteos_m/kernel/include/sys/io.h b/third_party/musl/porting/liteos_m/kernel/include/sys/io.h
new file mode 100755
index 000000000..16658ceca
--- /dev/null
+++ b/third_party/musl/porting/liteos_m/kernel/include/sys/io.h
@@ -0,0 +1,17 @@
+#ifndef	_SYS_IO_H
+#define	_SYS_IO_H
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#include <features.h>
+
+#include <bits/io.h>
+
+int iopl(int);
+int ioperm(unsigned long, unsigned long, int);
+
+#ifdef __cplusplus
+}
+#endif
+#endif
diff --git a/third_party/musl/porting/liteos_m/kernel/include/sys/ioctl.h b/third_party/musl/porting/liteos_m/kernel/include/sys/ioctl.h
new file mode 100755
index 000000000..c2ce3b484
--- /dev/null
+++ b/third_party/musl/porting/liteos_m/kernel/include/sys/ioctl.h
@@ -0,0 +1,125 @@
+#ifndef	_SYS_IOCTL_H
+#define	_SYS_IOCTL_H
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#include <bits/alltypes.h>
+#include <bits/ioctl.h>
+
+#define N_TTY           0
+#define N_SLIP          1
+#define N_MOUSE         2
+#define N_PPP           3
+#define N_STRIP         4
+#define N_AX25          5
+#define N_X25           6
+#define N_6PACK         7
+#define N_MASC          8
+#define N_R3964         9
+#define N_PROFIBUS_FDL  10
+#define N_IRDA          11
+#define N_SMSBLOCK      12
+#define N_HDLC          13
+#define N_SYNC_PPP      14
+#define N_HCI           15
+#define N_GIGASET_M101  16
+#define N_SLCAN         17
+#define N_PPS           18
+#define N_V253          19
+#define N_CAIF          20
+#define N_GSM0710       21
+#define N_TI_WL         22
+#define N_TRACESINK     23
+#define N_TRACEROUTER   24
+#define N_NCI           25
+#define N_SPEAKUP       26
+#define N_NULL          27
+
+#define TIOCPKT_DATA       0
+#define TIOCPKT_FLUSHREAD  1
+#define TIOCPKT_FLUSHWRITE 2
+#define TIOCPKT_STOP       4
+#define TIOCPKT_START      8
+#define TIOCPKT_NOSTOP    16
+#define TIOCPKT_DOSTOP    32
+#define TIOCPKT_IOCTL     64
+
+#define TIOCSER_TEMT 1
+
+struct winsize {
+	unsigned short ws_row;
+	unsigned short ws_col;
+	unsigned short ws_xpixel;
+	unsigned short ws_ypixel;
+};
+
+#define SIOCADDRT          0x890B
+#define SIOCDELRT          0x890C
+#define SIOCRTMSG          0x890D
+
+#define SIOCGIFNAME        0x8910
+#define SIOCSIFLINK        0x8911
+#define SIOCGIFCONF        0x8912
+#define SIOCGIFFLAGS       0x8913
+#define SIOCSIFFLAGS       0x8914
+#define SIOCGIFADDR        0x8915
+#define SIOCSIFADDR        0x8916
+#define SIOCGIFDSTADDR     0x8917
+#define SIOCSIFDSTADDR     0x8918
+#define SIOCGIFBRDADDR     0x8919
+#define SIOCSIFBRDADDR     0x891a
+#define SIOCGIFNETMASK     0x891b
+#define SIOCSIFNETMASK     0x891c
+#define SIOCGIFMETRIC      0x891d
+#define SIOCSIFMETRIC      0x891e
+#define SIOCGIFMEM         0x891f
+#define SIOCSIFMEM         0x8920
+#define SIOCGIFMTU         0x8921
+#define SIOCSIFMTU         0x8922
+#define SIOCSIFNAME        0x8923
+#define SIOCSIFHWADDR      0x8924
+#define SIOCGIFENCAP       0x8925
+#define SIOCSIFENCAP       0x8926
+#define SIOCGIFHWADDR      0x8927
+#define SIOCGIFSLAVE       0x8929
+#define SIOCSIFSLAVE       0x8930
+#define SIOCADDMULTI       0x8931
+#define SIOCDELMULTI       0x8932
+#define SIOCGIFINDEX       0x8933
+#define SIOGIFINDEX        SIOCGIFINDEX
+#define SIOCSIFPFLAGS      0x8934
+#define SIOCGIFPFLAGS      0x8935
+#define SIOCDIFADDR        0x8936
+#define SIOCSIFHWBROADCAST 0x8937
+#define SIOCGIFCOUNT       0x8938
+
+#define SIOCGIFBR          0x8940
+#define SIOCSIFBR          0x8941
+
+#define SIOCGIFTXQLEN      0x8942
+#define SIOCSIFTXQLEN      0x8943
+
+#define SIOCDARP           0x8953
+#define SIOCGARP           0x8954
+#define SIOCSARP           0x8955
+
+#define SIOCDRARP          0x8960
+#define SIOCGRARP          0x8961
+#define SIOCSRARP          0x8962
+
+#define SIOCGIFMAP         0x8970
+#define SIOCSIFMAP         0x8971
+
+#define SIOCADDDLCI        0x8980
+#define SIOCDELDLCI        0x8981
+
+#define SIOCDEVPRIVATE     0x89F0
+#define SIOCPROTOPRIVATE   0x89E0
+
+int ioctl (int, int, ...);
+
+#ifdef __cplusplus
+}
+#endif
+#endif
diff --git a/third_party/musl/porting/liteos_m/kernel/include/sys/ipc.h b/third_party/musl/porting/liteos_m/kernel/include/sys/ipc.h
new file mode 100755
index 000000000..9e366b7be
--- /dev/null
+++ b/third_party/musl/porting/liteos_m/kernel/include/sys/ipc.h
@@ -0,0 +1,42 @@
+#ifndef _SYS_IPC_H
+#define _SYS_IPC_H
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#include <features.h>
+
+#define __NEED_uid_t
+#define __NEED_gid_t
+#define __NEED_mode_t
+#define __NEED_key_t
+
+#include <bits/alltypes.h>
+
+#define __ipc_perm_key __key
+#define __ipc_perm_seq __seq
+
+#if defined(_GNU_SOURCE) || defined(_BSD_SOURCE)
+#define __key key
+#define __seq seq
+#endif
+
+#include <bits/ipc.h>
+#include <bits/ipcstat.h>
+
+#define IPC_CREAT  01000
+#define IPC_EXCL   02000
+#define IPC_NOWAIT 04000
+
+#define IPC_RMID 0
+#define IPC_SET  1
+#define IPC_INFO 3
+
+#define IPC_PRIVATE ((key_t) 0)
+
+key_t ftok (const char *, int);
+
+#ifdef __cplusplus
+}
+#endif
+#endif
diff --git a/third_party/musl/porting/liteos_m/kernel/include/sys/kd.h b/third_party/musl/porting/liteos_m/kernel/include/sys/kd.h
new file mode 100755
index 000000000..42122b9c3
--- /dev/null
+++ b/third_party/musl/porting/liteos_m/kernel/include/sys/kd.h
@@ -0,0 +1 @@
+#include <bits/kd.h>
diff --git a/third_party/musl/porting/liteos_m/kernel/include/sys/klog.h b/third_party/musl/porting/liteos_m/kernel/include/sys/klog.h
new file mode 100755
index 000000000..aa66684e3
--- /dev/null
+++ b/third_party/musl/porting/liteos_m/kernel/include/sys/klog.h
@@ -0,0 +1,14 @@
+#ifndef	_SYS_KLOG_H
+#define	_SYS_KLOG_H
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+int klogctl (int, char *, int);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
diff --git a/third_party/musl/porting/liteos_m/kernel/include/sys/membarrier.h b/third_party/musl/porting/liteos_m/kernel/include/sys/membarrier.h
new file mode 100755
index 000000000..10cb31083
--- /dev/null
+++ b/third_party/musl/porting/liteos_m/kernel/include/sys/membarrier.h
@@ -0,0 +1,17 @@
+#ifndef _SYS_MEMBARRIER_H
+#define _SYS_MEMBARRIER_H
+
+#define MEMBARRIER_CMD_QUERY 0
+#define MEMBARRIER_CMD_GLOBAL 1
+#define MEMBARRIER_CMD_GLOBAL_EXPEDITED 2
+#define MEMBARRIER_CMD_REGISTER_GLOBAL_EXPEDITED 4
+#define MEMBARRIER_CMD_PRIVATE_EXPEDITED 8
+#define MEMBARRIER_CMD_REGISTER_PRIVATE_EXPEDITED 16
+#define MEMBARRIER_CMD_PRIVATE_EXPEDITED_SYNC_CORE 32
+#define MEMBARRIER_CMD_REGISTER_PRIVATE_EXPEDITED_SYNC_CORE 64
+
+#define MEMBARRIER_CMD_SHARED MEMBARRIER_CMD_GLOBAL
+
+int membarrier(int, int);
+
+#endif
diff --git a/third_party/musl/porting/liteos_m/kernel/include/sys/mman.h b/third_party/musl/porting/liteos_m/kernel/include/sys/mman.h
new file mode 100755
index 000000000..3bade7272
--- /dev/null
+++ b/third_party/musl/porting/liteos_m/kernel/include/sys/mman.h
@@ -0,0 +1,150 @@
+#ifndef	_SYS_MMAN_H
+#define	_SYS_MMAN_H
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#include <features.h>
+
+#define __NEED_mode_t
+#define __NEED_size_t
+#define __NEED_off_t
+
+#if defined(_GNU_SOURCE)
+#define __NEED_ssize_t
+#endif
+
+#include <bits/alltypes.h>
+
+#define MAP_FAILED ((void *) -1)
+
+#define MAP_SHARED     0x01
+#define MAP_PRIVATE    0x02
+#define MAP_SHARED_VALIDATE 0x03
+#define MAP_TYPE       0x0f
+#define MAP_FIXED      0x10
+#define MAP_ANON       0x20
+#define MAP_ANONYMOUS  MAP_ANON
+#define MAP_NORESERVE  0x4000
+#define MAP_GROWSDOWN  0x0100
+#define MAP_DENYWRITE  0x0800
+#define MAP_EXECUTABLE 0x1000
+#define MAP_LOCKED     0x2000
+#define MAP_POPULATE   0x8000
+#define MAP_NONBLOCK   0x10000
+#define MAP_STACK      0x20000
+#define MAP_HUGETLB    0x40000
+#define MAP_SYNC       0x80000
+#define MAP_FIXED_NOREPLACE 0x100000
+#define MAP_FILE       0
+
+#define MAP_HUGE_SHIFT 26
+#define MAP_HUGE_MASK  0x3f
+#define MAP_HUGE_64KB  (16 << 26)
+#define MAP_HUGE_512KB (19 << 26)
+#define MAP_HUGE_1MB   (20 << 26)
+#define MAP_HUGE_2MB   (21 << 26)
+#define MAP_HUGE_8MB   (23 << 26)
+#define MAP_HUGE_16MB  (24 << 26)
+#define MAP_HUGE_32MB  (25 << 26)
+#define MAP_HUGE_256MB (28 << 26)
+#define MAP_HUGE_512MB (29 << 26)
+#define MAP_HUGE_1GB   (30 << 26)
+#define MAP_HUGE_2GB   (31 << 26)
+#define MAP_HUGE_16GB  (34U << 26)
+
+#define PROT_NONE      0
+#define PROT_READ      1
+#define PROT_WRITE     2
+#define PROT_EXEC      4
+#define PROT_GROWSDOWN 0x01000000
+#define PROT_GROWSUP   0x02000000
+
+#define MS_ASYNC       1
+#define MS_INVALIDATE  2
+#define MS_SYNC        4
+
+#define MCL_CURRENT    1
+#define MCL_FUTURE     2
+#define MCL_ONFAULT    4
+
+#define POSIX_MADV_NORMAL     0
+#define POSIX_MADV_RANDOM     1
+#define POSIX_MADV_SEQUENTIAL 2
+#define POSIX_MADV_WILLNEED   3
+#define POSIX_MADV_DONTNEED   4
+
+#if defined(_GNU_SOURCE) || defined(_BSD_SOURCE)
+#define MADV_NORMAL      0
+#define MADV_RANDOM      1
+#define MADV_SEQUENTIAL  2
+#define MADV_WILLNEED    3
+#define MADV_DONTNEED    4
+#define MADV_FREE        8
+#define MADV_REMOVE      9
+#define MADV_DONTFORK    10
+#define MADV_DOFORK      11
+#define MADV_MERGEABLE   12
+#define MADV_UNMERGEABLE 13
+#define MADV_HUGEPAGE    14
+#define MADV_NOHUGEPAGE  15
+#define MADV_DONTDUMP    16
+#define MADV_DODUMP      17
+#define MADV_WIPEONFORK  18
+#define MADV_KEEPONFORK  19
+#define MADV_COLD        20
+#define MADV_PAGEOUT     21
+#define MADV_HWPOISON    100
+#define MADV_SOFT_OFFLINE 101
+#endif
+
+#ifdef _GNU_SOURCE
+#define MREMAP_MAYMOVE 1
+#define MREMAP_FIXED 2
+
+#define MLOCK_ONFAULT 0x01
+
+#define MFD_CLOEXEC 0x0001U
+#define MFD_ALLOW_SEALING 0x0002U
+#define MFD_HUGETLB 0x0004U
+#endif
+
+#include <bits/mman.h>
+
+void *mmap (void *, size_t, int, int, int, off_t);
+int munmap (void *, size_t);
+
+int mprotect (void *, size_t, int);
+int msync (void *, size_t, int);
+
+int posix_madvise (void *, size_t, int);
+
+int mlock (const void *, size_t);
+int munlock (const void *, size_t);
+int mlockall (int);
+int munlockall (void);
+
+#ifdef _GNU_SOURCE
+void *mremap (void *, size_t, size_t, int, ...);
+int remap_file_pages (void *, size_t, int, size_t, int);
+int memfd_create (const char *, unsigned);
+int mlock2 (const void *, size_t, unsigned);
+#endif
+
+#if defined(_GNU_SOURCE) || defined(_BSD_SOURCE)
+int madvise (void *, size_t, int);
+int mincore (void *, size_t, unsigned char *);
+#endif
+
+int shm_open (const char *, int, mode_t);
+int shm_unlink (const char *);
+
+#if defined(_LARGEFILE64_SOURCE) || defined(_GNU_SOURCE)
+#define mmap64 mmap
+#define off64_t off_t
+#endif
+
+#ifdef __cplusplus
+}
+#endif
+#endif
diff --git a/third_party/musl/porting/liteos_m/kernel/include/sys/mount.h b/third_party/musl/porting/liteos_m/kernel/include/sys/mount.h
new file mode 100755
index 000000000..57a89c09e
--- /dev/null
+++ b/third_party/musl/porting/liteos_m/kernel/include/sys/mount.h
@@ -0,0 +1,74 @@
+#ifndef _SYS_MOUNT_H
+#define _SYS_MOUNT_H
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#include <sys/ioctl.h>
+
+#define BLKROSET   _IO(0x12, 93)
+#define BLKROGET   _IO(0x12, 94)
+#define BLKRRPART  _IO(0x12, 95)
+#define BLKGETSIZE _IO(0x12, 96)
+#define BLKFLSBUF  _IO(0x12, 97)
+#define BLKRASET   _IO(0x12, 98)
+#define BLKRAGET   _IO(0x12, 99)
+#define BLKFRASET  _IO(0x12,100)
+#define BLKFRAGET  _IO(0x12,101)
+#define BLKSECTSET _IO(0x12,102)
+#define BLKSECTGET _IO(0x12,103)
+#define BLKSSZGET  _IO(0x12,104)
+#define BLKBSZGET  _IOR(0x12,112,size_t)
+#define BLKBSZSET  _IOW(0x12,113,size_t)
+#define BLKGETSIZE64 _IOR(0x12,114,size_t)
+
+#define MS_RDONLY      1
+#define MS_NOSUID      2
+#define MS_NODEV       4
+#define MS_NOEXEC      8
+#define MS_SYNCHRONOUS 16
+#define MS_REMOUNT     32
+#define MS_MANDLOCK    64
+#define MS_DIRSYNC     128
+#define MS_NOATIME     1024
+#define MS_NODIRATIME  2048
+#define MS_BIND        4096
+#define MS_MOVE        8192
+#define MS_REC         16384
+#define MS_SILENT      32768
+#define MS_POSIXACL    (1<<16)
+#define MS_UNBINDABLE  (1<<17)
+#define MS_PRIVATE     (1<<18)
+#define MS_SLAVE       (1<<19)
+#define MS_SHARED      (1<<20)
+#define MS_RELATIME    (1<<21)
+#define MS_KERNMOUNT   (1<<22)
+#define MS_I_VERSION   (1<<23)
+#define MS_STRICTATIME (1<<24)
+#define MS_LAZYTIME    (1<<25)
+#define MS_NOREMOTELOCK (1<<27)
+#define MS_NOSEC       (1<<28)
+#define MS_BORN        (1<<29)
+#define MS_ACTIVE      (1<<30)
+#define MS_NOUSER      (1U<<31)
+
+#define MS_RMT_MASK (MS_RDONLY|MS_SYNCHRONOUS|MS_MANDLOCK|MS_I_VERSION|MS_LAZYTIME)
+
+#define MS_MGC_VAL 0xc0ed0000
+#define MS_MGC_MSK 0xffff0000
+
+#define MNT_FORCE       1
+#define MNT_DETACH      2
+#define MNT_EXPIRE      4
+#define UMOUNT_NOFOLLOW 8
+
+int mount(const char *, const char *, const char *, unsigned long, const void *);
+int umount(const char *);
+int umount2(const char *, int);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
diff --git a/third_party/musl/porting/liteos_m/kernel/include/sys/msg.h b/third_party/musl/porting/liteos_m/kernel/include/sys/msg.h
new file mode 100755
index 000000000..db5c62a42
--- /dev/null
+++ b/third_party/musl/porting/liteos_m/kernel/include/sys/msg.h
@@ -0,0 +1,53 @@
+#ifndef _SYS_MSG_H
+#define _SYS_MSG_H
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#include <sys/ipc.h>
+
+#define __NEED_pid_t
+#define __NEED_key_t
+#define __NEED_time_t
+#define __NEED_size_t
+#define __NEED_ssize_t
+
+#include <bits/alltypes.h>
+
+typedef unsigned long msgqnum_t;
+typedef unsigned long msglen_t;
+
+#include <bits/msg.h>
+
+#define __msg_cbytes msg_cbytes
+
+#define MSG_NOERROR 010000
+#define MSG_EXCEPT  020000
+
+#define MSG_STAT (11 | (IPC_STAT & 0x100))
+#define MSG_INFO 12
+#define MSG_STAT_ANY (13 | (IPC_STAT & 0x100))
+
+struct msginfo {
+	int msgpool, msgmap, msgmax, msgmnb, msgmni, msgssz, msgtql;
+	unsigned short msgseg;
+};
+
+int msgctl (int, int, struct msqid_ds *);
+int msgget (key_t, int);
+ssize_t msgrcv (int, void *, size_t, long, int);
+int msgsnd (int, const void *, size_t, int);
+
+#if defined(_GNU_SOURCE) || defined(_BSD_SOURCE)
+struct msgbuf {
+	long mtype;
+	char mtext[1];
+};
+#endif
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
diff --git a/third_party/musl/porting/liteos_m/kernel/include/sys/mtio.h b/third_party/musl/porting/liteos_m/kernel/include/sys/mtio.h
new file mode 100755
index 000000000..f16a529bb
--- /dev/null
+++ b/third_party/musl/porting/liteos_m/kernel/include/sys/mtio.h
@@ -0,0 +1,188 @@
+#ifndef _SYS_MTIO_H
+#define _SYS_MTIO_H
+
+#include <sys/types.h>
+#include <sys/ioctl.h>
+
+struct mtop {
+	short mt_op;
+	int mt_count;
+};
+
+#define _IOT_mtop _IOT (_IOTS (short), 1, _IOTS (int), 1, 0, 0)
+#define _IOT_mtget _IOT (_IOTS (long), 7, 0, 0, 0, 0)
+#define _IOT_mtpos _IOT_SIMPLE (long)
+#define _IOT_mtconfiginfo _IOT (_IOTS (long), 2, _IOTS (short), 3, _IOTS (long), 1)
+
+
+#define MTRESET 0
+#define MTFSF	1
+#define MTBSF	2
+#define MTFSR	3
+#define MTBSR	4
+#define MTWEOF	5
+#define MTREW	6
+#define MTOFFL	7
+#define MTNOP	8
+#define MTRETEN 9
+#define MTBSFM	10
+#define MTFSFM  11
+#define MTEOM	12
+#define MTERASE 13
+#define MTRAS1  14
+#define MTRAS2	15
+#define MTRAS3  16
+#define MTSETBLK 20
+#define MTSETDENSITY 21
+#define MTSEEK	22
+#define MTTELL	23
+#define MTSETDRVBUFFER 24
+#define MTFSS	25
+#define MTBSS	26
+#define MTWSM	27
+#define MTLOCK  28
+#define MTUNLOCK 29
+#define MTLOAD  30
+#define MTUNLOAD 31
+#define MTCOMPRESSION 32
+#define MTSETPART 33
+#define MTMKPART  34
+
+struct mtget {
+	long mt_type;
+	long mt_resid;
+	long mt_dsreg;
+	long mt_gstat;
+	long mt_erreg;
+	int mt_fileno;
+	int mt_blkno;
+};
+
+#define MT_ISUNKNOWN		0x01
+#define MT_ISQIC02		0x02
+#define MT_ISWT5150		0x03
+#define MT_ISARCHIVE_5945L2	0x04
+#define MT_ISCMSJ500		0x05
+#define MT_ISTDC3610		0x06
+#define MT_ISARCHIVE_VP60I	0x07
+#define MT_ISARCHIVE_2150L	0x08
+#define MT_ISARCHIVE_2060L	0x09
+#define MT_ISARCHIVESC499	0x0A
+#define MT_ISQIC02_ALL_FEATURES	0x0F
+#define MT_ISWT5099EEN24	0x11
+#define MT_ISTEAC_MT2ST		0x12
+#define MT_ISEVEREX_FT40A	0x32
+#define MT_ISDDS1		0x51
+#define MT_ISDDS2		0x52
+#define MT_ISSCSI1		0x71
+#define MT_ISSCSI2		0x72
+#define MT_ISFTAPE_UNKNOWN	0x800000
+#define MT_ISFTAPE_FLAG		0x800000
+
+struct mt_tape_info {
+	long t_type;
+	char *t_name;
+};
+
+#define MT_TAPE_INFO \
+{									      \
+	{MT_ISUNKNOWN,		"Unknown type of tape device"},		      \
+	{MT_ISQIC02,		"Generic QIC-02 tape streamer"},	      \
+	{MT_ISWT5150,		"Wangtek 5150, QIC-150"},		      \
+	{MT_ISARCHIVE_5945L2,	"Archive 5945L-2"},			      \
+	{MT_ISCMSJ500,		"CMS Jumbo 500"},			      \
+	{MT_ISTDC3610,		"Tandberg TDC 3610, QIC-24"},		      \
+	{MT_ISARCHIVE_VP60I,	"Archive VP60i, QIC-02"},		      \
+	{MT_ISARCHIVE_2150L,	"Archive Viper 2150L"},			      \
+	{MT_ISARCHIVE_2060L,	"Archive Viper 2060L"},			      \
+	{MT_ISARCHIVESC499,	"Archive SC-499 QIC-36 controller"},	      \
+	{MT_ISQIC02_ALL_FEATURES, "Generic QIC-02 tape, all features"},	      \
+	{MT_ISWT5099EEN24,	"Wangtek 5099-een24, 60MB"},		      \
+	{MT_ISTEAC_MT2ST,	"Teac MT-2ST 155mb data cassette drive"},     \
+	{MT_ISEVEREX_FT40A,	"Everex FT40A, QIC-40"},		      \
+	{MT_ISSCSI1,		"Generic SCSI-1 tape"},			      \
+	{MT_ISSCSI2,		"Generic SCSI-2 tape"},			      \
+	{0, 0}								      \
+}
+
+struct mtpos {
+	long mt_blkno;
+};
+
+struct mtconfiginfo  {
+	long mt_type;
+	long ifc_type;
+	unsigned short irqnr;
+	unsigned short dmanr;
+	unsigned short port;
+	unsigned long debug;
+	unsigned have_dens:1;
+	unsigned have_bsf:1;
+	unsigned have_fsr:1;
+	unsigned have_bsr:1;
+	unsigned have_eod:1;
+	unsigned have_seek:1;
+	unsigned have_tell:1;
+	unsigned have_ras1:1;
+	unsigned have_ras2:1;
+	unsigned have_ras3:1;
+	unsigned have_qfa:1;
+	unsigned pad1:5;
+	char reserved[10];
+};
+
+#define	MTIOCTOP _IOW('m', 1, struct mtop)
+#define	MTIOCGET _IOR('m', 2, struct mtget)
+#define	MTIOCPOS _IOR('m', 3, struct mtpos)
+
+#define	MTIOCGETCONFIG	_IOR('m', 4, struct mtconfiginfo)
+#define	MTIOCSETCONFIG	_IOW('m', 5, struct mtconfiginfo)
+
+#define GMT_EOF(x)              ((x) & 0x80000000)
+#define GMT_BOT(x)              ((x) & 0x40000000)
+#define GMT_EOT(x)              ((x) & 0x20000000)
+#define GMT_SM(x)               ((x) & 0x10000000)
+#define GMT_EOD(x)              ((x) & 0x08000000)
+#define GMT_WR_PROT(x)          ((x) & 0x04000000)
+#define GMT_ONLINE(x)           ((x) & 0x01000000)
+#define GMT_D_6250(x)           ((x) & 0x00800000)
+#define GMT_D_1600(x)           ((x) & 0x00400000)
+#define GMT_D_800(x)            ((x) & 0x00200000)
+#define GMT_DR_OPEN(x)          ((x) & 0x00040000)
+#define GMT_IM_REP_EN(x)        ((x) & 0x00010000)
+
+#define MT_ST_BLKSIZE_SHIFT	0
+#define MT_ST_BLKSIZE_MASK	0xffffff
+#define MT_ST_DENSITY_SHIFT	24
+#define MT_ST_DENSITY_MASK	0xff000000
+#define MT_ST_SOFTERR_SHIFT	0
+#define MT_ST_SOFTERR_MASK	0xffff
+#define MT_ST_OPTIONS		0xf0000000
+#define MT_ST_BOOLEANS		0x10000000
+#define MT_ST_SETBOOLEANS	0x30000000
+#define MT_ST_CLEARBOOLEANS	0x40000000
+#define MT_ST_WRITE_THRESHOLD	0x20000000
+#define MT_ST_DEF_BLKSIZE	0x50000000
+#define MT_ST_DEF_OPTIONS	0x60000000
+#define MT_ST_BUFFER_WRITES	0x1
+#define MT_ST_ASYNC_WRITES	0x2
+#define MT_ST_READ_AHEAD	0x4
+#define MT_ST_DEBUGGING		0x8
+#define MT_ST_TWO_FM		0x10
+#define MT_ST_FAST_MTEOM	0x20
+#define MT_ST_AUTO_LOCK		0x40
+#define MT_ST_DEF_WRITES	0x80
+#define MT_ST_CAN_BSR		0x100
+#define MT_ST_NO_BLKLIMS	0x200
+#define MT_ST_CAN_PARTITIONS    0x400
+#define MT_ST_SCSI2LOGICAL      0x800
+#define MT_ST_CLEAR_DEFAULT	0xfffff
+#define MT_ST_DEF_DENSITY	(MT_ST_DEF_OPTIONS | 0x100000)
+#define MT_ST_DEF_COMPRESSION	(MT_ST_DEF_OPTIONS | 0x200000)
+#define MT_ST_DEF_DRVBUFFER	(MT_ST_DEF_OPTIONS | 0x300000)
+#define MT_ST_HPLOADER_OFFSET 10000
+#ifndef DEFTAPE
+# define DEFTAPE	"/dev/tape"
+#endif
+
+#endif
diff --git a/third_party/musl/porting/liteos_m/kernel/include/sys/param.h b/third_party/musl/porting/liteos_m/kernel/include/sys/param.h
new file mode 100755
index 000000000..ce6b80198
--- /dev/null
+++ b/third_party/musl/porting/liteos_m/kernel/include/sys/param.h
@@ -0,0 +1,35 @@
+#ifndef _SYS_PARAM_H
+#define _SYS_PARAM_H
+
+#define MAXSYMLINKS 20
+#define MAXHOSTNAMELEN 64
+#define MAXNAMLEN 255
+#define MAXPATHLEN 4096
+#define NBBY 8
+#define NGROUPS 32
+#define CANBSIZ 255
+#define NOFILE 256
+#define NCARGS 131072
+#define DEV_BSIZE 512
+#define NOGROUP (-1)
+
+#undef MIN
+#undef MAX
+#define MIN(a,b) (((a)<(b))?(a):(b))
+#define MAX(a,b) (((a)>(b))?(a):(b))
+
+#define __bitop(x,i,o) ((x)[(i)/8] o (1<<(i)%8))
+#define setbit(x,i) __bitop(x,i,|=)
+#define clrbit(x,i) __bitop(x,i,&=~)
+#define isset(x,i) __bitop(x,i,&)
+#define isclr(x,i) !isset(x,i)
+
+#define howmany(n,d) (((n)+((d)-1))/(d))
+#define roundup(n,d) (howmany(n,d)*(d))
+#define powerof2(n) !(((n)-1) & (n))
+
+#include <sys/resource.h>
+#include <endian.h>
+#include <limits.h>
+
+#endif
diff --git a/third_party/musl/porting/liteos_m/kernel/include/sys/personality.h b/third_party/musl/porting/liteos_m/kernel/include/sys/personality.h
new file mode 100755
index 000000000..31d43dfe1
--- /dev/null
+++ b/third_party/musl/porting/liteos_m/kernel/include/sys/personality.h
@@ -0,0 +1,46 @@
+#ifndef _PERSONALITY_H
+#define _PERSONALITY_H
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#define ADDR_NO_RANDOMIZE  0x0040000
+#define MMAP_PAGE_ZERO     0x0100000
+#define ADDR_COMPAT_LAYOUT 0x0200000
+#define READ_IMPLIES_EXEC  0x0400000
+#define ADDR_LIMIT_32BIT   0x0800000
+#define SHORT_INODE        0x1000000
+#define WHOLE_SECONDS      0x2000000
+#define STICKY_TIMEOUTS    0x4000000
+#define ADDR_LIMIT_3GB     0x8000000
+
+#define PER_LINUX 0
+#define PER_LINUX_32BIT ADDR_LIMIT_32BIT
+#define PER_SVR4 (1 | STICKY_TIMEOUTS | MMAP_PAGE_ZERO)
+#define PER_SVR3 (2 | STICKY_TIMEOUTS | SHORT_INODE)
+#define PER_SCOSVR3 (3 | STICKY_TIMEOUTS | WHOLE_SECONDS | SHORT_INODE)
+#define PER_OSR5 (3 | STICKY_TIMEOUTS | WHOLE_SECONDS)
+#define PER_WYSEV386 (4 | STICKY_TIMEOUTS | SHORT_INODE)
+#define PER_ISCR4 (5 | STICKY_TIMEOUTS)
+#define PER_BSD 6
+#define PER_SUNOS (6 | STICKY_TIMEOUTS)
+#define PER_XENIX (7 | STICKY_TIMEOUTS | SHORT_INODE)
+#define PER_LINUX32 8
+#define PER_LINUX32_3GB (8 | ADDR_LIMIT_3GB)
+#define PER_IRIX32 (9 | STICKY_TIMEOUTS)
+#define PER_IRIXN32 (0xa | STICKY_TIMEOUTS)
+#define PER_IRIX64 (0x0b | STICKY_TIMEOUTS)
+#define PER_RISCOS 0xc
+#define PER_SOLARIS (0xd | STICKY_TIMEOUTS)
+#define PER_UW7 (0xe | STICKY_TIMEOUTS | MMAP_PAGE_ZERO)
+#define PER_OSF4 0xf
+#define PER_HPUX 0x10
+#define PER_MASK 0xff
+
+int personality(unsigned long);
+
+#ifdef __cplusplus
+}
+#endif
+#endif
diff --git a/third_party/musl/porting/liteos_m/kernel/include/sys/poll.h b/third_party/musl/porting/liteos_m/kernel/include/sys/poll.h
new file mode 100755
index 000000000..99170401d
--- /dev/null
+++ b/third_party/musl/porting/liteos_m/kernel/include/sys/poll.h
@@ -0,0 +1,2 @@
+#warning redirecting incorrect #include <sys/poll.h> to <poll.h>
+#include <poll.h>
diff --git a/third_party/musl/porting/liteos_m/kernel/include/sys/prctl.h b/third_party/musl/porting/liteos_m/kernel/include/sys/prctl.h
new file mode 100755
index 000000000..d9c846e9c
--- /dev/null
+++ b/third_party/musl/porting/liteos_m/kernel/include/sys/prctl.h
@@ -0,0 +1,167 @@
+#ifndef _SYS_PRCTL_H
+#define _SYS_PRCTL_H
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#include <stdint.h>
+
+#define PR_SET_PDEATHSIG  1
+#define PR_GET_PDEATHSIG  2
+#define PR_GET_DUMPABLE   3
+#define PR_SET_DUMPABLE   4
+#define PR_GET_UNALIGN   5
+#define PR_SET_UNALIGN   6
+#define PR_UNALIGN_NOPRINT 1
+#define PR_UNALIGN_SIGBUS 2
+#define PR_GET_KEEPCAPS   7
+#define PR_SET_KEEPCAPS   8
+#define PR_GET_FPEMU  9
+#define PR_SET_FPEMU 10
+#define PR_FPEMU_NOPRINT 1
+#define PR_FPEMU_SIGFPE 2
+#define PR_GET_FPEXC 11
+#define PR_SET_FPEXC 12
+#define PR_FP_EXC_SW_ENABLE 0x80
+#define PR_FP_EXC_DIV  0x010000
+#define PR_FP_EXC_OVF  0x020000
+#define PR_FP_EXC_UND  0x040000
+#define PR_FP_EXC_RES  0x080000
+#define PR_FP_EXC_INV  0x100000
+#define PR_FP_EXC_DISABLED 0
+#define PR_FP_EXC_NONRECOV 1
+#define PR_FP_EXC_ASYNC 2
+#define PR_FP_EXC_PRECISE 3
+#define PR_GET_TIMING   13
+#define PR_SET_TIMING   14
+#define PR_TIMING_STATISTICAL  0
+#define PR_TIMING_TIMESTAMP    1
+#define PR_SET_NAME    15
+#define PR_GET_NAME    16
+#define PR_GET_ENDIAN 19
+#define PR_SET_ENDIAN 20
+#define PR_ENDIAN_BIG 0
+#define PR_ENDIAN_LITTLE 1
+#define PR_ENDIAN_PPC_LITTLE 2
+#define PR_GET_SECCOMP 21
+#define PR_SET_SECCOMP 22
+#define PR_CAPBSET_READ 23
+#define PR_CAPBSET_DROP 24
+#define PR_GET_TSC 25
+#define PR_SET_TSC 26
+#define PR_TSC_ENABLE 1
+#define PR_TSC_SIGSEGV 2
+#define PR_GET_SECUREBITS 27
+#define PR_SET_SECUREBITS 28
+#define PR_SET_TIMERSLACK 29
+#define PR_GET_TIMERSLACK 30
+
+#define PR_TASK_PERF_EVENTS_DISABLE             31
+#define PR_TASK_PERF_EVENTS_ENABLE              32
+
+#define PR_MCE_KILL     33
+#define PR_MCE_KILL_CLEAR   0
+#define PR_MCE_KILL_SET     1
+#define PR_MCE_KILL_LATE    0
+#define PR_MCE_KILL_EARLY   1
+#define PR_MCE_KILL_DEFAULT 2
+#define PR_MCE_KILL_GET 34
+
+#define PR_SET_MM               35
+#define PR_SET_MM_START_CODE           1
+#define PR_SET_MM_END_CODE             2
+#define PR_SET_MM_START_DATA           3
+#define PR_SET_MM_END_DATA             4
+#define PR_SET_MM_START_STACK          5
+#define PR_SET_MM_START_BRK            6
+#define PR_SET_MM_BRK                  7
+#define PR_SET_MM_ARG_START            8
+#define PR_SET_MM_ARG_END              9
+#define PR_SET_MM_ENV_START            10
+#define PR_SET_MM_ENV_END              11
+#define PR_SET_MM_AUXV                 12
+#define PR_SET_MM_EXE_FILE             13
+#define PR_SET_MM_MAP                  14
+#define PR_SET_MM_MAP_SIZE             15
+
+struct prctl_mm_map {
+	uint64_t start_code;
+	uint64_t end_code;
+	uint64_t start_data;
+	uint64_t end_data;
+	uint64_t start_brk;
+	uint64_t brk;
+	uint64_t start_stack;
+	uint64_t arg_start;
+	uint64_t arg_end;
+	uint64_t env_start;
+	uint64_t env_end;
+	uint64_t *auxv;
+	uint32_t auxv_size;
+	uint32_t exe_fd;
+};
+
+#define PR_SET_PTRACER 0x59616d61
+#define PR_SET_PTRACER_ANY (-1UL)
+
+#define PR_SET_CHILD_SUBREAPER  36
+#define PR_GET_CHILD_SUBREAPER  37
+
+#define PR_SET_NO_NEW_PRIVS     38
+#define PR_GET_NO_NEW_PRIVS     39
+
+#define PR_GET_TID_ADDRESS      40
+
+#define PR_SET_THP_DISABLE      41
+#define PR_GET_THP_DISABLE      42
+
+#define PR_MPX_ENABLE_MANAGEMENT  43
+#define PR_MPX_DISABLE_MANAGEMENT 44
+
+#define PR_SET_FP_MODE          45
+#define PR_GET_FP_MODE          46
+#define PR_FP_MODE_FR (1 << 0)
+#define PR_FP_MODE_FRE (1 << 1)
+
+#define PR_CAP_AMBIENT          47
+#define PR_CAP_AMBIENT_IS_SET   1
+#define PR_CAP_AMBIENT_RAISE    2
+#define PR_CAP_AMBIENT_LOWER    3
+#define PR_CAP_AMBIENT_CLEAR_ALL 4
+
+#define PR_SVE_SET_VL           50
+#define PR_SVE_SET_VL_ONEXEC (1 << 18)
+#define PR_SVE_GET_VL           51
+#define PR_SVE_VL_LEN_MASK 0xffff
+#define PR_SVE_VL_INHERIT (1 << 17)
+
+#define PR_GET_SPECULATION_CTRL 52
+#define PR_SET_SPECULATION_CTRL 53
+#define PR_SPEC_STORE_BYPASS 0
+#define PR_SPEC_INDIRECT_BRANCH 1
+#define PR_SPEC_NOT_AFFECTED 0
+#define PR_SPEC_PRCTL (1UL << 0)
+#define PR_SPEC_ENABLE (1UL << 1)
+#define PR_SPEC_DISABLE (1UL << 2)
+#define PR_SPEC_FORCE_DISABLE (1UL << 3)
+#define PR_SPEC_DISABLE_NOEXEC (1UL << 4)
+
+#define PR_PAC_RESET_KEYS       54
+#define PR_PAC_APIAKEY (1UL << 0)
+#define PR_PAC_APIBKEY (1UL << 1)
+#define PR_PAC_APDAKEY (1UL << 2)
+#define PR_PAC_APDBKEY (1UL << 3)
+#define PR_PAC_APGAKEY (1UL << 4)
+
+#define PR_SET_TAGGED_ADDR_CTRL 55
+#define PR_GET_TAGGED_ADDR_CTRL 56
+#define PR_TAGGED_ADDR_ENABLE (1UL << 0)
+
+int prctl (int, ...);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
diff --git a/third_party/musl/porting/liteos_m/kernel/include/sys/procfs.h b/third_party/musl/porting/liteos_m/kernel/include/sys/procfs.h
new file mode 100755
index 000000000..38e58c168
--- /dev/null
+++ b/third_party/musl/porting/liteos_m/kernel/include/sys/procfs.h
@@ -0,0 +1,63 @@
+#ifndef _SYS_PROCFS_H
+#define _SYS_PROCFS_H
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#include <sys/time.h>
+#include <sys/types.h>
+#include <sys/user.h>
+
+struct elf_siginfo {
+	int si_signo;
+	int si_code;
+	int si_errno;
+};
+
+struct elf_prstatus {
+	struct elf_siginfo pr_info;
+	short int pr_cursig;
+	unsigned long int pr_sigpend;
+	unsigned long int pr_sighold;
+	pid_t pr_pid;
+	pid_t pr_ppid;
+	pid_t pr_pgrp;
+	pid_t pr_sid;
+	struct {
+		long tv_sec, tv_usec;
+	} pr_utime, pr_stime, pr_cutime, pr_cstime;
+	elf_gregset_t pr_reg;
+	int pr_fpvalid;
+};
+
+#define ELF_PRARGSZ 80
+
+struct elf_prpsinfo {
+	char pr_state;
+	char pr_sname;
+	char pr_zomb;
+	char pr_nice;
+	unsigned long int pr_flag;
+#if UINTPTR_MAX == 0xffffffff
+	unsigned short int pr_uid;
+	unsigned short int pr_gid;
+#else
+	unsigned int pr_uid;
+	unsigned int pr_gid;
+#endif
+	int pr_pid, pr_ppid, pr_pgrp, pr_sid;
+	char pr_fname[16];
+	char pr_psargs[ELF_PRARGSZ];
+};
+
+typedef void *psaddr_t;
+typedef elf_gregset_t prgregset_t;
+typedef elf_fpregset_t prfpregset_t;
+typedef pid_t lwpid_t;
+typedef struct elf_prstatus prstatus_t;
+typedef struct elf_prpsinfo prpsinfo_t;
+
+#ifdef __cplusplus
+}
+#endif
+#endif
diff --git a/third_party/musl/porting/liteos_m/kernel/include/sys/ptrace.h b/third_party/musl/porting/liteos_m/kernel/include/sys/ptrace.h
new file mode 100755
index 000000000..5d62a9859
--- /dev/null
+++ b/third_party/musl/porting/liteos_m/kernel/include/sys/ptrace.h
@@ -0,0 +1,138 @@
+#ifndef _SYS_PTRACE_H
+#define _SYS_PTRACE_H
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#include <stdint.h>
+
+#define PTRACE_TRACEME 0
+#define PT_TRACE_ME PTRACE_TRACEME
+
+#define PTRACE_PEEKTEXT 1
+#define PTRACE_PEEKDATA 2
+#define PTRACE_PEEKUSER 3
+#define PTRACE_POKETEXT 4
+#define PTRACE_POKEDATA 5
+#define PTRACE_POKEUSER 6
+#define PTRACE_CONT 7
+#define PTRACE_KILL 8
+#define PTRACE_SINGLESTEP 9
+#define PTRACE_GETREGS 12
+#define PTRACE_SETREGS 13
+#define PTRACE_GETFPREGS 14
+#define PTRACE_SETFPREGS 15
+#define PTRACE_ATTACH 16
+#define PTRACE_DETACH 17
+#define PTRACE_GETFPXREGS 18
+#define PTRACE_SETFPXREGS 19
+#define PTRACE_SYSCALL 24
+#define PTRACE_SETOPTIONS 0x4200
+#define PTRACE_GETEVENTMSG 0x4201
+#define PTRACE_GETSIGINFO 0x4202
+#define PTRACE_SETSIGINFO 0x4203
+#define PTRACE_GETREGSET 0x4204
+#define PTRACE_SETREGSET 0x4205
+#define PTRACE_SEIZE 0x4206
+#define PTRACE_INTERRUPT 0x4207
+#define PTRACE_LISTEN 0x4208
+#define PTRACE_PEEKSIGINFO 0x4209
+#define PTRACE_GETSIGMASK 0x420a
+#define PTRACE_SETSIGMASK 0x420b
+#define PTRACE_SECCOMP_GET_FILTER 0x420c
+#define PTRACE_SECCOMP_GET_METADATA 0x420d
+#define PTRACE_GET_SYSCALL_INFO 0x420e
+
+#define PT_READ_I PTRACE_PEEKTEXT
+#define PT_READ_D PTRACE_PEEKDATA
+#define PT_READ_U PTRACE_PEEKUSER
+#define PT_WRITE_I PTRACE_POKETEXT
+#define PT_WRITE_D PTRACE_POKEDATA
+#define PT_WRITE_U PTRACE_POKEUSER
+#define PT_CONTINUE PTRACE_CONT
+#define PT_KILL PTRACE_KILL
+#define PT_STEP PTRACE_SINGLESTEP
+#define PT_GETREGS PTRACE_GETREGS
+#define PT_SETREGS PTRACE_SETREGS
+#define PT_GETFPREGS PTRACE_GETFPREGS
+#define PT_SETFPREGS PTRACE_SETFPREGS
+#define PT_ATTACH PTRACE_ATTACH
+#define PT_DETACH PTRACE_DETACH
+#define PT_GETFPXREGS PTRACE_GETFPXREGS
+#define PT_SETFPXREGS PTRACE_SETFPXREGS
+#define PT_SYSCALL PTRACE_SYSCALL
+#define PT_SETOPTIONS PTRACE_SETOPTIONS
+#define PT_GETEVENTMSG PTRACE_GETEVENTMSG
+#define PT_GETSIGINFO PTRACE_GETSIGINFO
+#define PT_SETSIGINFO PTRACE_SETSIGINFO
+
+#define PTRACE_O_TRACESYSGOOD   0x00000001
+#define PTRACE_O_TRACEFORK      0x00000002
+#define PTRACE_O_TRACEVFORK     0x00000004
+#define PTRACE_O_TRACECLONE     0x00000008
+#define PTRACE_O_TRACEEXEC      0x00000010
+#define PTRACE_O_TRACEVFORKDONE 0x00000020
+#define PTRACE_O_TRACEEXIT      0x00000040
+#define PTRACE_O_TRACESECCOMP   0x00000080
+#define PTRACE_O_EXITKILL       0x00100000
+#define PTRACE_O_SUSPEND_SECCOMP 0x00200000
+#define PTRACE_O_MASK           0x003000ff
+
+#define PTRACE_EVENT_FORK 1
+#define PTRACE_EVENT_VFORK 2
+#define PTRACE_EVENT_CLONE 3
+#define PTRACE_EVENT_EXEC 4
+#define PTRACE_EVENT_VFORK_DONE 5
+#define PTRACE_EVENT_EXIT 6
+#define PTRACE_EVENT_SECCOMP 7
+#define PTRACE_EVENT_STOP 128
+
+#define PTRACE_PEEKSIGINFO_SHARED 1
+
+#define PTRACE_SYSCALL_INFO_NONE 0
+#define PTRACE_SYSCALL_INFO_ENTRY 1
+#define PTRACE_SYSCALL_INFO_EXIT 2
+#define PTRACE_SYSCALL_INFO_SECCOMP 3
+
+#include <bits/ptrace.h>
+
+struct __ptrace_peeksiginfo_args {
+	uint64_t off;
+	uint32_t flags;
+	int32_t nr;
+};
+
+struct __ptrace_seccomp_metadata {
+	uint64_t filter_off;
+	uint64_t flags;
+};
+
+struct __ptrace_syscall_info {
+	uint8_t op;
+	uint8_t __pad[3];
+	uint32_t arch;
+	uint64_t instruction_pointer;
+	uint64_t stack_pointer;
+	union {
+		struct {
+			uint64_t nr;
+			uint64_t args[6];
+		} entry;
+		struct {
+			int64_t rval;
+			uint8_t is_error;
+		} exit;
+		struct {
+			uint64_t nr;
+			uint64_t args[6];
+			uint32_t ret_data;
+		} seccomp;
+	};
+};
+
+long ptrace(int, ...);
+
+#ifdef __cplusplus
+}
+#endif
+#endif
diff --git a/third_party/musl/porting/liteos_m/kernel/include/sys/quota.h b/third_party/musl/porting/liteos_m/kernel/include/sys/quota.h
new file mode 100755
index 000000000..3ed73785d
--- /dev/null
+++ b/third_party/musl/porting/liteos_m/kernel/include/sys/quota.h
@@ -0,0 +1,102 @@
+#ifndef _SYS_QUOTA_H
+#define _SYS_QUOTA_H
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#include <stdint.h>
+
+#define _LINUX_QUOTA_VERSION 2
+
+#define dbtob(num) ((num) << 10)
+#define btodb(num) ((num) >> 10)
+#define fs_to_dq_blocks(num, blksize) (((num) * (blksize)) / 1024)
+
+#define MAX_IQ_TIME 604800
+#define MAX_DQ_TIME 604800
+
+#define MAXQUOTAS 2
+#define USRQUOTA  0
+#define GRPQUOTA  1
+
+#define INITQFNAMES { "user", "group", "undefined" };
+
+#define QUOTAFILENAME "quota"
+#define QUOTAGROUP "staff"
+
+#define NR_DQHASH 43
+#define NR_DQUOTS 256
+
+#define SUBCMDMASK       0x00ff
+#define SUBCMDSHIFT      8
+#define QCMD(cmd, type)  (((cmd) << SUBCMDSHIFT) | ((type) & SUBCMDMASK))
+
+#define Q_SYNC     0x800001
+#define Q_QUOTAON  0x800002
+#define Q_QUOTAOFF 0x800003
+#define Q_GETFMT   0x800004
+#define Q_GETINFO  0x800005
+#define Q_SETINFO  0x800006
+#define Q_GETQUOTA 0x800007
+#define Q_SETQUOTA 0x800008
+
+#define	QFMT_VFS_OLD 1
+#define	QFMT_VFS_V0 2
+#define QFMT_OCFS2 3
+#define	QFMT_VFS_V1 4
+
+#define QIF_BLIMITS	1
+#define QIF_SPACE	2
+#define QIF_ILIMITS	4
+#define QIF_INODES	8
+#define QIF_BTIME	16
+#define QIF_ITIME	32
+#define QIF_LIMITS	(QIF_BLIMITS | QIF_ILIMITS)
+#define QIF_USAGE	(QIF_SPACE | QIF_INODES)
+#define QIF_TIMES	(QIF_BTIME | QIF_ITIME)
+#define QIF_ALL		(QIF_LIMITS | QIF_USAGE | QIF_TIMES)
+
+struct dqblk {
+	uint64_t dqb_bhardlimit;
+	uint64_t dqb_bsoftlimit;
+	uint64_t dqb_curspace;
+	uint64_t dqb_ihardlimit;
+	uint64_t dqb_isoftlimit;
+	uint64_t dqb_curinodes;
+	uint64_t dqb_btime;
+	uint64_t dqb_itime;
+	uint32_t dqb_valid;
+};
+
+#define	dq_bhardlimit	dq_dqb.dqb_bhardlimit
+#define	dq_bsoftlimit	dq_dqb.dqb_bsoftlimit
+#define dq_curspace	dq_dqb.dqb_curspace
+#define dq_valid	dq_dqb.dqb_valid
+#define	dq_ihardlimit	dq_dqb.dqb_ihardlimit
+#define	dq_isoftlimit	dq_dqb.dqb_isoftlimit
+#define	dq_curinodes	dq_dqb.dqb_curinodes
+#define	dq_btime	dq_dqb.dqb_btime
+#define	dq_itime	dq_dqb.dqb_itime
+
+#define dqoff(UID)      ((long long)(UID) * sizeof (struct dqblk))
+
+#define IIF_BGRACE	1
+#define IIF_IGRACE	2
+#define IIF_FLAGS	4
+#define IIF_ALL		(IIF_BGRACE | IIF_IGRACE | IIF_FLAGS)
+
+struct dqinfo {
+	uint64_t dqi_bgrace;
+	uint64_t dqi_igrace;
+	uint32_t dqi_flags;
+	uint32_t dqi_valid;
+};
+
+int quotactl(int, const char *, int, char *);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
diff --git a/third_party/musl/porting/liteos_m/kernel/include/sys/random.h b/third_party/musl/porting/liteos_m/kernel/include/sys/random.h
new file mode 100755
index 000000000..4ee7bf2cc
--- /dev/null
+++ b/third_party/musl/porting/liteos_m/kernel/include/sys/random.h
@@ -0,0 +1,19 @@
+#ifndef _SYS_RANDOM_H
+#define _SYS_RANDOM_H
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#define __NEED_size_t
+#define __NEED_ssize_t
+#include <bits/alltypes.h>
+
+#define GRND_NONBLOCK	0x0001
+#define GRND_RANDOM	0x0002
+
+ssize_t getrandom(void *, size_t, unsigned);
+
+#ifdef __cplusplus
+}
+#endif
+#endif
diff --git a/third_party/musl/porting/liteos_m/kernel/include/sys/reboot.h b/third_party/musl/porting/liteos_m/kernel/include/sys/reboot.h
new file mode 100755
index 000000000..9702eddba
--- /dev/null
+++ b/third_party/musl/porting/liteos_m/kernel/include/sys/reboot.h
@@ -0,0 +1,20 @@
+#ifndef _SYS_REBOOT_H
+#define _SYS_REBOOT_H
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#define RB_AUTOBOOT     0x01234567
+#define RB_HALT_SYSTEM  0xcdef0123
+#define RB_ENABLE_CAD   0x89abcdef
+#define RB_DISABLE_CAD  0
+#define RB_POWER_OFF    0x4321fedc
+#define RB_SW_SUSPEND   0xd000fce2
+#define RB_KEXEC        0x45584543
+
+int reboot(int);
+
+#ifdef __cplusplus
+}
+#endif
+#endif
diff --git a/third_party/musl/porting/liteos_m/kernel/include/sys/reg.h b/third_party/musl/porting/liteos_m/kernel/include/sys/reg.h
new file mode 100755
index 000000000..b47452d00
--- /dev/null
+++ b/third_party/musl/porting/liteos_m/kernel/include/sys/reg.h
@@ -0,0 +1,9 @@
+#ifndef _SYS_REG_H
+#define _SYS_REG_H
+
+#include <limits.h>
+#include <unistd.h>
+
+#include <bits/reg.h>
+
+#endif
diff --git a/third_party/musl/porting/liteos_m/kernel/include/sys/resource.h b/third_party/musl/porting/liteos_m/kernel/include/sys/resource.h
new file mode 100755
index 000000000..dc5f52d9e
--- /dev/null
+++ b/third_party/musl/porting/liteos_m/kernel/include/sys/resource.h
@@ -0,0 +1,116 @@
+#ifndef	_SYS_RESOURCE_H
+#define	_SYS_RESOURCE_H
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#include <features.h>
+#include <sys/time.h>
+
+#define __NEED_id_t
+
+#ifdef _GNU_SOURCE
+#define __NEED_pid_t
+#endif
+
+#include <bits/alltypes.h>
+#include <bits/resource.h>
+
+typedef unsigned long long rlim_t;
+
+struct rlimit {
+	rlim_t rlim_cur;
+	rlim_t rlim_max;
+};
+
+struct rusage {
+	struct timeval ru_utime;
+	struct timeval ru_stime;
+	/* linux extensions, but useful */
+	long	ru_maxrss;
+	long	ru_ixrss;
+	long	ru_idrss;
+	long	ru_isrss;
+	long	ru_minflt;
+	long	ru_majflt;
+	long	ru_nswap;
+	long	ru_inblock;
+	long	ru_oublock;
+	long	ru_msgsnd;
+	long	ru_msgrcv;
+	long	ru_nsignals;
+	long	ru_nvcsw;
+	long	ru_nivcsw;
+	/* room for more... */
+	long    __reserved[16];
+};
+
+int getrlimit (int, struct rlimit *);
+int setrlimit (int, const struct rlimit *);
+int getrusage (int, struct rusage *);
+
+int getpriority (int, id_t);
+int setpriority (int, id_t, int);
+
+#ifdef _GNU_SOURCE
+int prlimit(pid_t, int, const struct rlimit *, struct rlimit *);
+#define prlimit64 prlimit
+#endif
+
+#define PRIO_MIN (-20)
+#define PRIO_MAX 20
+
+#define PRIO_PROCESS 0
+#define PRIO_PGRP    1
+#define PRIO_USER    2
+
+#define RUSAGE_SELF     0
+#define RUSAGE_CHILDREN (-1)
+#define RUSAGE_THREAD   1
+
+#define RLIM_INFINITY (~0ULL)
+#define RLIM_SAVED_CUR RLIM_INFINITY
+#define RLIM_SAVED_MAX RLIM_INFINITY
+
+#define RLIMIT_CPU     0
+#define RLIMIT_FSIZE   1
+#define RLIMIT_DATA    2
+#define RLIMIT_STACK   3
+#define RLIMIT_CORE    4
+#ifndef RLIMIT_RSS
+#define RLIMIT_RSS     5
+#define RLIMIT_NPROC   6
+#define RLIMIT_NOFILE  7
+#define RLIMIT_MEMLOCK 8
+#define RLIMIT_AS      9
+#endif
+#define RLIMIT_LOCKS   10
+#define RLIMIT_SIGPENDING 11
+#define RLIMIT_MSGQUEUE 12
+#define RLIMIT_NICE    13
+#define RLIMIT_RTPRIO  14
+#define RLIMIT_RTTIME  15
+#define RLIMIT_NLIMITS 16
+
+#define RLIM_NLIMITS RLIMIT_NLIMITS
+
+#if defined(_LARGEFILE64_SOURCE) || defined(_GNU_SOURCE)
+#define RLIM64_INFINITY RLIM_INFINITY
+#define RLIM64_SAVED_CUR RLIM_SAVED_CUR
+#define RLIM64_SAVED_MAX RLIM_SAVED_MAX
+#define getrlimit64 getrlimit
+#define setrlimit64 setrlimit
+#define rlimit64 rlimit
+#define rlim64_t rlim_t
+#endif
+
+#if _REDIR_TIME64
+__REDIR(getrusage, __getrusage_time64);
+#endif
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
diff --git a/third_party/musl/porting/liteos_m/kernel/include/sys/select.h b/third_party/musl/porting/liteos_m/kernel/include/sys/select.h
new file mode 100755
index 000000000..b3bab1d57
--- /dev/null
+++ b/third_party/musl/porting/liteos_m/kernel/include/sys/select.h
@@ -0,0 +1,46 @@
+#ifndef _SYS_SELECT_H
+#define _SYS_SELECT_H
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#include <features.h>
+
+#define __NEED_size_t
+#define __NEED_time_t
+#define __NEED_suseconds_t
+#define __NEED_struct_timeval
+#define __NEED_struct_timespec
+#define __NEED_sigset_t
+
+#include <bits/alltypes.h>
+
+#define FD_SETSIZE 1024
+
+typedef unsigned long fd_mask;
+
+typedef struct {
+	unsigned long fds_bits[FD_SETSIZE / 8 / sizeof(long)];
+} fd_set;
+
+#define FD_ZERO(s) do { int __i; unsigned long *__b=(s)->fds_bits; for(__i=sizeof (fd_set)/sizeof (long); __i; __i--) *__b++=0; } while(0)
+#define FD_SET(d, s)   ((s)->fds_bits[(d)/(8*sizeof(long))] |= (1UL<<((d)%(8*sizeof(long)))))
+#define FD_CLR(d, s)   ((s)->fds_bits[(d)/(8*sizeof(long))] &= ~(1UL<<((d)%(8*sizeof(long)))))
+#define FD_ISSET(d, s) !!((s)->fds_bits[(d)/(8*sizeof(long))] & (1UL<<((d)%(8*sizeof(long)))))
+
+int select (int, fd_set *__restrict, fd_set *__restrict, fd_set *__restrict, struct timeval *__restrict);
+int pselect (int, fd_set *__restrict, fd_set *__restrict, fd_set *__restrict, const struct timespec *__restrict, const sigset_t *__restrict);
+
+#if defined(_GNU_SOURCE) || defined(_BSD_SOURCE)
+#define NFDBITS (8*(int)sizeof(long))
+#endif
+
+#if _REDIR_TIME64
+__REDIR(select, __select_time64);
+__REDIR(pselect, __pselect_time64);
+#endif
+
+#ifdef __cplusplus
+}
+#endif
+#endif
diff --git a/third_party/musl/porting/liteos_m/kernel/include/sys/sem.h b/third_party/musl/porting/liteos_m/kernel/include/sys/sem.h
new file mode 100755
index 000000000..a747784ed
--- /dev/null
+++ b/third_party/musl/porting/liteos_m/kernel/include/sys/sem.h
@@ -0,0 +1,72 @@
+#ifndef _SYS_SEM_H
+#define _SYS_SEM_H
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#include <features.h>
+
+#define __NEED_size_t
+#define __NEED_pid_t
+#define __NEED_time_t
+#ifdef _GNU_SOURCE
+#define __NEED_struct_timespec
+#endif
+#include <bits/alltypes.h>
+
+#include <sys/ipc.h>
+
+#define SEM_UNDO	0x1000
+#define GETPID		11
+#define GETVAL		12
+#define GETALL		13
+#define GETNCNT		14
+#define GETZCNT		15
+#define SETVAL		16
+#define SETALL		17
+
+#include <bits/sem.h>
+
+#define _SEM_SEMUN_UNDEFINED 1
+
+#define SEM_STAT (18 | (IPC_STAT & 0x100))
+#define SEM_INFO 19
+#define SEM_STAT_ANY (20 | (IPC_STAT & 0x100))
+
+struct  seminfo {
+	int semmap;
+	int semmni;
+	int semmns;
+	int semmnu;
+	int semmsl;
+	int semopm;
+	int semume;
+	int semusz;
+	int semvmx;
+	int semaem;
+};
+
+struct sembuf {
+	unsigned short sem_num;
+	short sem_op;
+	short sem_flg;
+};
+
+int semctl(int, int, int, ...);
+int semget(key_t, int, int);
+int semop(int, struct sembuf *, size_t);
+
+#ifdef _GNU_SOURCE
+int semtimedop(int, struct sembuf *, size_t, const struct timespec *);
+#endif
+
+#if _REDIR_TIME64
+#ifdef _GNU_SOURCE
+__REDIR(semtimedop, __semtimedop_time64);
+#endif
+#endif
+
+#ifdef __cplusplus
+}
+#endif
+#endif
diff --git a/third_party/musl/porting/liteos_m/kernel/include/sys/sendfile.h b/third_party/musl/porting/liteos_m/kernel/include/sys/sendfile.h
new file mode 100755
index 000000000..e7570d8e5
--- /dev/null
+++ b/third_party/musl/porting/liteos_m/kernel/include/sys/sendfile.h
@@ -0,0 +1,22 @@
+#ifndef _SYS_SENDFILE_H
+#define _SYS_SENDFILE_H
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#include <features.h>
+#include <unistd.h>
+
+ssize_t sendfile(int, int, off_t *, size_t);
+
+#if defined(_LARGEFILE64_SOURCE) || defined(_GNU_SOURCE)
+#define sendfile64 sendfile
+#define off64_t off_t
+#endif
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
diff --git a/third_party/musl/porting/liteos_m/kernel/include/sys/shm.h b/third_party/musl/porting/liteos_m/kernel/include/sys/shm.h
new file mode 100755
index 000000000..fd708cab1
--- /dev/null
+++ b/third_party/musl/porting/liteos_m/kernel/include/sys/shm.h
@@ -0,0 +1,70 @@
+#ifndef _SYS_SHM_H
+#define _SYS_SHM_H
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#include <features.h>
+
+#define __NEED_time_t
+#define __NEED_size_t
+#define __NEED_pid_t
+
+#include <bits/alltypes.h>
+
+#include <sys/ipc.h>
+
+#ifdef _GNU_SOURCE
+#define __used_ids used_ids
+#define __swap_attempts swap_attempts
+#define __swap_successes swap_successes
+#endif
+
+#include <bits/shm.h>
+
+#define SHM_R 0400
+#define SHM_W 0200
+
+#define SHM_RDONLY 010000
+#define SHM_RND    020000
+#define SHM_REMAP  040000
+#define SHM_EXEC   0100000
+
+#define SHM_LOCK 11
+#define SHM_UNLOCK 12
+#define SHM_STAT (13 | (IPC_STAT & 0x100))
+#define SHM_INFO 14
+#define SHM_STAT_ANY (15 | (IPC_STAT & 0x100))
+#define SHM_DEST 01000
+#define SHM_LOCKED 02000
+#define SHM_HUGETLB 04000
+#define SHM_NORESERVE 010000
+
+#define SHM_HUGE_SHIFT 26
+#define SHM_HUGE_MASK  0x3f
+#define SHM_HUGE_64KB  (16 << 26)
+#define SHM_HUGE_512KB (19 << 26)
+#define SHM_HUGE_1MB   (20 << 26)
+#define SHM_HUGE_2MB   (21 << 26)
+#define SHM_HUGE_8MB   (23 << 26)
+#define SHM_HUGE_16MB  (24 << 26)
+#define SHM_HUGE_32MB  (25 << 26)
+#define SHM_HUGE_256MB (28 << 26)
+#define SHM_HUGE_512MB (29 << 26)
+#define SHM_HUGE_1GB   (30 << 26)
+#define SHM_HUGE_2GB   (31 << 26)
+#define SHM_HUGE_16GB  (34U << 26)
+
+typedef unsigned long shmatt_t;
+
+void *shmat(int, const void *, int);
+int shmctl(int, int, struct shmid_ds *);
+int shmdt(const void *);
+int shmget(key_t, size_t, int);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
diff --git a/third_party/musl/porting/liteos_m/kernel/include/sys/signal.h b/third_party/musl/porting/liteos_m/kernel/include/sys/signal.h
new file mode 100755
index 000000000..45bdcc648
--- /dev/null
+++ b/third_party/musl/porting/liteos_m/kernel/include/sys/signal.h
@@ -0,0 +1,2 @@
+#warning redirecting incorrect #include <sys/signal.h> to <signal.h>
+#include <signal.h>
diff --git a/third_party/musl/porting/liteos_m/kernel/include/sys/signalfd.h b/third_party/musl/porting/liteos_m/kernel/include/sys/signalfd.h
new file mode 100755
index 000000000..e881e2cfd
--- /dev/null
+++ b/third_party/musl/porting/liteos_m/kernel/include/sys/signalfd.h
@@ -0,0 +1,49 @@
+#ifndef _SYS_SIGNALFD_H
+#define _SYS_SIGNALFD_H
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#include <stdint.h>
+#include <fcntl.h>
+
+#define __NEED_sigset_t
+
+#include <bits/alltypes.h>
+
+#define SFD_CLOEXEC O_CLOEXEC
+#define SFD_NONBLOCK O_NONBLOCK
+
+int signalfd(int, const sigset_t *, int);
+
+struct signalfd_siginfo {
+	uint32_t  ssi_signo;
+	int32_t   ssi_errno;
+	int32_t   ssi_code;
+	uint32_t  ssi_pid;
+	uint32_t  ssi_uid;
+	int32_t   ssi_fd;
+	uint32_t  ssi_tid;
+	uint32_t  ssi_band;
+	uint32_t  ssi_overrun;
+	uint32_t  ssi_trapno;
+	int32_t   ssi_status;
+	int32_t   ssi_int;
+	uint64_t  ssi_ptr;
+	uint64_t  ssi_utime;
+	uint64_t  ssi_stime;
+	uint64_t  ssi_addr;
+	uint16_t  ssi_addr_lsb;
+	uint16_t  __pad2;
+	int32_t   ssi_syscall;
+	uint64_t  ssi_call_addr;
+	uint32_t  ssi_arch;
+	uint8_t   __pad[128-14*4-5*8-2*2];
+};
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
diff --git a/third_party/musl/porting/liteos_m/kernel/include/sys/socket.h b/third_party/musl/porting/liteos_m/kernel/include/sys/socket.h
new file mode 100755
index 000000000..38f5bb17b
--- /dev/null
+++ b/third_party/musl/porting/liteos_m/kernel/include/sys/socket.h
@@ -0,0 +1,413 @@
+#ifndef	_SYS_SOCKET_H
+#define	_SYS_SOCKET_H
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#include <features.h>
+
+#define __NEED_socklen_t
+#define __NEED_sa_family_t
+#define __NEED_size_t
+#define __NEED_ssize_t
+#define __NEED_uid_t
+#define __NEED_pid_t
+#define __NEED_gid_t
+#define __NEED_struct_iovec
+
+#include <bits/alltypes.h>
+
+#include <bits/socket.h>
+
+struct msghdr {
+	void *msg_name;
+	socklen_t msg_namelen;
+	struct iovec *msg_iov;
+#if __LONG_MAX > 0x7fffffff && __BYTE_ORDER == __BIG_ENDIAN
+	int __pad1;
+#endif
+	int msg_iovlen;
+#if __LONG_MAX > 0x7fffffff && __BYTE_ORDER == __LITTLE_ENDIAN
+	int __pad1;
+#endif
+	void *msg_control;
+#if __LONG_MAX > 0x7fffffff && __BYTE_ORDER == __BIG_ENDIAN
+	int __pad2;
+#endif
+	socklen_t msg_controllen;
+#if __LONG_MAX > 0x7fffffff && __BYTE_ORDER == __LITTLE_ENDIAN
+	int __pad2;
+#endif
+	int msg_flags;
+};
+
+struct cmsghdr {
+#if __LONG_MAX > 0x7fffffff && __BYTE_ORDER == __BIG_ENDIAN
+	int __pad1;
+#endif
+	socklen_t cmsg_len;
+#if __LONG_MAX > 0x7fffffff && __BYTE_ORDER == __LITTLE_ENDIAN
+	int __pad1;
+#endif
+	int cmsg_level;
+	int cmsg_type;
+};
+
+#ifdef _GNU_SOURCE
+struct ucred {
+	pid_t pid;
+	uid_t uid;
+	gid_t gid;
+};
+
+struct mmsghdr {
+	struct msghdr msg_hdr;
+	unsigned int  msg_len;
+};
+
+struct timespec;
+
+int sendmmsg (int, struct mmsghdr *, unsigned int, unsigned int);
+int recvmmsg (int, struct mmsghdr *, unsigned int, unsigned int, struct timespec *);
+#endif
+
+struct linger {
+	int l_onoff;
+	int l_linger;
+};
+
+#define SHUT_RD 0
+#define SHUT_WR 1
+#define SHUT_RDWR 2
+
+#ifndef SOCK_STREAM
+#define SOCK_STREAM    1
+#define SOCK_DGRAM     2
+#endif
+
+#define SOCK_RAW       3
+#define SOCK_RDM       4
+#define SOCK_SEQPACKET 5
+#define SOCK_DCCP      6
+#define SOCK_PACKET    10
+
+#ifndef SOCK_CLOEXEC
+#define SOCK_CLOEXEC   02000000
+#define SOCK_NONBLOCK  04000
+#endif
+
+#define PF_UNSPEC       0
+#define PF_LOCAL        1
+#define PF_UNIX         PF_LOCAL
+#define PF_FILE         PF_LOCAL
+#define PF_INET         2
+#define PF_AX25         3
+#define PF_IPX          4
+#define PF_APPLETALK    5
+#define PF_NETROM       6
+#define PF_BRIDGE       7
+#define PF_ATMPVC       8
+#define PF_X25          9
+#define PF_INET6        10
+#define PF_ROSE         11
+#define PF_DECnet       12
+#define PF_NETBEUI      13
+#define PF_SECURITY     14
+#define PF_KEY          15
+#define PF_NETLINK      16
+#define PF_ROUTE        PF_NETLINK
+#define PF_PACKET       17
+#define PF_ASH          18
+#define PF_ECONET       19
+#define PF_ATMSVC       20
+#define PF_RDS          21
+#define PF_SNA          22
+#define PF_IRDA         23
+#define PF_PPPOX        24
+#define PF_WANPIPE      25
+#define PF_LLC          26
+#define PF_IB           27
+#define PF_MPLS         28
+#define PF_CAN          29
+#define PF_TIPC         30
+#define PF_BLUETOOTH    31
+#define PF_IUCV         32
+#define PF_RXRPC        33
+#define PF_ISDN         34
+#define PF_PHONET       35
+#define PF_IEEE802154   36
+#define PF_CAIF         37
+#define PF_ALG          38
+#define PF_NFC          39
+#define PF_VSOCK        40
+#define PF_KCM          41
+#define PF_QIPCRTR      42
+#define PF_SMC          43
+#define PF_XDP          44
+#define PF_MAX          45
+
+#define AF_UNSPEC       PF_UNSPEC
+#define AF_LOCAL        PF_LOCAL
+#define AF_UNIX         AF_LOCAL
+#define AF_FILE         AF_LOCAL
+#define AF_INET         PF_INET
+#define AF_AX25         PF_AX25
+#define AF_IPX          PF_IPX
+#define AF_APPLETALK    PF_APPLETALK
+#define AF_NETROM       PF_NETROM
+#define AF_BRIDGE       PF_BRIDGE
+#define AF_ATMPVC       PF_ATMPVC
+#define AF_X25          PF_X25
+#define AF_INET6        PF_INET6
+#define AF_ROSE         PF_ROSE
+#define AF_DECnet       PF_DECnet
+#define AF_NETBEUI      PF_NETBEUI
+#define AF_SECURITY     PF_SECURITY
+#define AF_KEY          PF_KEY
+#define AF_NETLINK      PF_NETLINK
+#define AF_ROUTE        PF_ROUTE
+#define AF_PACKET       PF_PACKET
+#define AF_ASH          PF_ASH
+#define AF_ECONET       PF_ECONET
+#define AF_ATMSVC       PF_ATMSVC
+#define AF_RDS          PF_RDS
+#define AF_SNA          PF_SNA
+#define AF_IRDA         PF_IRDA
+#define AF_PPPOX        PF_PPPOX
+#define AF_WANPIPE      PF_WANPIPE
+#define AF_LLC          PF_LLC
+#define AF_IB           PF_IB
+#define AF_MPLS         PF_MPLS
+#define AF_CAN          PF_CAN
+#define AF_TIPC         PF_TIPC
+#define AF_BLUETOOTH    PF_BLUETOOTH
+#define AF_IUCV         PF_IUCV
+#define AF_RXRPC        PF_RXRPC
+#define AF_ISDN         PF_ISDN
+#define AF_PHONET       PF_PHONET
+#define AF_IEEE802154   PF_IEEE802154
+#define AF_CAIF         PF_CAIF
+#define AF_ALG          PF_ALG
+#define AF_NFC          PF_NFC
+#define AF_VSOCK        PF_VSOCK
+#define AF_KCM          PF_KCM
+#define AF_QIPCRTR      PF_QIPCRTR
+#define AF_SMC          PF_SMC
+#define AF_XDP          PF_XDP
+#define AF_MAX          PF_MAX
+
+#ifndef SO_DEBUG
+#define SO_DEBUG        1
+#define SO_REUSEADDR    2
+#define SO_TYPE         3
+#define SO_ERROR        4
+#define SO_DONTROUTE    5
+#define SO_BROADCAST    6
+#define SO_SNDBUF       7
+#define SO_RCVBUF       8
+#define SO_KEEPALIVE    9
+#define SO_OOBINLINE    10
+#define SO_NO_CHECK     11
+#define SO_PRIORITY     12
+#define SO_LINGER       13
+#define SO_BSDCOMPAT    14
+#define SO_REUSEPORT    15
+#define SO_PASSCRED     16
+#define SO_PEERCRED     17
+#define SO_RCVLOWAT     18
+#define SO_SNDLOWAT     19
+#define SO_ACCEPTCONN   30
+#define SO_PEERSEC      31
+#define SO_SNDBUFFORCE  32
+#define SO_RCVBUFFORCE  33
+#define SO_PROTOCOL     38
+#define SO_DOMAIN       39
+#endif
+
+#ifndef SO_RCVTIMEO
+#if __LONG_MAX == 0x7fffffff
+#define SO_RCVTIMEO     66
+#define SO_SNDTIMEO     67
+#else
+#define SO_RCVTIMEO     20
+#define SO_SNDTIMEO     21
+#endif
+#endif
+
+#ifndef SO_TIMESTAMP
+#if __LONG_MAX == 0x7fffffff
+#define SO_TIMESTAMP    63
+#define SO_TIMESTAMPNS  64
+#define SO_TIMESTAMPING 65
+#else
+#define SO_TIMESTAMP    29
+#define SO_TIMESTAMPNS  35
+#define SO_TIMESTAMPING 37
+#endif
+#endif
+
+#define SO_SECURITY_AUTHENTICATION              22
+#define SO_SECURITY_ENCRYPTION_TRANSPORT        23
+#define SO_SECURITY_ENCRYPTION_NETWORK          24
+
+#define SO_BINDTODEVICE 25
+
+#define SO_ATTACH_FILTER        26
+#define SO_DETACH_FILTER        27
+#define SO_GET_FILTER           SO_ATTACH_FILTER
+
+#define SO_PEERNAME             28
+#define SCM_TIMESTAMP           SO_TIMESTAMP
+#define SO_PASSSEC              34
+#define SCM_TIMESTAMPNS         SO_TIMESTAMPNS
+#define SO_MARK                 36
+#define SCM_TIMESTAMPING        SO_TIMESTAMPING
+#define SO_RXQ_OVFL             40
+#define SO_WIFI_STATUS          41
+#define SCM_WIFI_STATUS         SO_WIFI_STATUS
+#define SO_PEEK_OFF             42
+#define SO_NOFCS                43
+#define SO_LOCK_FILTER          44
+#define SO_SELECT_ERR_QUEUE     45
+#define SO_BUSY_POLL            46
+#define SO_MAX_PACING_RATE      47
+#define SO_BPF_EXTENSIONS       48
+#define SO_INCOMING_CPU         49
+#define SO_ATTACH_BPF           50
+#define SO_DETACH_BPF           SO_DETACH_FILTER
+#define SO_ATTACH_REUSEPORT_CBPF 51
+#define SO_ATTACH_REUSEPORT_EBPF 52
+#define SO_CNX_ADVICE           53
+#define SCM_TIMESTAMPING_OPT_STATS 54
+#define SO_MEMINFO              55
+#define SO_INCOMING_NAPI_ID     56
+#define SO_COOKIE               57
+#define SCM_TIMESTAMPING_PKTINFO 58
+#define SO_PEERGROUPS           59
+#define SO_ZEROCOPY             60
+#define SO_TXTIME               61
+#define SCM_TXTIME              SO_TXTIME
+#define SO_BINDTOIFINDEX        62
+#define SO_DETACH_REUSEPORT_BPF 68
+
+#ifndef SOL_SOCKET
+#define SOL_SOCKET      1
+#endif
+
+#define SOL_IP          0
+#define SOL_IPV6        41
+#define SOL_ICMPV6      58
+
+#define SOL_RAW         255
+#define SOL_DECNET      261
+#define SOL_X25         262
+#define SOL_PACKET      263
+#define SOL_ATM         264
+#define SOL_AAL         265
+#define SOL_IRDA        266
+#define SOL_NETBEUI     267
+#define SOL_LLC         268
+#define SOL_DCCP        269
+#define SOL_NETLINK     270
+#define SOL_TIPC        271
+#define SOL_RXRPC       272
+#define SOL_PPPOL2TP    273
+#define SOL_BLUETOOTH   274
+#define SOL_PNPIPE      275
+#define SOL_RDS         276
+#define SOL_IUCV        277
+#define SOL_CAIF        278
+#define SOL_ALG         279
+#define SOL_NFC         280
+#define SOL_KCM         281
+#define SOL_TLS         282
+#define SOL_XDP         283
+
+#define SOMAXCONN       128
+
+#define MSG_OOB       0x0001
+#define MSG_PEEK      0x0002
+#define MSG_DONTROUTE 0x0004
+#define MSG_CTRUNC    0x0008
+#define MSG_PROXY     0x0010
+#define MSG_TRUNC     0x0020
+#define MSG_DONTWAIT  0x0040
+#define MSG_EOR       0x0080
+#define MSG_WAITALL   0x0100
+#define MSG_FIN       0x0200
+#define MSG_SYN       0x0400
+#define MSG_CONFIRM   0x0800
+#define MSG_RST       0x1000
+#define MSG_ERRQUEUE  0x2000
+#define MSG_NOSIGNAL  0x4000
+#define MSG_MORE      0x8000
+#define MSG_WAITFORONE 0x10000
+#define MSG_BATCH     0x40000
+#define MSG_ZEROCOPY  0x4000000
+#define MSG_FASTOPEN  0x20000000
+#define MSG_CMSG_CLOEXEC 0x40000000
+
+#define __CMSG_LEN(cmsg) (((cmsg)->cmsg_len + sizeof(long) - 1) & ~(long)(sizeof(long) - 1))
+#define __CMSG_NEXT(cmsg) ((unsigned char *)(cmsg) + __CMSG_LEN(cmsg))
+#define __MHDR_END(mhdr) ((unsigned char *)(mhdr)->msg_control + (mhdr)->msg_controllen)
+
+#define CMSG_DATA(cmsg) ((unsigned char *) (((struct cmsghdr *)(cmsg)) + 1))
+#define CMSG_NXTHDR(mhdr, cmsg) ((cmsg)->cmsg_len < sizeof (struct cmsghdr) || \
+	__CMSG_LEN(cmsg) + sizeof(struct cmsghdr) >= __MHDR_END(mhdr) - (unsigned char *)(cmsg) \
+	? 0 : (struct cmsghdr *)__CMSG_NEXT(cmsg))
+#define CMSG_FIRSTHDR(mhdr) ((size_t) (mhdr)->msg_controllen >= sizeof (struct cmsghdr) ? (struct cmsghdr *) (mhdr)->msg_control : (struct cmsghdr *) 0)
+
+#define CMSG_ALIGN(len) (((len) + sizeof (size_t) - 1) & (size_t) ~(sizeof (size_t) - 1))
+#define CMSG_SPACE(len) (CMSG_ALIGN (len) + CMSG_ALIGN (sizeof (struct cmsghdr)))
+#define CMSG_LEN(len)   (CMSG_ALIGN (sizeof (struct cmsghdr)) + (len))
+
+#define SCM_RIGHTS      0x01
+#define SCM_CREDENTIALS 0x02
+
+struct sockaddr {
+	sa_family_t sa_family;
+	char sa_data[14];
+};
+
+struct sockaddr_storage {
+	sa_family_t ss_family;
+	char __ss_padding[128-sizeof(long)-sizeof(sa_family_t)];
+	unsigned long __ss_align;
+};
+
+int socket (int, int, int);
+int socketpair (int, int, int, int [2]);
+
+int shutdown (int, int);
+
+int bind (int, const struct sockaddr *, socklen_t);
+int connect (int, const struct sockaddr *, socklen_t);
+int listen (int, int);
+int accept (int, struct sockaddr *__restrict, socklen_t *__restrict);
+int accept4(int, struct sockaddr *__restrict, socklen_t *__restrict, int);
+
+int getsockname (int, struct sockaddr *__restrict, socklen_t *__restrict);
+int getpeername (int, struct sockaddr *__restrict, socklen_t *__restrict);
+
+ssize_t send (int, const void *, size_t, int);
+ssize_t recv (int, void *, size_t, int);
+ssize_t sendto (int, const void *, size_t, int, const struct sockaddr *, socklen_t);
+ssize_t recvfrom (int, void *__restrict, size_t, int, struct sockaddr *__restrict, socklen_t *__restrict);
+ssize_t sendmsg (int, const struct msghdr *, int);
+ssize_t recvmsg (int, struct msghdr *, int);
+
+int getsockopt (int, int, int, void *__restrict, socklen_t *__restrict);
+int setsockopt (int, int, int, const void *, socklen_t);
+
+int sockatmark (int);
+
+#if _REDIR_TIME64
+#ifdef _GNU_SOURCE
+__REDIR(recvmmsg, __recvmmsg_time64);
+#endif
+#endif
+
+#ifdef __cplusplus
+}
+#endif
+#endif
diff --git a/third_party/musl/porting/liteos_m/kernel/include/sys/soundcard.h b/third_party/musl/porting/liteos_m/kernel/include/sys/soundcard.h
new file mode 100755
index 000000000..5ca776461
--- /dev/null
+++ b/third_party/musl/porting/liteos_m/kernel/include/sys/soundcard.h
@@ -0,0 +1 @@
+#include <bits/soundcard.h>
diff --git a/third_party/musl/porting/liteos_m/kernel/include/sys/stat.h b/third_party/musl/porting/liteos_m/kernel/include/sys/stat.h
new file mode 100755
index 000000000..10d446c46
--- /dev/null
+++ b/third_party/musl/porting/liteos_m/kernel/include/sys/stat.h
@@ -0,0 +1,127 @@
+#ifndef	_SYS_STAT_H
+#define	_SYS_STAT_H
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#include <features.h>
+
+#define __NEED_dev_t
+#define __NEED_ino_t
+#define __NEED_mode_t
+#define __NEED_nlink_t
+#define __NEED_uid_t
+#define __NEED_gid_t
+#define __NEED_off_t
+#define __NEED_time_t
+#define __NEED_blksize_t
+#define __NEED_blkcnt_t
+#define __NEED_struct_timespec
+
+#include <bits/alltypes.h>
+
+#include <bits/stat.h>
+
+#define st_atime st_atim.tv_sec
+#define st_mtime st_mtim.tv_sec
+#define st_ctime st_ctim.tv_sec
+
+#define S_IFMT  0170000
+
+#define S_IFDIR 0040000
+#define S_IFCHR 0020000
+#define S_IFBLK 0060000
+#define S_IFREG 0100000
+#define S_IFIFO 0010000
+#define S_IFLNK 0120000
+#define S_IFSOCK 0140000
+
+#define S_TYPEISMQ(buf)  0
+#define S_TYPEISSEM(buf) 0
+#define S_TYPEISSHM(buf) 0
+#define S_TYPEISTMO(buf) 0
+
+#define S_ISDIR(mode)  (((mode) & S_IFMT) == S_IFDIR)
+#define S_ISCHR(mode)  (((mode) & S_IFMT) == S_IFCHR)
+#define S_ISBLK(mode)  (((mode) & S_IFMT) == S_IFBLK)
+#define S_ISREG(mode)  (((mode) & S_IFMT) == S_IFREG)
+#define S_ISFIFO(mode) (((mode) & S_IFMT) == S_IFIFO)
+#define S_ISLNK(mode)  (((mode) & S_IFMT) == S_IFLNK)
+#define S_ISSOCK(mode) (((mode) & S_IFMT) == S_IFSOCK)
+
+#ifndef S_IRUSR
+#define S_ISUID 04000
+#define S_ISGID 02000
+#define S_ISVTX 01000
+#define S_IRUSR 0400
+#define S_IWUSR 0200
+#define S_IXUSR 0100
+#define S_IRWXU 0700
+#define S_IRGRP 0040
+#define S_IWGRP 0020
+#define S_IXGRP 0010
+#define S_IRWXG 0070
+#define S_IROTH 0004
+#define S_IWOTH 0002
+#define S_IXOTH 0001
+#define S_IRWXO 0007
+#endif
+
+#define UTIME_NOW  0x3fffffff
+#define UTIME_OMIT 0x3ffffffe
+
+int stat(const char *__restrict, struct stat *__restrict);
+int fstat(int, struct stat *);
+int lstat(const char *__restrict, struct stat *__restrict);
+int fstatat(int, const char *__restrict, struct stat *__restrict, int);
+int chmod(const char *, mode_t);
+int fchmod(int, mode_t);
+int fchmodat(int, const char *, mode_t, int);
+mode_t umask(mode_t);
+int mkdir(const char *, mode_t);
+int mkfifo(const char *, mode_t);
+int mkdirat(int, const char *, mode_t);
+int mkfifoat(int, const char *, mode_t);
+
+#if defined(_XOPEN_SOURCE) || defined(_GNU_SOURCE) || defined(_BSD_SOURCE)
+int mknod(const char *, mode_t, dev_t);
+int mknodat(int, const char *, mode_t, dev_t);
+#endif
+
+int futimens(int, const struct timespec [2]);
+int utimensat(int, const char *, const struct timespec [2], int);
+
+#if defined(_GNU_SOURCE) || defined(_BSD_SOURCE)
+int lchmod(const char *, mode_t);
+#define S_IREAD S_IRUSR
+#define S_IWRITE S_IWUSR
+#define S_IEXEC S_IXUSR
+#endif
+
+#if defined(_LARGEFILE64_SOURCE) || defined(_GNU_SOURCE)
+#define stat64 stat
+#define fstat64 fstat
+#define lstat64 lstat
+#define fstatat64 fstatat
+#define blkcnt64_t blkcnt_t
+#define fsblkcnt64_t fsblkcnt_t
+#define fsfilcnt64_t fsfilcnt_t
+#define ino64_t ino_t
+#define off64_t off_t
+#endif
+
+#if _REDIR_TIME64
+__REDIR(stat, __stat_time64);
+__REDIR(fstat, __fstat_time64);
+__REDIR(lstat, __lstat_time64);
+__REDIR(fstatat, __fstatat_time64);
+__REDIR(futimens, __futimens_time64);
+__REDIR(utimensat, __utimensat_time64);
+#endif
+
+#ifdef __cplusplus
+}
+#endif
+#endif
+
+
diff --git a/third_party/musl/porting/liteos_m/kernel/include/sys/statfs.h b/third_party/musl/porting/liteos_m/kernel/include/sys/statfs.h
new file mode 100755
index 000000000..6f4c6230f
--- /dev/null
+++ b/third_party/musl/porting/liteos_m/kernel/include/sys/statfs.h
@@ -0,0 +1,32 @@
+#ifndef	_SYS_STATFS_H
+#define	_SYS_STATFS_H
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#include <features.h>
+
+#include <sys/statvfs.h>
+
+typedef struct __fsid_t {
+	int __val[2];
+} fsid_t;
+
+#include <bits/statfs.h>
+
+int statfs (const char *, struct statfs *);
+int fstatfs (int, struct statfs *);
+
+#if defined(_LARGEFILE64_SOURCE) || defined(_GNU_SOURCE)
+#define statfs64 statfs
+#define fstatfs64 fstatfs
+#define fsblkcnt64_t fsblkcnt_t
+#define fsfilcnt64_t fsfilcnt_t
+#endif
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
diff --git a/third_party/musl/porting/liteos_m/kernel/include/sys/statvfs.h b/third_party/musl/porting/liteos_m/kernel/include/sys/statvfs.h
new file mode 100755
index 000000000..793490b6d
--- /dev/null
+++ b/third_party/musl/porting/liteos_m/kernel/include/sys/statvfs.h
@@ -0,0 +1,56 @@
+#ifndef	_SYS_STATVFS_H
+#define	_SYS_STATVFS_H
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#include <features.h>
+
+#define __NEED_fsblkcnt_t
+#define __NEED_fsfilcnt_t
+#include <bits/alltypes.h>
+
+struct statvfs {
+	unsigned long f_bsize, f_frsize;
+	fsblkcnt_t f_blocks, f_bfree, f_bavail;
+	fsfilcnt_t f_files, f_ffree, f_favail;
+#if __BYTE_ORDER == __LITTLE_ENDIAN
+	unsigned long f_fsid;
+	unsigned :8*(2*sizeof(int)-sizeof(long));
+#else
+	unsigned :8*(2*sizeof(int)-sizeof(long));
+	unsigned long f_fsid;
+#endif
+	unsigned long f_flag, f_namemax;
+	int __reserved[6];
+};
+
+int statvfs (const char *__restrict, struct statvfs *__restrict);
+int fstatvfs (int, struct statvfs *);
+
+#define ST_RDONLY 1
+#define ST_NOSUID 2
+#define ST_NODEV  4
+#define ST_NOEXEC 8
+#define ST_SYNCHRONOUS 16
+#define ST_MANDLOCK    64
+#define ST_WRITE       128
+#define ST_APPEND      256
+#define ST_IMMUTABLE   512
+#define ST_NOATIME     1024
+#define ST_NODIRATIME  2048
+#define ST_RELATIME    4096
+
+#if defined(_LARGEFILE64_SOURCE) || defined(_GNU_SOURCE)
+#define statvfs64 statvfs
+#define fstatvfs64 fstatvfs
+#define fsblkcnt64_t fsblkcnt_t
+#define fsfilcnt64_t fsfilcnt_t
+#endif
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
diff --git a/third_party/musl/porting/liteos_m/kernel/include/sys/stropts.h b/third_party/musl/porting/liteos_m/kernel/include/sys/stropts.h
new file mode 100755
index 000000000..5b5bc02f4
--- /dev/null
+++ b/third_party/musl/porting/liteos_m/kernel/include/sys/stropts.h
@@ -0,0 +1 @@
+#include <stropts.h>
diff --git a/third_party/musl/porting/liteos_m/kernel/include/sys/swap.h b/third_party/musl/porting/liteos_m/kernel/include/sys/swap.h
new file mode 100755
index 000000000..11c0f9296
--- /dev/null
+++ b/third_party/musl/porting/liteos_m/kernel/include/sys/swap.h
@@ -0,0 +1,21 @@
+#ifndef _SYS_SWAP_H
+#define _SYS_SWAP_H
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+
+#define	SWAP_FLAG_PREFER        0x8000
+#define	SWAP_FLAG_PRIO_MASK     0x7fff
+#define	SWAP_FLAG_PRIO_SHIFT    0
+#define SWAP_FLAG_DISCARD       0x10000
+
+int swapon (const char *, int);
+int swapoff (const char *);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
diff --git a/third_party/musl/porting/liteos_m/kernel/include/sys/syscall.h b/third_party/musl/porting/liteos_m/kernel/include/sys/syscall.h
new file mode 100755
index 000000000..24987ddf2
--- /dev/null
+++ b/third_party/musl/porting/liteos_m/kernel/include/sys/syscall.h
@@ -0,0 +1,6 @@
+#ifndef _SYS_SYSCALL_H
+#define _SYS_SYSCALL_H
+
+#include <bits/syscall.h>
+
+#endif
diff --git a/third_party/musl/porting/liteos_m/kernel/include/sys/sysinfo.h b/third_party/musl/porting/liteos_m/kernel/include/sys/sysinfo.h
new file mode 100755
index 000000000..6a3931e52
--- /dev/null
+++ b/third_party/musl/porting/liteos_m/kernel/include/sys/sysinfo.h
@@ -0,0 +1,36 @@
+#ifndef _SYS_SYSINFO_H
+#define _SYS_SYSINFO_H
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#define SI_LOAD_SHIFT 16
+
+struct sysinfo {
+	unsigned long uptime;
+	unsigned long loads[3];
+	unsigned long totalram;
+	unsigned long freeram;
+	unsigned long sharedram;
+	unsigned long bufferram;
+	unsigned long totalswap;
+	unsigned long freeswap;
+	unsigned short procs, pad;
+	unsigned long totalhigh;
+	unsigned long freehigh;
+	unsigned mem_unit;
+	char __reserved[256];
+};
+
+int sysinfo (struct sysinfo *);
+int get_nprocs_conf (void);
+int get_nprocs (void);
+long get_phys_pages (void);
+long get_avphys_pages (void);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
diff --git a/third_party/musl/porting/liteos_m/kernel/include/sys/syslog.h b/third_party/musl/porting/liteos_m/kernel/include/sys/syslog.h
new file mode 100755
index 000000000..7761eceeb
--- /dev/null
+++ b/third_party/musl/porting/liteos_m/kernel/include/sys/syslog.h
@@ -0,0 +1 @@
+#include <syslog.h>
diff --git a/third_party/musl/porting/liteos_m/kernel/include/sys/sysmacros.h b/third_party/musl/porting/liteos_m/kernel/include/sys/sysmacros.h
new file mode 100755
index 000000000..07a3ef183
--- /dev/null
+++ b/third_party/musl/porting/liteos_m/kernel/include/sys/sysmacros.h
@@ -0,0 +1,15 @@
+#ifndef _SYS_SYSMACROS_H
+#define _SYS_SYSMACROS_H
+
+#define major(x) \
+	((unsigned)( (((x)>>31>>1) & 0xfffff000) | (((x)>>8) & 0x00000fff) ))
+#define minor(x) \
+	((unsigned)( (((x)>>12) & 0xffffff00) | ((x) & 0x000000ff) ))
+
+#define makedev(x,y) ( \
+        (((x)&0xfffff000ULL) << 32) | \
+	(((x)&0x00000fffULL) << 8) | \
+        (((y)&0xffffff00ULL) << 12) | \
+	(((y)&0x000000ffULL)) )
+
+#endif
diff --git a/third_party/musl/porting/liteos_m/kernel/include/sys/termios.h b/third_party/musl/porting/liteos_m/kernel/include/sys/termios.h
new file mode 100755
index 000000000..f5f751f04
--- /dev/null
+++ b/third_party/musl/porting/liteos_m/kernel/include/sys/termios.h
@@ -0,0 +1,2 @@
+#warning redirecting incorrect #include <sys/termios.h> to <termios.h>
+#include <termios.h>
diff --git a/third_party/musl/porting/liteos_m/kernel/include/sys/time.h b/third_party/musl/porting/liteos_m/kernel/include/sys/time.h
new file mode 100755
index 000000000..cdc67ef65
--- /dev/null
+++ b/third_party/musl/porting/liteos_m/kernel/include/sys/time.h
@@ -0,0 +1,76 @@
+#ifndef _SYS_TIME_H
+#define _SYS_TIME_H
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#include <features.h>
+
+#include <sys/select.h>
+
+int gettimeofday (struct timeval *__restrict, void *__restrict);
+
+#define ITIMER_REAL    0
+#define ITIMER_VIRTUAL 1
+#define ITIMER_PROF    2
+
+struct itimerval {
+	struct timeval it_interval;
+	struct timeval it_value;
+};
+
+int getitimer (int, struct itimerval *);
+int setitimer (int, const struct itimerval *__restrict, struct itimerval *__restrict);
+int utimes (const char *, const struct timeval [2]);
+
+#if defined(_GNU_SOURCE) || defined(_BSD_SOURCE)
+struct timezone {
+	int tz_minuteswest;
+	int tz_dsttime;
+};
+int futimes(int, const struct timeval [2]);
+int futimesat(int, const char *, const struct timeval [2]);
+int lutimes(const char *, const struct timeval [2]);
+int settimeofday(const struct timeval *, const struct timezone *);
+int adjtime (const struct timeval *, struct timeval *);
+#define timerisset(t) ((t)->tv_sec || (t)->tv_usec)
+#define timerclear(t) ((t)->tv_sec = (t)->tv_usec = 0)
+#define timercmp(s,t,op) ((s)->tv_sec == (t)->tv_sec ? \
+	(s)->tv_usec op (t)->tv_usec : (s)->tv_sec op (t)->tv_sec)
+#define timeradd(s,t,a) (void) ( (a)->tv_sec = (s)->tv_sec + (t)->tv_sec, \
+	((a)->tv_usec = (s)->tv_usec + (t)->tv_usec) >= 1000000 && \
+	((a)->tv_usec -= 1000000, (a)->tv_sec++) )
+#define timersub(s,t,a) (void) ( (a)->tv_sec = (s)->tv_sec - (t)->tv_sec, \
+	((a)->tv_usec = (s)->tv_usec - (t)->tv_usec) < 0 && \
+	((a)->tv_usec += 1000000, (a)->tv_sec--) )
+#endif
+
+#if defined(_GNU_SOURCE)
+#define TIMEVAL_TO_TIMESPEC(tv, ts) ( \
+	(ts)->tv_sec = (tv)->tv_sec, \
+	(ts)->tv_nsec = (tv)->tv_usec * 1000, \
+	(void)0 )
+#define TIMESPEC_TO_TIMEVAL(tv, ts) ( \
+	(tv)->tv_sec = (ts)->tv_sec, \
+	(tv)->tv_usec = (ts)->tv_nsec / 1000, \
+	(void)0 )
+#endif
+
+#if _REDIR_TIME64
+__REDIR(gettimeofday, __gettimeofday_time64);
+__REDIR(getitimer, __getitimer_time64);
+__REDIR(setitimer, __setitimer_time64);
+__REDIR(utimes, __utimes_time64);
+#if defined(_GNU_SOURCE) || defined(_BSD_SOURCE)
+__REDIR(futimes, __futimes_time64);
+__REDIR(futimesat, __futimesat_time64);
+__REDIR(lutimes, __lutimes_time64);
+__REDIR(settimeofday, __settimeofday_time64);
+__REDIR(adjtime, __adjtime64);
+#endif
+#endif
+
+#ifdef __cplusplus
+}
+#endif
+#endif
diff --git a/third_party/musl/porting/liteos_m/kernel/include/sys/timeb.h b/third_party/musl/porting/liteos_m/kernel/include/sys/timeb.h
new file mode 100755
index 000000000..628239b7e
--- /dev/null
+++ b/third_party/musl/porting/liteos_m/kernel/include/sys/timeb.h
@@ -0,0 +1,28 @@
+#ifndef _SYS_TIMEB_H
+#define _SYS_TIMEB_H
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#include <features.h>
+
+#define __NEED_time_t
+
+#include <bits/alltypes.h>
+
+struct timeb {
+	time_t time;
+	unsigned short millitm;
+	short timezone, dstflag;
+};
+
+int ftime(struct timeb *);
+
+#if _REDIR_TIME64
+__REDIR(ftime, __ftime64);
+#endif
+
+#ifdef __cplusplus
+}
+#endif
+#endif
diff --git a/third_party/musl/porting/liteos_m/kernel/include/sys/timerfd.h b/third_party/musl/porting/liteos_m/kernel/include/sys/timerfd.h
new file mode 100755
index 000000000..1b832cdd8
--- /dev/null
+++ b/third_party/musl/porting/liteos_m/kernel/include/sys/timerfd.h
@@ -0,0 +1,32 @@
+#ifndef _SYS_TIMERFD_H
+#define _SYS_TIMERFD_H
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#include <time.h>
+#include <fcntl.h>
+
+#define TFD_NONBLOCK O_NONBLOCK
+#define TFD_CLOEXEC O_CLOEXEC
+
+#define TFD_TIMER_ABSTIME 1
+#define TFD_TIMER_CANCEL_ON_SET (1 << 1)
+
+struct itimerspec;
+
+int timerfd_create(int, int);
+int timerfd_settime(int, int, const struct itimerspec *, struct itimerspec *);
+int timerfd_gettime(int, struct itimerspec *);
+
+#if _REDIR_TIME64
+__REDIR(timerfd_settime, __timerfd_settime64);
+__REDIR(timerfd_gettime, __timerfd_gettime64);
+#endif
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
diff --git a/third_party/musl/porting/liteos_m/kernel/include/sys/times.h b/third_party/musl/porting/liteos_m/kernel/include/sys/times.h
new file mode 100755
index 000000000..80a50522d
--- /dev/null
+++ b/third_party/musl/porting/liteos_m/kernel/include/sys/times.h
@@ -0,0 +1,25 @@
+#ifndef	_SYS_TIMES_H
+#define	_SYS_TIMES_H
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#define __NEED_clock_t
+#include <bits/alltypes.h>
+
+struct tms {
+	clock_t tms_utime;
+	clock_t tms_stime;
+	clock_t tms_cutime;
+	clock_t tms_cstime;
+};
+
+clock_t times (struct tms *);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
+
diff --git a/third_party/musl/porting/liteos_m/kernel/include/sys/timex.h b/third_party/musl/porting/liteos_m/kernel/include/sys/timex.h
new file mode 100755
index 000000000..8b417e1be
--- /dev/null
+++ b/third_party/musl/porting/liteos_m/kernel/include/sys/timex.h
@@ -0,0 +1,103 @@
+#ifndef _SYS_TIMEX_H
+#define _SYS_TIMEX_H
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#define __NEED_clockid_t
+
+#include <bits/alltypes.h>
+
+#include <sys/time.h>
+
+struct ntptimeval {
+	struct timeval time;
+	long maxerror, esterror;
+};
+
+struct timex {
+	unsigned modes;
+	long offset, freq, maxerror, esterror;
+	int status;
+	long constant, precision, tolerance;
+	struct timeval time;
+	long tick, ppsfreq, jitter;
+	int shift;
+	long stabil, jitcnt, calcnt, errcnt, stbcnt;
+	int tai;
+	int __padding[11];
+};
+
+#define ADJ_OFFSET		0x0001
+#define ADJ_FREQUENCY		0x0002
+#define ADJ_MAXERROR		0x0004
+#define ADJ_ESTERROR		0x0008
+#define ADJ_STATUS		0x0010
+#define ADJ_TIMECONST		0x0020
+#define ADJ_TAI			0x0080
+#define ADJ_SETOFFSET		0x0100
+#define ADJ_MICRO		0x1000
+#define ADJ_NANO		0x2000
+#define ADJ_TICK		0x4000
+#define ADJ_OFFSET_SINGLESHOT	0x8001
+#define ADJ_OFFSET_SS_READ	0xa001
+
+#define MOD_OFFSET	ADJ_OFFSET
+#define MOD_FREQUENCY	ADJ_FREQUENCY
+#define MOD_MAXERROR	ADJ_MAXERROR
+#define MOD_ESTERROR	ADJ_ESTERROR
+#define MOD_STATUS	ADJ_STATUS
+#define MOD_TIMECONST	ADJ_TIMECONST
+#define MOD_CLKB	ADJ_TICK
+#define MOD_CLKA	ADJ_OFFSET_SINGLESHOT
+#define MOD_TAI		ADJ_TAI
+#define MOD_MICRO	ADJ_MICRO
+#define MOD_NANO	ADJ_NANO
+
+#define STA_PLL		0x0001
+#define STA_PPSFREQ	0x0002
+#define STA_PPSTIME	0x0004
+#define STA_FLL		0x0008
+
+#define STA_INS		0x0010
+#define STA_DEL		0x0020
+#define STA_UNSYNC	0x0040
+#define STA_FREQHOLD	0x0080
+
+#define STA_PPSSIGNAL	0x0100
+#define STA_PPSJITTER	0x0200
+#define STA_PPSWANDER	0x0400
+#define STA_PPSERROR	0x0800
+
+#define STA_CLOCKERR	0x1000
+#define STA_NANO	0x2000
+#define STA_MODE	0x4000
+#define STA_CLK		0x8000
+
+#define STA_RONLY (STA_PPSSIGNAL | STA_PPSJITTER | STA_PPSWANDER | \
+    STA_PPSERROR | STA_CLOCKERR | STA_NANO | STA_MODE | STA_CLK)
+
+#define TIME_OK		0
+#define TIME_INS	1
+#define TIME_DEL	2
+#define TIME_OOP	3
+#define TIME_WAIT	4
+#define TIME_ERROR	5
+#define TIME_BAD	TIME_ERROR
+
+#define MAXTC		6
+
+int adjtimex(struct timex *);
+int clock_adjtime(clockid_t, struct timex *);
+
+#if _REDIR_TIME64
+__REDIR(adjtimex, __adjtimex_time64);
+__REDIR(clock_adjtime, __clock_adjtime64);
+#endif
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
diff --git a/third_party/musl/porting/liteos_m/kernel/include/sys/ttydefaults.h b/third_party/musl/porting/liteos_m/kernel/include/sys/ttydefaults.h
new file mode 100755
index 000000000..edb55bc4d
--- /dev/null
+++ b/third_party/musl/porting/liteos_m/kernel/include/sys/ttydefaults.h
@@ -0,0 +1,34 @@
+#ifndef _SYS_TTYDEFAULTS_H
+#define _SYS_TTYDEFAULTS_H
+
+#define TTYDEF_IFLAG (BRKINT | ISTRIP | ICRNL | IMAXBEL | IXON | IXANY)
+#define TTYDEF_OFLAG (OPOST | ONLCR | XTABS)
+#define TTYDEF_LFLAG (ECHO | ICANON | ISIG | IEXTEN | ECHOE|ECHOKE|ECHOCTL)
+#define TTYDEF_CFLAG (CREAD | CS7 | PARENB | HUPCL)
+#define TTYDEF_SPEED (B9600)
+#define CTRL(x) ((x)&037)
+#define CEOF CTRL('d')
+
+#define CEOL '\0'
+#define CSTATUS '\0'
+
+#define CERASE 0177
+#define CINTR CTRL('c')
+#define CKILL CTRL('u')
+#define CMIN 1
+#define CQUIT 034
+#define CSUSP CTRL('z')
+#define CTIME 0
+#define CDSUSP CTRL('y')
+#define CSTART CTRL('q')
+#define CSTOP CTRL('s')
+#define CLNEXT CTRL('v')
+#define CDISCARD CTRL('o')
+#define CWERASE CTRL('w')
+#define CREPRINT CTRL('r')
+#define CEOT CEOF
+#define CBRK CEOL
+#define CRPRNT CREPRINT
+#define CFLUSH CDISCARD
+
+#endif
diff --git a/third_party/musl/porting/liteos_m/kernel/include/sys/types.h b/third_party/musl/porting/liteos_m/kernel/include/sys/types.h
new file mode 100755
index 000000000..0c35541da
--- /dev/null
+++ b/third_party/musl/porting/liteos_m/kernel/include/sys/types.h
@@ -0,0 +1,85 @@
+#ifndef	_SYS_TYPES_H
+#define	_SYS_TYPES_H
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#include <features.h>
+
+#define __NEED_ino_t
+#define __NEED_dev_t
+#define __NEED_uid_t
+#define __NEED_gid_t
+#define __NEED_mode_t
+#define __NEED_nlink_t
+#define __NEED_off_t
+#define __NEED_pid_t
+#define __NEED_size_t
+#define __NEED_ssize_t
+#define __NEED_time_t
+#define __NEED_timer_t
+#define __NEED_clockid_t
+
+#define __NEED_blkcnt_t
+#define __NEED_fsblkcnt_t
+#define __NEED_fsfilcnt_t
+
+#define __NEED_id_t
+#define __NEED_key_t
+#define __NEED_clock_t
+#define __NEED_suseconds_t
+#define __NEED_blksize_t
+
+#define __NEED_pthread_t
+#define __NEED_pthread_attr_t
+#define __NEED_pthread_mutexattr_t
+#define __NEED_pthread_condattr_t
+#define __NEED_pthread_rwlockattr_t
+#define __NEED_pthread_barrierattr_t
+#define __NEED_pthread_mutex_t
+#define __NEED_pthread_cond_t
+#define __NEED_pthread_rwlock_t
+#define __NEED_pthread_barrier_t
+#define __NEED_pthread_spinlock_t
+#define __NEED_pthread_key_t
+#define __NEED_pthread_once_t
+#define __NEED_useconds_t
+
+#if defined(_GNU_SOURCE) || defined(_BSD_SOURCE)
+#define __NEED_int8_t
+#define __NEED_int16_t
+#define __NEED_int32_t
+#define __NEED_int64_t
+#define __NEED_u_int64_t
+#define __NEED_register_t
+#endif
+
+#include <bits/alltypes.h>
+
+#if defined(_GNU_SOURCE) || defined(_BSD_SOURCE)
+typedef unsigned char u_int8_t;
+typedef unsigned short u_int16_t;
+typedef unsigned u_int32_t;
+typedef char *caddr_t;
+typedef unsigned char u_char;
+typedef unsigned short u_short, ushort;
+typedef unsigned u_int, uint;
+typedef unsigned long u_long, ulong;
+typedef long long quad_t;
+typedef unsigned long long u_quad_t;
+#include <endian.h>
+#include <sys/select.h>
+#endif
+
+#if defined(_LARGEFILE64_SOURCE) || defined(_GNU_SOURCE)
+#define blkcnt64_t blkcnt_t
+#define fsblkcnt64_t fsblkcnt_t
+#define fsfilcnt64_t fsfilcnt_t
+#define ino64_t ino_t
+#define off64_t off_t
+#endif
+
+#ifdef __cplusplus
+}
+#endif
+#endif
diff --git a/third_party/musl/porting/liteos_m/kernel/include/sys/ucontext.h b/third_party/musl/porting/liteos_m/kernel/include/sys/ucontext.h
new file mode 100755
index 000000000..5fdbd63db
--- /dev/null
+++ b/third_party/musl/porting/liteos_m/kernel/include/sys/ucontext.h
@@ -0,0 +1 @@
+#include <ucontext.h>
diff --git a/third_party/musl/porting/liteos_m/kernel/include/sys/uio.h b/third_party/musl/porting/liteos_m/kernel/include/sys/uio.h
new file mode 100755
index 000000000..00f73a2f0
--- /dev/null
+++ b/third_party/musl/porting/liteos_m/kernel/include/sys/uio.h
@@ -0,0 +1,48 @@
+#ifndef _SYS_UIO_H
+#define _SYS_UIO_H
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#include <features.h>
+
+#define __NEED_size_t
+#define __NEED_ssize_t
+#define __NEED_struct_iovec
+
+#if defined(_GNU_SOURCE) || defined(_BSD_SOURCE)
+#define __NEED_off_t
+#endif
+
+#ifdef _GNU_SOURCE
+#define __NEED_pid_t
+#endif
+
+#include <bits/alltypes.h>
+
+#define UIO_MAXIOV 1024
+
+ssize_t readv (int, const struct iovec *, int);
+ssize_t writev (int, const struct iovec *, int);
+
+#if defined(_GNU_SOURCE) || defined(_BSD_SOURCE)
+ssize_t preadv (int, const struct iovec *, int, off_t);
+ssize_t pwritev (int, const struct iovec *, int, off_t);
+#if defined(_LARGEFILE64_SOURCE) || defined(_GNU_SOURCE)
+#define preadv64 preadv
+#define pwritev64 pwritev
+#define off64_t off_t
+#endif
+#endif
+
+#ifdef _GNU_SOURCE
+ssize_t process_vm_writev(pid_t, const struct iovec *, unsigned long, const struct iovec *, unsigned long, unsigned long);
+ssize_t process_vm_readv(pid_t, const struct iovec *, unsigned long, const struct iovec *, unsigned long, unsigned long);
+#endif
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
diff --git a/third_party/musl/porting/liteos_m/kernel/include/sys/un.h b/third_party/musl/porting/liteos_m/kernel/include/sys/un.h
new file mode 100755
index 000000000..1a3193ad2
--- /dev/null
+++ b/third_party/musl/porting/liteos_m/kernel/include/sys/un.h
@@ -0,0 +1,31 @@
+#ifndef	_SYS_UN_H
+#define	_SYS_UN_H
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#include <features.h>
+
+#define __NEED_sa_family_t
+#if defined(_GNU_SOURCE) || defined(_BSD_SOURCE)
+#define __NEED_size_t
+#endif
+
+#include <bits/alltypes.h>
+
+struct sockaddr_un {
+	sa_family_t sun_family;
+	char sun_path[108];
+};
+
+#if defined(_GNU_SOURCE) || defined(_BSD_SOURCE)
+size_t strlen(const char *);
+#define SUN_LEN(s) (2+strlen((s)->sun_path))
+#endif
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
diff --git a/third_party/musl/porting/liteos_m/kernel/include/sys/user.h b/third_party/musl/porting/liteos_m/kernel/include/sys/user.h
new file mode 100755
index 000000000..96a034009
--- /dev/null
+++ b/third_party/musl/porting/liteos_m/kernel/include/sys/user.h
@@ -0,0 +1,16 @@
+#ifndef _SYS_USER_H
+#define _SYS_USER_H
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#include <limits.h>
+#include <stdint.h>
+#include <unistd.h>
+
+#include <bits/user.h>
+
+#ifdef __cplusplus
+}
+#endif
+#endif
diff --git a/third_party/musl/porting/liteos_m/kernel/include/sys/utsname.h b/third_party/musl/porting/liteos_m/kernel/include/sys/utsname.h
new file mode 100755
index 000000000..2c80fb5a2
--- /dev/null
+++ b/third_party/musl/porting/liteos_m/kernel/include/sys/utsname.h
@@ -0,0 +1,29 @@
+#ifndef	_SYS_UTSNAME_H
+#define	_SYS_UTSNAME_H
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#include <features.h>
+
+struct utsname {
+	char sysname[65];
+	char nodename[65];
+	char release[65];
+	char version[65];
+	char machine[65];
+#ifdef _GNU_SOURCE
+	char domainname[65];
+#else
+	char __domainname[65];
+#endif
+};
+
+int uname (struct utsname *);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
diff --git a/third_party/musl/porting/liteos_m/kernel/include/sys/vfs.h b/third_party/musl/porting/liteos_m/kernel/include/sys/vfs.h
new file mode 100755
index 000000000..a899db276
--- /dev/null
+++ b/third_party/musl/porting/liteos_m/kernel/include/sys/vfs.h
@@ -0,0 +1 @@
+#include <sys/statfs.h>
diff --git a/third_party/musl/porting/liteos_m/kernel/include/sys/vt.h b/third_party/musl/porting/liteos_m/kernel/include/sys/vt.h
new file mode 100755
index 000000000..5000de499
--- /dev/null
+++ b/third_party/musl/porting/liteos_m/kernel/include/sys/vt.h
@@ -0,0 +1 @@
+#include <bits/vt.h>
diff --git a/third_party/musl/porting/liteos_m/kernel/include/sys/wait.h b/third_party/musl/porting/liteos_m/kernel/include/sys/wait.h
new file mode 100755
index 000000000..d4b1f2e18
--- /dev/null
+++ b/third_party/musl/porting/liteos_m/kernel/include/sys/wait.h
@@ -0,0 +1,67 @@
+#ifndef	_SYS_WAIT_H
+#define	_SYS_WAIT_H
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#include <features.h>
+
+#define __NEED_pid_t
+#define __NEED_id_t
+#include <bits/alltypes.h>
+
+typedef enum {
+	P_ALL = 0,
+	P_PID = 1,
+	P_PGID = 2,
+	P_PIDFD = 3
+} idtype_t;
+
+pid_t wait (int *);
+pid_t waitpid (pid_t, int *, int );
+
+#if defined(_POSIX_SOURCE) || defined(_POSIX_C_SOURCE) \
+ || defined(_XOPEN_SOURCE) || defined(_GNU_SOURCE) \
+ || defined(_BSD_SOURCE)
+#include <signal.h>
+int waitid (idtype_t, id_t, siginfo_t *, int);
+#endif
+
+#if defined(_GNU_SOURCE) || defined(_BSD_SOURCE)
+#include <sys/resource.h>
+pid_t wait3 (int *, int, struct rusage *);
+pid_t wait4 (pid_t, int *, int, struct rusage *);
+#endif
+
+#define WNOHANG    1
+#define WUNTRACED  2
+
+#define WSTOPPED   2
+#define WEXITED    4
+#define WCONTINUED 8
+#define WNOWAIT    0x1000000
+
+#define __WNOTHREAD 0x20000000
+#define __WALL      0x40000000
+#define __WCLONE    0x80000000
+
+#define WEXITSTATUS(s) (((s) & 0xff00) >> 8)
+#define WTERMSIG(s) ((s) & 0x7f)
+#define WSTOPSIG(s) WEXITSTATUS(s)
+#define WCOREDUMP(s) ((s) & 0x80)
+#define WIFEXITED(s) (!WTERMSIG(s))
+#define WIFSTOPPED(s) ((short)((((s)&0xffff)*0x10001)>>8) > 0x7f00)
+#define WIFSIGNALED(s) (((s)&0xffff)-1U < 0xffu)
+#define WIFCONTINUED(s) ((s) == 0xffff)
+
+#if _REDIR_TIME64
+#if defined(_GNU_SOURCE) || defined(_BSD_SOURCE)
+__REDIR(wait3, __wait3_time64);
+__REDIR(wait4, __wait4_time64);
+#endif
+#endif
+
+#ifdef __cplusplus
+}
+#endif
+#endif
diff --git a/third_party/musl/porting/liteos_m/kernel/include/sys/xattr.h b/third_party/musl/porting/liteos_m/kernel/include/sys/xattr.h
new file mode 100755
index 000000000..eeeaafc44
--- /dev/null
+++ b/third_party/musl/porting/liteos_m/kernel/include/sys/xattr.h
@@ -0,0 +1,32 @@
+#ifndef	_SYS_XATTR_H
+#define	_SYS_XATTR_H
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#define __NEED_ssize_t
+#define __NEED_size_t
+#include <bits/alltypes.h>
+
+#define XATTR_CREATE 1
+#define XATTR_REPLACE 2
+
+ssize_t getxattr(const char *, const char *, void *, size_t);
+ssize_t lgetxattr(const char *, const char *, void *, size_t);
+ssize_t fgetxattr(int, const char *, void *, size_t);
+ssize_t listxattr(const char *, char *, size_t);
+ssize_t llistxattr(const char *, char *, size_t);
+ssize_t flistxattr(int, char *, size_t);
+int setxattr(const char *, const char *, const void *, size_t, int);
+int lsetxattr(const char *, const char *, const void *, size_t, int);
+int fsetxattr(int, const char *, const void *, size_t, int);
+int removexattr(const char *, const char *);
+int lremovexattr(const char *, const char *);
+int fremovexattr(int, const char *);
+
+#define __UAPI_DEF_XATTR        0
+
+#ifdef __cplusplus
+}
+#endif
+#endif
diff --git a/third_party/musl/porting/liteos_m/kernel/include/syscall.h b/third_party/musl/porting/liteos_m/kernel/include/syscall.h
new file mode 100755
index 000000000..4c3057844
--- /dev/null
+++ b/third_party/musl/porting/liteos_m/kernel/include/syscall.h
@@ -0,0 +1 @@
+#include <sys/syscall.h>
diff --git a/third_party/musl/porting/liteos_m/kernel/include/sysexits.h b/third_party/musl/porting/liteos_m/kernel/include/sysexits.h
new file mode 100755
index 000000000..16eeb4193
--- /dev/null
+++ b/third_party/musl/porting/liteos_m/kernel/include/sysexits.h
@@ -0,0 +1,21 @@
+#ifndef	_SYSEXITS_H
+#define _SYSEXITS_H
+#define EX_OK 0
+#define EX__BASE 64
+#define EX_USAGE 64
+#define EX_DATAERR 65
+#define EX_NOINPUT 66
+#define EX_NOUSER 67
+#define EX_NOHOST 68
+#define EX_UNAVAILABLE 69
+#define EX_SOFTWARE 70
+#define EX_OSERR 71
+#define EX_OSFILE 72
+#define EX_CANTCREAT 73
+#define EX_IOERR 74
+#define EX_TEMPFAIL 75
+#define EX_PROTOCOL 76
+#define EX_NOPERM 77
+#define EX_CONFIG 78
+#define EX__MAX 78
+#endif
diff --git a/third_party/musl/porting/liteos_m/kernel/include/syslog.h b/third_party/musl/porting/liteos_m/kernel/include/syslog.h
new file mode 100755
index 000000000..5b4d2964e
--- /dev/null
+++ b/third_party/musl/porting/liteos_m/kernel/include/syslog.h
@@ -0,0 +1,100 @@
+#ifndef _SYSLOG_H
+#define _SYSLOG_H
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#include <features.h>
+
+#define LOG_EMERG   0
+#define LOG_ALERT   1
+#define LOG_CRIT    2
+#define LOG_ERR     3
+#define LOG_WARNING 4
+#define LOG_NOTICE  5
+#define LOG_INFO    6
+#define LOG_DEBUG   7
+
+#define LOG_PRIMASK 7
+#define LOG_PRI(p) ((p)&LOG_PRIMASK)
+#define	LOG_MAKEPRI(f, p) (((f)<<3)|(p))
+
+#define LOG_MASK(p) (1<<(p))
+#define LOG_UPTO(p) ((1<<((p)+1))-1)
+
+#define LOG_KERN     (0<<3)
+#define LOG_USER     (1<<3)
+#define LOG_MAIL     (2<<3)
+#define LOG_DAEMON   (3<<3)
+#define LOG_AUTH     (4<<3)
+#define LOG_SYSLOG   (5<<3)
+#define LOG_LPR      (6<<3)
+#define LOG_NEWS     (7<<3)
+#define LOG_UUCP     (8<<3)
+#define LOG_CRON     (9<<3)
+#define	LOG_AUTHPRIV (10<<3)
+#define	LOG_FTP      (11<<3)
+
+#define LOG_LOCAL0   (16<<3)
+#define LOG_LOCAL1   (17<<3)
+#define LOG_LOCAL2   (18<<3)
+#define LOG_LOCAL3   (19<<3)
+#define LOG_LOCAL4   (20<<3)
+#define LOG_LOCAL5   (21<<3)
+#define LOG_LOCAL6   (22<<3)
+#define LOG_LOCAL7   (23<<3)
+
+#define LOG_NFACILITIES 24
+#define LOG_FACMASK 0x3f8
+#define LOG_FAC(p) (((p)&LOG_FACMASK)>>3)
+
+#define LOG_PID    0x01
+#define LOG_CONS   0x02
+#define LOG_ODELAY 0x04
+#define LOG_NDELAY 0x08
+#define LOG_NOWAIT 0x10
+#define LOG_PERROR 0x20
+
+void closelog (void);
+void openlog (const char *, int, int);
+int setlogmask (int);
+void syslog (int, const char *, ...);
+
+#if defined(_GNU_SOURCE) || defined(_BSD_SOURCE)
+#define _PATH_LOG "/dev/log"
+#define __NEED_va_list
+#include <bits/alltypes.h>
+void vsyslog (int, const char *, va_list);
+#if defined(SYSLOG_NAMES)
+#define	INTERNAL_NOPRI 0x10
+#define	INTERNAL_MARK (LOG_NFACILITIES<<3)
+typedef struct {
+	char *c_name;
+	int c_val;
+} CODE;
+#define prioritynames ((CODE *)(const CODE []){ \
+	{ "alert", LOG_ALERT }, { "crit", LOG_CRIT }, { "debug", LOG_DEBUG }, \
+	{ "emerg", LOG_EMERG }, { "err", LOG_ERR }, { "error", LOG_ERR }, \
+	{ "info", LOG_INFO }, { "none", INTERNAL_NOPRI }, \
+	{ "notice", LOG_NOTICE }, { "panic", LOG_EMERG }, \
+	{ "warn", LOG_WARNING }, { "warning", LOG_WARNING }, { 0, -1 } })
+#define facilitynames ((CODE *)(const CODE []){ \
+	{ "auth", LOG_AUTH }, { "authpriv", LOG_AUTHPRIV }, \
+	{ "cron", LOG_CRON }, { "daemon", LOG_DAEMON }, { "ftp", LOG_FTP }, \
+	{ "kern", LOG_KERN }, { "lpr", LOG_LPR }, { "mail", LOG_MAIL }, \
+	{ "mark", INTERNAL_MARK }, { "news", LOG_NEWS }, \
+	{ "security", LOG_AUTH }, { "syslog", LOG_SYSLOG }, \
+	{ "user", LOG_USER }, { "uucp", LOG_UUCP }, \
+	{ "local0", LOG_LOCAL0 }, { "local1", LOG_LOCAL1 }, \
+	{ "local2", LOG_LOCAL2 }, { "local3", LOG_LOCAL3 }, \
+	{ "local4", LOG_LOCAL4 }, { "local5", LOG_LOCAL5 }, \
+	{ "local6", LOG_LOCAL6 }, { "local7", LOG_LOCAL7 }, { 0, -1 } })
+#endif
+#endif
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
diff --git a/third_party/musl/porting/liteos_m/kernel/include/tar.h b/third_party/musl/porting/liteos_m/kernel/include/tar.h
new file mode 100755
index 000000000..be589842a
--- /dev/null
+++ b/third_party/musl/porting/liteos_m/kernel/include/tar.h
@@ -0,0 +1,33 @@
+#ifndef	_TAR_H
+#define	_TAR_H
+
+#define TSUID   04000
+#define TSGID   02000
+#define TSVTX   01000
+#define TUREAD  00400
+#define TUWRITE 00200
+#define TUEXEC  00100
+#define TGREAD  00040
+#define TGWRITE 00020
+#define TGEXEC  00010
+#define TOREAD  00004
+#define TOWRITE 00002
+#define TOEXEC  00001
+
+#define REGTYPE  '0'
+#define AREGTYPE '\0'
+#define LNKTYPE  '1'
+#define SYMTYPE  '2'
+#define CHRTYPE  '3'
+#define BLKTYPE  '4'
+#define DIRTYPE  '5'
+#define FIFOTYPE '6'
+#define CONTTYPE '7'
+
+#define TMAGIC "ustar"
+#define TMAGLEN 6
+
+#define TVERSION "00"
+#define TVERSLEN 2
+
+#endif
diff --git a/third_party/musl/porting/liteos_m/kernel/include/termios.h b/third_party/musl/porting/liteos_m/kernel/include/termios.h
new file mode 100755
index 000000000..d73c780d4
--- /dev/null
+++ b/third_party/musl/porting/liteos_m/kernel/include/termios.h
@@ -0,0 +1,46 @@
+#ifndef	_TERMIOS_H
+#define	_TERMIOS_H
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#include <features.h>
+
+#define __NEED_pid_t
+
+#include <bits/alltypes.h>
+
+typedef unsigned char cc_t;
+typedef unsigned int speed_t;
+typedef unsigned int tcflag_t;
+
+#define NCCS 32
+
+#include <bits/termios.h>
+
+speed_t cfgetospeed (const struct termios *);
+speed_t cfgetispeed (const struct termios *);
+int cfsetospeed (struct termios *, speed_t);
+int cfsetispeed (struct termios *, speed_t);
+
+int tcgetattr (int, struct termios *);
+int tcsetattr (int, int, const struct termios *);
+
+int tcsendbreak (int, int);
+int tcdrain (int);
+int tcflush (int, int);
+int tcflow (int, int);
+
+pid_t tcgetsid (int);
+
+#if defined(_GNU_SOURCE) || defined(_BSD_SOURCE)
+void cfmakeraw(struct termios *);
+int cfsetspeed(struct termios *, speed_t);
+#endif
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
diff --git a/third_party/musl/porting/liteos_m/kernel/include/tgmath.h b/third_party/musl/porting/liteos_m/kernel/include/tgmath.h
new file mode 100755
index 000000000..94b2add17
--- /dev/null
+++ b/third_party/musl/porting/liteos_m/kernel/include/tgmath.h
@@ -0,0 +1,275 @@
+#ifndef _TGMATH_H
+#define _TGMATH_H
+
+#ifdef __ICCARM__ /* for iar */
+#include_next <tgmath.h>
+#else
+
+/*
+the return types are only correct with gcc (__GNUC__)
+otherwise they are long double or long double complex
+
+the long double version of a function is never chosen when
+sizeof(double) == sizeof(long double)
+(but the return type is set correctly with gcc)
+*/
+
+#include <math.h>
+#include <complex.h>
+
+#define __IS_FP(x) (sizeof((x)+1ULL) == sizeof((x)+1.0f))
+#define __IS_CX(x) (__IS_FP(x) && sizeof(x) == sizeof((x)+I))
+#define __IS_REAL(x) (__IS_FP(x) && 2*sizeof(x) == sizeof((x)+I))
+
+#define __FLT(x) (__IS_REAL(x) && sizeof(x) == sizeof(float))
+#define __LDBL(x) (__IS_REAL(x) && sizeof(x) == sizeof(long double) && sizeof(long double) != sizeof(double))
+
+#define __FLTCX(x) (__IS_CX(x) && sizeof(x) == sizeof(float complex))
+#define __DBLCX(x) (__IS_CX(x) && sizeof(x) == sizeof(double complex))
+#define __LDBLCX(x) (__IS_CX(x) && sizeof(x) == sizeof(long double complex) && sizeof(long double) != sizeof(double))
+
+/* return type */
+
+#ifdef __GNUC__
+/*
+the result must be casted to the right type
+(otherwise the result type is determined by the conversion
+rules applied to all the function return types so it is long
+double or long double complex except for integral functions)
+
+this cannot be done in c99, so the typeof gcc extension is
+used and that the type of ?: depends on wether an operand is
+a null pointer constant or not
+(in c11 _Generic can be used)
+
+the c arguments below must be integer constant expressions
+so they can be in null pointer constants
+(__IS_FP above was carefully chosen this way)
+*/
+/* if c then t else void */
+#define __type1(c,t) __typeof__(*(0?(t*)0:(void*)!(c)))
+/* if c then t1 else t2 */
+#define __type2(c,t1,t2) __typeof__(*(0?(__type1(c,t1)*)0:(__type1(!(c),t2)*)0))
+/* cast to double when x is integral, otherwise use typeof(x) */
+#define __RETCAST(x) ( \
+	__type2(__IS_FP(x), __typeof__(x), double))
+/* 2 args case, should work for complex types (cpow) */
+#define __RETCAST_2(x, y) ( \
+	__type2(__IS_FP(x) && __IS_FP(y), \
+		__typeof__((x)+(y)), \
+		__typeof__((x)+(y)+1.0)))
+/* 3 args case (fma only) */
+#define __RETCAST_3(x, y, z) ( \
+	__type2(__IS_FP(x) && __IS_FP(y) && __IS_FP(z), \
+		__typeof__((x)+(y)+(z)), \
+		__typeof__((x)+(y)+(z)+1.0)))
+/* drop complex from the type of x */
+/* TODO: wrong when sizeof(long double)==sizeof(double) */
+#define __RETCAST_REAL(x) (  \
+	__type2(__IS_FP(x) && sizeof((x)+I) == sizeof(float complex), float, \
+	__type2(sizeof((x)+1.0+I) == sizeof(double complex), double, \
+		long double)))
+/* add complex to the type of x */
+#define __RETCAST_CX(x) (__typeof__(__RETCAST(x)0+I))
+#else
+#define __RETCAST(x)
+#define __RETCAST_2(x, y)
+#define __RETCAST_3(x, y, z)
+#define __RETCAST_REAL(x)
+#define __RETCAST_CX(x)
+#endif
+
+/* function selection */
+
+#define __tg_real_nocast(fun, x) ( \
+	__FLT(x) ? fun ## f (x) : \
+	__LDBL(x) ? fun ## l (x) : \
+	fun(x) )
+
+#define __tg_real(fun, x) (__RETCAST(x)__tg_real_nocast(fun, x))
+
+#define __tg_real_2_1(fun, x, y) (__RETCAST(x)( \
+	__FLT(x) ? fun ## f (x, y) : \
+	__LDBL(x) ? fun ## l (x, y) : \
+	fun(x, y) ))
+
+#define __tg_real_2(fun, x, y) (__RETCAST_2(x, y)( \
+	__FLT(x) && __FLT(y) ? fun ## f (x, y) : \
+	__LDBL((x)+(y)) ? fun ## l (x, y) : \
+	fun(x, y) ))
+
+#define __tg_complex(fun, x) (__RETCAST_CX(x)( \
+	__FLTCX((x)+I) && __IS_FP(x) ? fun ## f (x) : \
+	__LDBLCX((x)+I) ? fun ## l (x) : \
+	fun(x) ))
+
+#define __tg_complex_retreal(fun, x) (__RETCAST_REAL(x)( \
+	__FLTCX((x)+I) && __IS_FP(x) ? fun ## f (x) : \
+	__LDBLCX((x)+I) ? fun ## l (x) : \
+	fun(x) ))
+
+#define __tg_real_complex(fun, x) (__RETCAST(x)( \
+	__FLTCX(x) ? c ## fun ## f (x) : \
+	__DBLCX(x) ? c ## fun (x) : \
+	__LDBLCX(x) ? c ## fun ## l (x) : \
+	__FLT(x) ? fun ## f (x) : \
+	__LDBL(x) ? fun ## l (x) : \
+	fun(x) ))
+
+/* special cases */
+
+#define __tg_real_remquo(x, y, z) (__RETCAST_2(x, y)( \
+	__FLT(x) && __FLT(y) ? remquof(x, y, z) : \
+	__LDBL((x)+(y)) ? remquol(x, y, z) : \
+	remquo(x, y, z) ))
+
+#define __tg_real_fma(x, y, z) (__RETCAST_3(x, y, z)( \
+	__FLT(x) && __FLT(y) && __FLT(z) ? fmaf(x, y, z) : \
+	__LDBL((x)+(y)+(z)) ? fmal(x, y, z) : \
+	fma(x, y, z) ))
+
+#define __tg_real_complex_pow(x, y) (__RETCAST_2(x, y)( \
+	__FLTCX((x)+(y)) && __IS_FP(x) && __IS_FP(y) ? cpowf(x, y) : \
+	__FLTCX((x)+(y)) ? cpow(x, y) : \
+	__DBLCX((x)+(y)) ? cpow(x, y) : \
+	__LDBLCX((x)+(y)) ? cpowl(x, y) : \
+	__FLT(x) && __FLT(y) ? powf(x, y) : \
+	__LDBL((x)+(y)) ? powl(x, y) : \
+	pow(x, y) ))
+
+#define __tg_real_complex_fabs(x) (__RETCAST_REAL(x)( \
+	__FLTCX(x) ? cabsf(x) : \
+	__DBLCX(x) ? cabs(x) : \
+	__LDBLCX(x) ? cabsl(x) : \
+	__FLT(x) ? fabsf(x) : \
+	__LDBL(x) ? fabsl(x) : \
+	fabs(x) ))
+
+/* suppress any macros in math.h or complex.h */
+
+#undef acos
+#undef acosh
+#undef asin
+#undef asinh
+#undef atan
+#undef atan2
+#undef atanh
+#undef carg
+#undef cbrt
+#undef ceil
+#undef cimag
+#undef conj
+#undef copysign
+#undef cos
+#undef cosh
+#undef cproj
+#undef creal
+#undef erf
+#undef erfc
+#undef exp
+#undef exp2
+#undef expm1
+#undef fabs
+#undef fdim
+#undef floor
+#undef fma
+#undef fmax
+#undef fmin
+#undef fmod
+#undef frexp
+#undef hypot
+#undef ilogb
+#undef ldexp
+#undef lgamma
+#undef llrint
+#undef llround
+#undef log
+#undef log10
+#undef log1p
+#undef log2
+#undef logb
+#undef lrint
+#undef lround
+#undef nearbyint
+#undef nextafter
+#undef nexttoward
+#undef pow
+#undef remainder
+#undef remquo
+#undef rint
+#undef round
+#undef scalbln
+#undef scalbn
+#undef sin
+#undef sinh
+#undef sqrt
+#undef tan
+#undef tanh
+#undef tgamma
+#undef trunc
+
+/* tg functions */
+
+#define acos(x)         __tg_real_complex(acos, (x))
+#define acosh(x)        __tg_real_complex(acosh, (x))
+#define asin(x)         __tg_real_complex(asin, (x))
+#define asinh(x)        __tg_real_complex(asinh, (x))
+#define atan(x)         __tg_real_complex(atan, (x))
+#define atan2(x,y)      __tg_real_2(atan2, (x), (y))
+#define atanh(x)        __tg_real_complex(atanh, (x))
+#define carg(x)         __tg_complex_retreal(carg, (x))
+#define cbrt(x)         __tg_real(cbrt, (x))
+#define ceil(x)         __tg_real(ceil, (x))
+#define cimag(x)        __tg_complex_retreal(cimag, (x))
+#define conj(x)         __tg_complex(conj, (x))
+#define copysign(x,y)   __tg_real_2(copysign, (x), (y))
+#define cos(x)          __tg_real_complex(cos, (x))
+#define cosh(x)         __tg_real_complex(cosh, (x))
+#define cproj(x)        __tg_complex(cproj, (x))
+#define creal(x)        __tg_complex_retreal(creal, (x))
+#define erf(x)          __tg_real(erf, (x))
+#define erfc(x)         __tg_real(erfc, (x))
+#define exp(x)          __tg_real_complex(exp, (x))
+#define exp2(x)         __tg_real(exp2, (x))
+#define expm1(x)        __tg_real(expm1, (x))
+#define fabs(x)         __tg_real_complex_fabs(x)
+#define fdim(x,y)       __tg_real_2(fdim, (x), (y))
+#define floor(x)        __tg_real(floor, (x))
+#define fma(x,y,z)      __tg_real_fma((x), (y), (z))
+#define fmax(x,y)       __tg_real_2(fmax, (x), (y))
+#define fmin(x,y)       __tg_real_2(fmin, (x), (y))
+#define fmod(x,y)       __tg_real_2(fmod, (x), (y))
+#define frexp(x,y)      __tg_real_2_1(frexp, (x), (y))
+#define hypot(x,y)      __tg_real_2(hypot, (x), (y))
+#define ilogb(x)        __tg_real_nocast(ilogb, (x))
+#define ldexp(x,y)      __tg_real_2_1(ldexp, (x), (y))
+#define lgamma(x)       __tg_real(lgamma, (x))
+#define llrint(x)       __tg_real_nocast(llrint, (x))
+#define llround(x)      __tg_real_nocast(llround, (x))
+#define log(x)          __tg_real_complex(log, (x))
+#define log10(x)        __tg_real(log10, (x))
+#define log1p(x)        __tg_real(log1p, (x))
+#define log2(x)         __tg_real(log2, (x))
+#define logb(x)         __tg_real(logb, (x))
+#define lrint(x)        __tg_real_nocast(lrint, (x))
+#define lround(x)       __tg_real_nocast(lround, (x))
+#define nearbyint(x)    __tg_real(nearbyint, (x))
+#define nextafter(x,y)  __tg_real_2(nextafter, (x), (y))
+#define nexttoward(x,y) __tg_real_2(nexttoward, (x), (y))
+#define pow(x,y)        __tg_real_complex_pow((x), (y))
+#define remainder(x,y)  __tg_real_2(remainder, (x), (y))
+#define remquo(x,y,z)   __tg_real_remquo((x), (y), (z))
+#define rint(x)         __tg_real(rint, (x))
+#define round(x)        __tg_real(round, (x))
+#define scalbln(x,y)    __tg_real_2_1(scalbln, (x), (y))
+#define scalbn(x,y)     __tg_real_2_1(scalbn, (x), (y))
+#define sin(x)          __tg_real_complex(sin, (x))
+#define sinh(x)         __tg_real_complex(sinh, (x))
+#define sqrt(x)         __tg_real_complex(sqrt, (x))
+#define tan(x)          __tg_real_complex(tan, (x))
+#define tanh(x)         __tg_real_complex(tanh, (x))
+#define tgamma(x)       __tg_real(tgamma, (x))
+#define trunc(x)        __tg_real(trunc, (x))
+
+#endif /* __ICCARM__ */
+#endif
diff --git a/third_party/musl/porting/liteos_m/kernel/include/threads.h b/third_party/musl/porting/liteos_m/kernel/include/threads.h
new file mode 100755
index 000000000..e4ace4faa
--- /dev/null
+++ b/third_party/musl/porting/liteos_m/kernel/include/threads.h
@@ -0,0 +1,98 @@
+#ifndef _THREADS_H
+#define _THREADS_H
+
+#ifdef __ICCARM__ /* for iar */
+#include_next <threads.h>
+#else
+
+#include <features.h>
+#include <time.h>
+
+#ifdef __cplusplus
+extern "C" {
+typedef unsigned long thrd_t;
+#else
+typedef struct __pthread *thrd_t;
+#define thread_local _Thread_local
+#endif
+
+typedef int once_flag;
+typedef unsigned tss_t;
+typedef int (*thrd_start_t)(void *);
+typedef void (*tss_dtor_t)(void *);
+
+#define __NEED_cnd_t
+#define __NEED_mtx_t
+
+#include <bits/alltypes.h>
+
+#define TSS_DTOR_ITERATIONS 4
+
+enum {
+	thrd_success  = 0,
+	thrd_busy     = 1,
+	thrd_error    = 2,
+	thrd_nomem    = 3,
+	thrd_timedout = 4,
+};
+
+enum {
+	mtx_plain     = 0,
+	mtx_recursive = 1,
+	mtx_timed     = 2,
+};
+
+#define ONCE_FLAG_INIT 0
+
+int thrd_create(thrd_t *, thrd_start_t, void *);
+_Noreturn void thrd_exit(int);
+
+int thrd_detach(thrd_t);
+int thrd_join(thrd_t, int *);
+
+int thrd_sleep(const struct timespec *, struct timespec *);
+void thrd_yield(void);
+
+thrd_t thrd_current(void);
+int thrd_equal(thrd_t, thrd_t);
+#ifndef __cplusplus
+#define thrd_equal(A, B) ((A) == (B))
+#endif
+
+void call_once(once_flag *, void (*)(void));
+
+int mtx_init(mtx_t *, int);
+void mtx_destroy(mtx_t *);
+
+int mtx_lock(mtx_t *);
+int mtx_timedlock(mtx_t *__restrict, const struct timespec *__restrict);
+int mtx_trylock(mtx_t *);
+int mtx_unlock(mtx_t *);
+
+int cnd_init(cnd_t *);
+void cnd_destroy(cnd_t *);
+
+int cnd_broadcast(cnd_t *);
+int cnd_signal(cnd_t *);
+
+int cnd_timedwait(cnd_t *__restrict, mtx_t *__restrict, const struct timespec *__restrict);
+int cnd_wait(cnd_t *, mtx_t *);
+
+int tss_create(tss_t *, tss_dtor_t);
+void tss_delete(tss_t);
+
+int tss_set(tss_t, void *);
+void *tss_get(tss_t);
+
+#if _REDIR_TIME64
+__REDIR(thrd_sleep, __thrd_sleep_time64);
+__REDIR(mtx_timedlock, __mtx_timedlock_time64);
+__REDIR(cnd_timedwait, __cnd_timedwait_time64);
+#endif
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* __ICCARM__ */
+#endif
diff --git a/third_party/musl/porting/liteos_m/kernel/include/time.h b/third_party/musl/porting/liteos_m/kernel/include/time.h
new file mode 100755
index 000000000..09ecd5241
--- /dev/null
+++ b/third_party/musl/porting/liteos_m/kernel/include/time.h
@@ -0,0 +1,243 @@
+#ifndef	_TIME_H
+#define _TIME_H
+
+#ifdef __ICCARM__ /* for iar */
+
+#if !defined(_DLIB_TIME_USES_64) || !defined(_DLIB_TIME_USES_LONG) || (_DLIB_TIME_USES_64 == 0) || (_DLIB_TIME_USES_LONG == 0)
+#error "_DLIB_TIME_USES_64=1 and _DLIB_TIME_USES_LONG=1 should be defined in IAR project(C/C++ Compiler->Preprocessor->Defined symbols)."
+#endif
+
+#ifndef tm_isdst
+#define tm_isdst    tm_isdst;	\
+	long __tm_gmtoff;	\
+	const char *__tm_zone
+
+#if defined(_BSD_SOURCE) || defined(_GNU_SOURCE)
+#define __tm_gmtoff tm_gmtoff
+#define __tm_zone tm_zone
+#endif
+
+#include_next <time.h>
+#undef tm_isdst
+
+#else /* tm_isdst */
+
+#include_next <time.h>
+
+#endif /* tm_isdst */
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#define __NEED_timer_t
+#define __NEED_clockid_t
+
+#include <bits/alltypes.h>
+
+struct itimerspec {
+	struct timespec it_interval;
+	struct timespec it_value;
+};
+
+#define CLOCK_REALTIME           0
+#define CLOCK_MONOTONIC          1
+#define CLOCK_PROCESS_CPUTIME_ID 2
+#define CLOCK_THREAD_CPUTIME_ID  3
+#define CLOCK_MONOTONIC_RAW      4
+#define CLOCK_REALTIME_COARSE    5
+#define CLOCK_MONOTONIC_COARSE   6
+#define CLOCK_BOOTTIME           7
+#define CLOCK_REALTIME_ALARM     8
+#define CLOCK_BOOTTIME_ALARM     9
+#define CLOCK_SGI_CYCLE         10
+#define CLOCK_TAI               11
+
+#define TIMER_ABSTIME 1
+
+struct tm *gmtime_r (const time_t *__restrict, struct tm *__restrict);
+struct tm *localtime_r (const time_t *__restrict, struct tm *__restrict);
+
+int nanosleep (const struct timespec *, struct timespec *);
+int clock_getres (clockid_t, struct timespec *);
+int clock_gettime (clockid_t, struct timespec *);
+int clock_settime (clockid_t, const struct timespec *);
+int clock_nanosleep (clockid_t, int, const struct timespec *, struct timespec *);
+
+struct sigevent;
+int timer_create (clockid_t, struct sigevent *__restrict, timer_t *__restrict);
+int timer_delete (timer_t);
+int timer_settime (timer_t, int, const struct itimerspec *__restrict, struct itimerspec *__restrict);
+int timer_gettime (timer_t, struct itimerspec *);
+int timer_getoverrun (timer_t);
+
+#ifdef __cplusplus
+}
+#endif
+
+#else
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#include <features.h>
+
+#ifndef NULL
+#ifdef __cplusplus
+#define NULL 0L
+#else
+#define NULL ((void*)0)
+#endif
+#endif
+
+#define __NEED_size_t
+#define __NEED_time_t
+#define __NEED_clock_t
+#define __NEED_struct_timespec
+
+#if defined(_POSIX_SOURCE) || defined(_POSIX_C_SOURCE) \
+ || defined(_XOPEN_SOURCE) || defined(_GNU_SOURCE) \
+ || defined(_BSD_SOURCE)
+#define __NEED_clockid_t
+#define __NEED_timer_t
+#define __NEED_pid_t
+#define __NEED_locale_t
+#endif
+
+#include <bits/alltypes.h>
+
+#if defined(_BSD_SOURCE) || defined(_GNU_SOURCE)
+#define __tm_gmtoff tm_gmtoff
+#define __tm_zone tm_zone
+#endif
+
+struct tm {
+	int tm_sec;
+	int tm_min;
+	int tm_hour;
+	int tm_mday;
+	int tm_mon;
+	int tm_year;
+	int tm_wday;
+	int tm_yday;
+	int tm_isdst;
+	long __tm_gmtoff;
+	const char *__tm_zone;
+};
+
+clock_t clock (void);
+time_t time (time_t *);
+double difftime (time_t, time_t);
+time_t mktime (struct tm *);
+size_t strftime (char *__restrict, size_t, const char *__restrict, const struct tm *__restrict);
+struct tm *gmtime (const time_t *);
+struct tm *localtime (const time_t *);
+char *asctime (const struct tm *);
+char *ctime (const time_t *);
+int timespec_get(struct timespec *, int);
+
+#define CLOCKS_PER_SEC 1000000L
+
+#define TIME_UTC 1
+
+#if defined(_POSIX_SOURCE) || defined(_POSIX_C_SOURCE) \
+ || defined(_XOPEN_SOURCE) || defined(_GNU_SOURCE) \
+ || defined(_BSD_SOURCE)
+
+size_t strftime_l (char *  __restrict, size_t, const char *  __restrict, const struct tm *  __restrict, locale_t);
+
+struct tm *gmtime_r (const time_t *__restrict, struct tm *__restrict);
+struct tm *localtime_r (const time_t *__restrict, struct tm *__restrict);
+char *asctime_r (const struct tm *__restrict, char *__restrict);
+char *ctime_r (const time_t *, char *);
+
+void tzset (void);
+
+struct itimerspec {
+	struct timespec it_interval;
+	struct timespec it_value;
+};
+
+#define CLOCK_REALTIME           0
+#define CLOCK_MONOTONIC          1
+#define CLOCK_PROCESS_CPUTIME_ID 2
+#define CLOCK_THREAD_CPUTIME_ID  3
+#define CLOCK_MONOTONIC_RAW      4
+#define CLOCK_REALTIME_COARSE    5
+#define CLOCK_MONOTONIC_COARSE   6
+#define CLOCK_BOOTTIME           7
+#define CLOCK_REALTIME_ALARM     8
+#define CLOCK_BOOTTIME_ALARM     9
+#define CLOCK_SGI_CYCLE         10
+#define CLOCK_TAI               11
+
+#define TIMER_ABSTIME 1
+
+int nanosleep (const struct timespec *, struct timespec *);
+int clock_getres (clockid_t, struct timespec *);
+int clock_gettime (clockid_t, struct timespec *);
+int clock_settime (clockid_t, const struct timespec *);
+int clock_nanosleep (clockid_t, int, const struct timespec *, struct timespec *);
+int clock_getcpuclockid (pid_t, clockid_t *);
+
+struct sigevent;
+int timer_create (clockid_t, struct sigevent *__restrict, timer_t *__restrict);
+int timer_delete (timer_t);
+int timer_settime (timer_t, int, const struct itimerspec *__restrict, struct itimerspec *__restrict);
+int timer_gettime (timer_t, struct itimerspec *);
+int timer_getoverrun (timer_t);
+
+extern char *tzname[2];
+
+#endif
+
+
+#if defined(_XOPEN_SOURCE) || defined(_BSD_SOURCE) || defined(_GNU_SOURCE)
+char *strptime (const char *__restrict, const char *__restrict, struct tm *__restrict);
+extern int daylight;
+extern long timezone;
+extern int getdate_err;
+struct tm *getdate (const char *);
+#endif
+
+
+#if defined(_GNU_SOURCE) || defined(_BSD_SOURCE)
+int stime(const time_t *);
+time_t timegm(struct tm *);
+#endif
+
+#if _REDIR_TIME64
+__REDIR(time, __time64);
+__REDIR(difftime, __difftime64);
+__REDIR(mktime, __mktime64);
+__REDIR(gmtime, __gmtime64);
+__REDIR(localtime, __localtime64);
+__REDIR(ctime, __ctime64);
+__REDIR(timespec_get, __timespec_get_time64);
+#if defined(_POSIX_SOURCE) || defined(_POSIX_C_SOURCE) \
+ || defined(_XOPEN_SOURCE) || defined(_GNU_SOURCE) \
+ || defined(_BSD_SOURCE)
+__REDIR(gmtime_r, __gmtime64_r);
+__REDIR(localtime_r, __localtime64_r);
+__REDIR(ctime_r, __ctime64_r);
+__REDIR(nanosleep, __nanosleep_time64);
+__REDIR(clock_getres, __clock_getres_time64);
+__REDIR(clock_gettime, __clock_gettime64);
+__REDIR(clock_settime, __clock_settime64);
+__REDIR(clock_nanosleep, __clock_nanosleep_time64);
+__REDIR(timer_settime, __timer_settime64);
+__REDIR(timer_gettime, __timer_gettime64);
+#endif
+#if defined(_GNU_SOURCE) || defined(_BSD_SOURCE)
+__REDIR(stime, __stime64);
+__REDIR(timegm, __timegm_time64);
+#endif
+#endif
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* __ICCARM__ */
+#endif
diff --git a/third_party/musl/porting/liteos_m/kernel/include/uchar.h b/third_party/musl/porting/liteos_m/kernel/include/uchar.h
new file mode 100755
index 000000000..8c39db3f4
--- /dev/null
+++ b/third_party/musl/porting/liteos_m/kernel/include/uchar.h
@@ -0,0 +1,34 @@
+#ifndef _UCHAR_H
+#define _UCHAR_H
+
+#ifdef __ICCARM__ /* for iar */
+#include_next <uchar.h>
+#else
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#if __cplusplus < 201103L
+typedef unsigned short char16_t;
+typedef unsigned char32_t;
+#endif
+
+#define __NEED_mbstate_t
+#define __NEED_size_t
+
+#include <features.h>
+#include <bits/alltypes.h>
+
+size_t c16rtomb(char *__restrict, char16_t, mbstate_t *__restrict);
+size_t mbrtoc16(char16_t *__restrict, const char *__restrict, size_t, mbstate_t *__restrict);
+
+size_t c32rtomb(char *__restrict, char32_t, mbstate_t *__restrict);
+size_t mbrtoc32(char32_t *__restrict, const char *__restrict, size_t, mbstate_t *__restrict);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* __ICCARM__ */
+#endif
diff --git a/third_party/musl/porting/liteos_m/kernel/include/ucontext.h b/third_party/musl/porting/liteos_m/kernel/include/ucontext.h
new file mode 100755
index 000000000..0f7571254
--- /dev/null
+++ b/third_party/musl/porting/liteos_m/kernel/include/ucontext.h
@@ -0,0 +1,25 @@
+#ifndef _UCONTEXT_H
+#define _UCONTEXT_H
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#include <features.h>
+
+#include <signal.h>
+
+#if defined(_GNU_SOURCE) || defined(_BSD_SOURCE)
+#define NGREG (sizeof(gregset_t)/sizeof(greg_t))
+#endif
+
+struct __ucontext;
+
+int  getcontext(struct __ucontext *);
+void makecontext(struct __ucontext *, void (*)(), int, ...);
+int  setcontext(const struct __ucontext *);
+int  swapcontext(struct __ucontext *, const struct __ucontext *);
+
+#ifdef __cplusplus
+}
+#endif
+#endif
diff --git a/third_party/musl/porting/liteos_m/kernel/include/ulimit.h b/third_party/musl/porting/liteos_m/kernel/include/ulimit.h
new file mode 100755
index 000000000..efdcd311e
--- /dev/null
+++ b/third_party/musl/porting/liteos_m/kernel/include/ulimit.h
@@ -0,0 +1,17 @@
+#ifndef _ULIMIT_H
+#define _ULIMIT_H
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#define UL_GETFSIZE 1
+#define UL_SETFSIZE 2
+
+long ulimit (int, ...);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
diff --git a/third_party/musl/kernel_m/include/unistd.h b/third_party/musl/porting/liteos_m/kernel/include/unistd.h
similarity index 100%
rename from third_party/musl/kernel_m/include/unistd.h
rename to third_party/musl/porting/liteos_m/kernel/include/unistd.h
diff --git a/third_party/musl/porting/liteos_m/kernel/include/utime.h b/third_party/musl/porting/liteos_m/kernel/include/utime.h
new file mode 100755
index 000000000..5755bd53e
--- /dev/null
+++ b/third_party/musl/porting/liteos_m/kernel/include/utime.h
@@ -0,0 +1,29 @@
+#ifndef	_UTIME_H
+#define	_UTIME_H
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#include <features.h>
+
+#define __NEED_time_t
+
+#include <bits/alltypes.h>
+
+struct utimbuf {
+	time_t actime;
+	time_t modtime;
+};
+
+int utime (const char *, const struct utimbuf *);
+
+#if _REDIR_TIME64
+__REDIR(utime, __utime64);
+#endif
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
diff --git a/third_party/musl/porting/liteos_m/kernel/include/utmp.h b/third_party/musl/porting/liteos_m/kernel/include/utmp.h
new file mode 100755
index 000000000..48a400d84
--- /dev/null
+++ b/third_party/musl/porting/liteos_m/kernel/include/utmp.h
@@ -0,0 +1,52 @@
+#ifndef _UTMP_H
+#define _UTMP_H
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#include <utmpx.h>
+
+#define ACCOUNTING 9
+#define UT_NAMESIZE 32
+#define UT_HOSTSIZE 256
+#define UT_LINESIZE 32
+
+struct lastlog {
+	time_t ll_time;
+	char ll_line[UT_LINESIZE];
+	char ll_host[UT_HOSTSIZE];
+};
+
+#define ut_time ut_tv.tv_sec
+#define ut_name ut_user
+#define ut_addr ut_addr_v6[0]
+#define utmp utmpx
+#define e_exit __e_exit
+#define e_termination __e_termination
+
+void         endutent(void);
+struct utmp *getutent(void);
+struct utmp *getutid(const struct utmp *);
+struct utmp *getutline(const struct utmp *);
+struct utmp *pututline(const struct utmp *);
+void         setutent(void);
+
+void updwtmp(const char *, const struct utmp *);
+int utmpname(const char *);
+
+int login_tty(int);
+
+#define _PATH_UTMP "/dev/null/utmp"
+#define _PATH_WTMP "/dev/null/wtmp"
+
+#define UTMP_FILE _PATH_UTMP
+#define WTMP_FILE _PATH_WTMP
+#define UTMP_FILENAME _PATH_UTMP
+#define WTMP_FILENAME _PATH_WTMP
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
diff --git a/third_party/musl/porting/liteos_m/kernel/include/utmpx.h b/third_party/musl/porting/liteos_m/kernel/include/utmpx.h
new file mode 100755
index 000000000..b293f427e
--- /dev/null
+++ b/third_party/musl/porting/liteos_m/kernel/include/utmpx.h
@@ -0,0 +1,67 @@
+#ifndef _UTMPX_H
+#define _UTMPX_H
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#include <features.h>
+
+#define __NEED_pid_t
+#define __NEED_time_t
+#define __NEED_suseconds_t
+#define __NEED_struct_timeval
+
+#include <bits/alltypes.h>
+
+struct utmpx {
+	short ut_type;
+	short __ut_pad1;
+	pid_t ut_pid;
+	char ut_line[32];
+	char ut_id[4];
+	char ut_user[32];
+	char ut_host[256];
+	struct {
+		short __e_termination;
+		short __e_exit;
+	} ut_exit;
+#if __BYTE_ORDER == 1234
+	int ut_session, __ut_pad2;
+#else
+	int __ut_pad2, ut_session;
+#endif
+	struct timeval ut_tv;
+	unsigned ut_addr_v6[4];
+	char __unused[20];
+};
+
+void          endutxent(void);
+struct utmpx *getutxent(void);
+struct utmpx *getutxid(const struct utmpx *);
+struct utmpx *getutxline(const struct utmpx *);
+struct utmpx *pututxline(const struct utmpx *);
+void          setutxent(void);
+
+#if defined(_BSD_SOURCE) || defined(_GNU_SOURCE)
+#define e_exit __e_exit
+#define e_termination __e_termination
+void updwtmpx(const char *, const struct utmpx *);
+int utmpxname(const char *);
+#endif
+
+#define EMPTY           0
+#define RUN_LVL         1
+#define BOOT_TIME       2
+#define NEW_TIME        3
+#define OLD_TIME        4
+#define INIT_PROCESS    5
+#define LOGIN_PROCESS   6
+#define USER_PROCESS    7
+#define DEAD_PROCESS    8
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
diff --git a/third_party/musl/porting/liteos_m/kernel/include/values.h b/third_party/musl/porting/liteos_m/kernel/include/values.h
new file mode 100755
index 000000000..fe4949f85
--- /dev/null
+++ b/third_party/musl/porting/liteos_m/kernel/include/values.h
@@ -0,0 +1,39 @@
+#ifndef _VALUES_H
+#define _VALUES_H
+
+#include <limits.h>
+
+#define CHARBITS   (sizeof(char)   * 8)
+#define SHORTBITS  (sizeof(short)  * 8)
+#define INTBITS    (sizeof(int)    * 8)
+#define LONGBITS   (sizeof(long)   * 8)
+#define PTRBITS    (sizeof(char *) * 8)
+#define DOUBLEBITS (sizeof(double) * 8)
+#define FLOATBITS  (sizeof(float)  * 8)
+
+#define MINSHORT SHRT_MIN
+#define MININT   INT_MIN
+#define MINLONG  LONG_MIN
+
+#define MAXSHORT SHRT_MAX
+#define MAXINT   INT_MAX
+#define MAXLONG  LONG_MAX
+
+#define HIBITS   MINSHORT
+#define HIBITL   MINLONG
+
+#include <float.h>
+
+#define MAXDOUBLE DBL_MAX
+#undef  MAXFLOAT
+#define MAXFLOAT  FLT_MAX
+#define MINDOUBLE DBL_MIN
+#define MINFLOAT  FLT_MIN
+#define DMINEXP   DBL_MIN_EXP
+#define FMINEXP   FLT_MIN_EXP
+#define DMAXEXP   DBL_MAX_EXP
+#define FMAXEXP   FLT_MAX_EXP
+
+#define BITSPERBYTE CHAR_BIT
+
+#endif
diff --git a/third_party/musl/porting/liteos_m/kernel/include/wait.h b/third_party/musl/porting/liteos_m/kernel/include/wait.h
new file mode 100755
index 000000000..98396e2d2
--- /dev/null
+++ b/third_party/musl/porting/liteos_m/kernel/include/wait.h
@@ -0,0 +1,2 @@
+#warning redirecting incorrect #include <wait.h> to <sys/wait.h>
+#include <sys/wait.h>
diff --git a/third_party/musl/porting/liteos_m/kernel/include/wchar.h b/third_party/musl/porting/liteos_m/kernel/include/wchar.h
new file mode 100755
index 000000000..f1068f272
--- /dev/null
+++ b/third_party/musl/porting/liteos_m/kernel/include/wchar.h
@@ -0,0 +1,212 @@
+#ifndef _WCHAR_H
+#define _WCHAR_H
+
+#ifdef __ICCARM__ /* for iar */
+#include_next <wchar.h>
+#else
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#include <features.h>
+
+#define __NEED_FILE
+#define __NEED___isoc_va_list
+#define __NEED_size_t
+#define __NEED_wchar_t
+#define __NEED_wint_t
+#define __NEED_mbstate_t
+#define __NEED_off_t
+
+#if __STDC_VERSION__ < 201112L
+#define __NEED_off_t
+#define __NEED_struct__IO_FILE
+#endif
+
+#if defined(_POSIX_SOURCE) || defined(_POSIX_C_SOURCE) \
+ || defined(_XOPEN_SOURCE) || defined(_GNU_SOURCE) || defined(_BSD_SOURCE)
+#define __NEED_locale_t
+#define __NEED_va_list
+#endif
+
+#if defined(_XOPEN_SOURCE) || defined(_GNU_SOURCE) || defined(_BSD_SOURCE)
+#define __NEED_wctype_t
+#endif
+
+#include <bits/alltypes.h>
+
+#if L'\0'-1 > 0
+#define WCHAR_MAX (0xffffffffu+L'\0')
+#define WCHAR_MIN (0+L'\0')
+#else
+#define WCHAR_MAX (0x7fffffff+L'\0')
+#define WCHAR_MIN (-1-0x7fffffff+L'\0')
+#endif
+
+#ifdef __cplusplus
+#define NULL 0L
+#else
+#define NULL ((void*)0)
+#endif
+
+#undef WEOF
+#define WEOF 0xffffffffU
+
+wchar_t *wcscpy (wchar_t *__restrict, const wchar_t *__restrict);
+wchar_t *wcsncpy (wchar_t *__restrict, const wchar_t *__restrict, size_t);
+
+wchar_t *wcscat (wchar_t *__restrict, const wchar_t *__restrict);
+wchar_t *wcsncat (wchar_t *__restrict, const wchar_t *__restrict, size_t);
+
+int wcscmp (const wchar_t *, const wchar_t *);
+int wcsncmp (const wchar_t *, const wchar_t *, size_t);
+
+int wcscoll(const wchar_t *, const wchar_t *);
+size_t wcsxfrm (wchar_t *__restrict, const wchar_t *__restrict, size_t);
+
+wchar_t *wcschr (const wchar_t *, wchar_t);
+wchar_t *wcsrchr (const wchar_t *, wchar_t);
+
+size_t wcscspn (const wchar_t *, const wchar_t *);
+size_t wcsspn (const wchar_t *, const wchar_t *);
+wchar_t *wcspbrk (const wchar_t *, const wchar_t *);
+
+wchar_t *wcstok (wchar_t *__restrict, const wchar_t *__restrict, wchar_t **__restrict);
+
+size_t wcslen (const wchar_t *);
+
+wchar_t *wcsstr (const wchar_t *__restrict, const wchar_t *__restrict);
+wchar_t *wcswcs (const wchar_t *, const wchar_t *);
+
+wchar_t *wmemchr (const wchar_t *, wchar_t, size_t);
+int wmemcmp (const wchar_t *, const wchar_t *, size_t);
+wchar_t *wmemcpy (wchar_t *__restrict, const wchar_t *__restrict, size_t);
+wchar_t *wmemmove (wchar_t *, const wchar_t *, size_t);
+wchar_t *wmemset (wchar_t *, wchar_t, size_t);
+
+wint_t btowc (int);
+int wctob (wint_t);
+
+int mbsinit (const mbstate_t *);
+size_t mbrtowc (wchar_t *__restrict, const char *__restrict, size_t, mbstate_t *__restrict);
+size_t wcrtomb (char *__restrict, wchar_t, mbstate_t *__restrict);
+
+size_t mbrlen (const char *__restrict, size_t, mbstate_t *__restrict);
+
+size_t mbsrtowcs (wchar_t *__restrict, const char **__restrict, size_t, mbstate_t *__restrict);
+size_t wcsrtombs (char *__restrict, const wchar_t **__restrict, size_t, mbstate_t *__restrict);
+
+float wcstof (const wchar_t *__restrict, wchar_t **__restrict);
+double wcstod (const wchar_t *__restrict, wchar_t **__restrict);
+long double wcstold (const wchar_t *__restrict, wchar_t **__restrict);
+
+long wcstol (const wchar_t *__restrict, wchar_t **__restrict, int);
+unsigned long wcstoul (const wchar_t *__restrict, wchar_t **__restrict, int);
+
+long long wcstoll (const wchar_t *__restrict, wchar_t **__restrict, int);
+unsigned long long wcstoull (const wchar_t *__restrict, wchar_t **__restrict, int);
+
+
+
+int fwide (FILE *, int);
+
+
+int wprintf (const wchar_t *__restrict, ...);
+int fwprintf (FILE *__restrict, const wchar_t *__restrict, ...);
+int swprintf (wchar_t *__restrict, size_t, const wchar_t *__restrict, ...);
+
+int vwprintf (const wchar_t *__restrict, __isoc_va_list);
+int vfwprintf (FILE *__restrict, const wchar_t *__restrict, __isoc_va_list);
+int vswprintf (wchar_t *__restrict, size_t, const wchar_t *__restrict, __isoc_va_list);
+
+int wscanf (const wchar_t *__restrict, ...);
+int fwscanf (FILE *__restrict, const wchar_t *__restrict, ...);
+int swscanf (const wchar_t *__restrict, const wchar_t *__restrict, ...);
+
+int vwscanf (const wchar_t *__restrict, __isoc_va_list);
+int vfwscanf (FILE *__restrict, const wchar_t *__restrict, __isoc_va_list);
+int vswscanf (const wchar_t *__restrict, const wchar_t *__restrict, __isoc_va_list);
+
+wint_t fgetwc (FILE *);
+wint_t getwc (FILE *);
+wint_t getwchar (void);
+
+wint_t fputwc (wchar_t, FILE *);
+wint_t putwc (wchar_t, FILE *);
+wint_t putwchar (wchar_t);
+
+wchar_t *fgetws (wchar_t *__restrict, int, FILE *__restrict);
+int fputws (const wchar_t *__restrict, FILE *__restrict);
+
+wint_t ungetwc (wint_t, FILE *);
+
+struct tm;
+size_t wcsftime (wchar_t *__restrict, size_t, const wchar_t *__restrict, const struct tm *__restrict);
+
+#undef iswdigit
+
+#if defined(_GNU_SOURCE)
+wint_t fgetwc_unlocked (FILE *);
+wint_t getwc_unlocked (FILE *);
+wint_t getwchar_unlocked (void);
+wint_t fputwc_unlocked (wchar_t, FILE *);
+wint_t putwc_unlocked (wchar_t, FILE *);
+wint_t putwchar_unlocked (wchar_t);
+wchar_t *fgetws_unlocked (wchar_t *__restrict, int, FILE *__restrict);
+int fputws_unlocked (const wchar_t *__restrict, FILE *__restrict);
+#endif
+
+#if defined(_GNU_SOURCE) || defined(_BSD_SOURCE)
+size_t wcsftime_l (wchar_t *__restrict, size_t, const wchar_t *__restrict, const struct tm *__restrict, locale_t);
+#endif
+
+#if defined(_POSIX_SOURCE) || defined(_POSIX_C_SOURCE) \
+ || defined(_XOPEN_SOURCE) || defined(_GNU_SOURCE)  || defined(_BSD_SOURCE)
+FILE *open_wmemstream(wchar_t **, size_t *);
+size_t mbsnrtowcs(wchar_t *__restrict, const char **__restrict, size_t, size_t, mbstate_t *__restrict);
+size_t wcsnrtombs(char *__restrict, const wchar_t **__restrict, size_t, size_t, mbstate_t *__restrict);
+wchar_t *wcsdup(const wchar_t *);
+size_t wcsnlen (const wchar_t *, size_t);
+wchar_t *wcpcpy (wchar_t *__restrict, const wchar_t *__restrict);
+wchar_t *wcpncpy (wchar_t *__restrict, const wchar_t *__restrict, size_t);
+int wcscasecmp(const wchar_t *, const wchar_t *);
+int wcscasecmp_l(const wchar_t *, const wchar_t *, locale_t);
+int wcsncasecmp(const wchar_t *, const wchar_t *, size_t);
+int wcsncasecmp_l(const wchar_t *, const wchar_t *, size_t, locale_t);
+int wcscoll_l(const wchar_t *, const wchar_t *, locale_t);
+size_t wcsxfrm_l(wchar_t *__restrict, const wchar_t *__restrict, size_t, locale_t);
+#endif
+
+#if defined(_XOPEN_SOURCE) || defined(_GNU_SOURCE) || defined(_BSD_SOURCE)
+int wcwidth (wchar_t);
+int wcswidth (const wchar_t *, size_t);
+int       iswalnum(wint_t);
+int       iswalpha(wint_t);
+int       iswblank(wint_t);
+int       iswcntrl(wint_t);
+int       iswdigit(wint_t);
+int       iswgraph(wint_t);
+int       iswlower(wint_t);
+int       iswprint(wint_t);
+int       iswpunct(wint_t);
+int       iswspace(wint_t);
+int       iswupper(wint_t);
+int       iswxdigit(wint_t);
+int       iswctype(wint_t, wctype_t);
+wint_t    towlower(wint_t);
+wint_t    towupper(wint_t);
+wctype_t  wctype(const char *);
+
+#ifndef __cplusplus
+#undef iswdigit
+#define iswdigit(a) (0 ? iswdigit(a) : ((unsigned)(a)-'0') < 10)
+#endif
+#endif
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* __ICCARM__ */
+#endif
diff --git a/third_party/musl/porting/liteos_m/kernel/include/wctype.h b/third_party/musl/porting/liteos_m/kernel/include/wctype.h
new file mode 100755
index 000000000..9a3faea47
--- /dev/null
+++ b/third_party/musl/porting/liteos_m/kernel/include/wctype.h
@@ -0,0 +1,84 @@
+#ifndef _WCTYPE_H
+#define _WCTYPE_H
+
+#ifdef __ICCARM__ /* for iar */
+#include_next <wctype.h>
+#else
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#include <features.h>
+
+#define __NEED_wint_t
+#define __NEED_wctype_t
+
+#if defined(_POSIX_SOURCE) || defined(_POSIX_C_SOURCE) \
+ || defined(_XOPEN_SOURCE) || defined(_GNU_SOURCE) || defined(_BSD_SOURCE)
+#define __NEED_locale_t
+#endif
+
+#include <bits/alltypes.h>
+
+typedef const int * wctrans_t;
+
+#undef WEOF
+#define WEOF 0xffffffffU
+
+#undef iswdigit
+
+int       iswalnum(wint_t);
+int       iswalpha(wint_t);
+int       iswblank(wint_t);
+int       iswcntrl(wint_t);
+int       iswdigit(wint_t);
+int       iswgraph(wint_t);
+int       iswlower(wint_t);
+int       iswprint(wint_t);
+int       iswpunct(wint_t);
+int       iswspace(wint_t);
+int       iswupper(wint_t);
+int       iswxdigit(wint_t);
+int       iswctype(wint_t, wctype_t);
+wint_t    towctrans(wint_t, wctrans_t);
+wint_t    towlower(wint_t);
+wint_t    towupper(wint_t);
+wctrans_t wctrans(const char *);
+wctype_t  wctype(const char *);
+
+#ifndef __cplusplus
+#undef iswdigit
+#define iswdigit(a) (0 ? iswdigit(a) : ((unsigned)(a)-'0') < 10)
+#endif
+
+#if defined(_POSIX_SOURCE) || defined(_POSIX_C_SOURCE) \
+ || defined(_XOPEN_SOURCE) || defined(_GNU_SOURCE) || defined(_BSD_SOURCE)
+
+int iswalnum_l(wint_t, locale_t);
+int iswalpha_l(wint_t, locale_t);
+int iswblank_l(wint_t, locale_t);
+int iswcntrl_l(wint_t, locale_t);
+int iswdigit_l(wint_t, locale_t);
+int iswgraph_l(wint_t, locale_t);
+int iswlower_l(wint_t, locale_t);
+int iswprint_l(wint_t, locale_t);
+int iswpunct_l(wint_t, locale_t);
+int iswspace_l(wint_t, locale_t);
+int iswupper_l(wint_t, locale_t);
+int iswxdigit_l(wint_t, locale_t);
+int iswctype_l(wint_t, wctype_t, locale_t);
+wint_t towlower_l(wint_t, locale_t);
+wint_t towupper_l(wint_t, locale_t);
+wint_t towctrans_l(wint_t, wctrans_t, locale_t);
+wctrans_t wctrans_l(const char *, locale_t);
+wctype_t  wctype_l(const char *, locale_t);
+
+#endif
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* __ICCARM__ */
+#endif
diff --git a/third_party/musl/porting/liteos_m/kernel/include/wordexp.h b/third_party/musl/porting/liteos_m/kernel/include/wordexp.h
new file mode 100755
index 000000000..5460002de
--- /dev/null
+++ b/third_party/musl/porting/liteos_m/kernel/include/wordexp.h
@@ -0,0 +1,41 @@
+#ifndef	_WORDEXP_H
+#define	_WORDEXP_H
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#include <features.h>
+
+#define __NEED_size_t
+
+#include <bits/alltypes.h>
+
+#define WRDE_DOOFFS  1
+#define WRDE_APPEND  2
+#define WRDE_NOCMD   4
+#define WRDE_REUSE   8
+#define WRDE_SHOWERR 16
+#define WRDE_UNDEF   32
+
+typedef struct {
+	size_t we_wordc;
+	char **we_wordv;
+	size_t we_offs;
+} wordexp_t;
+
+#define WRDE_NOSYS   -1
+#define WRDE_NOSPACE 1
+#define WRDE_BADCHAR 2
+#define WRDE_BADVAL  3
+#define WRDE_CMDSUB  4
+#define WRDE_SYNTAX  5
+
+int wordexp (const char *__restrict, wordexp_t *__restrict, int);
+void wordfree (wordexp_t *);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
diff --git a/third_party/musl/porting/liteos_m/kernel/src/ctype/__ctype_get_mb_cur_max.c b/third_party/musl/porting/liteos_m/kernel/src/ctype/__ctype_get_mb_cur_max.c
new file mode 100755
index 000000000..8e946fc12
--- /dev/null
+++ b/third_party/musl/porting/liteos_m/kernel/src/ctype/__ctype_get_mb_cur_max.c
@@ -0,0 +1,7 @@
+#include <stdlib.h>
+#include "locale_impl.h"
+
+size_t __ctype_get_mb_cur_max()
+{
+	return MB_CUR_MAX;
+}
diff --git a/third_party/musl/porting/liteos_m/kernel/src/ctype/isalnum.c b/third_party/musl/porting/liteos_m/kernel/src/ctype/isalnum.c
new file mode 100755
index 000000000..8018a2bc7
--- /dev/null
+++ b/third_party/musl/porting/liteos_m/kernel/src/ctype/isalnum.c
@@ -0,0 +1,13 @@
+#include <ctype.h>
+
+int isalnum(int c)
+{
+	return isalpha(c) || isdigit(c);
+}
+
+int __isalnum_l(int c, locale_t l)
+{
+	return isalnum(c);
+}
+
+weak_alias(__isalnum_l, isalnum_l);
diff --git a/third_party/musl/porting/liteos_m/kernel/src/ctype/isascii.c b/third_party/musl/porting/liteos_m/kernel/src/ctype/isascii.c
new file mode 100755
index 000000000..c8a45c294
--- /dev/null
+++ b/third_party/musl/porting/liteos_m/kernel/src/ctype/isascii.c
@@ -0,0 +1,7 @@
+#include <ctype.h>
+#undef isascii
+
+int isascii(int c)
+{
+	return !(c&~0x7f);
+}
\ No newline at end of file
diff --git a/third_party/musl/porting/liteos_m/kernel/src/ctype/isdigit.c b/third_party/musl/porting/liteos_m/kernel/src/ctype/isdigit.c
new file mode 100755
index 000000000..16beddb4c
--- /dev/null
+++ b/third_party/musl/porting/liteos_m/kernel/src/ctype/isdigit.c
@@ -0,0 +1,14 @@
+#include <ctype.h>
+#undef isdigit
+
+int isdigit(int c)
+{
+	return (unsigned)c-'0' < 10;
+}
+
+int __isdigit_l(int c, locale_t l)
+{
+	return isdigit(c);
+}
+
+weak_alias(__isdigit_l, isdigit_l);
diff --git a/third_party/musl/porting/liteos_m/kernel/src/ctype/islower.c b/third_party/musl/porting/liteos_m/kernel/src/ctype/islower.c
new file mode 100755
index 000000000..c3fa74c4c
--- /dev/null
+++ b/third_party/musl/porting/liteos_m/kernel/src/ctype/islower.c
@@ -0,0 +1,14 @@
+#include <ctype.h>
+#undef islower
+
+int islower(int c)
+{
+	return (unsigned)c-'a' < 26;
+}
+
+int __islower_l(int c, locale_t l)
+{
+	return islower(c);
+}
+
+weak_alias(__islower_l, islower_l);
diff --git a/third_party/musl/porting/liteos_m/kernel/src/ctype/isprint.c b/third_party/musl/porting/liteos_m/kernel/src/ctype/isprint.c
new file mode 100755
index 000000000..b950816bc
--- /dev/null
+++ b/third_party/musl/porting/liteos_m/kernel/src/ctype/isprint.c
@@ -0,0 +1,14 @@
+#include <ctype.h>
+#undef isprint
+
+int isprint(int c)
+{
+	return (unsigned)c-0x20 < 0x5f;
+}
+
+int __isprint_l(int c, locale_t l)
+{
+	return isprint(c);
+}
+
+weak_alias(__isprint_l, isprint_l);
diff --git a/third_party/musl/porting/liteos_m/kernel/src/ctype/isspace.c b/third_party/musl/porting/liteos_m/kernel/src/ctype/isspace.c
new file mode 100755
index 000000000..428813e79
--- /dev/null
+++ b/third_party/musl/porting/liteos_m/kernel/src/ctype/isspace.c
@@ -0,0 +1,14 @@
+#include <ctype.h>
+#undef isspace
+
+int isspace(int c)
+{
+	return c == ' ' || (unsigned)c-'\t' < 5;
+}
+
+int __isspace_l(int c, locale_t l)
+{
+	return isspace(c);
+}
+
+weak_alias(__isspace_l, isspace_l);
diff --git a/third_party/musl/porting/liteos_m/kernel/src/ctype/isupper.c b/third_party/musl/porting/liteos_m/kernel/src/ctype/isupper.c
new file mode 100755
index 000000000..bfd15acdb
--- /dev/null
+++ b/third_party/musl/porting/liteos_m/kernel/src/ctype/isupper.c
@@ -0,0 +1,14 @@
+#include <ctype.h>
+#undef isupper
+
+int isupper(int c)
+{
+	return (unsigned)c-'A' < 26;
+}
+
+int __isupper_l(int c, locale_t l)
+{
+	return isupper(c);
+}
+
+weak_alias(__isupper_l, isupper_l);
diff --git a/third_party/musl/porting/liteos_m/kernel/src/ctype/isxdigit.c b/third_party/musl/porting/liteos_m/kernel/src/ctype/isxdigit.c
new file mode 100755
index 000000000..aab1a745b
--- /dev/null
+++ b/third_party/musl/porting/liteos_m/kernel/src/ctype/isxdigit.c
@@ -0,0 +1,13 @@
+#include <ctype.h>
+
+int isxdigit(int c)
+{
+	return isdigit(c) || ((unsigned)c|32)-'a' < 6;
+}
+
+int __isxdigit_l(int c, locale_t l)
+{
+	return isxdigit(c);
+}
+
+weak_alias(__isxdigit_l, isxdigit_l);
diff --git a/third_party/musl/porting/liteos_m/kernel/src/ctype/tolower.c b/third_party/musl/porting/liteos_m/kernel/src/ctype/tolower.c
new file mode 100755
index 000000000..f10132ec2
--- /dev/null
+++ b/third_party/musl/porting/liteos_m/kernel/src/ctype/tolower.c
@@ -0,0 +1,14 @@
+#include <ctype.h>
+
+int tolower(int c)
+{
+	if (isupper(c)) return c | 32;
+	return c;
+}
+
+int __tolower_l(int c, locale_t l)
+{
+	return tolower(c);
+}
+
+weak_alias(__tolower_l, tolower_l);
diff --git a/third_party/musl/porting/liteos_m/kernel/src/ctype/toupper.c b/third_party/musl/porting/liteos_m/kernel/src/ctype/toupper.c
new file mode 100755
index 000000000..4e74a55c6
--- /dev/null
+++ b/third_party/musl/porting/liteos_m/kernel/src/ctype/toupper.c
@@ -0,0 +1,14 @@
+#include <ctype.h>
+
+int toupper(int c)
+{
+	if (islower(c)) return c & 0x5f;
+	return c;
+}
+
+int __toupper_l(int c, locale_t l)
+{
+	return toupper(c);
+}
+
+weak_alias(__toupper_l, toupper_l);
diff --git a/third_party/musl/porting/liteos_m/kernel/src/errno/__strerror.h b/third_party/musl/porting/liteos_m/kernel/src/errno/__strerror.h
new file mode 100755
index 000000000..2f04d400b
--- /dev/null
+++ b/third_party/musl/porting/liteos_m/kernel/src/errno/__strerror.h
@@ -0,0 +1,105 @@
+/* This file is sorted such that 'errors' which represent exceptional
+ * conditions under which a correct program may fail come first, followed
+ * by messages that indicate an incorrect program or system failure. The
+ * macro E() along with double-inclusion is used to ensure that ordering
+ * of the strings remains synchronized. */
+
+E(EILSEQ,       "Illegal byte sequence")
+E(EDOM,         "Domain error")
+E(ERANGE,       "Result not representable")
+
+E(ENOTTY,       "Not a tty")
+E(EACCES,       "Permission denied")
+E(EPERM,        "Operation not permitted")
+E(ENOENT,       "No such file or directory")
+E(ESRCH,        "No such process")
+E(EEXIST,       "File exists")
+
+E(EOVERFLOW,    "Value too large for data type")
+E(ENOSPC,       "No space left on device")
+E(ENOMEM,       "Out of memory")
+
+E(EBUSY,        "Resource busy")
+E(EINTR,        "Interrupted system call")
+E(EAGAIN,       "Resource temporarily unavailable")
+E(ESPIPE,       "Invalid seek")
+
+E(EXDEV,        "Cross-device link")
+E(EROFS,        "Read-only file system")
+E(ENOTEMPTY,    "Directory not empty")
+
+E(ECONNRESET,   "Connection reset by peer")
+E(ETIMEDOUT,    "Operation timed out")
+E(ECONNREFUSED, "Connection refused")
+E(EHOSTDOWN,    "Host is down")
+E(EHOSTUNREACH, "Host is unreachable")
+E(EADDRINUSE,   "Address in use")
+
+E(EPIPE,        "Broken pipe")
+E(EIO,          "I/O error")
+E(ENXIO,        "No such device or address")
+E(ENOTBLK,      "Block device required")
+E(ENODEV,       "No such device")
+E(ENOTDIR,      "Not a directory")
+E(EISDIR,       "Is a directory")
+E(ETXTBSY,      "Text file busy")
+E(ENOEXEC,      "Exec format error")
+
+E(EINVAL,       "Invalid argument")
+
+E(E2BIG,        "Argument list too long")
+E(ELOOP,        "Symbolic link loop")
+E(ENAMETOOLONG, "Filename too long")
+E(ENFILE,       "Too many open files in system")
+E(EMFILE,       "No file descriptors available")
+E(EBADF,        "Bad file descriptor")
+E(ECHILD,       "No child process")
+E(EFAULT,       "Bad address")
+E(EFBIG,        "File too large")
+E(EMLINK,       "Too many links")
+E(ENOLCK,       "No locks available")
+
+E(EDEADLK,      "Resource deadlock would occur")
+E(ENOTRECOVERABLE, "State not recoverable")
+E(EOWNERDEAD,   "Previous owner died")
+E(ECANCELED,    "Operation canceled")
+E(ENOSYS,       "Function not implemented")
+E(ENOMSG,       "No message of desired type")
+E(EIDRM,        "Identifier removed")
+E(ENOSTR,       "Device not a stream")
+E(ENODATA,      "No data available")
+E(ETIME,        "Device timeout")
+E(ENOSR,        "Out of streams resources")
+E(ENOLINK,      "Link has been severed")
+E(EPROTO,       "Protocol error")
+E(EBADMSG,      "Bad message")
+E(EBADFD,       "File descriptor in bad state")
+E(ENOTSOCK,     "Not a socket")
+E(EDESTADDRREQ, "Destination address required")
+E(EMSGSIZE,     "Message too large")
+E(EPROTOTYPE,   "Protocol wrong type for socket")
+E(ENOPROTOOPT,  "Protocol not available")
+E(EPROTONOSUPPORT,"Protocol not supported")
+E(ESOCKTNOSUPPORT,"Socket type not supported")
+E(ENOTSUP,      "Not supported")
+E(EPFNOSUPPORT, "Protocol family not supported")
+E(EAFNOSUPPORT, "Address family not supported by protocol")
+E(EADDRNOTAVAIL,"Address not available")
+E(ENETDOWN,     "Network is down")
+E(ENETUNREACH,  "Network unreachable")
+E(ENETRESET,    "Connection reset by network")
+E(ECONNABORTED, "Connection aborted")
+E(ENOBUFS,      "No buffer space available")
+E(EISCONN,      "Socket is connected")
+E(ENOTCONN,     "Socket not connected")
+E(ESHUTDOWN,    "Cannot send after socket shutdown")
+E(EALREADY,     "Operation already in progress")
+E(EINPROGRESS,  "Operation in progress")
+E(ESTALE,       "Stale file handle")
+E(EREMOTEIO,    "Remote I/O error")
+E(EDQUOT,       "Quota exceeded")
+E(ENOMEDIUM,    "No medium found")
+E(EMEDIUMTYPE,  "Wrong medium type")
+E(EMULTIHOP,    "Multihop attempted")
+
+E(0,            "No error information")
diff --git a/third_party/musl/porting/liteos_m/kernel/src/errno/strerror.c b/third_party/musl/porting/liteos_m/kernel/src/errno/strerror.c
new file mode 100755
index 000000000..52686102e
--- /dev/null
+++ b/third_party/musl/porting/liteos_m/kernel/src/errno/strerror.c
@@ -0,0 +1,36 @@
+#include <errno.h>
+#include <string.h>
+#include "locale_impl.h"
+
+#define E(a,b) ((unsigned char)a),
+static const unsigned char errid[] = {
+#include "__strerror.h"
+};
+
+#undef E
+#define E(a,b) b "\0"
+static const char errmsg[] =
+#include "__strerror.h"
+;
+
+char *__strerror_l(int e, locale_t loc)
+{
+	const char *s;
+	int i;
+	/* mips has one error code outside of the 8-bit range due to a
+	 * historical typo, so we just remap it. */
+	if (EDQUOT==1133) {
+		if (e==109) e=-1;
+		else if (e==EDQUOT) e=109;
+	}
+	for (i=0; errid[i] && errid[i] != e; i++);
+	for (s=errmsg; i; s++, i--) for (; *s; s++);
+	return (char *)s;
+}
+
+char *strerror(int e)
+{
+	return __strerror_l(e, NULL);
+}
+
+weak_alias(__strerror_l, strerror_l);
diff --git a/third_party/musl/kernel/src/exit/abort.c b/third_party/musl/porting/liteos_m/kernel/src/exit/abort.c
old mode 100644
new mode 100755
similarity index 83%
rename from third_party/musl/kernel/src/exit/abort.c
rename to third_party/musl/porting/liteos_m/kernel/src/exit/abort.c
index 183dac0c6..de8630025
--- a/third_party/musl/kernel/src/exit/abort.c
+++ b/third_party/musl/porting/liteos_m/kernel/src/exit/abort.c
@@ -1,6 +1,6 @@
 #include "stdlib.h"
 #include "string.h"
-#include "los_exc.h"
+#include "los_task.h"
 
 void abort(void) {
   LOS_Panic("System was being aborted\n");
diff --git a/third_party/musl/kernel/src/exit/assert.c b/third_party/musl/porting/liteos_m/kernel/src/exit/assert.c
old mode 100644
new mode 100755
similarity index 59%
rename from third_party/musl/kernel/src/exit/assert.c
rename to third_party/musl/porting/liteos_m/kernel/src/exit/assert.c
index 4753506bb..fb7d5c0eb
--- a/third_party/musl/kernel/src/exit/assert.c
+++ b/third_party/musl/porting/liteos_m/kernel/src/exit/assert.c
@@ -1,11 +1,7 @@
 #include "assert.h"
-#include "los_hwi.h"
-#include "los_printf.h"
-#include "los_exc.h"
+#include "los_context.h"
+#include "los_debug.h"
 
-#ifdef __cplusplus
-extern "C" {
-#endif /* __cplusplus */
 
 void __assert(const char* file, int line, const char* expr) {
   PRINT_ERR("__assert error: %s, %d, %s\n", file, line, expr);
@@ -14,17 +10,13 @@ void __assert(const char* file, int line, const char* expr) {
 }
 
 void __assert2(const char* file, int line, const char* func, const char* expr) {
-  PRINT_ERR("%s:%d: %s: assertion \"%s\" failed", file, line, func, expr);
+  PRINT_ERR("%s:%d: %s: assertion \"%s\" failed\n", file, line, func, expr);
   LOS_Panic("__assert error:\n");
   while (1);
 }
 
 void __assert_fail(const char* expr, const char* file, int line, const char* func) {
-  PRINT_ERR("%s:%d: %s: assertion \"%s\" failed", file, line, func, expr);
+  PRINT_ERR("%s:%d: %s: assertion \"%s\" failed\n", file, line, func, expr);
   LOS_Panic("__assert error:\n");
   while (1);
 }
-
-#ifdef __cplusplus
-}
-#endif /* __cplusplus */
\ No newline at end of file
diff --git a/third_party/musl/porting/liteos_m/kernel/src/include/features.h b/third_party/musl/porting/liteos_m/kernel/src/include/features.h
new file mode 100755
index 000000000..53ace76c1
--- /dev/null
+++ b/third_party/musl/porting/liteos_m/kernel/src/include/features.h
@@ -0,0 +1,16 @@
+#ifndef FEATURES_H
+#define FEATURES_H
+
+#include "../../include/features.h"
+
+#define weak __attribute__((__weak__))
+#define hidden __attribute__((__visibility__("hidden")))
+#ifndef weak_alias
+#define weak_alias(old, new) \
+    extern __typeof(old) new __attribute__((__weak__, __alias__(#old)))
+#endif
+#ifndef strong_alias
+#define strong_alias(old, new) \
+    extern __typeof(old) new __attribute__((__alias__(#old)))
+#endif
+#endif
diff --git a/third_party/musl/porting/liteos_m/kernel/src/include/string.h b/third_party/musl/porting/liteos_m/kernel/src/include/string.h
new file mode 100755
index 000000000..fe8eac908
--- /dev/null
+++ b/third_party/musl/porting/liteos_m/kernel/src/include/string.h
@@ -0,0 +1,12 @@
+#ifndef STRING_H
+#define STRING_H
+
+#include "features.h"
+#include "../../include/string.h"
+
+hidden void *__memrchr(const void *, int, size_t);
+hidden char *__stpcpy(char *, const char *);
+hidden char *__stpncpy(char *, const char *, size_t);
+hidden char *__strchrnul(const char *, int);
+
+#endif
diff --git a/third_party/musl/porting/liteos_m/kernel/src/internal/atomic.h b/third_party/musl/porting/liteos_m/kernel/src/internal/atomic.h
new file mode 100755
index 000000000..f938879b0
--- /dev/null
+++ b/third_party/musl/porting/liteos_m/kernel/src/internal/atomic.h
@@ -0,0 +1,318 @@
+#ifndef _ATOMIC_H
+#define _ATOMIC_H
+
+#include <stdint.h>
+
+#include "atomic_arch.h"
+
+#ifdef a_ll
+
+#ifndef a_pre_llsc
+#define a_pre_llsc()
+#endif
+
+#ifndef a_post_llsc
+#define a_post_llsc()
+#endif
+
+#ifndef a_cas
+#define a_cas a_cas
+static inline int a_cas(volatile int *p, int t, int s)
+{
+	int old;
+	a_pre_llsc();
+	do old = a_ll(p);
+	while (old==t && !a_sc(p, s));
+	a_post_llsc();
+	return old;
+}
+#endif
+
+#ifndef a_swap
+#define a_swap a_swap
+static inline int a_swap(volatile int *p, int v)
+{
+	int old;
+	a_pre_llsc();
+	do old = a_ll(p);
+	while (!a_sc(p, v));
+	a_post_llsc();
+	return old;
+}
+#endif
+
+#ifndef a_fetch_add
+#define a_fetch_add a_fetch_add
+static inline int a_fetch_add(volatile int *p, int v)
+{
+	int old;
+	a_pre_llsc();
+	do old = a_ll(p);
+	while (!a_sc(p, (unsigned)old + v));
+	a_post_llsc();
+	return old;
+}
+#endif
+
+#ifndef a_fetch_and
+#define a_fetch_and a_fetch_and
+static inline int a_fetch_and(volatile int *p, int v)
+{
+	int old;
+	a_pre_llsc();
+	do old = a_ll(p);
+	while (!a_sc(p, old & v));
+	a_post_llsc();
+	return old;
+}
+#endif
+
+#ifndef a_fetch_or
+#define a_fetch_or a_fetch_or
+static inline int a_fetch_or(volatile int *p, int v)
+{
+	int old;
+	a_pre_llsc();
+	do old = a_ll(p);
+	while (!a_sc(p, old | v));
+	a_post_llsc();
+	return old;
+}
+#endif
+
+#endif
+
+#ifdef a_ll_p
+
+#ifndef a_cas_p
+#define a_cas_p a_cas_p
+static inline void *a_cas_p(volatile void *p, void *t, void *s)
+{
+	void *old;
+	a_pre_llsc();
+	do old = a_ll_p(p);
+	while (old==t && !a_sc_p(p, s));
+	a_post_llsc();
+	return old;
+}
+#endif
+
+#endif
+
+#ifndef a_cas
+#error missing definition of a_cas
+#endif
+
+#ifndef a_swap
+#define a_swap a_swap
+static inline int a_swap(volatile int *p, int v)
+{
+	int old;
+	do old = *p;
+	while (a_cas(p, old, v) != old);
+	return old;
+}
+#endif
+
+#ifndef a_fetch_add
+#define a_fetch_add a_fetch_add
+static inline int a_fetch_add(volatile int *p, int v)
+{
+	int old;
+	do old = *p;
+	while (a_cas(p, old, (unsigned)old+v) != old);
+	return old;
+}
+#endif
+
+#ifndef a_fetch_and
+#define a_fetch_and a_fetch_and
+static inline int a_fetch_and(volatile int *p, int v)
+{
+	int old;
+	do old = *p;
+	while (a_cas(p, old, old&v) != old);
+	return old;
+}
+#endif
+#ifndef a_fetch_or
+#define a_fetch_or a_fetch_or
+static inline int a_fetch_or(volatile int *p, int v)
+{
+	int old;
+	do old = *p;
+	while (a_cas(p, old, old|v) != old);
+	return old;
+}
+#endif
+
+#ifndef a_and
+#define a_and a_and
+static inline void a_and(volatile int *p, int v)
+{
+	a_fetch_and(p, v);
+}
+#endif
+
+#ifndef a_or
+#define a_or a_or
+static inline void a_or(volatile int *p, int v)
+{
+	a_fetch_or(p, v);
+}
+#endif
+
+#ifndef a_inc
+#define a_inc a_inc
+static inline void a_inc(volatile int *p)
+{
+	a_fetch_add(p, 1);
+}
+#endif
+
+#ifndef a_dec
+#define a_dec a_dec
+static inline void a_dec(volatile int *p)
+{
+	a_fetch_add(p, -1);
+}
+#endif
+
+#ifndef a_store
+#define a_store a_store
+static inline void a_store(volatile int *p, int v)
+{
+#ifdef a_barrier
+	a_barrier();
+	*p = v;
+	a_barrier();
+#else
+	a_swap(p, v);
+#endif
+}
+#endif
+
+#ifndef a_barrier
+#define a_barrier a_barrier
+static void a_barrier()
+{
+	volatile int tmp = 0;
+	a_cas(&tmp, 0, 0);
+}
+#endif
+
+#ifndef a_spin
+#define a_spin a_barrier
+#endif
+
+#ifndef a_and_64
+#define a_and_64 a_and_64
+static inline void a_and_64(volatile uint64_t *p, uint64_t v)
+{
+	union { uint64_t v; uint32_t r[2]; } u = { v };
+	if (u.r[0]+1) a_and((int *)p, u.r[0]);
+	if (u.r[1]+1) a_and((int *)p+1, u.r[1]);
+}
+#endif
+
+#ifndef a_or_64
+#define a_or_64 a_or_64
+static inline void a_or_64(volatile uint64_t *p, uint64_t v)
+{
+	union { uint64_t v; uint32_t r[2]; } u = { v };
+	if (u.r[0]) a_or((int *)p, u.r[0]);
+	if (u.r[1]) a_or((int *)p+1, u.r[1]);
+}
+#endif
+
+#ifndef a_cas_p
+typedef char a_cas_p_undefined_but_pointer_not_32bit[-sizeof(char) == 0xffffffff ? 1 : -1];
+#define a_cas_p a_cas_p
+static inline void *a_cas_p(volatile void *p, void *t, void *s)
+{
+	return (void *)a_cas((volatile int *)p, (int)t, (int)s);
+}
+#endif
+
+#ifndef a_or_l
+#define a_or_l a_or_l
+static inline void a_or_l(volatile void *p, long v)
+{
+	if (sizeof(long) == sizeof(int)) a_or(p, v);
+	else a_or_64(p, v);
+}
+#endif
+
+#ifndef a_crash
+#define a_crash a_crash
+static inline void a_crash()
+{
+	*(volatile char *)0=0;
+}
+#endif
+
+#ifndef a_ctz_32
+#define a_ctz_32 a_ctz_32
+static inline int a_ctz_32(uint32_t x)
+{
+#ifdef a_clz_32
+	return 31-a_clz_32(x&-x);
+#else
+	static const char debruijn32[32] = {
+		0, 1, 23, 2, 29, 24, 19, 3, 30, 27, 25, 11, 20, 8, 4, 13,
+		31, 22, 28, 18, 26, 10, 7, 12, 21, 17, 9, 6, 16, 5, 15, 14
+	};
+	return debruijn32[(x&-x)*0x076be629 >> 27];
+#endif
+}
+#endif
+
+#ifndef a_ctz_64
+#define a_ctz_64 a_ctz_64
+static inline int a_ctz_64(uint64_t x)
+{
+	static const char debruijn64[64] = {
+		0, 1, 2, 53, 3, 7, 54, 27, 4, 38, 41, 8, 34, 55, 48, 28,
+		62, 5, 39, 46, 44, 42, 22, 9, 24, 35, 59, 56, 49, 18, 29, 11,
+		63, 52, 6, 26, 37, 40, 33, 47, 61, 45, 43, 21, 23, 58, 17, 10,
+		51, 25, 36, 32, 60, 20, 57, 16, 50, 31, 19, 15, 30, 14, 13, 12
+	};
+	if (sizeof(long) < 8) {
+		uint32_t y = x;
+		if (!y) {
+			y = x>>32;
+			return 32 + a_ctz_32(y);
+		}
+		return a_ctz_32(y);
+	}
+	return debruijn64[(x&-x)*0x022fdd63cc95386dull >> 58];
+}
+#endif
+
+static inline int a_ctz_l(unsigned long x)
+{
+	return (sizeof(long) < 8) ? a_ctz_32(x) : a_ctz_64(x);
+}
+
+#ifndef a_clz_64
+#define a_clz_64 a_clz_64
+static inline int a_clz_64(uint64_t x)
+{
+#ifdef a_clz_32
+	if (x>>32)
+		return a_clz_32(x>>32);
+	return a_clz_32(x) + 32;
+#else
+	uint32_t y;
+	int r;
+	if (x>>32) y=x>>32, r=0; else y=x, r=32;
+	if (y>>16) y>>=16; else r |= 16;
+	if (y>>8) y>>=8; else r |= 8;
+	if (y>>4) y>>=4; else r |= 4;
+	if (y>>2) y>>=2; else r |= 2;
+	return r | !(y>>1);
+#endif
+}
+#endif
+
+#endif
diff --git a/third_party/musl/porting/liteos_m/kernel/src/internal/intscan.c b/third_party/musl/porting/liteos_m/kernel/src/internal/intscan.c
new file mode 100755
index 000000000..a4a5ae861
--- /dev/null
+++ b/third_party/musl/porting/liteos_m/kernel/src/internal/intscan.c
@@ -0,0 +1,100 @@
+#include <limits.h>
+#include <errno.h>
+#include <ctype.h>
+#include "shgetc.h"
+
+/* Lookup table for digit values. -1==255>=36 -> invalid */
+static const unsigned char table[] = { -1,
+-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,
+-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,
+-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,
+ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9,-1,-1,-1,-1,-1,-1,
+-1,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,
+25,26,27,28,29,30,31,32,33,34,35,-1,-1,-1,-1,-1,
+-1,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,
+25,26,27,28,29,30,31,32,33,34,35,-1,-1,-1,-1,-1,
+-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,
+-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,
+-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,
+-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,
+-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,
+-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,
+-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,
+-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,
+};
+
+unsigned long long __intscan(FILE *f, unsigned base, int pok, unsigned long long lim)
+{
+	const unsigned char *val = table+1;
+	int c, neg=0;
+	unsigned x;
+	unsigned long long y;
+	if (base > 36 || base == 1) {
+		errno = EINVAL;
+		return 0;
+	}
+	while (isspace((c=shgetc(f))));
+	if (c=='+' || c=='-') {
+		neg = -(c=='-');
+		c = shgetc(f);
+	}
+	if ((base == 0 || base == 16) && c=='0') {
+		c = shgetc(f);
+		if ((c|32)=='x') {
+			c = shgetc(f);
+			if (val[c]>=16) {
+				shunget(f);
+				if (pok) shunget(f);
+				else shlim(f, 0);
+				return 0;
+			}
+			base = 16;
+		} else if (base == 0) {
+			base = 8;
+		}
+	} else {
+		if (base == 0) base = 10;
+		if (val[c] >= base) {
+			shunget(f);
+			shlim(f, 0);
+			errno = EINVAL;
+			return 0;
+		}
+	}
+	if (base == 10) {
+		for (x=0; c-'0'<10U && x<=UINT_MAX/10-1; c=shgetc(f))
+			x = x*10 + (c-'0');
+		for (y=x; c-'0'<10U && y<=ULLONG_MAX/10 && 10*y<=ULLONG_MAX-(c-'0'); c=shgetc(f))
+			y = y*10 + (c-'0');
+		if (c-'0'>=10U) goto done;
+	} else if (!(base & base-1)) {
+		int bs = "\0\1\2\4\7\3\6\5"[(0x17*base)>>5&7];
+		for (x=0; val[c]<base && x<=UINT_MAX/32; c=shgetc(f))
+			x = x<<bs | val[c];
+		for (y=x; val[c]<base && y<=ULLONG_MAX>>bs; c=shgetc(f))
+			y = y<<bs | val[c];
+	} else {
+		for (x=0; val[c]<base && x<=UINT_MAX/36-1; c=shgetc(f))
+			x = x*base + val[c];
+		for (y=x; val[c]<base && y<=ULLONG_MAX/base && base*y<=ULLONG_MAX-val[c]; c=shgetc(f))
+			y = y*base + val[c];
+	}
+	if (val[c]<base) {
+		for (; val[c]<base; c=shgetc(f));
+		errno = ERANGE;
+		y = lim;
+		if (lim&1) neg = 0;
+	}
+done:
+	shunget(f);
+	if (y>=lim) {
+		if (!(lim&1) && !neg) {
+			errno = ERANGE;
+			return lim-1;
+		} else if (y>lim) {
+			errno = ERANGE;
+			return lim;
+		}
+	}
+	return (y^neg)-neg;
+}
diff --git a/third_party/musl/porting/liteos_m/kernel/src/internal/intscan.h b/third_party/musl/porting/liteos_m/kernel/src/internal/intscan.h
new file mode 100755
index 000000000..fa9561fb9
--- /dev/null
+++ b/third_party/musl/porting/liteos_m/kernel/src/internal/intscan.h
@@ -0,0 +1,9 @@
+#ifndef INTSCAN_H
+#define INTSCAN_H
+
+#include <stdio.h>
+#include "../include/features.h"
+
+hidden unsigned long long __intscan(FILE *, unsigned, int, unsigned long long);
+
+#endif
diff --git a/third_party/musl/porting/liteos_m/kernel/src/internal/libc.h b/third_party/musl/porting/liteos_m/kernel/src/internal/libc.h
new file mode 100755
index 000000000..85a102e6a
--- /dev/null
+++ b/third_party/musl/porting/liteos_m/kernel/src/internal/libc.h
@@ -0,0 +1,19 @@
+#ifndef LIBC_H
+#define LIBC_H
+
+#include <stdlib.h>
+#include <stdio.h>
+#include <limits.h>
+
+struct __locale_map;
+
+struct __locale_struct {
+	const struct __locale_map *cat[6];
+};
+
+#define __NEED_locale_t
+#include <bits/alltypes.h>
+
+
+
+#endif
diff --git a/third_party/musl/porting/liteos_m/kernel/src/internal/libm.h b/third_party/musl/porting/liteos_m/kernel/src/internal/libm.h
new file mode 100755
index 000000000..a0983612e
--- /dev/null
+++ b/third_party/musl/porting/liteos_m/kernel/src/internal/libm.h
@@ -0,0 +1,272 @@
+#ifndef _LIBM_H
+#define _LIBM_H
+
+#include <stdint.h>
+#include <float.h>
+#include <math.h>
+#include <endian.h>
+#include "../include/features.h"
+
+
+#if LDBL_MANT_DIG == 53 && LDBL_MAX_EXP == 1024
+#elif LDBL_MANT_DIG == 64 && LDBL_MAX_EXP == 16384 && __BYTE_ORDER == __LITTLE_ENDIAN
+union ldshape {
+	long double f;
+	struct {
+		uint64_t m;
+		uint16_t se;
+	} i;
+};
+#elif LDBL_MANT_DIG == 64 && LDBL_MAX_EXP == 16384 && __BYTE_ORDER == __BIG_ENDIAN
+/* This is the m68k variant of 80-bit long double, and this definition only works
+ * on archs where the alignment requirement of uint64_t is <= 4. */
+union ldshape {
+	long double f;
+	struct {
+		uint16_t se;
+		uint16_t pad;
+		uint64_t m;
+	} i;
+};
+#elif LDBL_MANT_DIG == 113 && LDBL_MAX_EXP == 16384 && __BYTE_ORDER == __LITTLE_ENDIAN
+union ldshape {
+	long double f;
+	struct {
+		uint64_t lo;
+		uint32_t mid;
+		uint16_t top;
+		uint16_t se;
+	} i;
+	struct {
+		uint64_t lo;
+		uint64_t hi;
+	} i2;
+};
+#elif LDBL_MANT_DIG == 113 && LDBL_MAX_EXP == 16384 && __BYTE_ORDER == __BIG_ENDIAN
+union ldshape {
+	long double f;
+	struct {
+		uint16_t se;
+		uint16_t top;
+		uint32_t mid;
+		uint64_t lo;
+	} i;
+	struct {
+		uint64_t hi;
+		uint64_t lo;
+	} i2;
+};
+#else
+#error Unsupported long double representation
+#endif
+
+/* Support non-nearest rounding mode.  */
+#define WANT_ROUNDING 1
+/* Support signaling NaNs.  */
+#define WANT_SNAN 0
+
+#if WANT_SNAN
+#error SNaN is unsupported
+#else
+#define issignalingf_inline(x) 0
+#define issignaling_inline(x) 0
+#endif
+
+#ifndef TOINT_INTRINSICS
+#define TOINT_INTRINSICS 0
+#endif
+
+#if TOINT_INTRINSICS
+/* Round x to nearest int in all rounding modes, ties have to be rounded
+   consistently with converttoint so the results match.  If the result
+   would be outside of [-2^31, 2^31-1] then the semantics is unspecified.  */
+static double_t roundtoint(double_t);
+
+/* Convert x to nearest int in all rounding modes, ties have to be rounded
+   consistently with roundtoint.  If the result is not representible in an
+   int32_t then the semantics is unspecified.  */
+static int32_t converttoint(double_t);
+#endif
+
+/* Helps static branch prediction so hot path can be better optimized.  */
+#ifdef __GNUC__
+#define predict_true(x) __builtin_expect(!!(x), 1)
+#define predict_false(x) __builtin_expect(x, 0)
+#else
+#define predict_true(x) (x)
+#define predict_false(x) (x)
+#endif
+
+/* Evaluate an expression as the specified type. With standard excess
+   precision handling a type cast or assignment is enough (with
+   -ffloat-store an assignment is required, in old compilers argument
+   passing and return statement may not drop excess precision).  */
+
+static inline float eval_as_float(float x)
+{
+	float y = x;
+	return y;
+}
+
+static inline double eval_as_double(double x)
+{
+	double y = x;
+	return y;
+}
+
+/* fp_barrier returns its input, but limits code transformations
+   as if it had a side-effect (e.g. observable io) and returned
+   an arbitrary value.  */
+
+#ifndef fp_barrierf
+#define fp_barrierf fp_barrierf
+static inline float fp_barrierf(float x)
+{
+	volatile float y = x;
+	return y;
+}
+#endif
+
+#ifndef fp_barrier
+#define fp_barrier fp_barrier
+static inline double fp_barrier(double x)
+{
+	volatile double y = x;
+	return y;
+}
+#endif
+
+#ifndef fp_barrierl
+#define fp_barrierl fp_barrierl
+static inline long double fp_barrierl(long double x)
+{
+	volatile long double y = x;
+	return y;
+}
+#endif
+
+/* fp_force_eval ensures that the input value is computed when that's
+   otherwise unused.  To prevent the constant folding of the input
+   expression, an additional fp_barrier may be needed or a compilation
+   mode that does so (e.g. -frounding-math in gcc). Then it can be
+   used to evaluate an expression for its fenv side-effects only.   */
+
+#ifndef fp_force_evalf
+#define fp_force_evalf fp_force_evalf
+static inline void fp_force_evalf(float x)
+{
+	volatile float y;
+	y = x;
+}
+#endif
+
+#ifndef fp_force_eval
+#define fp_force_eval fp_force_eval
+static inline void fp_force_eval(double x)
+{
+	volatile double y;
+	y = x;
+}
+#endif
+
+#ifndef fp_force_evall
+#define fp_force_evall fp_force_evall
+static inline void fp_force_evall(long double x)
+{
+	volatile long double y;
+	y = x;
+}
+#endif
+
+#define FORCE_EVAL(x) do {                        \
+	if (sizeof(x) == sizeof(float)) {         \
+		fp_force_evalf(x);                \
+	} else if (sizeof(x) == sizeof(double)) { \
+		fp_force_eval(x);                 \
+	} else {                                  \
+		fp_force_evall(x);                \
+	}                                         \
+} while(0)
+
+#define asuint(f) ((union{float _f; uint32_t _i;}){f})._i
+#define asfloat(i) ((union{uint32_t _i; float _f;}){i})._f
+#define asuint64(f) ((union{double _f; uint64_t _i;}){f})._i
+#define asdouble(i) ((union{uint64_t _i; double _f;}){i})._f
+
+#define EXTRACT_WORDS(hi,lo,d)                    \
+do {                                              \
+  uint64_t __u = asuint64(d);                     \
+  (hi) = __u >> 32;                               \
+  (lo) = (uint32_t)__u;                           \
+} while (0)
+
+#define GET_HIGH_WORD(hi,d)                       \
+do {                                              \
+  (hi) = asuint64(d) >> 32;                       \
+} while (0)
+
+#define GET_LOW_WORD(lo,d)                        \
+do {                                              \
+  (lo) = (uint32_t)asuint64(d);                   \
+} while (0)
+
+#define INSERT_WORDS(d,hi,lo)                     \
+do {                                              \
+  (d) = asdouble(((uint64_t)(hi)<<32) | (uint32_t)(lo)); \
+} while (0)
+
+#define SET_HIGH_WORD(d,hi)                       \
+  INSERT_WORDS(d, hi, (uint32_t)asuint64(d))
+
+#define SET_LOW_WORD(d,lo)                        \
+  INSERT_WORDS(d, asuint64(d)>>32, lo)
+
+#define GET_FLOAT_WORD(w,d)                       \
+do {                                              \
+  (w) = asuint(d);                                \
+} while (0)
+
+#define SET_FLOAT_WORD(d,w)                       \
+do {                                              \
+  (d) = asfloat(w);                               \
+} while (0)
+
+hidden int    __rem_pio2_large(double*,double*,int,int,int);
+
+hidden int    __rem_pio2(double,double*);
+hidden double __sin(double,double,int);
+hidden double __cos(double,double);
+hidden double __tan(double,double,int);
+hidden double __expo2(double);
+
+hidden int    __rem_pio2f(float,double*);
+hidden float  __sindf(double);
+hidden float  __cosdf(double);
+hidden float  __tandf(double,int);
+hidden float  __expo2f(float);
+
+hidden int __rem_pio2l(long double, long double *);
+hidden long double __sinl(long double, long double, int);
+hidden long double __cosl(long double, long double);
+hidden long double __tanl(long double, long double, int);
+
+hidden long double __polevll(long double, const long double *, int);
+hidden long double __p1evll(long double, const long double *, int);
+
+extern int __signgam;
+hidden double __lgamma_r(double, int *);
+hidden float __lgammaf_r(float, int *);
+
+/* error handling functions */
+hidden float __math_xflowf(uint32_t, float);
+hidden float __math_uflowf(uint32_t);
+hidden float __math_oflowf(uint32_t);
+hidden float __math_divzerof(uint32_t);
+hidden float __math_invalidf(float);
+hidden double __math_xflow(uint32_t, double);
+hidden double __math_uflow(uint32_t);
+hidden double __math_oflow(uint32_t);
+hidden double __math_divzero(uint32_t);
+hidden double __math_invalid(double);
+
+#endif
diff --git a/third_party/musl/porting/liteos_m/kernel/src/internal/locale_impl.h b/third_party/musl/porting/liteos_m/kernel/src/internal/locale_impl.h
new file mode 100755
index 000000000..47b7c9e1f
--- /dev/null
+++ b/third_party/musl/porting/liteos_m/kernel/src/internal/locale_impl.h
@@ -0,0 +1,48 @@
+#ifndef _LOCALE_IMPL_H
+#define _LOCALE_IMPL_H
+
+#define __NEED_locale_t
+
+#include <locale.h>
+#include <stdlib.h>
+#include "libc.h"
+#include "pthread_impl.h"
+#include "../include/features.h"
+
+#define LOCALE_NAME_MAX 23
+
+struct __locale_map {
+	const void *map;
+	size_t map_size;
+	char name[LOCALE_NAME_MAX+1];
+	const struct __locale_map *next;
+};
+
+extern hidden const struct __locale_map __c_dot_utf8;
+extern hidden const struct __locale_struct __c_locale;
+extern hidden const struct __locale_struct __c_dot_utf8_locale;
+
+hidden const struct __locale_map *__get_locale(int, const char *);
+hidden const char *__mo_lookup(const void *, size_t, const char *);
+hidden const char *__lctrans(const char *, const struct __locale_map *);
+hidden const char *__lctrans_cur(const char *);
+hidden const char *__lctrans_impl(const char *, const struct __locale_map *);
+hidden int __loc_is_allocated(locale_t);
+hidden char *__gettextdomain(void);
+
+#define LOC_MAP_FAILED ((const struct __locale_map *)-1)
+
+#define LCTRANS(msg, lc, loc) __lctrans(msg, (loc)->cat[(lc)])
+#define LCTRANS_CUR(msg) __lctrans_cur(msg)
+
+#define C_LOCALE ((locale_t)&__c_locale)
+#define UTF8_LOCALE ((locale_t)&__c_dot_utf8_locale)
+
+#define CURRENT_LOCALE ((locale_t)&__c_locale)
+
+#define CURRENT_UTF8 (!!((locale_t)&__c_dot_utf8_locale)->cat[LC_CTYPE])
+
+#undef MB_CUR_MAX
+#define MB_CUR_MAX (CURRENT_UTF8 ? 4 : 1)
+
+#endif
diff --git a/third_party/musl/porting/liteos_m/kernel/src/internal/pthread_impl.h b/third_party/musl/porting/liteos_m/kernel/src/internal/pthread_impl.h
new file mode 100755
index 000000000..76b3ec9b6
--- /dev/null
+++ b/third_party/musl/porting/liteos_m/kernel/src/internal/pthread_impl.h
@@ -0,0 +1,136 @@
+#ifndef _PTHREAD_IMPL_H
+#define _PTHREAD_IMPL_H
+
+#include <pthread.h>
+#include <errno.h>
+#include <limits.h>
+#include <sys/mman.h>
+#include "libc.h"
+// #include "atomic.h"
+#include "../include/features.h"
+
+enum {
+	DT_EXITING = 0,
+	DT_JOINABLE,
+	DT_DETACHED,
+};
+
+struct __timer {
+	int timerid;
+	pthread_t thread;
+};
+
+#define __SU (sizeof(size_t)/sizeof(int))
+
+#define _a_stacksize __u.__s[0]
+#define _a_guardsize __u.__s[1]
+#define _a_stackaddr __u.__s[2]
+#define _a_detach __u.__i[3*__SU+0]
+#define _a_sched __u.__i[3*__SU+1]
+#define _a_policy __u.__i[3*__SU+2]
+#define _a_prio __u.__i[3*__SU+3]
+#define _m_type __u.__i[0]
+#define _m_lock __u.__vi[1]
+#define _m_waiters __u.__vi[2]
+#define _m_prev __u.__p[3]
+#define _m_next __u.__p[4]
+#define _m_count __u.__i[5]
+#define _c_shared __u.__p[0]
+#define _c_seq __u.__vi[2]
+#define _c_waiters __u.__vi[3]
+#define _c_clock __u.__i[4]
+#define _c_lock __u.__vi[8]
+#define _c_head __u.__p[1]
+#define _c_tail __u.__p[5]
+#define _rw_lock __u.__vi[0]
+#define _rw_waiters __u.__vi[1]
+#define _rw_shared __u.__i[2]
+#define _b_lock __u.__vi[0]
+#define _b_waiters __u.__vi[1]
+#define _b_limit __u.__i[2]
+#define _b_count __u.__vi[3]
+#define _b_waiters2 __u.__vi[4]
+#define _b_inst __u.__p[3]
+
+#ifndef CANARY
+#define CANARY canary
+#endif
+
+#ifndef DTP_OFFSET
+#define DTP_OFFSET 0
+#endif
+
+#ifndef tls_mod_off_t
+#define tls_mod_off_t size_t
+#endif
+
+#define SIGTIMER 32
+#define SIGCANCEL 33
+#define SIGSYNCCALL 34
+
+#define SIGALL_SET ((sigset_t *)(const unsigned long long [2]){ -1,-1 })
+#define SIGPT_SET \
+	((sigset_t *)(const unsigned long [_NSIG/8/sizeof(long)]){ \
+	[sizeof(long)==4] = 3UL<<(32*(sizeof(long)>4)) })
+#define SIGTIMER_SET \
+	((sigset_t *)(const unsigned long [_NSIG/8/sizeof(long)]){ \
+	 0x80000000 })
+
+void *__tls_get_addr(tls_mod_off_t *);
+hidden int __init_tp(void *);
+hidden void *__copy_tls(unsigned char *);
+hidden void __reset_tls(void);
+
+hidden void __membarrier_init(void);
+hidden void __dl_thread_cleanup(void);
+hidden void __testcancel(void);
+hidden void __do_cleanup_push(struct pthread_cleanup_buffer *);
+hidden void __do_cleanup_pop(struct pthread_cleanup_buffer *);
+hidden void __pthread_tsd_run_dtors(void);
+
+hidden void __pthread_key_delete_synccall(void (*)(void *), void *);
+hidden int __pthread_key_delete_impl(pthread_key_t);
+
+extern hidden volatile size_t __pthread_tsd_size;
+extern hidden void *__pthread_tsd_main[];
+extern hidden volatile int __aio_fut;
+extern hidden volatile int __eintr_valid_flag;
+
+hidden int __clone(int (*)(void *), void *, int, void *, ...);
+hidden int __thread_clone(int (*func)(void *), int flags, pthread_t *thread, unsigned char *sp);
+hidden int __set_thread_area(void *);
+hidden int __libc_sigaction(int, const struct sigaction *, struct sigaction *);
+hidden void __unmapself(void *, size_t);
+
+hidden int __timedwait(volatile int *, int, clockid_t, const struct timespec *, int);
+hidden int __timedwait_cp(volatile int *, int, clockid_t, const struct timespec *, int);
+hidden void __wait(volatile int *, volatile int *, int, int);
+
+hidden void __acquire_ptc(void);
+hidden void __release_ptc(void);
+hidden void __inhibit_ptc(void);
+
+hidden void __tl_lock(void);
+hidden void __tl_unlock(void);
+hidden void __tl_sync(pthread_t);
+
+extern hidden volatile int __thread_list_lock;
+
+extern hidden unsigned __default_stacksize;
+extern hidden unsigned __default_guardsize;
+
+#define DEFAULT_STACK_SIZE 131072
+#define DEFAULT_GUARD_SIZE 8192
+
+#define DEFAULT_STACK_MAX (8<<20)
+#define DEFAULT_GUARD_MAX (1<<20)
+
+#define __ATTRP_C11_THREAD ((void*)(uintptr_t)-1)
+
+#define MUSL_TYPE_THREAD    (-1)
+#define MUSL_TYPE_PROCESS   (0)
+
+#define PTHREAD_MUTEX_TYPE_MASK 3
+#define PTHREAD_PRIORITY_LOWEST 31
+
+#endif
diff --git a/third_party/musl/porting/liteos_m/kernel/src/internal/shgetc.c b/third_party/musl/porting/liteos_m/kernel/src/internal/shgetc.c
new file mode 100755
index 000000000..a4a9c633d
--- /dev/null
+++ b/third_party/musl/porting/liteos_m/kernel/src/internal/shgetc.c
@@ -0,0 +1,37 @@
+#include "shgetc.h"
+
+/* The shcnt field stores the number of bytes read so far, offset by
+ * the value of buf-rpos at the last function call (__shlim or __shgetc),
+ * so that between calls the inline shcnt macro can add rpos-buf to get
+ * the actual count. */
+
+void __shlim(FILE *f, off_t lim)
+{
+	f->shlim = lim;
+	f->shcnt = f->buf - f->rpos;
+	/* If lim is nonzero, rend must be a valid pointer. */
+	if (lim && f->rend - f->rpos > lim)
+		f->shend = f->rpos + lim;
+	else
+		f->shend = f->rend;
+}
+
+int __shgetc(FILE *f)
+{
+	int c;
+	off_t cnt = shcnt(f);
+	if (f->shlim && cnt >= f->shlim || (c=__uflow(f)) < 0) {
+		f->shcnt = f->buf - f->rpos + cnt;
+		f->shend = f->rpos;
+		f->shlim = -1;
+		return EOF;
+	}
+	cnt++;
+	if (f->shlim && f->rend - f->rpos > f->shlim - cnt)
+		f->shend = f->rpos + (f->shlim - cnt);
+	else
+		f->shend = f->rend;
+	f->shcnt = f->buf - f->rpos + cnt;
+	if (f->rpos[-1] != c) f->rpos[-1] = c;
+	return c;
+}
diff --git a/third_party/musl/porting/liteos_m/kernel/src/internal/shgetc.h b/third_party/musl/porting/liteos_m/kernel/src/internal/shgetc.h
new file mode 100755
index 000000000..e5d9b70c1
--- /dev/null
+++ b/third_party/musl/porting/liteos_m/kernel/src/internal/shgetc.h
@@ -0,0 +1,33 @@
+#include "stdio_impl.h"
+#include "../include/features.h"
+
+/* Scan helper "stdio" functions for use by scanf-family and strto*-family
+ * functions. These accept either a valid stdio FILE, or a minimal pseudo
+ * FILE whose buffer pointers point into a null-terminated string. In the
+ * latter case, the sh_fromstring macro should be used to setup the FILE;
+ * the rest of the structure can be left uninitialized.
+ *
+ * To begin using these functions, shlim must first be called on the FILE
+ * to set a field width limit, or 0 for no limit. For string pseudo-FILEs,
+ * a nonzero limit is not valid and produces undefined behavior. After that,
+ * shgetc, shunget, and shcnt are valid as long as no other stdio functions
+ * are called on the stream.
+ *
+ * When used with a real FILE object, shunget has only one byte of pushback
+ * available. Further shunget (up to a limit of the stdio UNGET buffer size)
+ * will adjust the position but will not restore the data to be read again.
+ * This functionality is needed for the wcsto*-family functions, where it's
+ * okay because the FILE will be discarded immediately anyway. When used
+ * with string pseudo-FILEs, shunget has unlimited pushback, back to the
+ * beginning of the string. */
+
+hidden void __shlim(FILE *, off_t);
+hidden int __shgetc(FILE *);
+
+#define shcnt(f) ((f)->shcnt + ((f)->rpos - (f)->buf))
+#define shlim(f, lim) __shlim((f), (lim))
+#define shgetc(f) (((f)->rpos != (f)->shend) ? *(f)->rpos++ : __shgetc(f))
+#define shunget(f) ((f)->shlim>=0 ? (void)(f)->rpos-- : (void)0)
+
+#define sh_fromstring(f, s) \
+	((f)->buf = (f)->rpos = (void *)(s), (f)->rend = (void*)-1)
diff --git a/third_party/musl/porting/liteos_m/kernel/src/internal/stdio_impl.h b/third_party/musl/porting/liteos_m/kernel/src/internal/stdio_impl.h
new file mode 100755
index 000000000..fa94606a0
--- /dev/null
+++ b/third_party/musl/porting/liteos_m/kernel/src/internal/stdio_impl.h
@@ -0,0 +1,88 @@
+#ifndef _STDIO_IMPL_H
+#define _STDIO_IMPL_H
+
+#define __NEED_struct__IO_FILE
+
+#include <stdio.h>
+#include <bits/alltypes.h>
+#include "../include/features.h"
+
+#define UNGET 8
+
+#define FLOCK(f)    __lockfile(f)
+#define FUNLOCK(f)  __unlockfile(f)
+
+#define F_PERM 1
+#define F_NORD 4
+#define F_NOWR 8
+#define F_EOF 16
+#define F_ERR 32
+#define F_SVB 64
+#define F_APP 128
+
+#define  PTHREAD_RECURSIVE_MUTEX_INITIALIZER_NP PTHREAD_MUTEX_INITIALIZER
+extern hidden FILE *volatile __stdin_used;
+extern hidden FILE *volatile __stdout_used;
+extern hidden FILE *volatile __stderr_used;
+
+hidden int __lockfile(FILE *);
+hidden int __unlockfile(FILE *);
+
+hidden size_t __stdio_read(FILE *, unsigned char *, size_t);
+hidden size_t __stdio_write(FILE *, const unsigned char *, size_t);
+hidden size_t __stdout_write(FILE *, const unsigned char *, size_t);
+hidden off_t __stdio_seek(FILE *, off_t, int);
+hidden int __stdio_close(FILE *);
+
+hidden size_t __string_read(FILE *, unsigned char *, size_t);
+
+hidden int __toread(FILE *);
+hidden int __towrite(FILE *);
+
+hidden void __stdio_exit(void);
+hidden void __stdio_exit_needed(void);
+
+#if defined(__PIC__) && (100*__GNUC__+__GNUC_MINOR__ >= 303)
+__attribute__((visibility("protected")))
+#endif
+int __overflow(FILE *, int), __uflow(FILE *);
+
+hidden int __fseeko(FILE *, off_t, int);
+hidden int __fseeko_unlocked(FILE *, off_t, int);
+hidden off_t __ftello(FILE *);
+hidden off_t __ftello_unlocked(FILE *);
+hidden size_t __fwritex(const unsigned char *, size_t, FILE *);
+hidden int __putc_unlocked(int, FILE *);
+
+hidden FILE *__fdopen(int, const char *);
+hidden int __fmodeflags(const char *);
+
+hidden FILE *__ofl_add(FILE *f);
+hidden FILE **__ofl_lock(void);
+hidden void __ofl_unlock(void);
+
+struct __pthread;
+hidden void __register_locked_file(FILE *, struct __pthread *);
+hidden void __unlist_locked_file(FILE *);
+hidden void __do_orphaned_stdio_locks(void);
+
+#define MAYBE_WAITERS 0x40000000
+
+hidden void __getopt_msg(const char *, const char *, const char *, size_t);
+
+#define feof(f) ((f)->flags & F_EOF)
+#define ferror(f) ((f)->flags & F_ERR)
+
+#define getc_unlocked(f) \
+	( ((f)->rpos != (f)->rend) ? *(f)->rpos++ : __uflow((f)) )
+
+#define putc_unlocked(c, f) \
+	( (((unsigned char)(c)!=(f)->lbf && (f)->wpos!=(f)->wend)) \
+	? *(f)->wpos++ = (unsigned char)(c) \
+	: __overflow((f),(unsigned char)(c)) )
+
+/* Caller-allocated FILE * operations */
+hidden FILE *__fopen_rb_ca(const char *, FILE *, unsigned char *, size_t);
+hidden int __fclose_ca(FILE *);
+
+#endif
diff --git a/third_party/musl/porting/liteos_m/kernel/src/locale/__lctrans.c b/third_party/musl/porting/liteos_m/kernel/src/locale/__lctrans.c
new file mode 100755
index 000000000..9fbe762ad
--- /dev/null
+++ b/third_party/musl/porting/liteos_m/kernel/src/locale/__lctrans.c
@@ -0,0 +1,19 @@
+#include <locale.h>
+#include "locale_impl.h"
+
+static const char *dummy(const char *msg, const struct __locale_map *lm)
+{
+	return msg;
+}
+
+weak_alias(dummy, __lctrans_impl);
+
+const char *__lctrans(const char *msg, const struct __locale_map *lm)
+{
+	return __lctrans_impl(msg, lm);
+}
+
+const char *__lctrans_cur(const char *msg)
+{
+	return __lctrans_impl(msg, CURRENT_LOCALE->cat[LC_MESSAGES]);
+}
diff --git a/third_party/musl/porting/liteos_m/kernel/src/locale/c_locale.c b/third_party/musl/porting/liteos_m/kernel/src/locale/c_locale.c
new file mode 100755
index 000000000..77ccf5873
--- /dev/null
+++ b/third_party/musl/porting/liteos_m/kernel/src/locale/c_locale.c
@@ -0,0 +1,15 @@
+#include "locale_impl.h"
+#include <stdint.h>
+
+static const uint32_t empty_mo[] = { 0x950412de, 0, -1, -1, -1 };
+
+const struct __locale_map __c_dot_utf8 = {
+	.map = empty_mo,
+	.map_size = sizeof empty_mo,
+	.name = "C.UTF-8"
+};
+
+const struct __locale_struct __c_locale = { 0 };
+const struct __locale_struct __c_dot_utf8_locale = {
+	.cat[LC_CTYPE] = &__c_dot_utf8
+};
diff --git a/third_party/musl/porting/liteos_m/kernel/src/locale/langinfo.c b/third_party/musl/porting/liteos_m/kernel/src/locale/langinfo.c
new file mode 100755
index 000000000..7953c3842
--- /dev/null
+++ b/third_party/musl/porting/liteos_m/kernel/src/locale/langinfo.c
@@ -0,0 +1,73 @@
+#include <locale.h>
+#include <langinfo.h>
+#include "locale_impl.h"
+
+static const char c_time[] =
+	"Sun\0" "Mon\0" "Tue\0" "Wed\0" "Thu\0" "Fri\0" "Sat\0"
+	"Sunday\0" "Monday\0" "Tuesday\0" "Wednesday\0"
+	"Thursday\0" "Friday\0" "Saturday\0"
+	"Jan\0" "Feb\0" "Mar\0" "Apr\0" "May\0" "Jun\0"
+	"Jul\0" "Aug\0" "Sep\0" "Oct\0" "Nov\0" "Dec\0"
+	"January\0"   "February\0" "March\0"    "April\0"
+	"May\0"       "June\0"     "July\0"     "August\0"
+	"September\0" "October\0"  "November\0" "December\0"
+	"AM\0" "PM\0"
+	"%a %b %e %T %Y\0"
+	"%m/%d/%y\0"
+	"%H:%M:%S\0"
+	"%I:%M:%S %p\0"
+	"\0"
+	"\0"
+	"%m/%d/%y\0"
+	"0123456789\0"
+	"%a %b %e %T %Y\0"
+	"%H:%M:%S";
+
+static const char c_messages[] = "^[yY]\0" "^[nN]\0" "yes\0" "no";
+static const char c_numeric[] = ".\0" "";
+
+char *__nl_langinfo_l(nl_item item, locale_t loc)
+{
+	int cat = item >> 16;
+	int idx = item & 65535;
+	const char *str;
+
+	if (item == CODESET) return loc->cat[LC_CTYPE] ? "UTF-8" : "ASCII";
+
+	/* _NL_LOCALE_NAME extension */
+	if (idx == 65535 && cat < LC_ALL)
+		return loc->cat[cat] ? (char *)loc->cat[cat]->name : "C";
+
+	switch (cat) {
+	case LC_NUMERIC:
+		if (idx > 1) return "";
+		str = c_numeric;
+		break;
+	case LC_TIME:
+		if (idx > 0x31) return "";
+		str = c_time;
+		break;
+	case LC_MONETARY:
+		if (idx > 0) return "";
+		str = "";
+		break;
+	case LC_MESSAGES:
+		if (idx > 3) return "";
+		str = c_messages;
+		break;
+	default:
+		return "";
+	}
+
+	for (; idx; idx--, str++) for (; *str; str++);
+	if (cat != LC_NUMERIC && *str) str = LCTRANS(str, cat, loc);
+	return (char *)str;
+}
+
+char *__nl_langinfo(nl_item item)
+{
+	return __nl_langinfo_l(item, CURRENT_LOCALE);
+}
+
+weak_alias(__nl_langinfo, nl_langinfo);
+weak_alias(__nl_langinfo_l, nl_langinfo_l);
diff --git a/third_party/musl/porting/liteos_m/kernel/src/math/exp_data.c b/third_party/musl/porting/liteos_m/kernel/src/math/exp_data.c
new file mode 100755
index 000000000..2d7faf9f3
--- /dev/null
+++ b/third_party/musl/porting/liteos_m/kernel/src/math/exp_data.c
@@ -0,0 +1,182 @@
+/*
+ * Shared data between exp, exp2 and pow.
+ *
+ * Copyright (c) 2018, Arm Limited.
+ * SPDX-License-Identifier: MIT
+ */
+
+#include "exp_data.h"
+
+#define N (1 << EXP_TABLE_BITS)
+
+const struct exp_data __exp_data1 = {
+// N/ln2
+.invln2N = 0x1.71547652b82fep0 * N,
+// -ln2/N
+.negln2hiN = -0x1.62e42fefa0000p-8,
+.negln2loN = -0x1.cf79abc9e3b3ap-47,
+// Used for rounding when !TOINT_INTRINSICS
+#if EXP_USE_TOINT_NARROW
+.shift = 0x1800000000.8p0,
+#else
+.shift = 0x1.8p52,
+#endif
+// exp polynomial coefficients.
+.poly = {
+// abs error: 1.555*2^-66
+// ulp error: 0.509 (0.511 without fma)
+// if |x| < ln2/256+eps
+// abs error if |x| < ln2/256+0x1p-15: 1.09*2^-65
+// abs error if |x| < ln2/128: 1.7145*2^-56
+0x1.ffffffffffdbdp-2,
+0x1.555555555543cp-3,
+0x1.55555cf172b91p-5,
+0x1.1111167a4d017p-7,
+},
+.exp2_shift = 0x1.8p52 / N,
+// exp2 polynomial coefficients.
+.exp2_poly = {
+// abs error: 1.2195*2^-65
+// ulp error: 0.507 (0.511 without fma)
+// if |x| < 1/256
+// abs error if |x| < 1/128: 1.9941*2^-56
+0x1.62e42fefa39efp-1,
+0x1.ebfbdff82c424p-3,
+0x1.c6b08d70cf4b5p-5,
+0x1.3b2abd24650ccp-7,
+0x1.5d7e09b4e3a84p-10,
+},
+// 2^(k/N) ~= H[k]*(1 + T[k]) for int k in [0,N)
+// tab[2*k] = asuint64(T[k])
+// tab[2*k+1] = asuint64(H[k]) - (k << 52)/N
+.tab = {
+0x0, 0x3ff0000000000000,
+0x3c9b3b4f1a88bf6e, 0x3feff63da9fb3335,
+0xbc7160139cd8dc5d, 0x3fefec9a3e778061,
+0xbc905e7a108766d1, 0x3fefe315e86e7f85,
+0x3c8cd2523567f613, 0x3fefd9b0d3158574,
+0xbc8bce8023f98efa, 0x3fefd06b29ddf6de,
+0x3c60f74e61e6c861, 0x3fefc74518759bc8,
+0x3c90a3e45b33d399, 0x3fefbe3ecac6f383,
+0x3c979aa65d837b6d, 0x3fefb5586cf9890f,
+0x3c8eb51a92fdeffc, 0x3fefac922b7247f7,
+0x3c3ebe3d702f9cd1, 0x3fefa3ec32d3d1a2,
+0xbc6a033489906e0b, 0x3fef9b66affed31b,
+0xbc9556522a2fbd0e, 0x3fef9301d0125b51,
+0xbc5080ef8c4eea55, 0x3fef8abdc06c31cc,
+0xbc91c923b9d5f416, 0x3fef829aaea92de0,
+0x3c80d3e3e95c55af, 0x3fef7a98c8a58e51,
+0xbc801b15eaa59348, 0x3fef72b83c7d517b,
+0xbc8f1ff055de323d, 0x3fef6af9388c8dea,
+0x3c8b898c3f1353bf, 0x3fef635beb6fcb75,
+0xbc96d99c7611eb26, 0x3fef5be084045cd4,
+0x3c9aecf73e3a2f60, 0x3fef54873168b9aa,
+0xbc8fe782cb86389d, 0x3fef4d5022fcd91d,
+0x3c8a6f4144a6c38d, 0x3fef463b88628cd6,
+0x3c807a05b0e4047d, 0x3fef3f49917ddc96,
+0x3c968efde3a8a894, 0x3fef387a6e756238,
+0x3c875e18f274487d, 0x3fef31ce4fb2a63f,
+0x3c80472b981fe7f2, 0x3fef2b4565e27cdd,
+0xbc96b87b3f71085e, 0x3fef24dfe1f56381,
+0x3c82f7e16d09ab31, 0x3fef1e9df51fdee1,
+0xbc3d219b1a6fbffa, 0x3fef187fd0dad990,
+0x3c8b3782720c0ab4, 0x3fef1285a6e4030b,
+0x3c6e149289cecb8f, 0x3fef0cafa93e2f56,
+0x3c834d754db0abb6, 0x3fef06fe0a31b715,
+0x3c864201e2ac744c, 0x3fef0170fc4cd831,
+0x3c8fdd395dd3f84a, 0x3feefc08b26416ff,
+0xbc86a3803b8e5b04, 0x3feef6c55f929ff1,
+0xbc924aedcc4b5068, 0x3feef1a7373aa9cb,
+0xbc9907f81b512d8e, 0x3feeecae6d05d866,
+0xbc71d1e83e9436d2, 0x3feee7db34e59ff7,
+0xbc991919b3ce1b15, 0x3feee32dc313a8e5,
+0x3c859f48a72a4c6d, 0x3feedea64c123422,
+0xbc9312607a28698a, 0x3feeda4504ac801c,
+0xbc58a78f4817895b, 0x3feed60a21f72e2a,
+0xbc7c2c9b67499a1b, 0x3feed1f5d950a897,
+0x3c4363ed60c2ac11, 0x3feece086061892d,
+0x3c9666093b0664ef, 0x3feeca41ed1d0057,
+0x3c6ecce1daa10379, 0x3feec6a2b5c13cd0,
+0x3c93ff8e3f0f1230, 0x3feec32af0d7d3de,
+0x3c7690cebb7aafb0, 0x3feebfdad5362a27,
+0x3c931dbdeb54e077, 0x3feebcb299fddd0d,
+0xbc8f94340071a38e, 0x3feeb9b2769d2ca7,
+0xbc87deccdc93a349, 0x3feeb6daa2cf6642,
+0xbc78dec6bd0f385f, 0x3feeb42b569d4f82,
+0xbc861246ec7b5cf6, 0x3feeb1a4ca5d920f,
+0x3c93350518fdd78e, 0x3feeaf4736b527da,
+0x3c7b98b72f8a9b05, 0x3feead12d497c7fd,
+0x3c9063e1e21c5409, 0x3feeab07dd485429,
+0x3c34c7855019c6ea, 0x3feea9268a5946b7,
+0x3c9432e62b64c035, 0x3feea76f15ad2148,
+0xbc8ce44a6199769f, 0x3feea5e1b976dc09,
+0xbc8c33c53bef4da8, 0x3feea47eb03a5585,
+0xbc845378892be9ae, 0x3feea34634ccc320,
+0xbc93cedd78565858, 0x3feea23882552225,
+0x3c5710aa807e1964, 0x3feea155d44ca973,
+0xbc93b3efbf5e2228, 0x3feea09e667f3bcd,
+0xbc6a12ad8734b982, 0x3feea012750bdabf,
+0xbc6367efb86da9ee, 0x3fee9fb23c651a2f,
+0xbc80dc3d54e08851, 0x3fee9f7df9519484,
+0xbc781f647e5a3ecf, 0x3fee9f75e8ec5f74,
+0xbc86ee4ac08b7db0, 0x3fee9f9a48a58174,
+0xbc8619321e55e68a, 0x3fee9feb564267c9,
+0x3c909ccb5e09d4d3, 0x3feea0694fde5d3f,
+0xbc7b32dcb94da51d, 0x3feea11473eb0187,
+0x3c94ecfd5467c06b, 0x3feea1ed0130c132,
+0x3c65ebe1abd66c55, 0x3feea2f336cf4e62,
+0xbc88a1c52fb3cf42, 0x3feea427543e1a12,
+0xbc9369b6f13b3734, 0x3feea589994cce13,
+0xbc805e843a19ff1e, 0x3feea71a4623c7ad,
+0xbc94d450d872576e, 0x3feea8d99b4492ed,
+0x3c90ad675b0e8a00, 0x3feeaac7d98a6699,
+0x3c8db72fc1f0eab4, 0x3feeace5422aa0db,
+0xbc65b6609cc5e7ff, 0x3feeaf3216b5448c,
+0x3c7bf68359f35f44, 0x3feeb1ae99157736,
+0xbc93091fa71e3d83, 0x3feeb45b0b91ffc6,
+0xbc5da9b88b6c1e29, 0x3feeb737b0cdc5e5,
+0xbc6c23f97c90b959, 0x3feeba44cbc8520f,
+0xbc92434322f4f9aa, 0x3feebd829fde4e50,
+0xbc85ca6cd7668e4b, 0x3feec0f170ca07ba,
+0x3c71affc2b91ce27, 0x3feec49182a3f090,
+0x3c6dd235e10a73bb, 0x3feec86319e32323,
+0xbc87c50422622263, 0x3feecc667b5de565,
+0x3c8b1c86e3e231d5, 0x3feed09bec4a2d33,
+0xbc91bbd1d3bcbb15, 0x3feed503b23e255d,
+0x3c90cc319cee31d2, 0x3feed99e1330b358,
+0x3c8469846e735ab3, 0x3feede6b5579fdbf,
+0xbc82dfcd978e9db4, 0x3feee36bbfd3f37a,
+0x3c8c1a7792cb3387, 0x3feee89f995ad3ad,
+0xbc907b8f4ad1d9fa, 0x3feeee07298db666,
+0xbc55c3d956dcaeba, 0x3feef3a2b84f15fb,
+0xbc90a40e3da6f640, 0x3feef9728de5593a,
+0xbc68d6f438ad9334, 0x3feeff76f2fb5e47,
+0xbc91eee26b588a35, 0x3fef05b030a1064a,
+0x3c74ffd70a5fddcd, 0x3fef0c1e904bc1d2,
+0xbc91bdfbfa9298ac, 0x3fef12c25bd71e09,
+0x3c736eae30af0cb3, 0x3fef199bdd85529c,
+0x3c8ee3325c9ffd94, 0x3fef20ab5fffd07a,
+0x3c84e08fd10959ac, 0x3fef27f12e57d14b,
+0x3c63cdaf384e1a67, 0x3fef2f6d9406e7b5,
+0x3c676b2c6c921968, 0x3fef3720dcef9069,
+0xbc808a1883ccb5d2, 0x3fef3f0b555dc3fa,
+0xbc8fad5d3ffffa6f, 0x3fef472d4a07897c,
+0xbc900dae3875a949, 0x3fef4f87080d89f2,
+0x3c74a385a63d07a7, 0x3fef5818dcfba487,
+0xbc82919e2040220f, 0x3fef60e316c98398,
+0x3c8e5a50d5c192ac, 0x3fef69e603db3285,
+0x3c843a59ac016b4b, 0x3fef7321f301b460,
+0xbc82d52107b43e1f, 0x3fef7c97337b9b5f,
+0xbc892ab93b470dc9, 0x3fef864614f5a129,
+0x3c74b604603a88d3, 0x3fef902ee78b3ff6,
+0x3c83c5ec519d7271, 0x3fef9a51fbc74c83,
+0xbc8ff7128fd391f0, 0x3fefa4afa2a490da,
+0xbc8dae98e223747d, 0x3fefaf482d8e67f1,
+0x3c8ec3bc41aa2008, 0x3fefba1bee615a27,
+0x3c842b94c3a9eb32, 0x3fefc52b376bba97,
+0x3c8a64a931d185ee, 0x3fefd0765b6e4540,
+0xbc8e37bae43be3ed, 0x3fefdbfdad9cbe14,
+0x3c77893b4d91cd9d, 0x3fefe7c1819e90d8,
+0x3c5305c14160cc89, 0x3feff3c22b8f71f1,
+},
+};
diff --git a/third_party/musl/porting/liteos_m/kernel/src/math/exp_data.h b/third_party/musl/porting/liteos_m/kernel/src/math/exp_data.h
new file mode 100755
index 000000000..968ad760e
--- /dev/null
+++ b/third_party/musl/porting/liteos_m/kernel/src/math/exp_data.h
@@ -0,0 +1,26 @@
+/*
+ * Copyright (c) 2018, Arm Limited.
+ * SPDX-License-Identifier: MIT
+ */
+#ifndef _EXP_DATA_H
+#define _EXP_DATA_H
+
+#include <features.h>
+#include <stdint.h>
+
+#define EXP_TABLE_BITS 7
+#define EXP_POLY_ORDER 5
+#define EXP_USE_TOINT_NARROW 0
+#define EXP2_POLY_ORDER 5
+extern const struct exp_data {
+	double invln2N;
+	double shift;
+	double negln2hiN;
+	double negln2loN;
+	double poly[4]; /* Last four coefficients.  */
+	double exp2_shift;
+	double exp2_poly[EXP2_POLY_ORDER];
+	uint64_t tab[2*(1 << EXP_TABLE_BITS)];
+} __exp_data1;
+
+#endif
diff --git a/third_party/musl/porting/liteos_m/kernel/src/math/log.c b/third_party/musl/porting/liteos_m/kernel/src/math/log.c
new file mode 100755
index 000000000..4024f8289
--- /dev/null
+++ b/third_party/musl/porting/liteos_m/kernel/src/math/log.c
@@ -0,0 +1,127 @@
+/*
+ * Double-precision log(x) function.
+ *
+ * Copyright (c) 2018, Arm Limited.
+ * SPDX-License-Identifier: MIT
+ */
+
+#include <math.h>
+#include <stdint.h>
+#include "libm.h"
+#include "log_data.h"
+
+#define T __log_data.tab
+#define T2 __log_data.tab2
+#define B __log_data.poly1
+#define A __log_data.poly
+#define Ln2hi __log_data.ln2hi
+#define Ln2lo __log_data.ln2lo
+#define N (1 << LOG_TABLE_BITS)
+#define OFF 0x3fe6000000000000
+
+#ifdef NEED_MATH_DIVZERO
+/* base math internal func */
+double __math_divzero(uint32_t sign)
+{
+    return fp_barrier(sign ? -1.0 : 1.0) / 0.0;
+}
+#endif
+
+#ifdef NEED_MATH_INVALID
+double __math_invalid(double x)
+{
+	return (x - x) / (x - x);
+}
+#endif
+
+/* Top 16 bits of a double.  */
+static inline uint32_t top16(double x)
+{
+	return asuint64(x) >> 48;
+}
+
+double log(double x)
+{
+	double_t w, z, r, r2, r3, y, invc, logc, kd, hi, lo;
+	uint64_t ix, iz, tmp;
+	uint32_t top;
+	int k, i;
+
+	ix = asuint64(x);
+	top = top16(x);
+#define LO asuint64(1.0 - 0x1p-4)
+#define HI asuint64(1.0 + 0x1.09p-4)
+	if (predict_false(ix - LO < HI - LO)) {
+		/* Handle close to 1.0 inputs separately.  */
+		/* Fix sign of zero with downward rounding when x==1.  */
+		if (WANT_ROUNDING && predict_false(ix == asuint64(1.0)))
+			return 0;
+		r = x - 1.0;
+		r2 = r * r;
+		r3 = r * r2;
+		y = r3 *
+		    (B[1] + r * B[2] + r2 * B[3] +
+		     r3 * (B[4] + r * B[5] + r2 * B[6] +
+			   r3 * (B[7] + r * B[8] + r2 * B[9] + r3 * B[10])));
+		/* Worst-case error is around 0.507 ULP.  */
+		w = r * 0x1p27;
+		double_t rhi = r + w - w;
+		double_t rlo = r - rhi;
+		w = rhi * rhi * B[0]; /* B[0] == -0.5.  */
+		hi = r + w;
+		lo = r - hi + w;
+		lo += B[0] * rlo * (rhi + r);
+		y += lo;
+		y += hi;
+		return eval_as_double(y);
+	}
+	if (predict_false(top - 0x0010 >= 0x7ff0 - 0x0010)) {
+		/* x < 0x1p-1022 or inf or nan.  */
+		if (ix * 2 == 0)
+			return __math_divzero(1);
+		if (ix == asuint64(INFINITY)) /* log(inf) == inf.  */
+			return x;
+		if ((top & 0x8000) || (top & 0x7ff0) == 0x7ff0)
+			return __math_invalid(x);
+		/* x is subnormal, normalize it.  */
+		ix = asuint64(x * 0x1p52);
+		ix -= 52ULL << 52;
+	}
+
+	/* x = 2^k z; where z is in range [OFF,2*OFF) and exact.
+	   The range is split into N subintervals.
+	   The ith subinterval contains z and c is near its center.  */
+	tmp = ix - OFF;
+	i = (tmp >> (52 - LOG_TABLE_BITS)) % N;
+	k = (int64_t)tmp >> 52; /* arithmetic shift */
+	iz = ix - (tmp & 0xfffULL << 52);
+	invc = T[i].invc;
+	logc = T[i].logc;
+	z = asdouble(iz);
+
+	/* log(x) = log1p(z/c-1) + log(c) + k*Ln2.  */
+	/* r ~= z/c - 1, |r| < 1/(2*N).  */
+#if __FP_FAST_FMA
+	/* rounding error: 0x1p-55/N.  */
+	r = __builtin_fma(z, invc, -1.0);
+#else
+	/* rounding error: 0x1p-55/N + 0x1p-66.  */
+	r = (z - T2[i].chi - T2[i].clo) * invc;
+#endif
+	kd = (double_t)k;
+
+	/* hi + lo = r + log(c) + k*Ln2.  */
+	w = kd * Ln2hi + logc;
+	hi = w + r;
+	lo = w - hi + r + kd * Ln2lo;
+
+	/* log(x) = lo + (log1p(r) - r) + hi.  */
+	r2 = r * r; /* rounding error: 0x1p-54/N^2.  */
+	/* Worst case error if |y| > 0x1p-5:
+	   0.5 + 4.13/N + abs-poly-error*2^57 ULP (+ 0.002 ULP without fma)
+	   Worst case error if |y| > 0x1p-4:
+	   0.5 + 2.06/N + abs-poly-error*2^56 ULP (+ 0.001 ULP without fma).  */
+	y = lo + r2 * A[0] +
+	    r * r2 * (A[1] + r * A[2] + r2 * (A[3] + r * A[4])) + hi;
+	return eval_as_double(y);
+}
diff --git a/third_party/musl/porting/liteos_m/kernel/src/math/log_data.c b/third_party/musl/porting/liteos_m/kernel/src/math/log_data.c
new file mode 100755
index 000000000..1a6ec712a
--- /dev/null
+++ b/third_party/musl/porting/liteos_m/kernel/src/math/log_data.c
@@ -0,0 +1,328 @@
+/*
+ * Data for log.
+ *
+ * Copyright (c) 2018, Arm Limited.
+ * SPDX-License-Identifier: MIT
+ */
+
+#include "log_data.h"
+
+#define N (1 << LOG_TABLE_BITS)
+
+const struct log_data __log_data = {
+.ln2hi = 0x1.62e42fefa3800p-1,
+.ln2lo = 0x1.ef35793c76730p-45,
+.poly1 = {
+// relative error: 0x1.c04d76cp-63
+// in -0x1p-4 0x1.09p-4 (|log(1+x)| > 0x1p-4 outside the interval)
+-0x1p-1,
+0x1.5555555555577p-2,
+-0x1.ffffffffffdcbp-3,
+0x1.999999995dd0cp-3,
+-0x1.55555556745a7p-3,
+0x1.24924a344de3p-3,
+-0x1.fffffa4423d65p-4,
+0x1.c7184282ad6cap-4,
+-0x1.999eb43b068ffp-4,
+0x1.78182f7afd085p-4,
+-0x1.5521375d145cdp-4,
+},
+.poly = {
+// relative error: 0x1.926199e8p-56
+// abs error: 0x1.882ff33p-65
+// in -0x1.fp-9 0x1.fp-9
+-0x1.0000000000001p-1,
+0x1.555555551305bp-2,
+-0x1.fffffffeb459p-3,
+0x1.999b324f10111p-3,
+-0x1.55575e506c89fp-3,
+},
+/* Algorithm:
+
+	x = 2^k z
+	log(x) = k ln2 + log(c) + log(z/c)
+	log(z/c) = poly(z/c - 1)
+
+where z is in [1.6p-1; 1.6p0] which is split into N subintervals and z falls
+into the ith one, then table entries are computed as
+
+	tab[i].invc = 1/c
+	tab[i].logc = (double)log(c)
+	tab2[i].chi = (double)c
+	tab2[i].clo = (double)(c - (double)c)
+
+where c is near the center of the subinterval and is chosen by trying +-2^29
+floating point invc candidates around 1/center and selecting one for which
+
+	1) the rounding error in 0x1.8p9 + logc is 0,
+	2) the rounding error in z - chi - clo is < 0x1p-66 and
+	3) the rounding error in (double)log(c) is minimized (< 0x1p-66).
+
+Note: 1) ensures that k*ln2hi + logc can be computed without rounding error,
+2) ensures that z/c - 1 can be computed as (z - chi - clo)*invc with close to
+a single rounding error when there is no fast fma for z*invc - 1, 3) ensures
+that logc + poly(z/c - 1) has small error, however near x == 1 when
+|log(x)| < 0x1p-4, this is not enough so that is special cased.  */
+.tab = {
+{0x1.734f0c3e0de9fp+0, -0x1.7cc7f79e69000p-2},
+{0x1.713786a2ce91fp+0, -0x1.76feec20d0000p-2},
+{0x1.6f26008fab5a0p+0, -0x1.713e31351e000p-2},
+{0x1.6d1a61f138c7dp+0, -0x1.6b85b38287800p-2},
+{0x1.6b1490bc5b4d1p+0, -0x1.65d5590807800p-2},
+{0x1.69147332f0cbap+0, -0x1.602d076180000p-2},
+{0x1.6719f18224223p+0, -0x1.5a8ca86909000p-2},
+{0x1.6524f99a51ed9p+0, -0x1.54f4356035000p-2},
+{0x1.63356aa8f24c4p+0, -0x1.4f637c36b4000p-2},
+{0x1.614b36b9ddc14p+0, -0x1.49da7fda85000p-2},
+{0x1.5f66452c65c4cp+0, -0x1.445923989a800p-2},
+{0x1.5d867b5912c4fp+0, -0x1.3edf439b0b800p-2},
+{0x1.5babccb5b90dep+0, -0x1.396ce448f7000p-2},
+{0x1.59d61f2d91a78p+0, -0x1.3401e17bda000p-2},
+{0x1.5805612465687p+0, -0x1.2e9e2ef468000p-2},
+{0x1.56397cee76bd3p+0, -0x1.2941b3830e000p-2},
+{0x1.54725e2a77f93p+0, -0x1.23ec58cda8800p-2},
+{0x1.52aff42064583p+0, -0x1.1e9e129279000p-2},
+{0x1.50f22dbb2bddfp+0, -0x1.1956d2b48f800p-2},
+{0x1.4f38f4734ded7p+0, -0x1.141679ab9f800p-2},
+{0x1.4d843cfde2840p+0, -0x1.0edd094ef9800p-2},
+{0x1.4bd3ec078a3c8p+0, -0x1.09aa518db1000p-2},
+{0x1.4a27fc3e0258ap+0, -0x1.047e65263b800p-2},
+{0x1.4880524d48434p+0, -0x1.feb224586f000p-3},
+{0x1.46dce1b192d0bp+0, -0x1.f474a7517b000p-3},
+{0x1.453d9d3391854p+0, -0x1.ea4443d103000p-3},
+{0x1.43a2744b4845ap+0, -0x1.e020d44e9b000p-3},
+{0x1.420b54115f8fbp+0, -0x1.d60a22977f000p-3},
+{0x1.40782da3ef4b1p+0, -0x1.cc00104959000p-3},
+{0x1.3ee8f5d57fe8fp+0, -0x1.c202956891000p-3},
+{0x1.3d5d9a00b4ce9p+0, -0x1.b81178d811000p-3},
+{0x1.3bd60c010c12bp+0, -0x1.ae2c9ccd3d000p-3},
+{0x1.3a5242b75dab8p+0, -0x1.a45402e129000p-3},
+{0x1.38d22cd9fd002p+0, -0x1.9a877681df000p-3},
+{0x1.3755bc5847a1cp+0, -0x1.90c6d69483000p-3},
+{0x1.35dce49ad36e2p+0, -0x1.87120a645c000p-3},
+{0x1.34679984dd440p+0, -0x1.7d68fb4143000p-3},
+{0x1.32f5cceffcb24p+0, -0x1.73cb83c627000p-3},
+{0x1.3187775a10d49p+0, -0x1.6a39a9b376000p-3},
+{0x1.301c8373e3990p+0, -0x1.60b3154b7a000p-3},
+{0x1.2eb4ebb95f841p+0, -0x1.5737d76243000p-3},
+{0x1.2d50a0219a9d1p+0, -0x1.4dc7b8fc23000p-3},
+{0x1.2bef9a8b7fd2ap+0, -0x1.4462c51d20000p-3},
+{0x1.2a91c7a0c1babp+0, -0x1.3b08abc830000p-3},
+{0x1.293726014b530p+0, -0x1.31b996b490000p-3},
+{0x1.27dfa5757a1f5p+0, -0x1.2875490a44000p-3},
+{0x1.268b39b1d3bbfp+0, -0x1.1f3b9f879a000p-3},
+{0x1.2539d838ff5bdp+0, -0x1.160c8252ca000p-3},
+{0x1.23eb7aac9083bp+0, -0x1.0ce7f57f72000p-3},
+{0x1.22a012ba940b6p+0, -0x1.03cdc49fea000p-3},
+{0x1.2157996cc4132p+0, -0x1.f57bdbc4b8000p-4},
+{0x1.201201dd2fc9bp+0, -0x1.e370896404000p-4},
+{0x1.1ecf4494d480bp+0, -0x1.d17983ef94000p-4},
+{0x1.1d8f5528f6569p+0, -0x1.bf9674ed8a000p-4},
+{0x1.1c52311577e7cp+0, -0x1.adc79202f6000p-4},
+{0x1.1b17c74cb26e9p+0, -0x1.9c0c3e7288000p-4},
+{0x1.19e010c2c1ab6p+0, -0x1.8a646b372c000p-4},
+{0x1.18ab07bb670bdp+0, -0x1.78d01b3ac0000p-4},
+{0x1.1778a25efbcb6p+0, -0x1.674f145380000p-4},
+{0x1.1648d354c31dap+0, -0x1.55e0e6d878000p-4},
+{0x1.151b990275fddp+0, -0x1.4485cdea1e000p-4},
+{0x1.13f0ea432d24cp+0, -0x1.333d94d6aa000p-4},
+{0x1.12c8b7210f9dap+0, -0x1.22079f8c56000p-4},
+{0x1.11a3028ecb531p+0, -0x1.10e4698622000p-4},
+{0x1.107fbda8434afp+0, -0x1.ffa6c6ad20000p-5},
+{0x1.0f5ee0f4e6bb3p+0, -0x1.dda8d4a774000p-5},
+{0x1.0e4065d2a9fcep+0, -0x1.bbcece4850000p-5},
+{0x1.0d244632ca521p+0, -0x1.9a1894012c000p-5},
+{0x1.0c0a77ce2981ap+0, -0x1.788583302c000p-5},
+{0x1.0af2f83c636d1p+0, -0x1.5715e67d68000p-5},
+{0x1.09ddb98a01339p+0, -0x1.35c8a49658000p-5},
+{0x1.08cabaf52e7dfp+0, -0x1.149e364154000p-5},
+{0x1.07b9f2f4e28fbp+0, -0x1.e72c082eb8000p-6},
+{0x1.06ab58c358f19p+0, -0x1.a55f152528000p-6},
+{0x1.059eea5ecf92cp+0, -0x1.63d62cf818000p-6},
+{0x1.04949cdd12c90p+0, -0x1.228fb8caa0000p-6},
+{0x1.038c6c6f0ada9p+0, -0x1.c317b20f90000p-7},
+{0x1.02865137932a9p+0, -0x1.419355daa0000p-7},
+{0x1.0182427ea7348p+0, -0x1.81203c2ec0000p-8},
+{0x1.008040614b195p+0, -0x1.0040979240000p-9},
+{0x1.fe01ff726fa1ap-1, 0x1.feff384900000p-9},
+{0x1.fa11cc261ea74p-1, 0x1.7dc41353d0000p-7},
+{0x1.f6310b081992ep-1, 0x1.3cea3c4c28000p-6},
+{0x1.f25f63ceeadcdp-1, 0x1.b9fc114890000p-6},
+{0x1.ee9c8039113e7p-1, 0x1.1b0d8ce110000p-5},
+{0x1.eae8078cbb1abp-1, 0x1.58a5bd001c000p-5},
+{0x1.e741aa29d0c9bp-1, 0x1.95c8340d88000p-5},
+{0x1.e3a91830a99b5p-1, 0x1.d276aef578000p-5},
+{0x1.e01e009609a56p-1, 0x1.07598e598c000p-4},
+{0x1.dca01e577bb98p-1, 0x1.253f5e30d2000p-4},
+{0x1.d92f20b7c9103p-1, 0x1.42edd8b380000p-4},
+{0x1.d5cac66fb5ccep-1, 0x1.606598757c000p-4},
+{0x1.d272caa5ede9dp-1, 0x1.7da76356a0000p-4},
+{0x1.cf26e3e6b2ccdp-1, 0x1.9ab434e1c6000p-4},
+{0x1.cbe6da2a77902p-1, 0x1.b78c7bb0d6000p-4},
+{0x1.c8b266d37086dp-1, 0x1.d431332e72000p-4},
+{0x1.c5894bd5d5804p-1, 0x1.f0a3171de6000p-4},
+{0x1.c26b533bb9f8cp-1, 0x1.067152b914000p-3},
+{0x1.bf583eeece73fp-1, 0x1.147858292b000p-3},
+{0x1.bc4fd75db96c1p-1, 0x1.2266ecdca3000p-3},
+{0x1.b951e0c864a28p-1, 0x1.303d7a6c55000p-3},
+{0x1.b65e2c5ef3e2cp-1, 0x1.3dfc33c331000p-3},
+{0x1.b374867c9888bp-1, 0x1.4ba366b7a8000p-3},
+{0x1.b094b211d304ap-1, 0x1.5933928d1f000p-3},
+{0x1.adbe885f2ef7ep-1, 0x1.66acd2418f000p-3},
+{0x1.aaf1d31603da2p-1, 0x1.740f8ec669000p-3},
+{0x1.a82e63fd358a7p-1, 0x1.815c0f51af000p-3},
+{0x1.a5740ef09738bp-1, 0x1.8e92954f68000p-3},
+{0x1.a2c2a90ab4b27p-1, 0x1.9bb3602f84000p-3},
+{0x1.a01a01393f2d1p-1, 0x1.a8bed1c2c0000p-3},
+{0x1.9d79f24db3c1bp-1, 0x1.b5b515c01d000p-3},
+{0x1.9ae2505c7b190p-1, 0x1.c2967ccbcc000p-3},
+{0x1.9852ef297ce2fp-1, 0x1.cf635d5486000p-3},
+{0x1.95cbaeea44b75p-1, 0x1.dc1bd3446c000p-3},
+{0x1.934c69de74838p-1, 0x1.e8c01b8cfe000p-3},
+{0x1.90d4f2f6752e6p-1, 0x1.f5509c0179000p-3},
+{0x1.8e6528effd79dp-1, 0x1.00e6c121fb800p-2},
+{0x1.8bfce9fcc007cp-1, 0x1.071b80e93d000p-2},
+{0x1.899c0dabec30ep-1, 0x1.0d46b9e867000p-2},
+{0x1.87427aa2317fbp-1, 0x1.13687334bd000p-2},
+{0x1.84f00acb39a08p-1, 0x1.1980d67234800p-2},
+{0x1.82a49e8653e55p-1, 0x1.1f8ffe0cc8000p-2},
+{0x1.8060195f40260p-1, 0x1.2595fd7636800p-2},
+{0x1.7e22563e0a329p-1, 0x1.2b9300914a800p-2},
+{0x1.7beb377dcb5adp-1, 0x1.3187210436000p-2},
+{0x1.79baa679725c2p-1, 0x1.377266dec1800p-2},
+{0x1.77907f2170657p-1, 0x1.3d54ffbaf3000p-2},
+{0x1.756cadbd6130cp-1, 0x1.432eee32fe000p-2},
+},
+#if !__FP_FAST_FMA
+.tab2 = {
+{0x1.61000014fb66bp-1, 0x1.e026c91425b3cp-56},
+{0x1.63000034db495p-1, 0x1.dbfea48005d41p-55},
+{0x1.650000d94d478p-1, 0x1.e7fa786d6a5b7p-55},
+{0x1.67000074e6fadp-1, 0x1.1fcea6b54254cp-57},
+{0x1.68ffffedf0faep-1, -0x1.c7e274c590efdp-56},
+{0x1.6b0000763c5bcp-1, -0x1.ac16848dcda01p-55},
+{0x1.6d0001e5cc1f6p-1, 0x1.33f1c9d499311p-55},
+{0x1.6efffeb05f63ep-1, -0x1.e80041ae22d53p-56},
+{0x1.710000e86978p-1, 0x1.bff6671097952p-56},
+{0x1.72ffffc67e912p-1, 0x1.c00e226bd8724p-55},
+{0x1.74fffdf81116ap-1, -0x1.e02916ef101d2p-57},
+{0x1.770000f679c9p-1, -0x1.7fc71cd549c74p-57},
+{0x1.78ffffa7ec835p-1, 0x1.1bec19ef50483p-55},
+{0x1.7affffe20c2e6p-1, -0x1.07e1729cc6465p-56},
+{0x1.7cfffed3fc9p-1, -0x1.08072087b8b1cp-55},
+{0x1.7efffe9261a76p-1, 0x1.dc0286d9df9aep-55},
+{0x1.81000049ca3e8p-1, 0x1.97fd251e54c33p-55},
+{0x1.8300017932c8fp-1, -0x1.afee9b630f381p-55},
+{0x1.850000633739cp-1, 0x1.9bfbf6b6535bcp-55},
+{0x1.87000204289c6p-1, -0x1.bbf65f3117b75p-55},
+{0x1.88fffebf57904p-1, -0x1.9006ea23dcb57p-55},
+{0x1.8b00022bc04dfp-1, -0x1.d00df38e04b0ap-56},
+{0x1.8cfffe50c1b8ap-1, -0x1.8007146ff9f05p-55},
+{0x1.8effffc918e43p-1, 0x1.3817bd07a7038p-55},
+{0x1.910001efa5fc7p-1, 0x1.93e9176dfb403p-55},
+{0x1.9300013467bb9p-1, 0x1.f804e4b980276p-56},
+{0x1.94fffe6ee076fp-1, -0x1.f7ef0d9ff622ep-55},
+{0x1.96fffde3c12d1p-1, -0x1.082aa962638bap-56},
+{0x1.98ffff4458a0dp-1, -0x1.7801b9164a8efp-55},
+{0x1.9afffdd982e3ep-1, -0x1.740e08a5a9337p-55},
+{0x1.9cfffed49fb66p-1, 0x1.fce08c19bep-60},
+{0x1.9f00020f19c51p-1, -0x1.a3faa27885b0ap-55},
+{0x1.a10001145b006p-1, 0x1.4ff489958da56p-56},
+{0x1.a300007bbf6fap-1, 0x1.cbeab8a2b6d18p-55},
+{0x1.a500010971d79p-1, 0x1.8fecadd78793p-55},
+{0x1.a70001df52e48p-1, -0x1.f41763dd8abdbp-55},
+{0x1.a90001c593352p-1, -0x1.ebf0284c27612p-55},
+{0x1.ab0002a4f3e4bp-1, -0x1.9fd043cff3f5fp-57},
+{0x1.acfffd7ae1ed1p-1, -0x1.23ee7129070b4p-55},
+{0x1.aefffee510478p-1, 0x1.a063ee00edea3p-57},
+{0x1.b0fffdb650d5bp-1, 0x1.a06c8381f0ab9p-58},
+{0x1.b2ffffeaaca57p-1, -0x1.9011e74233c1dp-56},
+{0x1.b4fffd995badcp-1, -0x1.9ff1068862a9fp-56},
+{0x1.b7000249e659cp-1, 0x1.aff45d0864f3ep-55},
+{0x1.b8ffff987164p-1, 0x1.cfe7796c2c3f9p-56},
+{0x1.bafffd204cb4fp-1, -0x1.3ff27eef22bc4p-57},
+{0x1.bcfffd2415c45p-1, -0x1.cffb7ee3bea21p-57},
+{0x1.beffff86309dfp-1, -0x1.14103972e0b5cp-55},
+{0x1.c0fffe1b57653p-1, 0x1.bc16494b76a19p-55},
+{0x1.c2ffff1fa57e3p-1, -0x1.4feef8d30c6edp-57},
+{0x1.c4fffdcbfe424p-1, -0x1.43f68bcec4775p-55},
+{0x1.c6fffed54b9f7p-1, 0x1.47ea3f053e0ecp-55},
+{0x1.c8fffeb998fd5p-1, 0x1.383068df992f1p-56},
+{0x1.cb0002125219ap-1, -0x1.8fd8e64180e04p-57},
+{0x1.ccfffdd94469cp-1, 0x1.e7ebe1cc7ea72p-55},
+{0x1.cefffeafdc476p-1, 0x1.ebe39ad9f88fep-55},
+{0x1.d1000169af82bp-1, 0x1.57d91a8b95a71p-56},
+{0x1.d30000d0ff71dp-1, 0x1.9c1906970c7dap-55},
+{0x1.d4fffea790fc4p-1, -0x1.80e37c558fe0cp-58},
+{0x1.d70002edc87e5p-1, -0x1.f80d64dc10f44p-56},
+{0x1.d900021dc82aap-1, -0x1.47c8f94fd5c5cp-56},
+{0x1.dafffd86b0283p-1, 0x1.c7f1dc521617ep-55},
+{0x1.dd000296c4739p-1, 0x1.8019eb2ffb153p-55},
+{0x1.defffe54490f5p-1, 0x1.e00d2c652cc89p-57},
+{0x1.e0fffcdabf694p-1, -0x1.f8340202d69d2p-56},
+{0x1.e2fffdb52c8ddp-1, 0x1.b00c1ca1b0864p-56},
+{0x1.e4ffff24216efp-1, 0x1.2ffa8b094ab51p-56},
+{0x1.e6fffe88a5e11p-1, -0x1.7f673b1efbe59p-58},
+{0x1.e9000119eff0dp-1, -0x1.4808d5e0bc801p-55},
+{0x1.eafffdfa51744p-1, 0x1.80006d54320b5p-56},
+{0x1.ed0001a127fa1p-1, -0x1.002f860565c92p-58},
+{0x1.ef00007babcc4p-1, -0x1.540445d35e611p-55},
+{0x1.f0ffff57a8d02p-1, -0x1.ffb3139ef9105p-59},
+{0x1.f30001ee58ac7p-1, 0x1.a81acf2731155p-55},
+{0x1.f4ffff5823494p-1, 0x1.a3f41d4d7c743p-55},
+{0x1.f6ffffca94c6bp-1, -0x1.202f41c987875p-57},
+{0x1.f8fffe1f9c441p-1, 0x1.77dd1f477e74bp-56},
+{0x1.fafffd2e0e37ep-1, -0x1.f01199a7ca331p-57},
+{0x1.fd0001c77e49ep-1, 0x1.181ee4bceacb1p-56},
+{0x1.feffff7e0c331p-1, -0x1.e05370170875ap-57},
+{0x1.00ffff465606ep+0, -0x1.a7ead491c0adap-55},
+{0x1.02ffff3867a58p+0, -0x1.77f69c3fcb2ep-54},
+{0x1.04ffffdfc0d17p+0, 0x1.7bffe34cb945bp-54},
+{0x1.0700003cd4d82p+0, 0x1.20083c0e456cbp-55},
+{0x1.08ffff9f2cbe8p+0, -0x1.dffdfbe37751ap-57},
+{0x1.0b000010cda65p+0, -0x1.13f7faee626ebp-54},
+{0x1.0d00001a4d338p+0, 0x1.07dfa79489ff7p-55},
+{0x1.0effffadafdfdp+0, -0x1.7040570d66bcp-56},
+{0x1.110000bbafd96p+0, 0x1.e80d4846d0b62p-55},
+{0x1.12ffffae5f45dp+0, 0x1.dbffa64fd36efp-54},
+{0x1.150000dd59ad9p+0, 0x1.a0077701250aep-54},
+{0x1.170000f21559ap+0, 0x1.dfdf9e2e3deeep-55},
+{0x1.18ffffc275426p+0, 0x1.10030dc3b7273p-54},
+{0x1.1b000123d3c59p+0, 0x1.97f7980030188p-54},
+{0x1.1cffff8299eb7p+0, -0x1.5f932ab9f8c67p-57},
+{0x1.1effff48ad4p+0, 0x1.37fbf9da75bebp-54},
+{0x1.210000c8b86a4p+0, 0x1.f806b91fd5b22p-54},
+{0x1.2300003854303p+0, 0x1.3ffc2eb9fbf33p-54},
+{0x1.24fffffbcf684p+0, 0x1.601e77e2e2e72p-56},
+{0x1.26ffff52921d9p+0, 0x1.ffcbb767f0c61p-56},
+{0x1.2900014933a3cp+0, -0x1.202ca3c02412bp-56},
+{0x1.2b00014556313p+0, -0x1.2808233f21f02p-54},
+{0x1.2cfffebfe523bp+0, -0x1.8ff7e384fdcf2p-55},
+{0x1.2f0000bb8ad96p+0, -0x1.5ff51503041c5p-55},
+{0x1.30ffffb7ae2afp+0, -0x1.10071885e289dp-55},
+{0x1.32ffffeac5f7fp+0, -0x1.1ff5d3fb7b715p-54},
+{0x1.350000ca66756p+0, 0x1.57f82228b82bdp-54},
+{0x1.3700011fbf721p+0, 0x1.000bac40dd5ccp-55},
+{0x1.38ffff9592fb9p+0, -0x1.43f9d2db2a751p-54},
+{0x1.3b00004ddd242p+0, 0x1.57f6b707638e1p-55},
+{0x1.3cffff5b2c957p+0, 0x1.a023a10bf1231p-56},
+{0x1.3efffeab0b418p+0, 0x1.87f6d66b152bp-54},
+{0x1.410001532aff4p+0, 0x1.7f8375f198524p-57},
+{0x1.4300017478b29p+0, 0x1.301e672dc5143p-55},
+{0x1.44fffe795b463p+0, 0x1.9ff69b8b2895ap-55},
+{0x1.46fffe80475ep+0, -0x1.5c0b19bc2f254p-54},
+{0x1.48fffef6fc1e7p+0, 0x1.b4009f23a2a72p-54},
+{0x1.4afffe5bea704p+0, -0x1.4ffb7bf0d7d45p-54},
+{0x1.4d000171027dep+0, -0x1.9c06471dc6a3dp-54},
+{0x1.4f0000ff03ee2p+0, 0x1.77f890b85531cp-54},
+{0x1.5100012dc4bd1p+0, 0x1.004657166a436p-57},
+{0x1.530001605277ap+0, -0x1.6bfcece233209p-54},
+{0x1.54fffecdb704cp+0, -0x1.902720505a1d7p-55},
+{0x1.56fffef5f54a9p+0, 0x1.bbfe60ec96412p-54},
+{0x1.5900017e61012p+0, 0x1.87ec581afef9p-55},
+{0x1.5b00003c93e92p+0, -0x1.f41080abf0ccp-54},
+{0x1.5d0001d4919bcp+0, -0x1.8812afb254729p-54},
+{0x1.5efffe7b87a89p+0, -0x1.47eb780ed6904p-54},
+},
+#endif
+};
diff --git a/third_party/musl/porting/liteos_m/kernel/src/math/log_data.h b/third_party/musl/porting/liteos_m/kernel/src/math/log_data.h
new file mode 100755
index 000000000..d86752366
--- /dev/null
+++ b/third_party/musl/porting/liteos_m/kernel/src/math/log_data.h
@@ -0,0 +1,28 @@
+/*
+ * Copyright (c) 2018, Arm Limited.
+ * SPDX-License-Identifier: MIT
+ */
+#ifndef _LOG_DATA_H
+#define _LOG_DATA_H
+
+#include <features.h>
+
+#define LOG_TABLE_BITS 7
+#define LOG_POLY_ORDER 6
+#define LOG_POLY1_ORDER 12
+extern const struct log_data {
+	double ln2hi;
+	double ln2lo;
+	double poly[LOG_POLY_ORDER - 1]; /* First coefficient is 1.  */
+	double poly1[LOG_POLY1_ORDER - 1];
+	struct {
+		double invc, logc;
+	} tab[1 << LOG_TABLE_BITS];
+#if !__FP_FAST_FMA
+	struct {
+		double chi, clo;
+	} tab2[1 << LOG_TABLE_BITS];
+#endif
+} __log_data;
+
+#endif
diff --git a/third_party/musl/porting/liteos_m/kernel/src/math/pow.c b/third_party/musl/porting/liteos_m/kernel/src/math/pow.c
new file mode 100755
index 000000000..434aea3a6
--- /dev/null
+++ b/third_party/musl/porting/liteos_m/kernel/src/math/pow.c
@@ -0,0 +1,343 @@
+/*
+ * Double-precision x^y function.
+ *
+ * Copyright (c) 2018, Arm Limited.
+ * SPDX-License-Identifier: MIT
+ */
+
+#include <math.h>
+#include <stdint.h>
+#include "libm.h"
+#include "exp_data.h"
+#include "pow_data.h"
+
+/*
+Worst-case error: 0.54 ULP (~= ulperr_exp + 1024*Ln2*relerr_log*2^53)
+relerr_log: 1.3 * 2^-68 (Relative error of log, 1.5 * 2^-68 without fma)
+ulperr_exp: 0.509 ULP (ULP error of exp, 0.511 ULP without fma)
+*/
+
+#define T __pow_log_data1.tab
+#define A __pow_log_data1.poly
+#define Ln2hi __pow_log_data1.ln2hi
+#define Ln2lo __pow_log_data1.ln2lo
+#define N (1 << POW_LOG_TABLE_BITS)
+#define OFF 0x3fe6955500000000
+
+/* Top 12 bits of a double (sign and exponent bits).  */
+static inline uint32_t top12(double x)
+{
+	return asuint64(x) >> 52;
+}
+
+/* Compute y+TAIL = log(x) where the rounded result is y and TAIL has about
+   additional 15 bits precision.  IX is the bit representation of x, but
+   normalized in the subnormal range using the sign bit for the exponent.  */
+static inline double_t log_inline(uint64_t ix, double_t *tail)
+{
+	/* double_t for better performance on targets with FLT_EVAL_METHOD==2.  */
+	double_t z, r, y, invc, logc, logctail, kd, hi, t1, t2, lo, lo1, lo2, p;
+	uint64_t iz, tmp;
+	int k, i;
+
+	/* x = 2^k z; where z is in range [OFF,2*OFF) and exact.
+	   The range is split into N subintervals.
+	   The ith subinterval contains z and c is near its center.  */
+	tmp = ix - OFF;
+	i = (tmp >> (52 - POW_LOG_TABLE_BITS)) % N;
+	k = (int64_t)tmp >> 52; /* arithmetic shift */
+	iz = ix - (tmp & 0xfffULL << 52);
+	z = asdouble(iz);
+	kd = (double_t)k;
+
+	/* log(x) = k*Ln2 + log(c) + log1p(z/c-1).  */
+	invc = T[i].invc;
+	logc = T[i].logc;
+	logctail = T[i].logctail;
+
+	/* Note: 1/c is j/N or j/N/2 where j is an integer in [N,2N) and
+     |z/c - 1| < 1/N, so r = z/c - 1 is exactly representible.  */
+#if __FP_FAST_FMA
+	r = __builtin_fma(z, invc, -1.0);
+#else
+	/* Split z such that rhi, rlo and rhi*rhi are exact and |rlo| <= |r|.  */
+	double_t zhi = asdouble((iz + (1ULL << 31)) & (-1ULL << 32));
+	double_t zlo = z - zhi;
+	double_t rhi = zhi * invc - 1.0;
+	double_t rlo = zlo * invc;
+	r = rhi + rlo;
+#endif
+
+	/* k*Ln2 + log(c) + r.  */
+	t1 = kd * Ln2hi + logc;
+	t2 = t1 + r;
+	lo1 = kd * Ln2lo + logctail;
+	lo2 = t1 - t2 + r;
+
+	/* Evaluation is optimized assuming superscalar pipelined execution.  */
+	double_t ar, ar2, ar3, lo3, lo4;
+	ar = A[0] * r; /* A[0] = -0.5.  */
+	ar2 = r * ar;
+	ar3 = r * ar2;
+	/* k*Ln2 + log(c) + r + A[0]*r*r.  */
+#if __FP_FAST_FMA
+	hi = t2 + ar2;
+	lo3 = __builtin_fma(ar, r, -ar2);
+	lo4 = t2 - hi + ar2;
+#else
+	double_t arhi = A[0] * rhi;
+	double_t arhi2 = rhi * arhi;
+	hi = t2 + arhi2;
+	lo3 = rlo * (ar + arhi);
+	lo4 = t2 - hi + arhi2;
+#endif
+	/* p = log1p(r) - r - A[0]*r*r.  */
+	p = (ar3 * (A[1] + r * A[2] +
+		    ar2 * (A[3] + r * A[4] + ar2 * (A[5] + r * A[6]))));
+	lo = lo1 + lo2 + lo3 + lo4 + p;
+	y = hi + lo;
+	*tail = hi - y + lo;
+	return y;
+}
+
+#undef N
+#undef T
+#define N (1 << EXP_TABLE_BITS)
+#define InvLn2N __exp_data1.invln2N
+#define NegLn2hiN __exp_data1.negln2hiN
+#define NegLn2loN __exp_data1.negln2loN
+#define Shift __exp_data1.shift
+#define T __exp_data1.tab
+#define C2 __exp_data1.poly[5 - EXP_POLY_ORDER]
+#define C3 __exp_data1.poly[6 - EXP_POLY_ORDER]
+#define C4 __exp_data1.poly[7 - EXP_POLY_ORDER]
+#define C5 __exp_data1.poly[8 - EXP_POLY_ORDER]
+#define C6 __exp_data1.poly[9 - EXP_POLY_ORDER]
+
+/* Handle cases that may overflow or underflow when computing the result that
+   is scale*(1+TMP) without intermediate rounding.  The bit representation of
+   scale is in SBITS, however it has a computed exponent that may have
+   overflown into the sign bit so that needs to be adjusted before using it as
+   a double.  (int32_t)KI is the k used in the argument reduction and exponent
+   adjustment of scale, positive k here means the result may overflow and
+   negative k means the result may underflow.  */
+static inline double specialcase(double_t tmp, uint64_t sbits, uint64_t ki)
+{
+	double_t scale, y;
+
+	if ((ki & 0x80000000) == 0) {
+		/* k > 0, the exponent of scale might have overflowed by <= 460.  */
+		sbits -= 1009ull << 52;
+		scale = asdouble(sbits);
+		y = 0x1p1009 * (scale + scale * tmp);
+		return eval_as_double(y);
+	}
+	/* k < 0, need special care in the subnormal range.  */
+	sbits += 1022ull << 52;
+	/* Note: sbits is signed scale.  */
+	scale = asdouble(sbits);
+	y = scale + scale * tmp;
+	if (fabs(y) < 1.0) {
+		/* Round y to the right precision before scaling it into the subnormal
+		   range to avoid double rounding that can cause 0.5+E/2 ulp error where
+		   E is the worst-case ulp error outside the subnormal range.  So this
+		   is only useful if the goal is better than 1 ulp worst-case error.  */
+		double_t hi, lo, one = 1.0;
+		if (y < 0.0)
+			one = -1.0;
+		lo = scale - y + scale * tmp;
+		hi = one + y;
+		lo = one - hi + y + lo;
+		y = eval_as_double(hi + lo) - one;
+		/* Fix the sign of 0.  */
+		if (y == 0.0)
+			y = asdouble(sbits & 0x8000000000000000);
+		/* The underflow exception needs to be signaled explicitly.  */
+		fp_force_eval(fp_barrier(0x1p-1022) * 0x1p-1022);
+	}
+	y = 0x1p-1022 * y;
+	return eval_as_double(y);
+}
+
+#define SIGN_BIAS (0x800 << EXP_TABLE_BITS)
+
+/* Computes sign*exp(x+xtail) where |xtail| < 2^-8/N and |xtail| <= |x|.
+   The sign_bias argument is SIGN_BIAS or 0 and sets the sign to -1 or 1.  */
+static inline double exp_inline(double_t x, double_t xtail, uint32_t sign_bias)
+{
+	uint32_t abstop;
+	uint64_t ki, idx, top, sbits;
+	/* double_t for better performance on targets with FLT_EVAL_METHOD==2.  */
+	double_t kd, z, r, r2, scale, tail, tmp;
+
+	abstop = top12(x) & 0x7ff;
+	if (predict_false(abstop - top12(0x1p-54) >=
+			  top12(512.0) - top12(0x1p-54))) {
+		if (abstop - top12(0x1p-54) >= 0x80000000) {
+			/* Avoid spurious underflow for tiny x.  */
+			/* Note: 0 is common input.  */
+			double_t one = WANT_ROUNDING ? 1.0 + x : 1.0;
+			return sign_bias ? -one : one;
+		}
+		if (abstop >= top12(1024.0)) {
+			/* Note: inf and nan are already handled.  */
+			if (asuint64(x) >> 63)
+				return __math_uflow(sign_bias);
+			else
+				return __math_oflow(sign_bias);
+		}
+		/* Large x is special cased below.  */
+		abstop = 0;
+	}
+
+	/* exp(x) = 2^(k/N) * exp(r), with exp(r) in [2^(-1/2N),2^(1/2N)].  */
+	/* x = ln2/N*k + r, with int k and r in [-ln2/2N, ln2/2N].  */
+	z = InvLn2N * x;
+#if TOINT_INTRINSICS
+	kd = roundtoint(z);
+	ki = converttoint(z);
+#elif EXP_USE_TOINT_NARROW
+	/* z - kd is in [-0.5-2^-16, 0.5] in all rounding modes.  */
+	kd = eval_as_double(z + Shift);
+	ki = asuint64(kd) >> 16;
+	kd = (double_t)(int32_t)ki;
+#else
+	/* z - kd is in [-1, 1] in non-nearest rounding modes.  */
+	kd = eval_as_double(z + Shift);
+	ki = asuint64(kd);
+	kd -= Shift;
+#endif
+	r = x + kd * NegLn2hiN + kd * NegLn2loN;
+	/* The code assumes 2^-200 < |xtail| < 2^-8/N.  */
+	r += xtail;
+	/* 2^(k/N) ~= scale * (1 + tail).  */
+	idx = 2 * (ki % N);
+	top = (ki + sign_bias) << (52 - EXP_TABLE_BITS);
+	tail = asdouble(T[idx]);
+	/* This is only a valid scale when -1023*N < k < 1024*N.  */
+	sbits = T[idx + 1] + top;
+	/* exp(x) = 2^(k/N) * exp(r) ~= scale + scale * (tail + exp(r) - 1).  */
+	/* Evaluation is optimized assuming superscalar pipelined execution.  */
+	r2 = r * r;
+	/* Without fma the worst case error is 0.25/N ulp larger.  */
+	/* Worst case error is less than 0.5+1.11/N+(abs poly error * 2^53) ulp.  */
+	tmp = tail + r + r2 * (C2 + r * C3) + r2 * r2 * (C4 + r * C5);
+	if (predict_false(abstop == 0))
+		return specialcase(tmp, sbits, ki);
+	scale = asdouble(sbits);
+	/* Note: tmp == 0 or |tmp| > 2^-200 and scale > 2^-739, so there
+	   is no spurious underflow here even without fma.  */
+	return eval_as_double(scale + scale * tmp);
+}
+
+/* Returns 0 if not int, 1 if odd int, 2 if even int.  The argument is
+   the bit representation of a non-zero finite floating-point value.  */
+static inline int checkint(uint64_t iy)
+{
+	int e = iy >> 52 & 0x7ff;
+	if (e < 0x3ff)
+		return 0;
+	if (e > 0x3ff + 52)
+		return 2;
+	if (iy & ((1ULL << (0x3ff + 52 - e)) - 1))
+		return 0;
+	if (iy & (1ULL << (0x3ff + 52 - e)))
+		return 1;
+	return 2;
+}
+
+/* Returns 1 if input is the bit representation of 0, infinity or nan.  */
+static inline int zeroinfnan(uint64_t i)
+{
+	return 2 * i - 1 >= 2 * asuint64(INFINITY) - 1;
+}
+
+double pow(double x, double y)
+{
+	uint32_t sign_bias = 0;
+	uint64_t ix, iy;
+	uint32_t topx, topy;
+
+	ix = asuint64(x);
+	iy = asuint64(y);
+	topx = top12(x);
+	topy = top12(y);
+	if (predict_false(topx - 0x001 >= 0x7ff - 0x001 ||
+			  (topy & 0x7ff) - 0x3be >= 0x43e - 0x3be)) {
+		/* Note: if |y| > 1075 * ln2 * 2^53 ~= 0x1.749p62 then pow(x,y) = inf/0
+		   and if |y| < 2^-54 / 1075 ~= 0x1.e7b6p-65 then pow(x,y) = +-1.  */
+		/* Special cases: (x < 0x1p-126 or inf or nan) or
+		   (|y| < 0x1p-65 or |y| >= 0x1p63 or nan).  */
+		if (predict_false(zeroinfnan(iy))) {
+			if (2 * iy == 0)
+				return issignaling_inline(x) ? x + y : 1.0;
+			if (ix == asuint64(1.0))
+				return issignaling_inline(y) ? x + y : 1.0;
+			if (2 * ix > 2 * asuint64(INFINITY) ||
+			    2 * iy > 2 * asuint64(INFINITY))
+				return x + y;
+			if (2 * ix == 2 * asuint64(1.0))
+				return 1.0;
+			if ((2 * ix < 2 * asuint64(1.0)) == !(iy >> 63))
+				return 0.0; /* |x|<1 && y==inf or |x|>1 && y==-inf.  */
+			return y * y;
+		}
+		if (predict_false(zeroinfnan(ix))) {
+			double_t x2 = x * x;
+			if (ix >> 63 && checkint(iy) == 1)
+				x2 = -x2;
+			/* Without the barrier some versions of clang hoist the 1/x2 and
+			   thus division by zero exception can be signaled spuriously.  */
+			return iy >> 63 ? fp_barrier(1 / x2) : x2;
+		}
+		/* Here x and y are non-zero finite.  */
+		if (ix >> 63) {
+			/* Finite x < 0.  */
+			int yint = checkint(iy);
+			if (yint == 0)
+				return __math_invalid(x);
+			if (yint == 1)
+				sign_bias = SIGN_BIAS;
+			ix &= 0x7fffffffffffffff;
+			topx &= 0x7ff;
+		}
+		if ((topy & 0x7ff) - 0x3be >= 0x43e - 0x3be) {
+			/* Note: sign_bias == 0 here because y is not odd.  */
+			if (ix == asuint64(1.0))
+				return 1.0;
+			if ((topy & 0x7ff) < 0x3be) {
+				/* |y| < 2^-65, x^y ~= 1 + y*log(x).  */
+				if (WANT_ROUNDING)
+					return ix > asuint64(1.0) ? 1.0 + y :
+								    1.0 - y;
+				else
+					return 1.0;
+			}
+			return (ix > asuint64(1.0)) == (topy < 0x800) ?
+				       __math_oflow(0) :
+				       __math_uflow(0);
+		}
+		if (topx == 0) {
+			/* Normalize subnormal x so exponent becomes negative.  */
+			ix = asuint64(x * 0x1p52);
+			ix &= 0x7fffffffffffffff;
+			ix -= 52ULL << 52;
+		}
+	}
+
+	double_t lo;
+	double_t hi = log_inline(ix, &lo);
+	double_t ehi, elo;
+#if __FP_FAST_FMA
+	ehi = y * hi;
+	elo = y * lo + __builtin_fma(y, hi, -ehi);
+#else
+	double_t yhi = asdouble(iy & -1ULL << 27);
+	double_t ylo = y - yhi;
+	double_t lhi = asdouble(asuint64(hi) & -1ULL << 27);
+	double_t llo = hi - lhi + lo;
+	ehi = yhi * lhi;
+	elo = ylo * lhi + y * llo; /* |elo| < |ehi| * 2^-25.  */
+#endif
+	return exp_inline(ehi, elo, sign_bias);
+}
diff --git a/third_party/musl/porting/liteos_m/kernel/src/math/pow_data.c b/third_party/musl/porting/liteos_m/kernel/src/math/pow_data.c
new file mode 100755
index 000000000..0c9d07de4
--- /dev/null
+++ b/third_party/musl/porting/liteos_m/kernel/src/math/pow_data.c
@@ -0,0 +1,180 @@
+/*
+ * Data for the log part of pow.
+ *
+ * Copyright (c) 2018, Arm Limited.
+ * SPDX-License-Identifier: MIT
+ */
+
+#include "pow_data.h"
+
+#define N (1 << POW_LOG_TABLE_BITS)
+
+const struct pow_log_data __pow_log_data1 = {
+.ln2hi = 0x1.62e42fefa3800p-1,
+.ln2lo = 0x1.ef35793c76730p-45,
+.poly = {
+// relative error: 0x1.11922ap-70
+// in -0x1.6bp-8 0x1.6bp-8
+// Coefficients are scaled to match the scaling during evaluation.
+-0x1p-1,
+0x1.555555555556p-2 * -2,
+-0x1.0000000000006p-2 * -2,
+0x1.999999959554ep-3 * 4,
+-0x1.555555529a47ap-3 * 4,
+0x1.2495b9b4845e9p-3 * -8,
+-0x1.0002b8b263fc3p-3 * -8,
+},
+/* Algorithm:
+
+	x = 2^k z
+	log(x) = k ln2 + log(c) + log(z/c)
+	log(z/c) = poly(z/c - 1)
+
+where z is in [0x1.69555p-1; 0x1.69555p0] which is split into N subintervals
+and z falls into the ith one, then table entries are computed as
+
+	tab[i].invc = 1/c
+	tab[i].logc = round(0x1p43*log(c))/0x1p43
+	tab[i].logctail = (double)(log(c) - logc)
+
+where c is chosen near the center of the subinterval such that 1/c has only a
+few precision bits so z/c - 1 is exactly representible as double:
+
+	1/c = center < 1 ? round(N/center)/N : round(2*N/center)/N/2
+
+Note: |z/c - 1| < 1/N for the chosen c, |log(c) - logc - logctail| < 0x1p-97,
+the last few bits of logc are rounded away so k*ln2hi + logc has no rounding
+error and the interval for z is selected such that near x == 1, where log(x)
+is tiny, large cancellation error is avoided in logc + poly(z/c - 1).  */
+.tab = {
+#define A(a, b, c) {a, 0, b, c},
+A(0x1.6a00000000000p+0, -0x1.62c82f2b9c800p-2, 0x1.ab42428375680p-48)
+A(0x1.6800000000000p+0, -0x1.5d1bdbf580800p-2, -0x1.ca508d8e0f720p-46)
+A(0x1.6600000000000p+0, -0x1.5767717455800p-2, -0x1.362a4d5b6506dp-45)
+A(0x1.6400000000000p+0, -0x1.51aad872df800p-2, -0x1.684e49eb067d5p-49)
+A(0x1.6200000000000p+0, -0x1.4be5f95777800p-2, -0x1.41b6993293ee0p-47)
+A(0x1.6000000000000p+0, -0x1.4618bc21c6000p-2, 0x1.3d82f484c84ccp-46)
+A(0x1.5e00000000000p+0, -0x1.404308686a800p-2, 0x1.c42f3ed820b3ap-50)
+A(0x1.5c00000000000p+0, -0x1.3a64c55694800p-2, 0x1.0b1c686519460p-45)
+A(0x1.5a00000000000p+0, -0x1.347dd9a988000p-2, 0x1.5594dd4c58092p-45)
+A(0x1.5800000000000p+0, -0x1.2e8e2bae12000p-2, 0x1.67b1e99b72bd8p-45)
+A(0x1.5600000000000p+0, -0x1.2895a13de8800p-2, 0x1.5ca14b6cfb03fp-46)
+A(0x1.5600000000000p+0, -0x1.2895a13de8800p-2, 0x1.5ca14b6cfb03fp-46)
+A(0x1.5400000000000p+0, -0x1.22941fbcf7800p-2, -0x1.65a242853da76p-46)
+A(0x1.5200000000000p+0, -0x1.1c898c1699800p-2, -0x1.fafbc68e75404p-46)
+A(0x1.5000000000000p+0, -0x1.1675cababa800p-2, 0x1.f1fc63382a8f0p-46)
+A(0x1.4e00000000000p+0, -0x1.1058bf9ae4800p-2, -0x1.6a8c4fd055a66p-45)
+A(0x1.4c00000000000p+0, -0x1.0a324e2739000p-2, -0x1.c6bee7ef4030ep-47)
+A(0x1.4a00000000000p+0, -0x1.0402594b4d000p-2, -0x1.036b89ef42d7fp-48)
+A(0x1.4a00000000000p+0, -0x1.0402594b4d000p-2, -0x1.036b89ef42d7fp-48)
+A(0x1.4800000000000p+0, -0x1.fb9186d5e4000p-3, 0x1.d572aab993c87p-47)
+A(0x1.4600000000000p+0, -0x1.ef0adcbdc6000p-3, 0x1.b26b79c86af24p-45)
+A(0x1.4400000000000p+0, -0x1.e27076e2af000p-3, -0x1.72f4f543fff10p-46)
+A(0x1.4200000000000p+0, -0x1.d5c216b4fc000p-3, 0x1.1ba91bbca681bp-45)
+A(0x1.4000000000000p+0, -0x1.c8ff7c79aa000p-3, 0x1.7794f689f8434p-45)
+A(0x1.4000000000000p+0, -0x1.c8ff7c79aa000p-3, 0x1.7794f689f8434p-45)
+A(0x1.3e00000000000p+0, -0x1.bc286742d9000p-3, 0x1.94eb0318bb78fp-46)
+A(0x1.3c00000000000p+0, -0x1.af3c94e80c000p-3, 0x1.a4e633fcd9066p-52)
+A(0x1.3a00000000000p+0, -0x1.a23bc1fe2b000p-3, -0x1.58c64dc46c1eap-45)
+A(0x1.3a00000000000p+0, -0x1.a23bc1fe2b000p-3, -0x1.58c64dc46c1eap-45)
+A(0x1.3800000000000p+0, -0x1.9525a9cf45000p-3, -0x1.ad1d904c1d4e3p-45)
+A(0x1.3600000000000p+0, -0x1.87fa06520d000p-3, 0x1.bbdbf7fdbfa09p-45)
+A(0x1.3400000000000p+0, -0x1.7ab890210e000p-3, 0x1.bdb9072534a58p-45)
+A(0x1.3400000000000p+0, -0x1.7ab890210e000p-3, 0x1.bdb9072534a58p-45)
+A(0x1.3200000000000p+0, -0x1.6d60fe719d000p-3, -0x1.0e46aa3b2e266p-46)
+A(0x1.3000000000000p+0, -0x1.5ff3070a79000p-3, -0x1.e9e439f105039p-46)
+A(0x1.3000000000000p+0, -0x1.5ff3070a79000p-3, -0x1.e9e439f105039p-46)
+A(0x1.2e00000000000p+0, -0x1.526e5e3a1b000p-3, -0x1.0de8b90075b8fp-45)
+A(0x1.2c00000000000p+0, -0x1.44d2b6ccb8000p-3, 0x1.70cc16135783cp-46)
+A(0x1.2c00000000000p+0, -0x1.44d2b6ccb8000p-3, 0x1.70cc16135783cp-46)
+A(0x1.2a00000000000p+0, -0x1.371fc201e9000p-3, 0x1.178864d27543ap-48)
+A(0x1.2800000000000p+0, -0x1.29552f81ff000p-3, -0x1.48d301771c408p-45)
+A(0x1.2600000000000p+0, -0x1.1b72ad52f6000p-3, -0x1.e80a41811a396p-45)
+A(0x1.2600000000000p+0, -0x1.1b72ad52f6000p-3, -0x1.e80a41811a396p-45)
+A(0x1.2400000000000p+0, -0x1.0d77e7cd09000p-3, 0x1.a699688e85bf4p-47)
+A(0x1.2400000000000p+0, -0x1.0d77e7cd09000p-3, 0x1.a699688e85bf4p-47)
+A(0x1.2200000000000p+0, -0x1.fec9131dbe000p-4, -0x1.575545ca333f2p-45)
+A(0x1.2000000000000p+0, -0x1.e27076e2b0000p-4, 0x1.a342c2af0003cp-45)
+A(0x1.2000000000000p+0, -0x1.e27076e2b0000p-4, 0x1.a342c2af0003cp-45)
+A(0x1.1e00000000000p+0, -0x1.c5e548f5bc000p-4, -0x1.d0c57585fbe06p-46)
+A(0x1.1c00000000000p+0, -0x1.a926d3a4ae000p-4, 0x1.53935e85baac8p-45)
+A(0x1.1c00000000000p+0, -0x1.a926d3a4ae000p-4, 0x1.53935e85baac8p-45)
+A(0x1.1a00000000000p+0, -0x1.8c345d631a000p-4, 0x1.37c294d2f5668p-46)
+A(0x1.1a00000000000p+0, -0x1.8c345d631a000p-4, 0x1.37c294d2f5668p-46)
+A(0x1.1800000000000p+0, -0x1.6f0d28ae56000p-4, -0x1.69737c93373dap-45)
+A(0x1.1600000000000p+0, -0x1.51b073f062000p-4, 0x1.f025b61c65e57p-46)
+A(0x1.1600000000000p+0, -0x1.51b073f062000p-4, 0x1.f025b61c65e57p-46)
+A(0x1.1400000000000p+0, -0x1.341d7961be000p-4, 0x1.c5edaccf913dfp-45)
+A(0x1.1400000000000p+0, -0x1.341d7961be000p-4, 0x1.c5edaccf913dfp-45)
+A(0x1.1200000000000p+0, -0x1.16536eea38000p-4, 0x1.47c5e768fa309p-46)
+A(0x1.1000000000000p+0, -0x1.f0a30c0118000p-5, 0x1.d599e83368e91p-45)
+A(0x1.1000000000000p+0, -0x1.f0a30c0118000p-5, 0x1.d599e83368e91p-45)
+A(0x1.0e00000000000p+0, -0x1.b42dd71198000p-5, 0x1.c827ae5d6704cp-46)
+A(0x1.0e00000000000p+0, -0x1.b42dd71198000p-5, 0x1.c827ae5d6704cp-46)
+A(0x1.0c00000000000p+0, -0x1.77458f632c000p-5, -0x1.cfc4634f2a1eep-45)
+A(0x1.0c00000000000p+0, -0x1.77458f632c000p-5, -0x1.cfc4634f2a1eep-45)
+A(0x1.0a00000000000p+0, -0x1.39e87b9fec000p-5, 0x1.502b7f526feaap-48)
+A(0x1.0a00000000000p+0, -0x1.39e87b9fec000p-5, 0x1.502b7f526feaap-48)
+A(0x1.0800000000000p+0, -0x1.f829b0e780000p-6, -0x1.980267c7e09e4p-45)
+A(0x1.0800000000000p+0, -0x1.f829b0e780000p-6, -0x1.980267c7e09e4p-45)
+A(0x1.0600000000000p+0, -0x1.7b91b07d58000p-6, -0x1.88d5493faa639p-45)
+A(0x1.0400000000000p+0, -0x1.fc0a8b0fc0000p-7, -0x1.f1e7cf6d3a69cp-50)
+A(0x1.0400000000000p+0, -0x1.fc0a8b0fc0000p-7, -0x1.f1e7cf6d3a69cp-50)
+A(0x1.0200000000000p+0, -0x1.fe02a6b100000p-8, -0x1.9e23f0dda40e4p-46)
+A(0x1.0200000000000p+0, -0x1.fe02a6b100000p-8, -0x1.9e23f0dda40e4p-46)
+A(0x1.0000000000000p+0, 0x0.0000000000000p+0, 0x0.0000000000000p+0)
+A(0x1.0000000000000p+0, 0x0.0000000000000p+0, 0x0.0000000000000p+0)
+A(0x1.fc00000000000p-1, 0x1.0101575890000p-7, -0x1.0c76b999d2be8p-46)
+A(0x1.f800000000000p-1, 0x1.0205658938000p-6, -0x1.3dc5b06e2f7d2p-45)
+A(0x1.f400000000000p-1, 0x1.8492528c90000p-6, -0x1.aa0ba325a0c34p-45)
+A(0x1.f000000000000p-1, 0x1.0415d89e74000p-5, 0x1.111c05cf1d753p-47)
+A(0x1.ec00000000000p-1, 0x1.466aed42e0000p-5, -0x1.c167375bdfd28p-45)
+A(0x1.e800000000000p-1, 0x1.894aa149fc000p-5, -0x1.97995d05a267dp-46)
+A(0x1.e400000000000p-1, 0x1.ccb73cdddc000p-5, -0x1.a68f247d82807p-46)
+A(0x1.e200000000000p-1, 0x1.eea31c006c000p-5, -0x1.e113e4fc93b7bp-47)
+A(0x1.de00000000000p-1, 0x1.1973bd1466000p-4, -0x1.5325d560d9e9bp-45)
+A(0x1.da00000000000p-1, 0x1.3bdf5a7d1e000p-4, 0x1.cc85ea5db4ed7p-45)
+A(0x1.d600000000000p-1, 0x1.5e95a4d97a000p-4, -0x1.c69063c5d1d1ep-45)
+A(0x1.d400000000000p-1, 0x1.700d30aeac000p-4, 0x1.c1e8da99ded32p-49)
+A(0x1.d000000000000p-1, 0x1.9335e5d594000p-4, 0x1.3115c3abd47dap-45)
+A(0x1.cc00000000000p-1, 0x1.b6ac88dad6000p-4, -0x1.390802bf768e5p-46)
+A(0x1.ca00000000000p-1, 0x1.c885801bc4000p-4, 0x1.646d1c65aacd3p-45)
+A(0x1.c600000000000p-1, 0x1.ec739830a2000p-4, -0x1.dc068afe645e0p-45)
+A(0x1.c400000000000p-1, 0x1.fe89139dbe000p-4, -0x1.534d64fa10afdp-45)
+A(0x1.c000000000000p-1, 0x1.1178e8227e000p-3, 0x1.1ef78ce2d07f2p-45)
+A(0x1.be00000000000p-1, 0x1.1aa2b7e23f000p-3, 0x1.ca78e44389934p-45)
+A(0x1.ba00000000000p-1, 0x1.2d1610c868000p-3, 0x1.39d6ccb81b4a1p-47)
+A(0x1.b800000000000p-1, 0x1.365fcb0159000p-3, 0x1.62fa8234b7289p-51)
+A(0x1.b400000000000p-1, 0x1.4913d8333b000p-3, 0x1.5837954fdb678p-45)
+A(0x1.b200000000000p-1, 0x1.527e5e4a1b000p-3, 0x1.633e8e5697dc7p-45)
+A(0x1.ae00000000000p-1, 0x1.6574ebe8c1000p-3, 0x1.9cf8b2c3c2e78p-46)
+A(0x1.ac00000000000p-1, 0x1.6f0128b757000p-3, -0x1.5118de59c21e1p-45)
+A(0x1.aa00000000000p-1, 0x1.7898d85445000p-3, -0x1.c661070914305p-46)
+A(0x1.a600000000000p-1, 0x1.8beafeb390000p-3, -0x1.73d54aae92cd1p-47)
+A(0x1.a400000000000p-1, 0x1.95a5adcf70000p-3, 0x1.7f22858a0ff6fp-47)
+A(0x1.a000000000000p-1, 0x1.a93ed3c8ae000p-3, -0x1.8724350562169p-45)
+A(0x1.9e00000000000p-1, 0x1.b31d8575bd000p-3, -0x1.c358d4eace1aap-47)
+A(0x1.9c00000000000p-1, 0x1.bd087383be000p-3, -0x1.d4bc4595412b6p-45)
+A(0x1.9a00000000000p-1, 0x1.c6ffbc6f01000p-3, -0x1.1ec72c5962bd2p-48)
+A(0x1.9600000000000p-1, 0x1.db13db0d49000p-3, -0x1.aff2af715b035p-45)
+A(0x1.9400000000000p-1, 0x1.e530effe71000p-3, 0x1.212276041f430p-51)
+A(0x1.9200000000000p-1, 0x1.ef5ade4dd0000p-3, -0x1.a211565bb8e11p-51)
+A(0x1.9000000000000p-1, 0x1.f991c6cb3b000p-3, 0x1.bcbecca0cdf30p-46)
+A(0x1.8c00000000000p-1, 0x1.07138604d5800p-2, 0x1.89cdb16ed4e91p-48)
+A(0x1.8a00000000000p-1, 0x1.0c42d67616000p-2, 0x1.7188b163ceae9p-45)
+A(0x1.8800000000000p-1, 0x1.1178e8227e800p-2, -0x1.c210e63a5f01cp-45)
+A(0x1.8600000000000p-1, 0x1.16b5ccbacf800p-2, 0x1.b9acdf7a51681p-45)
+A(0x1.8400000000000p-1, 0x1.1bf99635a6800p-2, 0x1.ca6ed5147bdb7p-45)
+A(0x1.8200000000000p-1, 0x1.214456d0eb800p-2, 0x1.a87deba46baeap-47)
+A(0x1.7e00000000000p-1, 0x1.2bef07cdc9000p-2, 0x1.a9cfa4a5004f4p-45)
+A(0x1.7c00000000000p-1, 0x1.314f1e1d36000p-2, -0x1.8e27ad3213cb8p-45)
+A(0x1.7a00000000000p-1, 0x1.36b6776be1000p-2, 0x1.16ecdb0f177c8p-46)
+A(0x1.7800000000000p-1, 0x1.3c25277333000p-2, 0x1.83b54b606bd5cp-46)
+A(0x1.7600000000000p-1, 0x1.419b423d5e800p-2, 0x1.8e436ec90e09dp-47)
+A(0x1.7400000000000p-1, 0x1.4718dc271c800p-2, -0x1.f27ce0967d675p-45)
+A(0x1.7200000000000p-1, 0x1.4c9e09e173000p-2, -0x1.e20891b0ad8a4p-45)
+A(0x1.7000000000000p-1, 0x1.522ae0738a000p-2, 0x1.ebe708164c759p-45)
+A(0x1.6e00000000000p-1, 0x1.57bf753c8d000p-2, 0x1.fadedee5d40efp-46)
+A(0x1.6c00000000000p-1, 0x1.5d5bddf596000p-2, -0x1.a0b2a08a465dcp-47)
+},
+};
diff --git a/third_party/musl/porting/liteos_m/kernel/src/math/pow_data.h b/third_party/musl/porting/liteos_m/kernel/src/math/pow_data.h
new file mode 100755
index 000000000..18d2cb2ef
--- /dev/null
+++ b/third_party/musl/porting/liteos_m/kernel/src/math/pow_data.h
@@ -0,0 +1,22 @@
+/*
+ * Copyright (c) 2018, Arm Limited.
+ * SPDX-License-Identifier: MIT
+ */
+#ifndef _POW_DATA_H
+#define _POW_DATA_H
+
+#include <features.h>
+
+#define POW_LOG_TABLE_BITS 7
+#define POW_LOG_POLY_ORDER 8
+extern const struct pow_log_data {
+	double ln2hi;
+	double ln2lo;
+	double poly[POW_LOG_POLY_ORDER - 1]; /* First coefficient is 1.  */
+	/* Note: the pad field is unused, but allows slightly faster indexing.  */
+	struct {
+		double invc, pad, logc, logctail;
+	} tab[1 << POW_LOG_TABLE_BITS];
+} __pow_log_data1;
+
+#endif
diff --git a/third_party/musl/porting/liteos_m/kernel/src/math/round.c b/third_party/musl/porting/liteos_m/kernel/src/math/round.c
new file mode 100755
index 000000000..130d58d25
--- /dev/null
+++ b/third_party/musl/porting/liteos_m/kernel/src/math/round.c
@@ -0,0 +1,35 @@
+#include "libm.h"
+
+#if FLT_EVAL_METHOD==0 || FLT_EVAL_METHOD==1
+#define EPS DBL_EPSILON
+#elif FLT_EVAL_METHOD==2
+#define EPS LDBL_EPSILON
+#endif
+static const double_t toint = 1/EPS;
+
+double round(double x)
+{
+	union {double f; uint64_t i;} u = {x};
+	int e = u.i >> 52 & 0x7ff;
+	double_t y;
+
+	if (e >= 0x3ff+52)
+		return x;
+	if (u.i >> 63)
+		x = -x;
+	if (e < 0x3ff-1) {
+		/* raise inexact if x!=0 */
+		FORCE_EVAL(x + toint);
+		return 0*u.f;
+	}
+	y = x + toint - toint - x;
+	if (y > 0.5)
+		y = y + x - 1;
+	else if (y <= -0.5)
+		y = y + x + 1;
+	else
+		y = y + x;
+	if (u.i >> 63)
+		y = -y;
+	return y;
+}
diff --git a/third_party/musl/porting/liteos_m/kernel/src/math/sqrt.c b/third_party/musl/porting/liteos_m/kernel/src/math/sqrt.c
new file mode 100755
index 000000000..f1f6d76c7
--- /dev/null
+++ b/third_party/musl/porting/liteos_m/kernel/src/math/sqrt.c
@@ -0,0 +1,184 @@
+/* origin: FreeBSD /usr/src/lib/msun/src/e_sqrt.c */
+/*
+ * ====================================================
+ * Copyright (C) 1993 by Sun Microsystems, Inc. All rights reserved.
+ *
+ * Developed at SunSoft, a Sun Microsystems, Inc. business.
+ * Permission to use, copy, modify, and distribute this
+ * software is freely granted, provided that this notice
+ * is preserved.
+ * ====================================================
+ */
+/* sqrt(x)
+ * Return correctly rounded sqrt.
+ *           ------------------------------------------
+ *           |  Use the hardware sqrt if you have one |
+ *           ------------------------------------------
+ * Method:
+ *   Bit by bit method using integer arithmetic. (Slow, but portable)
+ *   1. Normalization
+ *      Scale x to y in [1,4) with even powers of 2:
+ *      find an integer k such that  1 <= (y=x*2^(2k)) < 4, then
+ *              sqrt(x) = 2^k * sqrt(y)
+ *   2. Bit by bit computation
+ *      Let q  = sqrt(y) truncated to i bit after binary point (q = 1),
+ *           i                                                   0
+ *                                     i+1         2
+ *          s  = 2*q , and      y  =  2   * ( y - q  ).         (1)
+ *           i      i            i                 i
+ *
+ *      To compute q    from q , one checks whether
+ *                  i+1       i
+ *
+ *                            -(i+1) 2
+ *                      (q + 2      ) <= y.                     (2)
+ *                        i
+ *                                                            -(i+1)
+ *      If (2) is false, then q   = q ; otherwise q   = q  + 2      .
+ *                             i+1   i             i+1   i
+ *
+ *      With some algebric manipulation, it is not difficult to see
+ *      that (2) is equivalent to
+ *                             -(i+1)
+ *                      s  +  2       <= y                      (3)
+ *                       i                i
+ *
+ *      The advantage of (3) is that s  and y  can be computed by
+ *                                    i      i
+ *      the following recurrence formula:
+ *          if (3) is false
+ *
+ *          s     =  s  ,       y    = y   ;                    (4)
+ *           i+1      i          i+1    i
+ *
+ *          otherwise,
+ *                         -i                     -(i+1)
+ *          s     =  s  + 2  ,  y    = y  -  s  - 2             (5)
+ *           i+1      i          i+1    i     i
+ *
+ *      One may easily use induction to prove (4) and (5).
+ *      Note. Since the left hand side of (3) contain only i+2 bits,
+ *            it does not necessary to do a full (53-bit) comparison
+ *            in (3).
+ *   3. Final rounding
+ *      After generating the 53 bits result, we compute one more bit.
+ *      Together with the remainder, we can decide whether the
+ *      result is exact, bigger than 1/2ulp, or less than 1/2ulp
+ *      (it will never equal to 1/2ulp).
+ *      The rounding mode can be detected by checking whether
+ *      huge + tiny is equal to huge, and whether huge - tiny is
+ *      equal to huge for some floating point number "huge" and "tiny".
+ *
+ * Special cases:
+ *      sqrt(+-0) = +-0         ... exact
+ *      sqrt(inf) = inf
+ *      sqrt(-ve) = NaN         ... with invalid signal
+ *      sqrt(NaN) = NaN         ... with invalid signal for signaling NaN
+ */
+
+#include "libm.h"
+
+static const double tiny = 1.0e-300;
+
+double sqrt(double x)
+{
+	double z;
+	int32_t sign = (int)0x80000000;
+	int32_t ix0,s0,q,m,t,i;
+	uint32_t r,t1,s1,ix1,q1;
+
+	EXTRACT_WORDS(ix0, ix1, x);
+
+	/* take care of Inf and NaN */
+	if ((ix0&0x7ff00000) == 0x7ff00000) {
+		return x*x + x;  /* sqrt(NaN)=NaN, sqrt(+inf)=+inf, sqrt(-inf)=sNaN */
+	}
+	/* take care of zero */
+	if (ix0 <= 0) {
+		if (((ix0&~sign)|ix1) == 0)
+			return x;  /* sqrt(+-0) = +-0 */
+		if (ix0 < 0)
+			return (x-x)/(x-x);  /* sqrt(-ve) = sNaN */
+	}
+	/* normalize x */
+	m = ix0>>20;
+	if (m == 0) {  /* subnormal x */
+		while (ix0 == 0) {
+			m -= 21;
+			ix0 |= (ix1>>11);
+			ix1 <<= 21;
+		}
+		for (i=0; (ix0&0x00100000) == 0; i++)
+			ix0<<=1;
+		m -= i - 1;
+		ix0 |= ix1>>(32-i);
+		ix1 <<= i;
+	}
+	m -= 1023;    /* unbias exponent */
+	ix0 = (ix0&0x000fffff)|0x00100000;
+	if (m & 1) {  /* odd m, double x to make it even */
+		ix0 += ix0 + ((ix1&sign)>>31);
+		ix1 += ix1;
+	}
+	m >>= 1;      /* m = [m/2] */
+
+	/* generate sqrt(x) bit by bit */
+	ix0 += ix0 + ((ix1&sign)>>31);
+	ix1 += ix1;
+	q = q1 = s0 = s1 = 0;  /* [q,q1] = sqrt(x) */
+	r = 0x00200000;        /* r = moving bit from right to left */
+
+	while (r != 0) {
+		t = s0 + r;
+		if (t <= ix0) {
+			s0   = t + r;
+			ix0 -= t;
+			q   += r;
+		}
+		ix0 += ix0 + ((ix1&sign)>>31);
+		ix1 += ix1;
+		r >>= 1;
+	}
+
+	r = sign;
+	while (r != 0) {
+		t1 = s1 + r;
+		t  = s0;
+		if (t < ix0 || (t == ix0 && t1 <= ix1)) {
+			s1 = t1 + r;
+			if ((t1&sign) == sign && (s1&sign) == 0)
+				s0++;
+			ix0 -= t;
+			if (ix1 < t1)
+				ix0--;
+			ix1 -= t1;
+			q1 += r;
+		}
+		ix0 += ix0 + ((ix1&sign)>>31);
+		ix1 += ix1;
+		r >>= 1;
+	}
+
+	/* use floating add to find out rounding direction */
+	if ((ix0|ix1) != 0) {
+		z = 1.0 - tiny; /* raise inexact flag */
+		if (z >= 1.0) {
+			z = 1.0 + tiny;
+			if (q1 == (uint32_t)0xffffffff) {
+				q1 = 0;
+				q++;
+			} else if (z > 1.0) {
+				if (q1 == (uint32_t)0xfffffffe)
+					q++;
+				q1 += 2;
+			} else
+				q1 += q1 & 1;
+		}
+	}
+	ix0 = (q>>1) + 0x3fe00000;
+	ix1 = q1>>1;
+	if (q&1)
+		ix1 |= sign;
+	INSERT_WORDS(z, ix0 + ((uint32_t)m << 20), ix1);
+	return z;
+}
diff --git a/third_party/musl/porting/liteos_m/kernel/src/misc/dirname.c b/third_party/musl/porting/liteos_m/kernel/src/misc/dirname.c
new file mode 100755
index 000000000..dd570883d
--- /dev/null
+++ b/third_party/musl/porting/liteos_m/kernel/src/misc/dirname.c
@@ -0,0 +1,14 @@
+#include <string.h>
+#include <libgen.h>
+
+char *dirname(char *s)
+{
+	size_t i;
+	if (!s || !*s) return ".";
+	i = strlen(s)-1;
+	for (; s[i]=='/'; i--) if (!i) return "/";
+	for (; s[i]!='/'; i--) if (!i) return ".";
+	for (; s[i]=='/'; i--) if (!i) return "/";
+	s[i+1] = 0;
+	return s;
+}
diff --git a/third_party/musl/porting/liteos_m/kernel/src/network/h_errno.c b/third_party/musl/porting/liteos_m/kernel/src/network/h_errno.c
new file mode 100755
index 000000000..c34c1693a
--- /dev/null
+++ b/third_party/musl/porting/liteos_m/kernel/src/network/h_errno.c
@@ -0,0 +1,9 @@
+#include <netdb.h>
+
+#undef h_errno
+static int h_errno;
+
+int *__h_errno_location(void)
+{
+    return &h_errno;
+}
diff --git a/third_party/musl/porting/liteos_m/kernel/src/network/htonl.c b/third_party/musl/porting/liteos_m/kernel/src/network/htonl.c
new file mode 100755
index 000000000..6622d16cc
--- /dev/null
+++ b/third_party/musl/porting/liteos_m/kernel/src/network/htonl.c
@@ -0,0 +1,8 @@
+#include <netinet/in.h>
+#include <byteswap.h>
+
+uint32_t htonl(uint32_t n)
+{
+	union { int i; char c; } u = { 1 };
+	return u.c ? bswap_32(n) : n;
+}
diff --git a/third_party/musl/porting/liteos_m/kernel/src/network/htons.c b/third_party/musl/porting/liteos_m/kernel/src/network/htons.c
new file mode 100755
index 000000000..03a3a1d59
--- /dev/null
+++ b/third_party/musl/porting/liteos_m/kernel/src/network/htons.c
@@ -0,0 +1,8 @@
+#include <netinet/in.h>
+#include <byteswap.h>
+
+uint16_t htons(uint16_t n)
+{
+	union { int i; char c; } u = { 1 };
+	return u.c ? bswap_16(n) : n;
+}
diff --git a/third_party/musl/porting/liteos_m/kernel/src/network/ntohl.c b/third_party/musl/porting/liteos_m/kernel/src/network/ntohl.c
new file mode 100755
index 000000000..d6fce4590
--- /dev/null
+++ b/third_party/musl/porting/liteos_m/kernel/src/network/ntohl.c
@@ -0,0 +1,8 @@
+#include <netinet/in.h>
+#include <byteswap.h>
+
+uint32_t ntohl(uint32_t n)
+{
+	union { int i; char c; } u = { 1 };
+	return u.c ? bswap_32(n) : n;
+}
diff --git a/third_party/musl/porting/liteos_m/kernel/src/network/ntohs.c b/third_party/musl/porting/liteos_m/kernel/src/network/ntohs.c
new file mode 100755
index 000000000..745cef425
--- /dev/null
+++ b/third_party/musl/porting/liteos_m/kernel/src/network/ntohs.c
@@ -0,0 +1,8 @@
+#include <netinet/in.h>
+#include <byteswap.h>
+
+uint16_t ntohs(uint16_t n)
+{
+	union { int i; char c; } u = { 1 };
+	return u.c ? bswap_16(n) : n;
+}
diff --git a/third_party/musl/porting/liteos_m/kernel/src/prng/random.c b/third_party/musl/porting/liteos_m/kernel/src/prng/random.c
new file mode 100755
index 000000000..dafd30980
--- /dev/null
+++ b/third_party/musl/porting/liteos_m/kernel/src/prng/random.c
@@ -0,0 +1,126 @@
+#include <stdlib.h>
+#include <stdint.h>
+#include "los_context.h"
+/*
+this code uses the same lagged fibonacci generator as the
+original bsd random implementation except for the seeding
+which was broken in the original
+*/
+
+static uint32_t init[] = {
+0x00000000,0x5851f42d,0xc0b18ccf,0xcbb5f646,
+0xc7033129,0x30705b04,0x20fd5db4,0x9a8b7f78,
+0x502959d8,0xab894868,0x6c0356a7,0x88cdb7ff,
+0xb477d43f,0x70a3a52b,0xa8e4baf1,0xfd8341fc,
+0x8ae16fd9,0x742d2f7a,0x0d1f0796,0x76035e09,
+0x40f7702c,0x6fa72ca5,0xaaa84157,0x58a0df74,
+0xc74a0364,0xae533cc4,0x04185faf,0x6de3b115,
+0x0cab8628,0xf043bfa4,0x398150e9,0x37521657};
+
+static int n = 31;
+static int i = 3;
+static int j = 0;
+static uint32_t *x = init+1;
+
+static uint32_t lcg31(uint32_t x) {
+	return (1103515245*x + 12345) & 0x7fffffff;
+}
+
+static uint64_t lcg64(uint64_t x) {
+	return 6364136223846793005ull*x + 1;
+}
+
+static void *savestate(void) {
+	x[-1] = (n<<16)|(i<<8)|j;
+	return x-1;
+}
+
+static void loadstate(uint32_t *state) {
+	x = state+1;
+	n = x[-1]>>16;
+	i = (x[-1]>>8)&0xff;
+	j = x[-1]&0xff;
+}
+
+static void __srandom(unsigned seed) {
+	int k;
+	uint64_t s = seed;
+
+	if (n == 0) {
+		x[0] = s;
+		return;
+	}
+	i = n == 31 || n == 7 ? 3 : 1;
+	j = 0;
+	for (k = 0; k < n; k++) {
+		s = lcg64(s);
+		x[k] = s>>32;
+	}
+	/* make sure x contains at least one odd number */
+	x[0] |= 1;
+}
+
+void srandom(unsigned seed) {
+	unsigned int intSave;
+
+	intSave = LOS_IntLock();
+	__srandom(seed);
+	LOS_IntRestore(intSave);
+}
+
+char *initstate(unsigned seed, char *state, size_t size) {
+	void *old;
+	unsigned int intSave;
+
+	if (size < 8)
+		return 0;
+
+	intSave = LOS_IntLock();
+	old = savestate();
+	if (size < 32)
+		n = 0;
+	else if (size < 64)
+		n = 7;
+	else if (size < 128)
+		n = 15;
+	else if (size < 256)
+		n = 31;
+	else
+		n = 63;
+	x = (uint32_t*)state + 1;
+	__srandom(seed);
+	savestate();
+	LOS_IntRestore(intSave);
+	return old;
+}
+
+char *setstate(char *state) {
+	void *old;
+	unsigned int intSave;
+
+	intSave = LOS_IntLock();
+	old = savestate();
+	loadstate((uint32_t*)state);
+	LOS_IntRestore(intSave);
+	return old;
+}
+
+long random(void) {
+	long k;
+	unsigned int intSave;
+
+	intSave = LOS_IntLock();
+	if (n == 0) {
+		k = x[0] = lcg31(x[0]);
+		goto end;
+	}
+	x[i] += x[j];
+	k = x[i]>>1;
+	if (++i == n)
+		i = 0;
+	if (++j == n)
+		j = 0;
+end:
+	LOS_IntRestore(intSave);
+	return k;
+}
diff --git a/third_party/musl/porting/liteos_m/kernel/src/regex/regcomp.c b/third_party/musl/porting/liteos_m/kernel/src/regex/regcomp.c
new file mode 100755
index 000000000..fb24556eb
--- /dev/null
+++ b/third_party/musl/porting/liteos_m/kernel/src/regex/regcomp.c
@@ -0,0 +1,2953 @@
+/*
+  regcomp.c - TRE POSIX compatible regex compilation functions.
+
+  Copyright (c) 2001-2009 Ville Laurikari <vl@iki.fi>
+  All rights reserved.
+
+  Redistribution and use in source and binary forms, with or without
+  modification, are permitted provided that the following conditions
+  are met:
+
+    1. Redistributions of source code must retain the above copyright
+       notice, this list of conditions and the following disclaimer.
+
+    2. Redistributions in binary form must reproduce the above copyright
+       notice, this list of conditions and the following disclaimer in the
+       documentation and/or other materials provided with the distribution.
+
+  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDER AND CONTRIBUTORS
+  ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+  A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT
+  HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+*/
+
+#include <string.h>
+#include <stdlib.h>
+#include <regex.h>
+#include <limits.h>
+#include <stdint.h>
+#include <ctype.h>
+
+#include "tre.h"
+
+#include <assert.h>
+
+/***********************************************************************
+ from tre-compile.h
+***********************************************************************/
+
+typedef struct {
+  int position;
+  int code_min;
+  int code_max;
+  int *tags;
+  int assertions;
+  tre_ctype_t class;
+  tre_ctype_t *neg_classes;
+  int backref;
+} tre_pos_and_tags_t;
+
+
+/***********************************************************************
+ from tre-ast.c and tre-ast.h
+***********************************************************************/
+
+/* The different AST node types. */
+typedef enum {
+  LITERAL,
+  CATENATION,
+  ITERATION,
+  UNION
+} tre_ast_type_t;
+
+/* Special subtypes of TRE_LITERAL. */
+#define EMPTY	  -1   /* Empty leaf (denotes empty string). */
+#define ASSERTION -2   /* Assertion leaf. */
+#define TAG	  -3   /* Tag leaf. */
+#define BACKREF	  -4   /* Back reference leaf. */
+
+#define IS_SPECIAL(x)	((x)->code_min < 0)
+#define IS_EMPTY(x)	((x)->code_min == EMPTY)
+#define IS_ASSERTION(x) ((x)->code_min == ASSERTION)
+#define IS_TAG(x)	((x)->code_min == TAG)
+#define IS_BACKREF(x)	((x)->code_min == BACKREF)
+
+
+/* A generic AST node.  All AST nodes consist of this node on the top
+   level with `obj' pointing to the actual content. */
+typedef struct {
+  tre_ast_type_t type;   /* Type of the node. */
+  void *obj;             /* Pointer to actual node. */
+  int nullable;
+  int submatch_id;
+  int num_submatches;
+  int num_tags;
+  tre_pos_and_tags_t *firstpos;
+  tre_pos_and_tags_t *lastpos;
+} tre_ast_node_t;
+
+
+/* A "literal" node.  These are created for assertions, back references,
+   tags, matching parameter settings, and all expressions that match one
+   character. */
+typedef struct {
+  long code_min;
+  long code_max;
+  int position;
+  tre_ctype_t class;
+  tre_ctype_t *neg_classes;
+} tre_literal_t;
+
+/* A "catenation" node.	 These are created when two regexps are concatenated.
+   If there are more than one subexpressions in sequence, the `left' part
+   holds all but the last, and `right' part holds the last subexpression
+   (catenation is left associative). */
+typedef struct {
+  tre_ast_node_t *left;
+  tre_ast_node_t *right;
+} tre_catenation_t;
+
+/* An "iteration" node.	 These are created for the "*", "+", "?", and "{m,n}"
+   operators. */
+typedef struct {
+  /* Subexpression to match. */
+  tre_ast_node_t *arg;
+  /* Minimum number of consecutive matches. */
+  int min;
+  /* Maximum number of consecutive matches. */
+  int max;
+  /* If 0, match as many characters as possible, if 1 match as few as
+     possible.	Note that this does not always mean the same thing as
+     matching as many/few repetitions as possible. */
+  unsigned int minimal:1;
+} tre_iteration_t;
+
+/* An "union" node.  These are created for the "|" operator. */
+typedef struct {
+  tre_ast_node_t *left;
+  tre_ast_node_t *right;
+} tre_union_t;
+
+
+static tre_ast_node_t *
+tre_ast_new_node(tre_mem_t mem, int type, void *obj)
+{
+	tre_ast_node_t *node = tre_mem_calloc(mem, sizeof *node);
+	if (!node || !obj)
+		return 0;
+	node->obj = obj;
+	node->type = type;
+	node->nullable = -1;
+	node->submatch_id = -1;
+	return node;
+}
+
+static tre_ast_node_t *
+tre_ast_new_literal(tre_mem_t mem, int code_min, int code_max, int position)
+{
+	tre_ast_node_t *node;
+	tre_literal_t *lit;
+
+	lit = tre_mem_calloc(mem, sizeof *lit);
+	node = tre_ast_new_node(mem, LITERAL, lit);
+	if (!node)
+		return 0;
+	lit->code_min = code_min;
+	lit->code_max = code_max;
+	lit->position = position;
+	return node;
+}
+
+static tre_ast_node_t *
+tre_ast_new_iter(tre_mem_t mem, tre_ast_node_t *arg, int min, int max, int minimal)
+{
+	tre_ast_node_t *node;
+	tre_iteration_t *iter;
+
+	iter = tre_mem_calloc(mem, sizeof *iter);
+	node = tre_ast_new_node(mem, ITERATION, iter);
+	if (!node)
+		return 0;
+	iter->arg = arg;
+	iter->min = min;
+	iter->max = max;
+	iter->minimal = minimal;
+	node->num_submatches = arg->num_submatches;
+	return node;
+}
+
+static tre_ast_node_t *
+tre_ast_new_union(tre_mem_t mem, tre_ast_node_t *left, tre_ast_node_t *right)
+{
+	tre_ast_node_t *node;
+	tre_union_t *un;
+
+	if (!left)
+		return right;
+	un = tre_mem_calloc(mem, sizeof *un);
+	node = tre_ast_new_node(mem, UNION, un);
+	if (!node || !right)
+		return 0;
+	un->left = left;
+	un->right = right;
+	node->num_submatches = left->num_submatches + right->num_submatches;
+	return node;
+}
+
+static tre_ast_node_t *
+tre_ast_new_catenation(tre_mem_t mem, tre_ast_node_t *left, tre_ast_node_t *right)
+{
+	tre_ast_node_t *node;
+	tre_catenation_t *cat;
+
+	if (!left)
+		return right;
+	cat = tre_mem_calloc(mem, sizeof *cat);
+	node = tre_ast_new_node(mem, CATENATION, cat);
+	if (!node)
+		return 0;
+	cat->left = left;
+	cat->right = right;
+	node->num_submatches = left->num_submatches + right->num_submatches;
+	return node;
+}
+
+
+/***********************************************************************
+ from tre-stack.c and tre-stack.h
+***********************************************************************/
+
+typedef struct tre_stack_rec tre_stack_t;
+
+/* Creates a new stack object.	`size' is initial size in bytes, `max_size'
+   is maximum size, and `increment' specifies how much more space will be
+   allocated with realloc() if all space gets used up.	Returns the stack
+   object or NULL if out of memory. */
+static tre_stack_t *
+tre_stack_new(int size, int max_size, int increment);
+
+/* Frees the stack object. */
+static void
+tre_stack_destroy(tre_stack_t *s);
+
+/* Returns the current number of objects in the stack. */
+static int
+tre_stack_num_objects(tre_stack_t *s);
+
+/* Each tre_stack_push_*(tre_stack_t *s, <type> value) function pushes
+   `value' on top of stack `s'.  Returns REG_ESPACE if out of memory.
+   This tries to realloc() more space before failing if maximum size
+   has not yet been reached.  Returns REG_OK if successful. */
+#define declare_pushf(typetag, type)					      \
+  static reg_errcode_t tre_stack_push_ ## typetag(tre_stack_t *s, type value)
+
+declare_pushf(voidptr, void *);
+declare_pushf(int, int);
+
+/* Each tre_stack_pop_*(tre_stack_t *s) function pops the topmost
+   element off of stack `s' and returns it.  The stack must not be
+   empty. */
+#define declare_popf(typetag, type)		  \
+  static type tre_stack_pop_ ## typetag(tre_stack_t *s)
+
+declare_popf(voidptr, void *);
+declare_popf(int, int);
+
+/* Just to save some typing. */
+#define STACK_PUSH(s, typetag, value)					      \
+  do									      \
+    {									      \
+      status = tre_stack_push_ ## typetag(s, value);			      \
+    }									      \
+  while (/*CONSTCOND*/0)
+
+#define STACK_PUSHX(s, typetag, value)					      \
+  {									      \
+    status = tre_stack_push_ ## typetag(s, value);			      \
+    if (status != REG_OK)						      \
+      break;								      \
+  }
+
+#define STACK_PUSHR(s, typetag, value)					      \
+  {									      \
+    reg_errcode_t _status;						      \
+    _status = tre_stack_push_ ## typetag(s, value);			      \
+    if (_status != REG_OK)						      \
+      return _status;							      \
+  }
+
+union tre_stack_item {
+  void *voidptr_value;
+  int int_value;
+};
+
+struct tre_stack_rec {
+  int size;
+  int max_size;
+  int increment;
+  int ptr;
+  union tre_stack_item *stack;
+};
+
+
+static tre_stack_t *
+tre_stack_new(int size, int max_size, int increment)
+{
+  tre_stack_t *s;
+
+  s = xmalloc(sizeof(*s));
+  if (s != NULL)
+    {
+      s->stack = xmalloc(sizeof(*s->stack) * size);
+      if (s->stack == NULL)
+	{
+	  xfree(s);
+	  return NULL;
+	}
+      s->size = size;
+      s->max_size = max_size;
+      s->increment = increment;
+      s->ptr = 0;
+    }
+  return s;
+}
+
+static void
+tre_stack_destroy(tre_stack_t *s)
+{
+  xfree(s->stack);
+  xfree(s);
+}
+
+static int
+tre_stack_num_objects(tre_stack_t *s)
+{
+  return s->ptr;
+}
+
+static reg_errcode_t
+tre_stack_push(tre_stack_t *s, union tre_stack_item value)
+{
+  if (s->ptr < s->size)
+    {
+      s->stack[s->ptr] = value;
+      s->ptr++;
+    }
+  else
+    {
+      if (s->size >= s->max_size)
+	{
+	  return REG_ESPACE;
+	}
+      else
+	{
+	  union tre_stack_item *new_buffer;
+	  int new_size;
+	  new_size = s->size + s->increment;
+	  if (new_size > s->max_size)
+	    new_size = s->max_size;
+	  new_buffer = xrealloc(s->stack, sizeof(*new_buffer) * new_size);
+	  if (new_buffer == NULL)
+	    {
+	      return REG_ESPACE;
+	    }
+	  assert(new_size > s->size);
+	  s->size = new_size;
+	  s->stack = new_buffer;
+	  tre_stack_push(s, value);
+	}
+    }
+  return REG_OK;
+}
+
+#define define_pushf(typetag, type)  \
+  declare_pushf(typetag, type) {     \
+    union tre_stack_item item;	     \
+    item.typetag ## _value = value;  \
+    return tre_stack_push(s, item);  \
+}
+
+define_pushf(int, int)
+define_pushf(voidptr, void *)
+
+#define define_popf(typetag, type)		    \
+  declare_popf(typetag, type) {			    \
+    return s->stack[--s->ptr].typetag ## _value;    \
+  }
+
+define_popf(int, int)
+define_popf(voidptr, void *)
+
+
+/***********************************************************************
+ from tre-parse.c and tre-parse.h
+***********************************************************************/
+
+/* Parse context. */
+typedef struct {
+	/* Memory allocator. The AST is allocated using this. */
+	tre_mem_t mem;
+	/* Stack used for keeping track of regexp syntax. */
+	tre_stack_t *stack;
+	/* The parsed node after a parse function returns. */
+	tre_ast_node_t *n;
+	/* Position in the regexp pattern after a parse function returns. */
+	const char *s;
+	/* The first character of the last subexpression parsed. */
+	const char *start;
+	/* Current submatch ID. */
+	int submatch_id;
+	/* Current position (number of literal). */
+	int position;
+	/* The highest back reference or -1 if none seen so far. */
+	int max_backref;
+	/* Compilation flags. */
+	int cflags;
+} tre_parse_ctx_t;
+
+/* Some macros for expanding \w, \s, etc. */
+static const struct {
+	char c;
+	const char *expansion;
+} tre_macros[] = {
+	{'t', "\t"}, {'n', "\n"}, {'r', "\r"},
+	{'f', "\f"}, {'a', "\a"}, {'e', "\033"},
+	{'w', "[[:alnum:]_]"}, {'W', "[^[:alnum:]_]"}, {'s', "[[:space:]]"},
+	{'S', "[^[:space:]]"}, {'d', "[[:digit:]]"}, {'D', "[^[:digit:]]"},
+	{ 0, 0 }
+};
+
+/* Expands a macro delimited by `regex' and `regex_end' to `buf', which
+   must have at least `len' items.  Sets buf[0] to zero if the there
+   is no match in `tre_macros'. */
+static const char *tre_expand_macro(const char *s)
+{
+	int i;
+	for (i = 0; tre_macros[i].c && tre_macros[i].c != *s; i++);
+	return tre_macros[i].expansion;
+}
+
+static int
+tre_compare_lit(const void *a, const void *b)
+{
+	const tre_literal_t *const *la = a;
+	const tre_literal_t *const *lb = b;
+	/* assumes the range of valid code_min is < INT_MAX */
+	return la[0]->code_min - lb[0]->code_min;
+}
+
+struct literals {
+	tre_mem_t mem;
+	tre_literal_t **a;
+	int len;
+	int cap;
+};
+
+static tre_literal_t *tre_new_lit(struct literals *p)
+{
+	tre_literal_t **a;
+	if (p->len >= p->cap) {
+		if (p->cap >= 1<<15)
+			return 0;
+		p->cap *= 2;
+		a = xrealloc(p->a, p->cap * sizeof *p->a);
+		if (!a)
+			return 0;
+		p->a = a;
+	}
+	a = p->a + p->len++;
+	*a = tre_mem_calloc(p->mem, sizeof **a);
+	return *a;
+}
+
+static int add_icase_literals(struct literals *ls, int min, int max)
+{
+	tre_literal_t *lit;
+	int b, e, c;
+	for (c=min; c<=max; ) {
+		/* assumes islower(c) and isupper(c) are exclusive
+		   and toupper(c)!=c if islower(c).
+		   multiple opposite case characters are not supported */
+		if (tre_islower(c)) {
+			b = e = tre_toupper(c);
+			for (c++, e++; c<=max; c++, e++)
+				if (tre_toupper(c) != e) break;
+		} else if (tre_isupper(c)) {
+			b = e = tre_tolower(c);
+			for (c++, e++; c<=max; c++, e++)
+				if (tre_tolower(c) != e) break;
+		} else {
+			c++;
+			continue;
+		}
+		lit = tre_new_lit(ls);
+		if (!lit)
+			return -1;
+		lit->code_min = b;
+		lit->code_max = e-1;
+		lit->position = -1;
+	}
+	return 0;
+}
+
+
+/* Maximum number of character classes in a negated bracket expression. */
+#define MAX_NEG_CLASSES 64
+
+struct neg {
+	int negate;
+	int len;
+	tre_ctype_t a[MAX_NEG_CLASSES];
+};
+
+// TODO: parse bracket into a set of non-overlapping [lo,hi] ranges
+
+/*
+bracket grammar:
+Bracket  =  '[' List ']'  |  '[^' List ']'
+List     =  Term  |  List Term
+Term     =  Char  |  Range  |  Chclass  |  Eqclass
+Range    =  Char '-' Char  |  Char '-' '-'
+Char     =  Coll  |  coll_single
+Meta     =  ']'  |  '-'
+Coll     =  '[.' coll_single '.]'  |  '[.' coll_multi '.]'  |  '[.' Meta '.]'
+Eqclass  =  '[=' coll_single '=]'  |  '[=' coll_multi '=]'
+Chclass  =  '[:' class ':]'
+
+coll_single is a single char collating element but it can be
+ '-' only at the beginning or end of a List and
+ ']' only at the beginning of a List and
+ '^' anywhere except after the openning '['
+*/
+
+static reg_errcode_t parse_bracket_terms(tre_parse_ctx_t *ctx, const char *s, struct literals *ls, struct neg *neg)
+{
+	const char *start = s;
+	tre_ctype_t class;
+	int min, max;
+	wchar_t wc;
+	int len;
+
+	for (;;) {
+		class = 0;
+		len = mbtowc(&wc, s, -1);
+		if (len <= 0)
+			return *s ? REG_BADPAT : REG_EBRACK;
+		if (*s == ']' && s != start) {
+			ctx->s = s+1;
+			return REG_OK;
+		}
+		if (*s == '-' && s != start && s[1] != ']' &&
+		    /* extension: [a-z--@] is accepted as [a-z]|[--@] */
+		    (s[1] != '-' || s[2] == ']'))
+			return REG_ERANGE;
+		if (*s == '[' && (s[1] == '.' || s[1] == '='))
+			/* collating symbols and equivalence classes are not supported */
+			return REG_ECOLLATE;
+		if (*s == '[' && s[1] == ':') {
+			char tmp[CHARCLASS_NAME_MAX+1];
+			s += 2;
+			for (len=0; len < CHARCLASS_NAME_MAX && s[len]; len++) {
+				if (s[len] == ':') {
+					memcpy(tmp, s, len);
+					tmp[len] = 0;
+					class = tre_ctype(tmp);
+					break;
+				}
+			}
+			if (!class || s[len+1] != ']')
+				return REG_ECTYPE;
+			min = 0;
+			max = TRE_CHAR_MAX;
+			s += len+2;
+		} else {
+			min = max = wc;
+			s += len;
+			if (*s == '-' && s[1] != ']') {
+				s++;
+				len = mbtowc(&wc, s, -1);
+				max = wc;
+				/* XXX - Should use collation order instead of
+				   encoding values in character ranges. */
+				if (len <= 0 || min > max)
+					return REG_ERANGE;
+				s += len;
+			}
+		}
+
+		if (class && neg->negate) {
+			if (neg->len >= MAX_NEG_CLASSES)
+				return REG_ESPACE;
+			neg->a[neg->len++] = class;
+		} else  {
+			tre_literal_t *lit = tre_new_lit(ls);
+			if (!lit)
+				return REG_ESPACE;
+			lit->code_min = min;
+			lit->code_max = max;
+			lit->class = class;
+			lit->position = -1;
+
+			/* Add opposite-case codepoints if REG_ICASE is present.
+			   It seems that POSIX requires that bracket negation
+			   should happen before case-folding, but most practical
+			   implementations do it the other way around. Changing
+			   the order would need efficient representation of
+			   case-fold ranges and bracket range sets even with
+			   simple patterns so this is ok for now. */
+			if (ctx->cflags & REG_ICASE && !class)
+				if (add_icase_literals(ls, min, max))
+					return REG_ESPACE;
+		}
+	}
+}
+
+static reg_errcode_t parse_bracket(tre_parse_ctx_t *ctx, const char *s)
+{
+	int i, max, min, negmax, negmin;
+	tre_ast_node_t *node = 0, *n;
+	tre_ctype_t *nc = 0;
+	tre_literal_t *lit;
+	struct literals ls;
+	struct neg neg;
+	reg_errcode_t err;
+
+	ls.mem = ctx->mem;
+	ls.len = 0;
+	ls.cap = 32;
+	ls.a = xmalloc(ls.cap * sizeof *ls.a);
+	if (!ls.a)
+		return REG_ESPACE;
+	neg.len = 0;
+	neg.negate = *s == '^';
+	if (neg.negate)
+		s++;
+
+	err = parse_bracket_terms(ctx, s, &ls, &neg);
+	if (err != REG_OK)
+		goto parse_bracket_done;
+
+	if (neg.negate) {
+		/*
+		 * With REG_NEWLINE, POSIX requires that newlines are not matched by
+		 * any form of a non-matching list.
+		 */
+		if (ctx->cflags & REG_NEWLINE) {
+			lit = tre_new_lit(&ls);
+			if (!lit) {
+				err = REG_ESPACE;
+				goto parse_bracket_done;
+			}
+			lit->code_min = '\n';
+			lit->code_max = '\n';
+			lit->position = -1;
+		}
+		/* Sort the array if we need to negate it. */
+		qsort(ls.a, ls.len, sizeof *ls.a, tre_compare_lit);
+		/* extra lit for the last negated range */
+		lit = tre_new_lit(&ls);
+		if (!lit) {
+			err = REG_ESPACE;
+			goto parse_bracket_done;
+		}
+		lit->code_min = TRE_CHAR_MAX+1;
+		lit->code_max = TRE_CHAR_MAX+1;
+		lit->position = -1;
+		/* negated classes */
+		if (neg.len) {
+			nc = tre_mem_alloc(ctx->mem, (neg.len+1)*sizeof *neg.a);
+			if (!nc) {
+				err = REG_ESPACE;
+				goto parse_bracket_done;
+			}
+			memcpy(nc, neg.a, neg.len*sizeof *neg.a);
+			nc[neg.len] = 0;
+		}
+	}
+
+	/* Build a union of the items in the array, negated if necessary. */
+	negmax = negmin = 0;
+	for (i = 0; i < ls.len; i++) {
+		lit = ls.a[i];
+		min = lit->code_min;
+		max = lit->code_max;
+		if (neg.negate) {
+			if (min <= negmin) {
+				/* Overlap. */
+				negmin = MAX(max + 1, negmin);
+				continue;
+			}
+			negmax = min - 1;
+			lit->code_min = negmin;
+			lit->code_max = negmax;
+			negmin = max + 1;
+		}
+		lit->position = ctx->position;
+		lit->neg_classes = nc;
+		n = tre_ast_new_node(ctx->mem, LITERAL, lit);
+		node = tre_ast_new_union(ctx->mem, node, n);
+		if (!node) {
+			err = REG_ESPACE;
+			break;
+		}
+	}
+
+parse_bracket_done:
+	xfree(ls.a);
+	ctx->position++;
+	ctx->n = node;
+	return err;
+}
+
+static const char *parse_dup_count(const char *s, int *n)
+{
+	*n = -1;
+	if (!isdigit(*s))
+		return s;
+	*n = 0;
+	for (;;) {
+		*n = 10 * *n + (*s - '0');
+		s++;
+		if (!isdigit(*s) || *n > RE_DUP_MAX)
+			break;
+	}
+	return s;
+}
+
+static const char *parse_dup(const char *s, int ere, int *pmin, int *pmax)
+{
+	int min, max;
+
+	s = parse_dup_count(s, &min);
+	if (*s == ',')
+		s = parse_dup_count(s+1, &max);
+	else
+		max = min;
+
+	if (
+		(max < min && max >= 0) ||
+		max > RE_DUP_MAX ||
+		min > RE_DUP_MAX ||
+		min < 0 ||
+		(!ere && *s++ != '\\') ||
+		*s++ != '}'
+	)
+		return 0;
+	*pmin = min;
+	*pmax = max;
+	return s;
+}
+
+static int hexval(unsigned c)
+{
+	if (c-'0'<10) return c-'0';
+	c |= 32;
+	if (c-'a'<6) return c-'a'+10;
+	return -1;
+}
+
+static reg_errcode_t marksub(tre_parse_ctx_t *ctx, tre_ast_node_t *node, int subid)
+{
+	if (node->submatch_id >= 0) {
+		tre_ast_node_t *n = tre_ast_new_literal(ctx->mem, EMPTY, -1, -1);
+		if (!n)
+			return REG_ESPACE;
+		n = tre_ast_new_catenation(ctx->mem, n, node);
+		if (!n)
+			return REG_ESPACE;
+		n->num_submatches = node->num_submatches;
+		node = n;
+	}
+	node->submatch_id = subid;
+	node->num_submatches++;
+	ctx->n = node;
+	return REG_OK;
+}
+
+/*
+BRE grammar:
+Regex  =  Branch  |  '^'  |  '$'  |  '^$'  |  '^' Branch  |  Branch '$'  |  '^' Branch '$'
+Branch =  Atom  |  Branch Atom
+Atom   =  char  |  quoted_char  |  '.'  |  Bracket  |  Atom Dup  |  '\(' Branch '\)'  |  back_ref
+Dup    =  '*'  |  '\{' Count '\}'  |  '\{' Count ',\}'  |  '\{' Count ',' Count '\}'
+
+(leading ^ and trailing $ in a sub expr may be an anchor or literal as well)
+
+ERE grammar:
+Regex  =  Branch  |  Regex '|' Branch
+Branch =  Atom  |  Branch Atom
+Atom   =  char  |  quoted_char  |  '.'  |  Bracket  |  Atom Dup  |  '(' Regex ')'  |  '^'  |  '$'
+Dup    =  '*'  |  '+'  |  '?'  |  '{' Count '}'  |  '{' Count ',}'  |  '{' Count ',' Count '}'
+
+(a*+?, ^*, $+, \X, {, (|a) are unspecified)
+*/
+
+static reg_errcode_t parse_atom(tre_parse_ctx_t *ctx, const char *s)
+{
+	int len, ere = ctx->cflags & REG_EXTENDED;
+	const char *p;
+	tre_ast_node_t *node;
+	wchar_t wc;
+	switch (*s) {
+	case '[':
+		return parse_bracket(ctx, s+1);
+	case '\\':
+		p = tre_expand_macro(s+1);
+		if (p) {
+			/* assume \X expansion is a single atom */
+			reg_errcode_t err = parse_atom(ctx, p);
+			ctx->s = s+2;
+			return err;
+		}
+		/* extensions: \b, \B, \<, \>, \xHH \x{HHHH} */
+		switch (*++s) {
+		case 0:
+			return REG_EESCAPE;
+		case 'b':
+			node = tre_ast_new_literal(ctx->mem, ASSERTION, ASSERT_AT_WB, -1);
+			break;
+		case 'B':
+			node = tre_ast_new_literal(ctx->mem, ASSERTION, ASSERT_AT_WB_NEG, -1);
+			break;
+		case '<':
+			node = tre_ast_new_literal(ctx->mem, ASSERTION, ASSERT_AT_BOW, -1);
+			break;
+		case '>':
+			node = tre_ast_new_literal(ctx->mem, ASSERTION, ASSERT_AT_EOW, -1);
+			break;
+		case 'x':
+			s++;
+			int i, v = 0, c;
+			len = 2;
+			if (*s == '{') {
+				len = 8;
+				s++;
+			}
+			for (i=0; i<len && v<0x110000; i++) {
+				c = hexval(s[i]);
+				if (c < 0) break;
+				v = 16*v + c;
+			}
+			s += i;
+			if (len == 8) {
+				if (*s != '}')
+					return REG_EBRACE;
+				s++;
+			}
+			node = tre_ast_new_literal(ctx->mem, v, v, ctx->position++);
+			s--;
+			break;
+		case '{':
+		case '+':
+		case '?':
+			/* extension: treat \+, \? as repetitions in BRE */
+			/* reject repetitions after empty expression in BRE */
+			if (!ere)
+				return REG_BADRPT;
+		case '|':
+			/* extension: treat \| as alternation in BRE */
+			if (!ere) {
+				node = tre_ast_new_literal(ctx->mem, EMPTY, -1, -1);
+				s--;
+				goto end;
+			}
+			/* fallthrough */
+		default:
+			if (!ere && (unsigned)*s-'1' < 9) {
+				/* back reference */
+				int val = *s - '0';
+				node = tre_ast_new_literal(ctx->mem, BACKREF, val, ctx->position++);
+				ctx->max_backref = MAX(val, ctx->max_backref);
+			} else {
+				/* extension: accept unknown escaped char
+				   as a literal */
+				goto parse_literal;
+			}
+		}
+		s++;
+		break;
+	case '.':
+		if (ctx->cflags & REG_NEWLINE) {
+			tre_ast_node_t *tmp1, *tmp2;
+			tmp1 = tre_ast_new_literal(ctx->mem, 0, '\n'-1, ctx->position++);
+			tmp2 = tre_ast_new_literal(ctx->mem, '\n'+1, TRE_CHAR_MAX, ctx->position++);
+			if (tmp1 && tmp2)
+				node = tre_ast_new_union(ctx->mem, tmp1, tmp2);
+			else
+				node = 0;
+		} else {
+			node = tre_ast_new_literal(ctx->mem, 0, TRE_CHAR_MAX, ctx->position++);
+		}
+		s++;
+		break;
+	case '^':
+		/* '^' has a special meaning everywhere in EREs, and at beginning of BRE. */
+		if (!ere && s != ctx->start)
+			goto parse_literal;
+		node = tre_ast_new_literal(ctx->mem, ASSERTION, ASSERT_AT_BOL, -1);
+		s++;
+		break;
+	case '$':
+		/* '$' is special everywhere in EREs, and at the end of a BRE subexpression. */
+		if (!ere && s[1] && (s[1]!='\\'|| (s[2]!=')' && s[2]!='|')))
+			goto parse_literal;
+		node = tre_ast_new_literal(ctx->mem, ASSERTION, ASSERT_AT_EOL, -1);
+		s++;
+		break;
+	case '*':
+	case '{':
+	case '+':
+	case '?':
+		/* reject repetitions after empty expression in ERE */
+		if (ere)
+			return REG_BADRPT;
+	case '|':
+		if (!ere)
+			goto parse_literal;
+	case 0:
+		node = tre_ast_new_literal(ctx->mem, EMPTY, -1, -1);
+		break;
+	default:
+parse_literal:
+		len = mbtowc(&wc, s, -1);
+		if (len < 0)
+			return REG_BADPAT;
+		if (ctx->cflags & REG_ICASE && (tre_isupper(wc) || tre_islower(wc))) {
+			tre_ast_node_t *tmp1, *tmp2;
+			/* multiple opposite case characters are not supported */
+			tmp1 = tre_ast_new_literal(ctx->mem, tre_toupper(wc), tre_toupper(wc), ctx->position);
+			tmp2 = tre_ast_new_literal(ctx->mem, tre_tolower(wc), tre_tolower(wc), ctx->position);
+			if (tmp1 && tmp2)
+				node = tre_ast_new_union(ctx->mem, tmp1, tmp2);
+			else
+				node = 0;
+		} else {
+			node = tre_ast_new_literal(ctx->mem, wc, wc, ctx->position);
+		}
+		ctx->position++;
+		s += len;
+		break;
+	}
+end:
+	if (!node)
+		return REG_ESPACE;
+	ctx->n = node;
+	ctx->s = s;
+	return REG_OK;
+}
+
+#define PUSHPTR(err, s, v) do { \
+	if ((err = tre_stack_push_voidptr(s, v)) != REG_OK) \
+		return err; \
+} while(0)
+
+#define PUSHINT(err, s, v) do { \
+	if ((err = tre_stack_push_int(s, v)) != REG_OK) \
+		return err; \
+} while(0)
+
+static reg_errcode_t tre_parse(tre_parse_ctx_t *ctx)
+{
+	tre_ast_node_t *nbranch=0, *nunion=0;
+	int ere = ctx->cflags & REG_EXTENDED;
+	const char *s = ctx->start;
+	int subid = 0;
+	int depth = 0;
+	reg_errcode_t err;
+	tre_stack_t *stack = ctx->stack;
+
+	PUSHINT(err, stack, subid++);
+	for (;;) {
+		if ((!ere && *s == '\\' && s[1] == '(') ||
+		    (ere && *s == '(')) {
+			PUSHPTR(err, stack, nunion);
+			PUSHPTR(err, stack, nbranch);
+			PUSHINT(err, stack, subid++);
+			s++;
+			if (!ere)
+				s++;
+			depth++;
+			nbranch = nunion = 0;
+			ctx->start = s;
+			continue;
+		}
+		if ((!ere && *s == '\\' && s[1] == ')') ||
+		    (ere && *s == ')' && depth)) {
+			ctx->n = tre_ast_new_literal(ctx->mem, EMPTY, -1, -1);
+			if (!ctx->n)
+				return REG_ESPACE;
+		} else {
+			err = parse_atom(ctx, s);
+			if (err != REG_OK)
+				return err;
+			s = ctx->s;
+		}
+
+	parse_iter:
+		for (;;) {
+			int min, max;
+
+			if (*s!='\\' && *s!='*') {
+				if (!ere)
+					break;
+				if (*s!='+' && *s!='?' && *s!='{')
+					break;
+			}
+			if (*s=='\\' && ere)
+				break;
+			/* extension: treat \+, \? as repetitions in BRE */
+			if (*s=='\\' && s[1]!='+' && s[1]!='?' && s[1]!='{')
+				break;
+			if (*s=='\\')
+				s++;
+
+			/* handle ^* at the start of a BRE. */
+			if (!ere && s==ctx->start+1 && s[-1]=='^')
+				break;
+
+			/* extension: multiple consecutive *+?{,} is unspecified,
+			   but (a+)+ has to be supported so accepting a++ makes
+			   sense, note however that the RE_DUP_MAX limit can be
+			   circumvented: (a{255}){255} uses a lot of memory.. */
+			if (*s=='{') {
+				s = parse_dup(s+1, ere, &min, &max);
+				if (!s)
+					return REG_BADBR;
+			} else {
+				min=0;
+				max=-1;
+				if (*s == '+')
+					min = 1;
+				if (*s == '?')
+					max = 1;
+				s++;
+			}
+			if (max == 0)
+				ctx->n = tre_ast_new_literal(ctx->mem, EMPTY, -1, -1);
+			else
+				ctx->n = tre_ast_new_iter(ctx->mem, ctx->n, min, max, 0);
+			if (!ctx->n)
+				return REG_ESPACE;
+		}
+
+		nbranch = tre_ast_new_catenation(ctx->mem, nbranch, ctx->n);
+		if ((ere && *s == '|') ||
+		    (ere && *s == ')' && depth) ||
+		    (!ere && *s == '\\' && s[1] == ')') ||
+		    /* extension: treat \| as alternation in BRE */
+		    (!ere && *s == '\\' && s[1] == '|') ||
+		    !*s) {
+			/* extension: empty branch is unspecified (), (|a), (a|)
+			   here they are not rejected but match on empty string */
+			int c = *s;
+			nunion = tre_ast_new_union(ctx->mem, nunion, nbranch);
+			nbranch = 0;
+
+			if (c == '\\' && s[1] == '|') {
+				s+=2;
+				ctx->start = s;
+			} else if (c == '|') {
+				s++;
+				ctx->start = s;
+			} else {
+				if (c == '\\') {
+					if (!depth) return REG_EPAREN;
+					s+=2;
+				} else if (c == ')')
+					s++;
+				depth--;
+				err = marksub(ctx, nunion, tre_stack_pop_int(stack));
+				if (err != REG_OK)
+					return err;
+				if (!c && depth<0) {
+					ctx->submatch_id = subid;
+					return REG_OK;
+				}
+				if (!c || depth<0)
+					return REG_EPAREN;
+				nbranch = tre_stack_pop_voidptr(stack);
+				nunion = tre_stack_pop_voidptr(stack);
+				goto parse_iter;
+			}
+		}
+	}
+}
+
+
+/***********************************************************************
+ from tre-compile.c
+***********************************************************************/
+
+
+/*
+  TODO:
+   - Fix tre_ast_to_tnfa() to recurse using a stack instead of recursive
+     function calls.
+*/
+
+/*
+  Algorithms to setup tags so that submatch addressing can be done.
+*/
+
+
+/* Inserts a catenation node to the root of the tree given in `node'.
+   As the left child a new tag with number `tag_id' to `node' is added,
+   and the right child is the old root. */
+static reg_errcode_t
+tre_add_tag_left(tre_mem_t mem, tre_ast_node_t *node, int tag_id)
+{
+  tre_catenation_t *c;
+
+  c = tre_mem_alloc(mem, sizeof(*c));
+  if (c == NULL)
+    return REG_ESPACE;
+  c->left = tre_ast_new_literal(mem, TAG, tag_id, -1);
+  if (c->left == NULL)
+    return REG_ESPACE;
+  c->right = tre_mem_alloc(mem, sizeof(tre_ast_node_t));
+  if (c->right == NULL)
+    return REG_ESPACE;
+
+  c->right->obj = node->obj;
+  c->right->type = node->type;
+  c->right->nullable = -1;
+  c->right->submatch_id = -1;
+  c->right->firstpos = NULL;
+  c->right->lastpos = NULL;
+  c->right->num_tags = 0;
+  c->right->num_submatches = 0;
+  node->obj = c;
+  node->type = CATENATION;
+  return REG_OK;
+}
+
+/* Inserts a catenation node to the root of the tree given in `node'.
+   As the right child a new tag with number `tag_id' to `node' is added,
+   and the left child is the old root. */
+static reg_errcode_t
+tre_add_tag_right(tre_mem_t mem, tre_ast_node_t *node, int tag_id)
+{
+  tre_catenation_t *c;
+
+  c = tre_mem_alloc(mem, sizeof(*c));
+  if (c == NULL)
+    return REG_ESPACE;
+  c->right = tre_ast_new_literal(mem, TAG, tag_id, -1);
+  if (c->right == NULL)
+    return REG_ESPACE;
+  c->left = tre_mem_alloc(mem, sizeof(tre_ast_node_t));
+  if (c->left == NULL)
+    return REG_ESPACE;
+
+  c->left->obj = node->obj;
+  c->left->type = node->type;
+  c->left->nullable = -1;
+  c->left->submatch_id = -1;
+  c->left->firstpos = NULL;
+  c->left->lastpos = NULL;
+  c->left->num_tags = 0;
+  c->left->num_submatches = 0;
+  node->obj = c;
+  node->type = CATENATION;
+  return REG_OK;
+}
+
+typedef enum {
+  ADDTAGS_RECURSE,
+  ADDTAGS_AFTER_ITERATION,
+  ADDTAGS_AFTER_UNION_LEFT,
+  ADDTAGS_AFTER_UNION_RIGHT,
+  ADDTAGS_AFTER_CAT_LEFT,
+  ADDTAGS_AFTER_CAT_RIGHT,
+  ADDTAGS_SET_SUBMATCH_END
+} tre_addtags_symbol_t;
+
+
+typedef struct {
+  int tag;
+  int next_tag;
+} tre_tag_states_t;
+
+
+/* Go through `regset' and set submatch data for submatches that are
+   using this tag. */
+static void
+tre_purge_regset(int *regset, tre_tnfa_t *tnfa, int tag)
+{
+  int i;
+
+  for (i = 0; regset[i] >= 0; i++)
+    {
+      int id = regset[i] / 2;
+      int start = !(regset[i] % 2);
+      if (start)
+	tnfa->submatch_data[id].so_tag = tag;
+      else
+	tnfa->submatch_data[id].eo_tag = tag;
+    }
+  regset[0] = -1;
+}
+
+
+/* Adds tags to appropriate locations in the parse tree in `tree', so that
+   subexpressions marked for submatch addressing can be traced. */
+static reg_errcode_t
+tre_add_tags(tre_mem_t mem, tre_stack_t *stack, tre_ast_node_t *tree,
+	     tre_tnfa_t *tnfa)
+{
+  reg_errcode_t status = REG_OK;
+  tre_addtags_symbol_t symbol;
+  tre_ast_node_t *node = tree; /* Tree node we are currently looking at. */
+  int bottom = tre_stack_num_objects(stack);
+  /* True for first pass (counting number of needed tags) */
+  int first_pass = (mem == NULL || tnfa == NULL);
+  int *regset, *orig_regset;
+  int num_tags = 0; /* Total number of tags. */
+  int num_minimals = 0;	 /* Number of special minimal tags. */
+  int tag = 0;	    /* The tag that is to be added next. */
+  int next_tag = 1; /* Next tag to use after this one. */
+  int *parents;	    /* Stack of submatches the current submatch is
+		       contained in. */
+  int minimal_tag = -1; /* Tag that marks the beginning of a minimal match. */
+  tre_tag_states_t *saved_states;
+
+  tre_tag_direction_t direction = TRE_TAG_MINIMIZE;
+  if (!first_pass)
+    {
+      tnfa->end_tag = 0;
+      tnfa->minimal_tags[0] = -1;
+    }
+
+  regset = xmalloc(sizeof(*regset) * ((tnfa->num_submatches + 1) * 2));
+  if (regset == NULL)
+    return REG_ESPACE;
+  regset[0] = -1;
+  orig_regset = regset;
+
+  parents = xmalloc(sizeof(*parents) * (tnfa->num_submatches + 1));
+  if (parents == NULL)
+    {
+      xfree(regset);
+      return REG_ESPACE;
+    }
+  parents[0] = -1;
+
+  saved_states = xmalloc(sizeof(*saved_states) * (tnfa->num_submatches + 1));
+  if (saved_states == NULL)
+    {
+      xfree(regset);
+      xfree(parents);
+      return REG_ESPACE;
+    }
+  else
+    {
+      unsigned int i;
+      for (i = 0; i <= tnfa->num_submatches; i++)
+	saved_states[i].tag = -1;
+    }
+
+  STACK_PUSH(stack, voidptr, node);
+  STACK_PUSH(stack, int, ADDTAGS_RECURSE);
+
+  while (tre_stack_num_objects(stack) > bottom)
+    {
+      if (status != REG_OK)
+	break;
+
+      symbol = (tre_addtags_symbol_t)tre_stack_pop_int(stack);
+      switch (symbol)
+	{
+
+	case ADDTAGS_SET_SUBMATCH_END:
+	  {
+	    int id = tre_stack_pop_int(stack);
+	    int i;
+
+	    /* Add end of this submatch to regset. */
+	    for (i = 0; regset[i] >= 0; i++);
+	    regset[i] = id * 2 + 1;
+	    regset[i + 1] = -1;
+
+	    /* Pop this submatch from the parents stack. */
+	    for (i = 0; parents[i] >= 0; i++);
+	    parents[i - 1] = -1;
+	    break;
+	  }
+
+	case ADDTAGS_RECURSE:
+	  node = tre_stack_pop_voidptr(stack);
+
+	  if (node->submatch_id >= 0)
+	    {
+	      int id = node->submatch_id;
+	      int i;
+
+
+	      /* Add start of this submatch to regset. */
+	      for (i = 0; regset[i] >= 0; i++);
+	      regset[i] = id * 2;
+	      regset[i + 1] = -1;
+
+	      if (!first_pass)
+		{
+		  for (i = 0; parents[i] >= 0; i++);
+		  tnfa->submatch_data[id].parents = NULL;
+		  if (i > 0)
+		    {
+		      int *p = xmalloc(sizeof(*p) * (i + 1));
+		      if (p == NULL)
+			{
+			  status = REG_ESPACE;
+			  break;
+			}
+		      assert(tnfa->submatch_data[id].parents == NULL);
+		      tnfa->submatch_data[id].parents = p;
+		      for (i = 0; parents[i] >= 0; i++)
+			p[i] = parents[i];
+		      p[i] = -1;
+		    }
+		}
+
+	      /* Add end of this submatch to regset after processing this
+		 node. */
+	      STACK_PUSHX(stack, int, node->submatch_id);
+	      STACK_PUSHX(stack, int, ADDTAGS_SET_SUBMATCH_END);
+	    }
+
+	  switch (node->type)
+	    {
+	    case LITERAL:
+	      {
+		tre_literal_t *lit = node->obj;
+
+		if (!IS_SPECIAL(lit) || IS_BACKREF(lit))
+		  {
+		    int i;
+		    if (regset[0] >= 0)
+		      {
+			/* Regset is not empty, so add a tag before the
+			   literal or backref. */
+			if (!first_pass)
+			  {
+			    status = tre_add_tag_left(mem, node, tag);
+			    tnfa->tag_directions[tag] = direction;
+			    if (minimal_tag >= 0)
+			      {
+				for (i = 0; tnfa->minimal_tags[i] >= 0; i++);
+				tnfa->minimal_tags[i] = tag;
+				tnfa->minimal_tags[i + 1] = minimal_tag;
+				tnfa->minimal_tags[i + 2] = -1;
+				minimal_tag = -1;
+				num_minimals++;
+			      }
+			    tre_purge_regset(regset, tnfa, tag);
+			  }
+			else
+			  {
+			    node->num_tags = 1;
+			  }
+
+			regset[0] = -1;
+			tag = next_tag;
+			num_tags++;
+			next_tag++;
+		      }
+		  }
+		else
+		  {
+		    assert(!IS_TAG(lit));
+		  }
+		break;
+	      }
+	    case CATENATION:
+	      {
+		tre_catenation_t *cat = node->obj;
+		tre_ast_node_t *left = cat->left;
+		tre_ast_node_t *right = cat->right;
+		int reserved_tag = -1;
+
+
+		/* After processing right child. */
+		STACK_PUSHX(stack, voidptr, node);
+		STACK_PUSHX(stack, int, ADDTAGS_AFTER_CAT_RIGHT);
+
+		/* Process right child. */
+		STACK_PUSHX(stack, voidptr, right);
+		STACK_PUSHX(stack, int, ADDTAGS_RECURSE);
+
+		/* After processing left child. */
+		STACK_PUSHX(stack, int, next_tag + left->num_tags);
+		if (left->num_tags > 0 && right->num_tags > 0)
+		  {
+		    /* Reserve the next tag to the right child. */
+		    reserved_tag = next_tag;
+		    next_tag++;
+		  }
+		STACK_PUSHX(stack, int, reserved_tag);
+		STACK_PUSHX(stack, int, ADDTAGS_AFTER_CAT_LEFT);
+
+		/* Process left child. */
+		STACK_PUSHX(stack, voidptr, left);
+		STACK_PUSHX(stack, int, ADDTAGS_RECURSE);
+
+		}
+	      break;
+	    case ITERATION:
+	      {
+		tre_iteration_t *iter = node->obj;
+
+		if (first_pass)
+		  {
+		    STACK_PUSHX(stack, int, regset[0] >= 0 || iter->minimal);
+		  }
+		else
+		  {
+		    STACK_PUSHX(stack, int, tag);
+		    STACK_PUSHX(stack, int, iter->minimal);
+		  }
+		STACK_PUSHX(stack, voidptr, node);
+		STACK_PUSHX(stack, int, ADDTAGS_AFTER_ITERATION);
+
+		STACK_PUSHX(stack, voidptr, iter->arg);
+		STACK_PUSHX(stack, int, ADDTAGS_RECURSE);
+
+		/* Regset is not empty, so add a tag here. */
+		if (regset[0] >= 0 || iter->minimal)
+		  {
+		    if (!first_pass)
+		      {
+			int i;
+			status = tre_add_tag_left(mem, node, tag);
+			if (iter->minimal)
+			  tnfa->tag_directions[tag] = TRE_TAG_MAXIMIZE;
+			else
+			  tnfa->tag_directions[tag] = direction;
+			if (minimal_tag >= 0)
+			  {
+			    for (i = 0; tnfa->minimal_tags[i] >= 0; i++);
+			    tnfa->minimal_tags[i] = tag;
+			    tnfa->minimal_tags[i + 1] = minimal_tag;
+			    tnfa->minimal_tags[i + 2] = -1;
+			    minimal_tag = -1;
+			    num_minimals++;
+			  }
+			tre_purge_regset(regset, tnfa, tag);
+		      }
+
+		    regset[0] = -1;
+		    tag = next_tag;
+		    num_tags++;
+		    next_tag++;
+		  }
+		direction = TRE_TAG_MINIMIZE;
+	      }
+	      break;
+	    case UNION:
+	      {
+		tre_union_t *uni = node->obj;
+		tre_ast_node_t *left = uni->left;
+		tre_ast_node_t *right = uni->right;
+		int left_tag;
+		int right_tag;
+
+		if (regset[0] >= 0)
+		  {
+		    left_tag = next_tag;
+		    right_tag = next_tag + 1;
+		  }
+		else
+		  {
+		    left_tag = tag;
+		    right_tag = next_tag;
+		  }
+
+		/* After processing right child. */
+		STACK_PUSHX(stack, int, right_tag);
+		STACK_PUSHX(stack, int, left_tag);
+		STACK_PUSHX(stack, voidptr, regset);
+		STACK_PUSHX(stack, int, regset[0] >= 0);
+		STACK_PUSHX(stack, voidptr, node);
+		STACK_PUSHX(stack, voidptr, right);
+		STACK_PUSHX(stack, voidptr, left);
+		STACK_PUSHX(stack, int, ADDTAGS_AFTER_UNION_RIGHT);
+
+		/* Process right child. */
+		STACK_PUSHX(stack, voidptr, right);
+		STACK_PUSHX(stack, int, ADDTAGS_RECURSE);
+
+		/* After processing left child. */
+		STACK_PUSHX(stack, int, ADDTAGS_AFTER_UNION_LEFT);
+
+		/* Process left child. */
+		STACK_PUSHX(stack, voidptr, left);
+		STACK_PUSHX(stack, int, ADDTAGS_RECURSE);
+
+		/* Regset is not empty, so add a tag here. */
+		if (regset[0] >= 0)
+		  {
+		    if (!first_pass)
+		      {
+			int i;
+			status = tre_add_tag_left(mem, node, tag);
+			tnfa->tag_directions[tag] = direction;
+			if (minimal_tag >= 0)
+			  {
+			    for (i = 0; tnfa->minimal_tags[i] >= 0; i++);
+			    tnfa->minimal_tags[i] = tag;
+			    tnfa->minimal_tags[i + 1] = minimal_tag;
+			    tnfa->minimal_tags[i + 2] = -1;
+			    minimal_tag = -1;
+			    num_minimals++;
+			  }
+			tre_purge_regset(regset, tnfa, tag);
+		      }
+
+		    regset[0] = -1;
+		    tag = next_tag;
+		    num_tags++;
+		    next_tag++;
+		  }
+
+		if (node->num_submatches > 0)
+		  {
+		    /* The next two tags are reserved for markers. */
+		    next_tag++;
+		    tag = next_tag;
+		    next_tag++;
+		  }
+
+		break;
+	      }
+	    }
+
+	  if (node->submatch_id >= 0)
+	    {
+	      int i;
+	      /* Push this submatch on the parents stack. */
+	      for (i = 0; parents[i] >= 0; i++);
+	      parents[i] = node->submatch_id;
+	      parents[i + 1] = -1;
+	    }
+
+	  break; /* end case: ADDTAGS_RECURSE */
+
+	case ADDTAGS_AFTER_ITERATION:
+	  {
+	    int minimal = 0;
+	    int enter_tag;
+	    node = tre_stack_pop_voidptr(stack);
+	    if (first_pass)
+	      {
+		node->num_tags = ((tre_iteration_t *)node->obj)->arg->num_tags
+		  + tre_stack_pop_int(stack);
+		minimal_tag = -1;
+	      }
+	    else
+	      {
+		minimal = tre_stack_pop_int(stack);
+		enter_tag = tre_stack_pop_int(stack);
+		if (minimal)
+		  minimal_tag = enter_tag;
+	      }
+
+	    if (!first_pass)
+	      {
+		if (minimal)
+		  direction = TRE_TAG_MINIMIZE;
+		else
+		  direction = TRE_TAG_MAXIMIZE;
+	      }
+	    break;
+	  }
+
+	case ADDTAGS_AFTER_CAT_LEFT:
+	  {
+	    int new_tag = tre_stack_pop_int(stack);
+	    next_tag = tre_stack_pop_int(stack);
+	    if (new_tag >= 0)
+	      {
+		tag = new_tag;
+	      }
+	    break;
+	  }
+
+	case ADDTAGS_AFTER_CAT_RIGHT:
+	  node = tre_stack_pop_voidptr(stack);
+	  if (first_pass)
+	    node->num_tags = ((tre_catenation_t *)node->obj)->left->num_tags
+	      + ((tre_catenation_t *)node->obj)->right->num_tags;
+	  break;
+
+	case ADDTAGS_AFTER_UNION_LEFT:
+	  /* Lift the bottom of the `regset' array so that when processing
+	     the right operand the items currently in the array are
+	     invisible.	 The original bottom was saved at ADDTAGS_UNION and
+	     will be restored at ADDTAGS_AFTER_UNION_RIGHT below. */
+	  while (*regset >= 0)
+	    regset++;
+	  break;
+
+	case ADDTAGS_AFTER_UNION_RIGHT:
+	  {
+	    int added_tags, tag_left, tag_right;
+	    tre_ast_node_t *left = tre_stack_pop_voidptr(stack);
+	    tre_ast_node_t *right = tre_stack_pop_voidptr(stack);
+	    node = tre_stack_pop_voidptr(stack);
+	    added_tags = tre_stack_pop_int(stack);
+	    if (first_pass)
+	      {
+		node->num_tags = ((tre_union_t *)node->obj)->left->num_tags
+		  + ((tre_union_t *)node->obj)->right->num_tags + added_tags
+		  + ((node->num_submatches > 0) ? 2 : 0);
+	      }
+	    regset = tre_stack_pop_voidptr(stack);
+	    tag_left = tre_stack_pop_int(stack);
+	    tag_right = tre_stack_pop_int(stack);
+
+	    /* Add tags after both children, the left child gets a smaller
+	       tag than the right child.  This guarantees that we prefer
+	       the left child over the right child. */
+	    /* XXX - This is not always necessary (if the children have
+	       tags which must be seen for every match of that child). */
+	    /* XXX - Check if this is the only place where tre_add_tag_right
+	       is used.	 If so, use tre_add_tag_left (putting the tag before
+	       the child as opposed after the child) and throw away
+	       tre_add_tag_right. */
+	    if (node->num_submatches > 0)
+	      {
+		if (!first_pass)
+		  {
+		    status = tre_add_tag_right(mem, left, tag_left);
+		    tnfa->tag_directions[tag_left] = TRE_TAG_MAXIMIZE;
+		    if (status == REG_OK)
+		      status = tre_add_tag_right(mem, right, tag_right);
+		    tnfa->tag_directions[tag_right] = TRE_TAG_MAXIMIZE;
+		  }
+		num_tags += 2;
+	      }
+	    direction = TRE_TAG_MAXIMIZE;
+	    break;
+	  }
+
+	default:
+	  assert(0);
+	  break;
+
+	} /* end switch(symbol) */
+    } /* end while(tre_stack_num_objects(stack) > bottom) */
+
+  if (!first_pass)
+    tre_purge_regset(regset, tnfa, tag);
+
+  if (!first_pass && minimal_tag >= 0)
+    {
+      int i;
+      for (i = 0; tnfa->minimal_tags[i] >= 0; i++);
+      tnfa->minimal_tags[i] = tag;
+      tnfa->minimal_tags[i + 1] = minimal_tag;
+      tnfa->minimal_tags[i + 2] = -1;
+      minimal_tag = -1;
+      num_minimals++;
+    }
+
+  assert(tree->num_tags == num_tags);
+  tnfa->end_tag = num_tags;
+  tnfa->num_tags = num_tags;
+  tnfa->num_minimals = num_minimals;
+  xfree(orig_regset);
+  xfree(parents);
+  xfree(saved_states);
+  return status;
+}
+
+
+
+/*
+  AST to TNFA compilation routines.
+*/
+
+typedef enum {
+  COPY_RECURSE,
+  COPY_SET_RESULT_PTR
+} tre_copyast_symbol_t;
+
+/* Flags for tre_copy_ast(). */
+#define COPY_REMOVE_TAGS	 1
+#define COPY_MAXIMIZE_FIRST_TAG	 2
+
+static reg_errcode_t
+tre_copy_ast(tre_mem_t mem, tre_stack_t *stack, tre_ast_node_t *ast,
+	     int flags, int *pos_add, tre_tag_direction_t *tag_directions,
+	     tre_ast_node_t **copy, int *max_pos)
+{
+  reg_errcode_t status = REG_OK;
+  int bottom = tre_stack_num_objects(stack);
+  int num_copied = 0;
+  int first_tag = 1;
+  tre_ast_node_t **result = copy;
+  tre_copyast_symbol_t symbol;
+
+  STACK_PUSH(stack, voidptr, ast);
+  STACK_PUSH(stack, int, COPY_RECURSE);
+
+  while (status == REG_OK && tre_stack_num_objects(stack) > bottom)
+    {
+      tre_ast_node_t *node;
+      if (status != REG_OK)
+	break;
+
+      symbol = (tre_copyast_symbol_t)tre_stack_pop_int(stack);
+      switch (symbol)
+	{
+	case COPY_SET_RESULT_PTR:
+	  result = tre_stack_pop_voidptr(stack);
+	  break;
+	case COPY_RECURSE:
+	  node = tre_stack_pop_voidptr(stack);
+	  switch (node->type)
+	    {
+	    case LITERAL:
+	      {
+		tre_literal_t *lit = node->obj;
+		int pos = lit->position;
+		int min = lit->code_min;
+		int max = lit->code_max;
+		if (!IS_SPECIAL(lit) || IS_BACKREF(lit))
+		  {
+		    /* XXX - e.g. [ab] has only one position but two
+		       nodes, so we are creating holes in the state space
+		       here.  Not fatal, just wastes memory. */
+		    pos += *pos_add;
+		    num_copied++;
+		  }
+		else if (IS_TAG(lit) && (flags & COPY_REMOVE_TAGS))
+		  {
+		    /* Change this tag to empty. */
+		    min = EMPTY;
+		    max = pos = -1;
+		  }
+		else if (IS_TAG(lit) && (flags & COPY_MAXIMIZE_FIRST_TAG)
+			 && first_tag)
+		  {
+		    /* Maximize the first tag. */
+		    tag_directions[max] = TRE_TAG_MAXIMIZE;
+		    first_tag = 0;
+		  }
+		*result = tre_ast_new_literal(mem, min, max, pos);
+		if (*result == NULL)
+		  status = REG_ESPACE;
+		else {
+		  tre_literal_t *p = (*result)->obj;
+		  p->class = lit->class;
+		  p->neg_classes = lit->neg_classes;
+		}
+
+		if (pos > *max_pos)
+		  *max_pos = pos;
+		break;
+	      }
+	    case UNION:
+	      {
+		tre_union_t *uni = node->obj;
+		tre_union_t *tmp;
+		*result = tre_ast_new_union(mem, uni->left, uni->right);
+		if (*result == NULL)
+		  {
+		    status = REG_ESPACE;
+		    break;
+		  }
+		tmp = (*result)->obj;
+		result = &tmp->left;
+		STACK_PUSHX(stack, voidptr, uni->right);
+		STACK_PUSHX(stack, int, COPY_RECURSE);
+		STACK_PUSHX(stack, voidptr, &tmp->right);
+		STACK_PUSHX(stack, int, COPY_SET_RESULT_PTR);
+		STACK_PUSHX(stack, voidptr, uni->left);
+		STACK_PUSHX(stack, int, COPY_RECURSE);
+		break;
+	      }
+	    case CATENATION:
+	      {
+		tre_catenation_t *cat = node->obj;
+		tre_catenation_t *tmp;
+		*result = tre_ast_new_catenation(mem, cat->left, cat->right);
+		if (*result == NULL)
+		  {
+		    status = REG_ESPACE;
+		    break;
+		  }
+		tmp = (*result)->obj;
+		tmp->left = NULL;
+		tmp->right = NULL;
+		result = &tmp->left;
+
+		STACK_PUSHX(stack, voidptr, cat->right);
+		STACK_PUSHX(stack, int, COPY_RECURSE);
+		STACK_PUSHX(stack, voidptr, &tmp->right);
+		STACK_PUSHX(stack, int, COPY_SET_RESULT_PTR);
+		STACK_PUSHX(stack, voidptr, cat->left);
+		STACK_PUSHX(stack, int, COPY_RECURSE);
+		break;
+	      }
+	    case ITERATION:
+	      {
+		tre_iteration_t *iter = node->obj;
+		STACK_PUSHX(stack, voidptr, iter->arg);
+		STACK_PUSHX(stack, int, COPY_RECURSE);
+		*result = tre_ast_new_iter(mem, iter->arg, iter->min,
+					   iter->max, iter->minimal);
+		if (*result == NULL)
+		  {
+		    status = REG_ESPACE;
+		    break;
+		  }
+		iter = (*result)->obj;
+		result = &iter->arg;
+		break;
+	      }
+	    default:
+	      assert(0);
+	      break;
+	    }
+	  break;
+	}
+    }
+  *pos_add += num_copied;
+  return status;
+}
+
+typedef enum {
+  EXPAND_RECURSE,
+  EXPAND_AFTER_ITER
+} tre_expand_ast_symbol_t;
+
+/* Expands each iteration node that has a finite nonzero minimum or maximum
+   iteration count to a catenated sequence of copies of the node. */
+static reg_errcode_t
+tre_expand_ast(tre_mem_t mem, tre_stack_t *stack, tre_ast_node_t *ast,
+	       int *position, tre_tag_direction_t *tag_directions)
+{
+  reg_errcode_t status = REG_OK;
+  int bottom = tre_stack_num_objects(stack);
+  int pos_add = 0;
+  int pos_add_total = 0;
+  int max_pos = 0;
+  int iter_depth = 0;
+
+  STACK_PUSHR(stack, voidptr, ast);
+  STACK_PUSHR(stack, int, EXPAND_RECURSE);
+  while (status == REG_OK && tre_stack_num_objects(stack) > bottom)
+    {
+      tre_ast_node_t *node;
+      tre_expand_ast_symbol_t symbol;
+
+      if (status != REG_OK)
+	break;
+
+      symbol = (tre_expand_ast_symbol_t)tre_stack_pop_int(stack);
+      node = tre_stack_pop_voidptr(stack);
+      switch (symbol)
+	{
+	case EXPAND_RECURSE:
+	  switch (node->type)
+	    {
+	    case LITERAL:
+	      {
+		tre_literal_t *lit= node->obj;
+		if (!IS_SPECIAL(lit) || IS_BACKREF(lit))
+		  {
+		    lit->position += pos_add;
+		    if (lit->position > max_pos)
+		      max_pos = lit->position;
+		  }
+		break;
+	      }
+	    case UNION:
+	      {
+		tre_union_t *uni = node->obj;
+		STACK_PUSHX(stack, voidptr, uni->right);
+		STACK_PUSHX(stack, int, EXPAND_RECURSE);
+		STACK_PUSHX(stack, voidptr, uni->left);
+		STACK_PUSHX(stack, int, EXPAND_RECURSE);
+		break;
+	      }
+	    case CATENATION:
+	      {
+		tre_catenation_t *cat = node->obj;
+		STACK_PUSHX(stack, voidptr, cat->right);
+		STACK_PUSHX(stack, int, EXPAND_RECURSE);
+		STACK_PUSHX(stack, voidptr, cat->left);
+		STACK_PUSHX(stack, int, EXPAND_RECURSE);
+		break;
+	      }
+	    case ITERATION:
+	      {
+		tre_iteration_t *iter = node->obj;
+		STACK_PUSHX(stack, int, pos_add);
+		STACK_PUSHX(stack, voidptr, node);
+		STACK_PUSHX(stack, int, EXPAND_AFTER_ITER);
+		STACK_PUSHX(stack, voidptr, iter->arg);
+		STACK_PUSHX(stack, int, EXPAND_RECURSE);
+		/* If we are going to expand this node at EXPAND_AFTER_ITER
+		   then don't increase the `pos' fields of the nodes now, it
+		   will get done when expanding. */
+		if (iter->min > 1 || iter->max > 1)
+		  pos_add = 0;
+		iter_depth++;
+		break;
+	      }
+	    default:
+	      assert(0);
+	      break;
+	    }
+	  break;
+	case EXPAND_AFTER_ITER:
+	  {
+	    tre_iteration_t *iter = node->obj;
+	    int pos_add_last;
+	    pos_add = tre_stack_pop_int(stack);
+	    pos_add_last = pos_add;
+	    if (iter->min > 1 || iter->max > 1)
+	      {
+		tre_ast_node_t *seq1 = NULL, *seq2 = NULL;
+		int j;
+		int pos_add_save = pos_add;
+
+		/* Create a catenated sequence of copies of the node. */
+		for (j = 0; j < iter->min; j++)
+		  {
+		    tre_ast_node_t *copy;
+		    /* Remove tags from all but the last copy. */
+		    int flags = ((j + 1 < iter->min)
+				 ? COPY_REMOVE_TAGS
+				 : COPY_MAXIMIZE_FIRST_TAG);
+		    pos_add_save = pos_add;
+		    status = tre_copy_ast(mem, stack, iter->arg, flags,
+					  &pos_add, tag_directions, &copy,
+					  &max_pos);
+		    if (status != REG_OK)
+		      return status;
+		    if (seq1 != NULL)
+		      seq1 = tre_ast_new_catenation(mem, seq1, copy);
+		    else
+		      seq1 = copy;
+		    if (seq1 == NULL)
+		      return REG_ESPACE;
+		  }
+
+		if (iter->max == -1)
+		  {
+		    /* No upper limit. */
+		    pos_add_save = pos_add;
+		    status = tre_copy_ast(mem, stack, iter->arg, 0,
+					  &pos_add, NULL, &seq2, &max_pos);
+		    if (status != REG_OK)
+		      return status;
+		    seq2 = tre_ast_new_iter(mem, seq2, 0, -1, 0);
+		    if (seq2 == NULL)
+		      return REG_ESPACE;
+		  }
+		else
+		  {
+		    for (j = iter->min; j < iter->max; j++)
+		      {
+			tre_ast_node_t *tmp, *copy;
+			pos_add_save = pos_add;
+			status = tre_copy_ast(mem, stack, iter->arg, 0,
+					      &pos_add, NULL, &copy, &max_pos);
+			if (status != REG_OK)
+			  return status;
+			if (seq2 != NULL)
+			  seq2 = tre_ast_new_catenation(mem, copy, seq2);
+			else
+			  seq2 = copy;
+			if (seq2 == NULL)
+			  return REG_ESPACE;
+			tmp = tre_ast_new_literal(mem, EMPTY, -1, -1);
+			if (tmp == NULL)
+			  return REG_ESPACE;
+			seq2 = tre_ast_new_union(mem, tmp, seq2);
+			if (seq2 == NULL)
+			  return REG_ESPACE;
+		      }
+		  }
+
+		pos_add = pos_add_save;
+		if (seq1 == NULL)
+		  seq1 = seq2;
+		else if (seq2 != NULL)
+		  seq1 = tre_ast_new_catenation(mem, seq1, seq2);
+		if (seq1 == NULL)
+		  return REG_ESPACE;
+		node->obj = seq1->obj;
+		node->type = seq1->type;
+	      }
+
+	    iter_depth--;
+	    pos_add_total += pos_add - pos_add_last;
+	    if (iter_depth == 0)
+	      pos_add = pos_add_total;
+
+	    break;
+	  }
+	default:
+	  assert(0);
+	  break;
+	}
+    }
+
+  *position += pos_add_total;
+
+  /* `max_pos' should never be larger than `*position' if the above
+     code works, but just an extra safeguard let's make sure
+     `*position' is set large enough so enough memory will be
+     allocated for the transition table. */
+  if (max_pos > *position)
+    *position = max_pos;
+
+  return status;
+}
+
+static tre_pos_and_tags_t *
+tre_set_empty(tre_mem_t mem)
+{
+  tre_pos_and_tags_t *new_set;
+
+  new_set = tre_mem_calloc(mem, sizeof(*new_set));
+  if (new_set == NULL)
+    return NULL;
+
+  new_set[0].position = -1;
+  new_set[0].code_min = -1;
+  new_set[0].code_max = -1;
+
+  return new_set;
+}
+
+static tre_pos_and_tags_t *
+tre_set_one(tre_mem_t mem, int position, int code_min, int code_max,
+	    tre_ctype_t class, tre_ctype_t *neg_classes, int backref)
+{
+  tre_pos_and_tags_t *new_set;
+
+  new_set = tre_mem_calloc(mem, sizeof(*new_set) * 2);
+  if (new_set == NULL)
+    return NULL;
+
+  new_set[0].position = position;
+  new_set[0].code_min = code_min;
+  new_set[0].code_max = code_max;
+  new_set[0].class = class;
+  new_set[0].neg_classes = neg_classes;
+  new_set[0].backref = backref;
+  new_set[1].position = -1;
+  new_set[1].code_min = -1;
+  new_set[1].code_max = -1;
+
+  return new_set;
+}
+
+static tre_pos_and_tags_t *
+tre_set_union(tre_mem_t mem, tre_pos_and_tags_t *set1, tre_pos_and_tags_t *set2,
+	      int *tags, int assertions)
+{
+  int s1, s2, i, j;
+  tre_pos_and_tags_t *new_set;
+  int *new_tags;
+  int num_tags;
+
+  for (num_tags = 0; tags != NULL && tags[num_tags] >= 0; num_tags++);
+  for (s1 = 0; set1[s1].position >= 0; s1++);
+  for (s2 = 0; set2[s2].position >= 0; s2++);
+  new_set = tre_mem_calloc(mem, sizeof(*new_set) * (s1 + s2 + 1));
+  if (!new_set )
+    return NULL;
+
+  for (s1 = 0; set1[s1].position >= 0; s1++)
+    {
+      new_set[s1].position = set1[s1].position;
+      new_set[s1].code_min = set1[s1].code_min;
+      new_set[s1].code_max = set1[s1].code_max;
+      new_set[s1].assertions = set1[s1].assertions | assertions;
+      new_set[s1].class = set1[s1].class;
+      new_set[s1].neg_classes = set1[s1].neg_classes;
+      new_set[s1].backref = set1[s1].backref;
+      if (set1[s1].tags == NULL && tags == NULL)
+	new_set[s1].tags = NULL;
+      else
+	{
+	  for (i = 0; set1[s1].tags != NULL && set1[s1].tags[i] >= 0; i++);
+	  new_tags = tre_mem_alloc(mem, (sizeof(*new_tags)
+					 * (i + num_tags + 1)));
+	  if (new_tags == NULL)
+	    return NULL;
+	  for (j = 0; j < i; j++)
+	    new_tags[j] = set1[s1].tags[j];
+	  for (i = 0; i < num_tags; i++)
+	    new_tags[j + i] = tags[i];
+	  new_tags[j + i] = -1;
+	  new_set[s1].tags = new_tags;
+	}
+    }
+
+  for (s2 = 0; set2[s2].position >= 0; s2++)
+    {
+      new_set[s1 + s2].position = set2[s2].position;
+      new_set[s1 + s2].code_min = set2[s2].code_min;
+      new_set[s1 + s2].code_max = set2[s2].code_max;
+      /* XXX - why not | assertions here as well? */
+      new_set[s1 + s2].assertions = set2[s2].assertions;
+      new_set[s1 + s2].class = set2[s2].class;
+      new_set[s1 + s2].neg_classes = set2[s2].neg_classes;
+      new_set[s1 + s2].backref = set2[s2].backref;
+      if (set2[s2].tags == NULL)
+	new_set[s1 + s2].tags = NULL;
+      else
+	{
+	  for (i = 0; set2[s2].tags[i] >= 0; i++);
+	  new_tags = tre_mem_alloc(mem, sizeof(*new_tags) * (i + 1));
+	  if (new_tags == NULL)
+	    return NULL;
+	  for (j = 0; j < i; j++)
+	    new_tags[j] = set2[s2].tags[j];
+	  new_tags[j] = -1;
+	  new_set[s1 + s2].tags = new_tags;
+	}
+    }
+  new_set[s1 + s2].position = -1;
+  return new_set;
+}
+
+/* Finds the empty path through `node' which is the one that should be
+   taken according to POSIX.2 rules, and adds the tags on that path to
+   `tags'.   `tags' may be NULL.  If `num_tags_seen' is not NULL, it is
+   set to the number of tags seen on the path. */
+static reg_errcode_t
+tre_match_empty(tre_stack_t *stack, tre_ast_node_t *node, int *tags,
+		int *assertions, int *num_tags_seen)
+{
+  tre_literal_t *lit;
+  tre_union_t *uni;
+  tre_catenation_t *cat;
+  tre_iteration_t *iter;
+  int i;
+  int bottom = tre_stack_num_objects(stack);
+  reg_errcode_t status = REG_OK;
+  if (num_tags_seen)
+    *num_tags_seen = 0;
+
+  status = tre_stack_push_voidptr(stack, node);
+
+  /* Walk through the tree recursively. */
+  while (status == REG_OK && tre_stack_num_objects(stack) > bottom)
+    {
+      node = tre_stack_pop_voidptr(stack);
+
+      switch (node->type)
+	{
+	case LITERAL:
+	  lit = (tre_literal_t *)node->obj;
+	  switch (lit->code_min)
+	    {
+	    case TAG:
+	      if (lit->code_max >= 0)
+		{
+		  if (tags != NULL)
+		    {
+		      /* Add the tag to `tags'. */
+		      for (i = 0; tags[i] >= 0; i++)
+			if (tags[i] == lit->code_max)
+			  break;
+		      if (tags[i] < 0)
+			{
+			  tags[i] = lit->code_max;
+			  tags[i + 1] = -1;
+			}
+		    }
+		  if (num_tags_seen)
+		    (*num_tags_seen)++;
+		}
+	      break;
+	    case ASSERTION:
+	      assert(lit->code_max >= 1
+		     || lit->code_max <= ASSERT_LAST);
+	      if (assertions != NULL)
+		*assertions |= lit->code_max;
+	      break;
+	    case EMPTY:
+	      break;
+	    default:
+	      assert(0);
+	      break;
+	    }
+	  break;
+
+	case UNION:
+	  /* Subexpressions starting earlier take priority over ones
+	     starting later, so we prefer the left subexpression over the
+	     right subexpression. */
+	  uni = (tre_union_t *)node->obj;
+	  if (uni->left->nullable)
+	    STACK_PUSHX(stack, voidptr, uni->left)
+	  else if (uni->right->nullable)
+	    STACK_PUSHX(stack, voidptr, uni->right)
+	  else
+	    assert(0);
+	  break;
+
+	case CATENATION:
+	  /* The path must go through both children. */
+	  cat = (tre_catenation_t *)node->obj;
+	  assert(cat->left->nullable);
+	  assert(cat->right->nullable);
+	  STACK_PUSHX(stack, voidptr, cat->left);
+	  STACK_PUSHX(stack, voidptr, cat->right);
+	  break;
+
+	case ITERATION:
+	  /* A match with an empty string is preferred over no match at
+	     all, so we go through the argument if possible. */
+	  iter = (tre_iteration_t *)node->obj;
+	  if (iter->arg->nullable)
+	    STACK_PUSHX(stack, voidptr, iter->arg);
+	  break;
+
+	default:
+	  assert(0);
+	  break;
+	}
+    }
+
+  return status;
+}
+
+
+typedef enum {
+  NFL_RECURSE,
+  NFL_POST_UNION,
+  NFL_POST_CATENATION,
+  NFL_POST_ITERATION
+} tre_nfl_stack_symbol_t;
+
+
+/* Computes and fills in the fields `nullable', `firstpos', and `lastpos' for
+   the nodes of the AST `tree'. */
+static reg_errcode_t
+tre_compute_nfl(tre_mem_t mem, tre_stack_t *stack, tre_ast_node_t *tree)
+{
+  int bottom = tre_stack_num_objects(stack);
+
+  STACK_PUSHR(stack, voidptr, tree);
+  STACK_PUSHR(stack, int, NFL_RECURSE);
+
+  while (tre_stack_num_objects(stack) > bottom)
+    {
+      tre_nfl_stack_symbol_t symbol;
+      tre_ast_node_t *node;
+
+      symbol = (tre_nfl_stack_symbol_t)tre_stack_pop_int(stack);
+      node = tre_stack_pop_voidptr(stack);
+      switch (symbol)
+	{
+	case NFL_RECURSE:
+	  switch (node->type)
+	    {
+	    case LITERAL:
+	      {
+		tre_literal_t *lit = (tre_literal_t *)node->obj;
+		if (IS_BACKREF(lit))
+		  {
+		    /* Back references: nullable = false, firstpos = {i},
+		       lastpos = {i}. */
+		    node->nullable = 0;
+		    node->firstpos = tre_set_one(mem, lit->position, 0,
+					     TRE_CHAR_MAX, 0, NULL, -1);
+		    if (!node->firstpos)
+		      return REG_ESPACE;
+		    node->lastpos = tre_set_one(mem, lit->position, 0,
+						TRE_CHAR_MAX, 0, NULL,
+						(int)lit->code_max);
+		    if (!node->lastpos)
+		      return REG_ESPACE;
+		  }
+		else if (lit->code_min < 0)
+		  {
+		    /* Tags, empty strings, params, and zero width assertions:
+		       nullable = true, firstpos = {}, and lastpos = {}. */
+		    node->nullable = 1;
+		    node->firstpos = tre_set_empty(mem);
+		    if (!node->firstpos)
+		      return REG_ESPACE;
+		    node->lastpos = tre_set_empty(mem);
+		    if (!node->lastpos)
+		      return REG_ESPACE;
+		  }
+		else
+		  {
+		    /* Literal at position i: nullable = false, firstpos = {i},
+		       lastpos = {i}. */
+		    node->nullable = 0;
+		    node->firstpos =
+		      tre_set_one(mem, lit->position, (int)lit->code_min,
+				  (int)lit->code_max, 0, NULL, -1);
+		    if (!node->firstpos)
+		      return REG_ESPACE;
+		    node->lastpos = tre_set_one(mem, lit->position,
+						(int)lit->code_min,
+						(int)lit->code_max,
+						lit->class, lit->neg_classes,
+						-1);
+		    if (!node->lastpos)
+		      return REG_ESPACE;
+		  }
+		break;
+	      }
+
+	    case UNION:
+	      /* Compute the attributes for the two subtrees, and after that
+		 for this node. */
+	      STACK_PUSHR(stack, voidptr, node);
+	      STACK_PUSHR(stack, int, NFL_POST_UNION);
+	      STACK_PUSHR(stack, voidptr, ((tre_union_t *)node->obj)->right);
+	      STACK_PUSHR(stack, int, NFL_RECURSE);
+	      STACK_PUSHR(stack, voidptr, ((tre_union_t *)node->obj)->left);
+	      STACK_PUSHR(stack, int, NFL_RECURSE);
+	      break;
+
+	    case CATENATION:
+	      /* Compute the attributes for the two subtrees, and after that
+		 for this node. */
+	      STACK_PUSHR(stack, voidptr, node);
+	      STACK_PUSHR(stack, int, NFL_POST_CATENATION);
+	      STACK_PUSHR(stack, voidptr, ((tre_catenation_t *)node->obj)->right);
+	      STACK_PUSHR(stack, int, NFL_RECURSE);
+	      STACK_PUSHR(stack, voidptr, ((tre_catenation_t *)node->obj)->left);
+	      STACK_PUSHR(stack, int, NFL_RECURSE);
+	      break;
+
+	    case ITERATION:
+	      /* Compute the attributes for the subtree, and after that for
+		 this node. */
+	      STACK_PUSHR(stack, voidptr, node);
+	      STACK_PUSHR(stack, int, NFL_POST_ITERATION);
+	      STACK_PUSHR(stack, voidptr, ((tre_iteration_t *)node->obj)->arg);
+	      STACK_PUSHR(stack, int, NFL_RECURSE);
+	      break;
+	    }
+	  break; /* end case: NFL_RECURSE */
+
+	case NFL_POST_UNION:
+	  {
+	    tre_union_t *uni = (tre_union_t *)node->obj;
+	    node->nullable = uni->left->nullable || uni->right->nullable;
+	    node->firstpos = tre_set_union(mem, uni->left->firstpos,
+					   uni->right->firstpos, NULL, 0);
+	    if (!node->firstpos)
+	      return REG_ESPACE;
+	    node->lastpos = tre_set_union(mem, uni->left->lastpos,
+					  uni->right->lastpos, NULL, 0);
+	    if (!node->lastpos)
+	      return REG_ESPACE;
+	    break;
+	  }
+
+	case NFL_POST_ITERATION:
+	  {
+	    tre_iteration_t *iter = (tre_iteration_t *)node->obj;
+
+	    if (iter->min == 0 || iter->arg->nullable)
+	      node->nullable = 1;
+	    else
+	      node->nullable = 0;
+	    node->firstpos = iter->arg->firstpos;
+	    node->lastpos = iter->arg->lastpos;
+	    break;
+	  }
+
+	case NFL_POST_CATENATION:
+	  {
+	    int num_tags, *tags, assertions;
+	    reg_errcode_t status;
+	    tre_catenation_t *cat = node->obj;
+	    node->nullable = cat->left->nullable && cat->right->nullable;
+
+	    /* Compute firstpos. */
+	    if (cat->left->nullable)
+	      {
+		/* The left side matches the empty string.  Make a first pass
+		   with tre_match_empty() to get the number of tags and
+		   parameters. */
+		status = tre_match_empty(stack, cat->left,
+					 NULL, NULL, &num_tags);
+		if (status != REG_OK)
+		  return status;
+		/* Allocate arrays for the tags and parameters. */
+		tags = xmalloc(sizeof(*tags) * (num_tags + 1));
+		if (!tags)
+		  return REG_ESPACE;
+		tags[0] = -1;
+		assertions = 0;
+		/* Second pass with tre_mach_empty() to get the list of
+		   tags and parameters. */
+		status = tre_match_empty(stack, cat->left, tags,
+					 &assertions, NULL);
+		if (status != REG_OK)
+		  {
+		    xfree(tags);
+		    return status;
+		  }
+		node->firstpos =
+		  tre_set_union(mem, cat->right->firstpos, cat->left->firstpos,
+				tags, assertions);
+		xfree(tags);
+		if (!node->firstpos)
+		  return REG_ESPACE;
+	      }
+	    else
+	      {
+		node->firstpos = cat->left->firstpos;
+	      }
+
+	    /* Compute lastpos. */
+	    if (cat->right->nullable)
+	      {
+		/* The right side matches the empty string.  Make a first pass
+		   with tre_match_empty() to get the number of tags and
+		   parameters. */
+		status = tre_match_empty(stack, cat->right,
+					 NULL, NULL, &num_tags);
+		if (status != REG_OK)
+		  return status;
+		/* Allocate arrays for the tags and parameters. */
+		tags = xmalloc(sizeof(int) * (num_tags + 1));
+		if (!tags)
+		  return REG_ESPACE;
+		tags[0] = -1;
+		assertions = 0;
+		/* Second pass with tre_mach_empty() to get the list of
+		   tags and parameters. */
+		status = tre_match_empty(stack, cat->right, tags,
+					 &assertions, NULL);
+		if (status != REG_OK)
+		  {
+		    xfree(tags);
+		    return status;
+		  }
+		node->lastpos =
+		  tre_set_union(mem, cat->left->lastpos, cat->right->lastpos,
+				tags, assertions);
+		xfree(tags);
+		if (!node->lastpos)
+		  return REG_ESPACE;
+	      }
+	    else
+	      {
+		node->lastpos = cat->right->lastpos;
+	      }
+	    break;
+	  }
+
+	default:
+	  assert(0);
+	  break;
+	}
+    }
+
+  return REG_OK;
+}
+
+
+/* Adds a transition from each position in `p1' to each position in `p2'. */
+static reg_errcode_t
+tre_make_trans(tre_pos_and_tags_t *p1, tre_pos_and_tags_t *p2,
+	       tre_tnfa_transition_t *transitions,
+	       int *counts, int *offs)
+{
+  tre_pos_and_tags_t *orig_p2 = p2;
+  tre_tnfa_transition_t *trans;
+  int i, j, k, l, dup, prev_p2_pos;
+
+  if (transitions != NULL)
+    while (p1->position >= 0)
+      {
+	p2 = orig_p2;
+	prev_p2_pos = -1;
+	while (p2->position >= 0)
+	  {
+	    /* Optimization: if this position was already handled, skip it. */
+	    if (p2->position == prev_p2_pos)
+	      {
+		p2++;
+		continue;
+	      }
+	    prev_p2_pos = p2->position;
+	    /* Set `trans' to point to the next unused transition from
+	       position `p1->position'. */
+	    trans = transitions + offs[p1->position];
+	    while (trans->state != NULL)
+	      {
+#if 0
+		/* If we find a previous transition from `p1->position' to
+		   `p2->position', it is overwritten.  This can happen only
+		   if there are nested loops in the regexp, like in "((a)*)*".
+		   In POSIX.2 repetition using the outer loop is always
+		   preferred over using the inner loop.	 Therefore the
+		   transition for the inner loop is useless and can be thrown
+		   away. */
+		/* XXX - The same position is used for all nodes in a bracket
+		   expression, so this optimization cannot be used (it will
+		   break bracket expressions) unless I figure out a way to
+		   detect it here. */
+		if (trans->state_id == p2->position)
+		  {
+		    break;
+		  }
+#endif
+		trans++;
+	      }
+
+	    if (trans->state == NULL)
+	      (trans + 1)->state = NULL;
+	    /* Use the character ranges, assertions, etc. from `p1' for
+	       the transition from `p1' to `p2'. */
+	    trans->code_min = p1->code_min;
+	    trans->code_max = p1->code_max;
+	    trans->state = transitions + offs[p2->position];
+	    trans->state_id = p2->position;
+	    trans->assertions = p1->assertions | p2->assertions
+	      | (p1->class ? ASSERT_CHAR_CLASS : 0)
+	      | (p1->neg_classes != NULL ? ASSERT_CHAR_CLASS_NEG : 0);
+	    if (p1->backref >= 0)
+	      {
+		assert((trans->assertions & ASSERT_CHAR_CLASS) == 0);
+		assert(p2->backref < 0);
+		trans->u.backref = p1->backref;
+		trans->assertions |= ASSERT_BACKREF;
+	      }
+	    else
+	      trans->u.class = p1->class;
+	    if (p1->neg_classes != NULL)
+	      {
+		for (i = 0; p1->neg_classes[i] != (tre_ctype_t)0; i++);
+		trans->neg_classes =
+		  xmalloc(sizeof(*trans->neg_classes) * (i + 1));
+		if (trans->neg_classes == NULL)
+		  return REG_ESPACE;
+		for (i = 0; p1->neg_classes[i] != (tre_ctype_t)0; i++)
+		  trans->neg_classes[i] = p1->neg_classes[i];
+		trans->neg_classes[i] = (tre_ctype_t)0;
+	      }
+	    else
+	      trans->neg_classes = NULL;
+
+	    /* Find out how many tags this transition has. */
+	    i = 0;
+	    if (p1->tags != NULL)
+	      while(p1->tags[i] >= 0)
+		i++;
+	    j = 0;
+	    if (p2->tags != NULL)
+	      while(p2->tags[j] >= 0)
+		j++;
+
+	    /* If we are overwriting a transition, free the old tag array. */
+	    if (trans->tags != NULL)
+	      xfree(trans->tags);
+	    trans->tags = NULL;
+
+	    /* If there were any tags, allocate an array and fill it. */
+	    if (i + j > 0)
+	      {
+		trans->tags = xmalloc(sizeof(*trans->tags) * (i + j + 1));
+		if (!trans->tags)
+		  return REG_ESPACE;
+		i = 0;
+		if (p1->tags != NULL)
+		  while(p1->tags[i] >= 0)
+		    {
+		      trans->tags[i] = p1->tags[i];
+		      i++;
+		    }
+		l = i;
+		j = 0;
+		if (p2->tags != NULL)
+		  while (p2->tags[j] >= 0)
+		    {
+		      /* Don't add duplicates. */
+		      dup = 0;
+		      for (k = 0; k < i; k++)
+			if (trans->tags[k] == p2->tags[j])
+			  {
+			    dup = 1;
+			    break;
+			  }
+		      if (!dup)
+			trans->tags[l++] = p2->tags[j];
+		      j++;
+		    }
+		trans->tags[l] = -1;
+	      }
+
+	    p2++;
+	  }
+	p1++;
+      }
+  else
+    /* Compute a maximum limit for the number of transitions leaving
+       from each state. */
+    while (p1->position >= 0)
+      {
+	p2 = orig_p2;
+	while (p2->position >= 0)
+	  {
+	    counts[p1->position]++;
+	    p2++;
+	  }
+	p1++;
+      }
+  return REG_OK;
+}
+
+/* Converts the syntax tree to a TNFA.	All the transitions in the TNFA are
+   labelled with one character range (there are no transitions on empty
+   strings).  The TNFA takes O(n^2) space in the worst case, `n' is size of
+   the regexp. */
+static reg_errcode_t
+tre_ast_to_tnfa(tre_ast_node_t *node, tre_tnfa_transition_t *transitions,
+		int *counts, int *offs)
+{
+  tre_union_t *uni;
+  tre_catenation_t *cat;
+  tre_iteration_t *iter;
+  reg_errcode_t errcode = REG_OK;
+
+  /* XXX - recurse using a stack!. */
+  switch (node->type)
+    {
+    case LITERAL:
+      break;
+    case UNION:
+      uni = (tre_union_t *)node->obj;
+      errcode = tre_ast_to_tnfa(uni->left, transitions, counts, offs);
+      if (errcode != REG_OK)
+	return errcode;
+      errcode = tre_ast_to_tnfa(uni->right, transitions, counts, offs);
+      break;
+
+    case CATENATION:
+      cat = (tre_catenation_t *)node->obj;
+      /* Add a transition from each position in cat->left->lastpos
+	 to each position in cat->right->firstpos. */
+      errcode = tre_make_trans(cat->left->lastpos, cat->right->firstpos,
+			       transitions, counts, offs);
+      if (errcode != REG_OK)
+	return errcode;
+      errcode = tre_ast_to_tnfa(cat->left, transitions, counts, offs);
+      if (errcode != REG_OK)
+	return errcode;
+      errcode = tre_ast_to_tnfa(cat->right, transitions, counts, offs);
+      break;
+
+    case ITERATION:
+      iter = (tre_iteration_t *)node->obj;
+      assert(iter->max == -1 || iter->max == 1);
+
+      if (iter->max == -1)
+	{
+	  assert(iter->min == 0 || iter->min == 1);
+	  /* Add a transition from each last position in the iterated
+	     expression to each first position. */
+	  errcode = tre_make_trans(iter->arg->lastpos, iter->arg->firstpos,
+				   transitions, counts, offs);
+	  if (errcode != REG_OK)
+	    return errcode;
+	}
+      errcode = tre_ast_to_tnfa(iter->arg, transitions, counts, offs);
+      break;
+    }
+  return errcode;
+}
+
+
+#define ERROR_EXIT(err)		  \
+  do				  \
+    {				  \
+      errcode = err;		  \
+      if (/*CONSTCOND*/1)	  \
+      	goto error_exit;	  \
+    }				  \
+ while (/*CONSTCOND*/0)
+
+
+int
+regcomp(regex_t *restrict preg, const char *restrict regex, int cflags)
+{
+  tre_stack_t *stack;
+  tre_ast_node_t *tree, *tmp_ast_l, *tmp_ast_r;
+  tre_pos_and_tags_t *p;
+  int *counts = NULL, *offs = NULL;
+  int i, add = 0;
+  tre_tnfa_transition_t *transitions, *initial;
+  tre_tnfa_t *tnfa = NULL;
+  tre_submatch_data_t *submatch_data;
+  tre_tag_direction_t *tag_directions = NULL;
+  reg_errcode_t errcode;
+  tre_mem_t mem;
+
+  /* Parse context. */
+  tre_parse_ctx_t parse_ctx;
+
+  /* Allocate a stack used throughout the compilation process for various
+     purposes. */
+  stack = tre_stack_new(512, 1024000, 128);
+  if (!stack)
+    return REG_ESPACE;
+  /* Allocate a fast memory allocator. */
+  mem = tre_mem_new();
+  if (!mem)
+    {
+      tre_stack_destroy(stack);
+      return REG_ESPACE;
+    }
+
+  /* Parse the regexp. */
+  memset(&parse_ctx, 0, sizeof(parse_ctx));
+  parse_ctx.mem = mem;
+  parse_ctx.stack = stack;
+  parse_ctx.start = regex;
+  parse_ctx.cflags = cflags;
+  parse_ctx.max_backref = -1;
+  errcode = tre_parse(&parse_ctx);
+  if (errcode != REG_OK)
+    ERROR_EXIT(errcode);
+  preg->re_nsub = parse_ctx.submatch_id - 1;
+  tree = parse_ctx.n;
+
+#ifdef TRE_DEBUG
+  tre_ast_print(tree);
+#endif /* TRE_DEBUG */
+
+  /* Referring to nonexistent subexpressions is illegal. */
+  if (parse_ctx.max_backref > (int)preg->re_nsub)
+    ERROR_EXIT(REG_ESUBREG);
+
+  /* Allocate the TNFA struct. */
+  tnfa = xcalloc(1, sizeof(tre_tnfa_t));
+  if (tnfa == NULL)
+    ERROR_EXIT(REG_ESPACE);
+  tnfa->have_backrefs = parse_ctx.max_backref >= 0;
+  tnfa->have_approx = 0;
+  tnfa->num_submatches = parse_ctx.submatch_id;
+
+  /* Set up tags for submatch addressing.  If REG_NOSUB is set and the
+     regexp does not have back references, this can be skipped. */
+  if (tnfa->have_backrefs || !(cflags & REG_NOSUB))
+    {
+
+      /* Figure out how many tags we will need. */
+      errcode = tre_add_tags(NULL, stack, tree, tnfa);
+      if (errcode != REG_OK)
+	ERROR_EXIT(errcode);
+
+      if (tnfa->num_tags > 0)
+	{
+	  tag_directions = xmalloc(sizeof(*tag_directions)
+				   * (tnfa->num_tags + 1));
+	  if (tag_directions == NULL)
+	    ERROR_EXIT(REG_ESPACE);
+	  tnfa->tag_directions = tag_directions;
+	  memset(tag_directions, -1,
+		 sizeof(*tag_directions) * (tnfa->num_tags + 1));
+	}
+      tnfa->minimal_tags = xcalloc((unsigned)tnfa->num_tags * 2 + 1,
+				   sizeof(*tnfa->minimal_tags));
+      if (tnfa->minimal_tags == NULL)
+	ERROR_EXIT(REG_ESPACE);
+
+      submatch_data = xcalloc((unsigned)parse_ctx.submatch_id,
+			      sizeof(*submatch_data));
+      if (submatch_data == NULL)
+	ERROR_EXIT(REG_ESPACE);
+      tnfa->submatch_data = submatch_data;
+
+      errcode = tre_add_tags(mem, stack, tree, tnfa);
+      if (errcode != REG_OK)
+	ERROR_EXIT(errcode);
+
+    }
+
+  /* Expand iteration nodes. */
+  errcode = tre_expand_ast(mem, stack, tree, &parse_ctx.position,
+			   tag_directions);
+  if (errcode != REG_OK)
+    ERROR_EXIT(errcode);
+
+  /* Add a dummy node for the final state.
+     XXX - For certain patterns this dummy node can be optimized away,
+	   for example "a*" or "ab*".	Figure out a simple way to detect
+	   this possibility. */
+  tmp_ast_l = tree;
+  tmp_ast_r = tre_ast_new_literal(mem, 0, 0, parse_ctx.position++);
+  if (tmp_ast_r == NULL)
+    ERROR_EXIT(REG_ESPACE);
+
+  tree = tre_ast_new_catenation(mem, tmp_ast_l, tmp_ast_r);
+  if (tree == NULL)
+    ERROR_EXIT(REG_ESPACE);
+
+  errcode = tre_compute_nfl(mem, stack, tree);
+  if (errcode != REG_OK)
+    ERROR_EXIT(errcode);
+
+  counts = xmalloc(sizeof(int) * parse_ctx.position);
+  if (counts == NULL)
+    ERROR_EXIT(REG_ESPACE);
+
+  offs = xmalloc(sizeof(int) * parse_ctx.position);
+  if (offs == NULL)
+    ERROR_EXIT(REG_ESPACE);
+
+  for (i = 0; i < parse_ctx.position; i++)
+    counts[i] = 0;
+  tre_ast_to_tnfa(tree, NULL, counts, NULL);
+
+  add = 0;
+  for (i = 0; i < parse_ctx.position; i++)
+    {
+      offs[i] = add;
+      add += counts[i] + 1;
+      counts[i] = 0;
+    }
+  transitions = xcalloc((unsigned)add + 1, sizeof(*transitions));
+  if (transitions == NULL)
+    ERROR_EXIT(REG_ESPACE);
+  tnfa->transitions = transitions;
+  tnfa->num_transitions = add;
+
+  errcode = tre_ast_to_tnfa(tree, transitions, counts, offs);
+  if (errcode != REG_OK)
+    ERROR_EXIT(errcode);
+
+  tnfa->firstpos_chars = NULL;
+
+  p = tree->firstpos;
+  i = 0;
+  while (p->position >= 0)
+    {
+      i++;
+      p++;
+    }
+
+  initial = xcalloc((unsigned)i + 1, sizeof(tre_tnfa_transition_t));
+  if (initial == NULL)
+    ERROR_EXIT(REG_ESPACE);
+  tnfa->initial = initial;
+
+  i = 0;
+  for (p = tree->firstpos; p->position >= 0; p++)
+    {
+      initial[i].state = transitions + offs[p->position];
+      initial[i].state_id = p->position;
+      initial[i].tags = NULL;
+      /* Copy the arrays p->tags, and p->params, they are allocated
+	 from a tre_mem object. */
+      if (p->tags)
+	{
+	  int j;
+	  for (j = 0; p->tags[j] >= 0; j++);
+	  initial[i].tags = xmalloc(sizeof(*p->tags) * (j + 1));
+	  if (!initial[i].tags)
+	    ERROR_EXIT(REG_ESPACE);
+	  memcpy(initial[i].tags, p->tags, sizeof(*p->tags) * (j + 1));
+	}
+      initial[i].assertions = p->assertions;
+      i++;
+    }
+  initial[i].state = NULL;
+
+  tnfa->num_transitions = add;
+  tnfa->final = transitions + offs[tree->lastpos[0].position];
+  tnfa->num_states = parse_ctx.position;
+  tnfa->cflags = cflags;
+
+  tre_mem_destroy(mem);
+  tre_stack_destroy(stack);
+  xfree(counts);
+  xfree(offs);
+
+  preg->TRE_REGEX_T_FIELD = (void *)tnfa;
+  return REG_OK;
+
+ error_exit:
+  /* Free everything that was allocated and return the error code. */
+  tre_mem_destroy(mem);
+  if (stack != NULL)
+    tre_stack_destroy(stack);
+  if (counts != NULL)
+    xfree(counts);
+  if (offs != NULL)
+    xfree(offs);
+  preg->TRE_REGEX_T_FIELD = (void *)tnfa;
+  regfree(preg);
+  return errcode;
+}
+
+
+
+
+void
+regfree(regex_t *preg)
+{
+  tre_tnfa_t *tnfa;
+  unsigned int i;
+  tre_tnfa_transition_t *trans;
+
+  tnfa = (void *)preg->TRE_REGEX_T_FIELD;
+  if (!tnfa)
+    return;
+
+  for (i = 0; i < tnfa->num_transitions; i++)
+    if (tnfa->transitions[i].state)
+      {
+	if (tnfa->transitions[i].tags)
+	  xfree(tnfa->transitions[i].tags);
+	if (tnfa->transitions[i].neg_classes)
+	  xfree(tnfa->transitions[i].neg_classes);
+      }
+  if (tnfa->transitions)
+    xfree(tnfa->transitions);
+
+  if (tnfa->initial)
+    {
+      for (trans = tnfa->initial; trans->state; trans++)
+	{
+	  if (trans->tags)
+	    xfree(trans->tags);
+	}
+      xfree(tnfa->initial);
+    }
+
+  if (tnfa->submatch_data)
+    {
+      for (i = 0; i < tnfa->num_submatches; i++)
+	if (tnfa->submatch_data[i].parents)
+	  xfree(tnfa->submatch_data[i].parents);
+      xfree(tnfa->submatch_data);
+    }
+
+  if (tnfa->tag_directions)
+    xfree(tnfa->tag_directions);
+  if (tnfa->firstpos_chars)
+    xfree(tnfa->firstpos_chars);
+  if (tnfa->minimal_tags)
+    xfree(tnfa->minimal_tags);
+  xfree(tnfa);
+}
diff --git a/third_party/musl/porting/liteos_m/kernel/src/regex/regexec.c b/third_party/musl/porting/liteos_m/kernel/src/regex/regexec.c
new file mode 100755
index 000000000..253b0e149
--- /dev/null
+++ b/third_party/musl/porting/liteos_m/kernel/src/regex/regexec.c
@@ -0,0 +1,1028 @@
+/*
+  regexec.c - TRE POSIX compatible matching functions (and more).
+
+  Copyright (c) 2001-2009 Ville Laurikari <vl@iki.fi>
+  All rights reserved.
+
+  Redistribution and use in source and binary forms, with or without
+  modification, are permitted provided that the following conditions
+  are met:
+
+    1. Redistributions of source code must retain the above copyright
+       notice, this list of conditions and the following disclaimer.
+
+    2. Redistributions in binary form must reproduce the above copyright
+       notice, this list of conditions and the following disclaimer in the
+       documentation and/or other materials provided with the distribution.
+
+  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDER AND CONTRIBUTORS
+  ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+  A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT
+  HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+*/
+
+#include <stdlib.h>
+#include <string.h>
+#include <wchar.h>
+#include <wctype.h>
+#include <limits.h>
+#include <stdint.h>
+
+#include <regex.h>
+
+#include "tre.h"
+
+#include <assert.h>
+
+static void
+tre_fill_pmatch(size_t nmatch, regmatch_t pmatch[], int cflags,
+		const tre_tnfa_t *tnfa, regoff_t *tags, regoff_t match_eo);
+
+/***********************************************************************
+ from tre-match-utils.h
+***********************************************************************/
+
+#define GET_NEXT_WCHAR() do {                                                 \
+    prev_c = next_c; pos += pos_add_next;                                     \
+    if ((pos_add_next = mbtowc(&next_c, str_byte, MB_LEN_MAX)) <= 0) {        \
+        if (pos_add_next < 0) { ret = REG_NOMATCH; goto error_exit; }         \
+        else pos_add_next++;                                                  \
+    }                                                                         \
+    str_byte += pos_add_next;                                                 \
+  } while (0)
+
+#define IS_WORD_CHAR(c)	 ((c) == L'_' || tre_isalnum(c))
+
+#define CHECK_ASSERTIONS(assertions)					      \
+  (((assertions & ASSERT_AT_BOL)					      \
+    && (pos > 0 || reg_notbol)						      \
+    && (prev_c != L'\n' || !reg_newline))				      \
+   || ((assertions & ASSERT_AT_EOL)					      \
+       && (next_c != L'\0' || reg_noteol)				      \
+       && (next_c != L'\n' || !reg_newline))				      \
+   || ((assertions & ASSERT_AT_BOW)					      \
+       && (IS_WORD_CHAR(prev_c) || !IS_WORD_CHAR(next_c)))	              \
+   || ((assertions & ASSERT_AT_EOW)					      \
+       && (!IS_WORD_CHAR(prev_c) || IS_WORD_CHAR(next_c)))		      \
+   || ((assertions & ASSERT_AT_WB)					      \
+       && (pos != 0 && next_c != L'\0'					      \
+	   && IS_WORD_CHAR(prev_c) == IS_WORD_CHAR(next_c)))		      \
+   || ((assertions & ASSERT_AT_WB_NEG)					      \
+       && (pos == 0 || next_c == L'\0'					      \
+	   || IS_WORD_CHAR(prev_c) != IS_WORD_CHAR(next_c))))
+
+#define CHECK_CHAR_CLASSES(trans_i, tnfa, eflags)                             \
+  (((trans_i->assertions & ASSERT_CHAR_CLASS)                                 \
+       && !(tnfa->cflags & REG_ICASE)                                         \
+       && !tre_isctype((tre_cint_t)prev_c, trans_i->u.class))                 \
+    || ((trans_i->assertions & ASSERT_CHAR_CLASS)                             \
+        && (tnfa->cflags & REG_ICASE)                                         \
+        && !tre_isctype(tre_tolower((tre_cint_t)prev_c),trans_i->u.class)     \
+	&& !tre_isctype(tre_toupper((tre_cint_t)prev_c),trans_i->u.class))    \
+    || ((trans_i->assertions & ASSERT_CHAR_CLASS_NEG)                         \
+        && tre_neg_char_classes_match(trans_i->neg_classes,(tre_cint_t)prev_c,\
+                                      tnfa->cflags & REG_ICASE)))
+
+
+
+
+/* Returns 1 if `t1' wins `t2', 0 otherwise. */
+static int
+tre_tag_order(int num_tags, tre_tag_direction_t *tag_directions,
+	      regoff_t *t1, regoff_t *t2)
+{
+  int i;
+  for (i = 0; i < num_tags; i++)
+    {
+      if (tag_directions[i] == TRE_TAG_MINIMIZE)
+	{
+	  if (t1[i] < t2[i])
+	    return 1;
+	  if (t1[i] > t2[i])
+	    return 0;
+	}
+      else
+	{
+	  if (t1[i] > t2[i])
+	    return 1;
+	  if (t1[i] < t2[i])
+	    return 0;
+	}
+    }
+  /*  assert(0);*/
+  return 0;
+}
+
+static int
+tre_neg_char_classes_match(tre_ctype_t *classes, tre_cint_t wc, int icase)
+{
+  while (*classes != (tre_ctype_t)0)
+    if ((!icase && tre_isctype(wc, *classes))
+	|| (icase && (tre_isctype(tre_toupper(wc), *classes)
+		      || tre_isctype(tre_tolower(wc), *classes))))
+      return 1; /* Match. */
+    else
+      classes++;
+  return 0; /* No match. */
+}
+
+
+/***********************************************************************
+ from tre-match-parallel.c
+***********************************************************************/
+
+/*
+  This algorithm searches for matches basically by reading characters
+  in the searched string one by one, starting at the beginning.	 All
+  matching paths in the TNFA are traversed in parallel.	 When two or
+  more paths reach the same state, exactly one is chosen according to
+  tag ordering rules; if returning submatches is not required it does
+  not matter which path is chosen.
+
+  The worst case time required for finding the leftmost and longest
+  match, or determining that there is no match, is always linearly
+  dependent on the length of the text being searched.
+
+  This algorithm cannot handle TNFAs with back referencing nodes.
+  See `tre-match-backtrack.c'.
+*/
+
+typedef struct {
+  tre_tnfa_transition_t *state;
+  regoff_t *tags;
+} tre_tnfa_reach_t;
+
+typedef struct {
+  regoff_t pos;
+  regoff_t **tags;
+} tre_reach_pos_t;
+
+
+static reg_errcode_t
+tre_tnfa_run_parallel(const tre_tnfa_t *tnfa, const void *string,
+		      regoff_t *match_tags, int eflags,
+		      regoff_t *match_end_ofs)
+{
+  /* State variables required by GET_NEXT_WCHAR. */
+  tre_char_t prev_c = 0, next_c = 0;
+  const char *str_byte = string;
+  regoff_t pos = -1;
+  regoff_t pos_add_next = 1;
+#ifdef TRE_MBSTATE
+  mbstate_t mbstate;
+#endif /* TRE_MBSTATE */
+  int reg_notbol = eflags & REG_NOTBOL;
+  int reg_noteol = eflags & REG_NOTEOL;
+  int reg_newline = tnfa->cflags & REG_NEWLINE;
+  reg_errcode_t ret;
+
+  char *buf;
+  tre_tnfa_transition_t *trans_i;
+  tre_tnfa_reach_t *reach, *reach_next, *reach_i, *reach_next_i;
+  tre_reach_pos_t *reach_pos;
+  int *tag_i;
+  int num_tags, i;
+
+  regoff_t match_eo = -1;	   /* end offset of match (-1 if no match found yet) */
+  int new_match = 0;
+  regoff_t *tmp_tags = NULL;
+  regoff_t *tmp_iptr;
+
+#ifdef TRE_MBSTATE
+  memset(&mbstate, '\0', sizeof(mbstate));
+#endif /* TRE_MBSTATE */
+
+  if (!match_tags)
+    num_tags = 0;
+  else
+    num_tags = tnfa->num_tags;
+
+  /* Allocate memory for temporary data required for matching.	This needs to
+     be done for every matching operation to be thread safe.  This allocates
+     everything in a single large block with calloc(). */
+  {
+    size_t tbytes, rbytes, pbytes, xbytes, total_bytes;
+    char *tmp_buf;
+
+    /* Ensure that tbytes and xbytes*num_states cannot overflow, and that
+     * they don't contribute more than 1/8 of SIZE_MAX to total_bytes. */
+    if (num_tags > SIZE_MAX/(8 * sizeof(regoff_t) * tnfa->num_states))
+      return REG_ESPACE;
+
+    /* Likewise check rbytes. */
+    if (tnfa->num_states+1 > SIZE_MAX/(8 * sizeof(*reach_next)))
+      return REG_ESPACE;
+
+    /* Likewise check pbytes. */
+    if (tnfa->num_states > SIZE_MAX/(8 * sizeof(*reach_pos)))
+      return REG_ESPACE;
+
+    /* Compute the length of the block we need. */
+    tbytes = sizeof(*tmp_tags) * num_tags;
+    rbytes = sizeof(*reach_next) * (tnfa->num_states + 1);
+    pbytes = sizeof(*reach_pos) * tnfa->num_states;
+    xbytes = sizeof(regoff_t) * num_tags;
+    total_bytes =
+      (sizeof(long) - 1) * 4 /* for alignment paddings */
+      + (rbytes + xbytes * tnfa->num_states) * 2 + tbytes + pbytes;
+
+    /* Allocate the memory. */
+    buf = calloc(total_bytes, 1);
+    if (buf == NULL)
+      return REG_ESPACE;
+
+    /* Get the various pointers within tmp_buf (properly aligned). */
+    tmp_tags = (void *)buf;
+    tmp_buf = buf + tbytes;
+    tmp_buf += ALIGN(tmp_buf, long);
+    reach_next = (void *)tmp_buf;
+    tmp_buf += rbytes;
+    tmp_buf += ALIGN(tmp_buf, long);
+    reach = (void *)tmp_buf;
+    tmp_buf += rbytes;
+    tmp_buf += ALIGN(tmp_buf, long);
+    reach_pos = (void *)tmp_buf;
+    tmp_buf += pbytes;
+    tmp_buf += ALIGN(tmp_buf, long);
+    for (i = 0; i < tnfa->num_states; i++)
+      {
+	reach[i].tags = (void *)tmp_buf;
+	tmp_buf += xbytes;
+	reach_next[i].tags = (void *)tmp_buf;
+	tmp_buf += xbytes;
+      }
+  }
+
+  for (i = 0; i < tnfa->num_states; i++)
+    reach_pos[i].pos = -1;
+
+  GET_NEXT_WCHAR();
+  pos = 0;
+
+  reach_next_i = reach_next;
+  while (1)
+    {
+      /* If no match found yet, add the initial states to `reach_next'. */
+      if (match_eo < 0)
+	{
+	  trans_i = tnfa->initial;
+	  while (trans_i->state != NULL)
+	    {
+	      if (reach_pos[trans_i->state_id].pos < pos)
+		{
+		  if (trans_i->assertions
+		      && CHECK_ASSERTIONS(trans_i->assertions))
+		    {
+		      trans_i++;
+		      continue;
+		    }
+
+		  reach_next_i->state = trans_i->state;
+		  for (i = 0; i < num_tags; i++)
+		    reach_next_i->tags[i] = -1;
+		  tag_i = trans_i->tags;
+		  if (tag_i)
+		    while (*tag_i >= 0)
+		      {
+			if (*tag_i < num_tags)
+			  reach_next_i->tags[*tag_i] = pos;
+			tag_i++;
+		      }
+		  if (reach_next_i->state == tnfa->final)
+		    {
+		      match_eo = pos;
+		      new_match = 1;
+		      for (i = 0; i < num_tags; i++)
+			match_tags[i] = reach_next_i->tags[i];
+		    }
+		  reach_pos[trans_i->state_id].pos = pos;
+		  reach_pos[trans_i->state_id].tags = &reach_next_i->tags;
+		  reach_next_i++;
+		}
+	      trans_i++;
+	    }
+	  reach_next_i->state = NULL;
+	}
+      else
+	{
+	  if (num_tags == 0 || reach_next_i == reach_next)
+	    /* We have found a match. */
+	    break;
+	}
+
+      /* Check for end of string. */
+      if (!next_c) break;
+
+      GET_NEXT_WCHAR();
+
+      /* Swap `reach' and `reach_next'. */
+      reach_i = reach;
+      reach = reach_next;
+      reach_next = reach_i;
+
+      /* For each state in `reach', weed out states that don't fulfill the
+	 minimal matching conditions. */
+      if (tnfa->num_minimals && new_match)
+	{
+	  new_match = 0;
+	  reach_next_i = reach_next;
+	  for (reach_i = reach; reach_i->state; reach_i++)
+	    {
+	      int skip = 0;
+	      for (i = 0; tnfa->minimal_tags[i] >= 0; i += 2)
+		{
+		  int end = tnfa->minimal_tags[i];
+		  int start = tnfa->minimal_tags[i + 1];
+		  if (end >= num_tags)
+		    {
+		      skip = 1;
+		      break;
+		    }
+		  else if (reach_i->tags[start] == match_tags[start]
+			   && reach_i->tags[end] < match_tags[end])
+		    {
+		      skip = 1;
+		      break;
+		    }
+		}
+	      if (!skip)
+		{
+		  reach_next_i->state = reach_i->state;
+		  tmp_iptr = reach_next_i->tags;
+		  reach_next_i->tags = reach_i->tags;
+		  reach_i->tags = tmp_iptr;
+		  reach_next_i++;
+		}
+	    }
+	  reach_next_i->state = NULL;
+
+	  /* Swap `reach' and `reach_next'. */
+	  reach_i = reach;
+	  reach = reach_next;
+	  reach_next = reach_i;
+	}
+
+      /* For each state in `reach' see if there is a transition leaving with
+	 the current input symbol to a state not yet in `reach_next', and
+	 add the destination states to `reach_next'. */
+      reach_next_i = reach_next;
+      for (reach_i = reach; reach_i->state; reach_i++)
+	{
+	  for (trans_i = reach_i->state; trans_i->state; trans_i++)
+	    {
+	      /* Does this transition match the input symbol? */
+	      if (trans_i->code_min <= (tre_cint_t)prev_c &&
+		  trans_i->code_max >= (tre_cint_t)prev_c)
+		{
+		  if (trans_i->assertions
+		      && (CHECK_ASSERTIONS(trans_i->assertions)
+			  || CHECK_CHAR_CLASSES(trans_i, tnfa, eflags)))
+		    {
+		      continue;
+		    }
+
+		  /* Compute the tags after this transition. */
+		  for (i = 0; i < num_tags; i++)
+		    tmp_tags[i] = reach_i->tags[i];
+		  tag_i = trans_i->tags;
+		  if (tag_i != NULL)
+		    while (*tag_i >= 0)
+		      {
+			if (*tag_i < num_tags)
+			  tmp_tags[*tag_i] = pos;
+			tag_i++;
+		      }
+
+		  if (reach_pos[trans_i->state_id].pos < pos)
+		    {
+		      /* Found an unvisited node. */
+		      reach_next_i->state = trans_i->state;
+		      tmp_iptr = reach_next_i->tags;
+		      reach_next_i->tags = tmp_tags;
+		      tmp_tags = tmp_iptr;
+		      reach_pos[trans_i->state_id].pos = pos;
+		      reach_pos[trans_i->state_id].tags = &reach_next_i->tags;
+
+		      if (reach_next_i->state == tnfa->final
+			  && (match_eo == -1
+			      || (num_tags > 0
+				  && reach_next_i->tags[0] <= match_tags[0])))
+			{
+			  match_eo = pos;
+			  new_match = 1;
+			  for (i = 0; i < num_tags; i++)
+			    match_tags[i] = reach_next_i->tags[i];
+			}
+		      reach_next_i++;
+
+		    }
+		  else
+		    {
+		      assert(reach_pos[trans_i->state_id].pos == pos);
+		      /* Another path has also reached this state.  We choose
+			 the winner by examining the tag values for both
+			 paths. */
+		      if (tre_tag_order(num_tags, tnfa->tag_directions,
+					tmp_tags,
+					*reach_pos[trans_i->state_id].tags))
+			{
+			  /* The new path wins. */
+			  tmp_iptr = *reach_pos[trans_i->state_id].tags;
+			  *reach_pos[trans_i->state_id].tags = tmp_tags;
+			  if (trans_i->state == tnfa->final)
+			    {
+			      match_eo = pos;
+			      new_match = 1;
+			      for (i = 0; i < num_tags; i++)
+				match_tags[i] = tmp_tags[i];
+			    }
+			  tmp_tags = tmp_iptr;
+			}
+		    }
+		}
+	    }
+	}
+      reach_next_i->state = NULL;
+    }
+
+  *match_end_ofs = match_eo;
+  ret = match_eo >= 0 ? REG_OK : REG_NOMATCH;
+error_exit:
+  xfree(buf);
+  return ret;
+}
+
+
+
+/***********************************************************************
+ from tre-match-backtrack.c
+***********************************************************************/
+
+/*
+  This matcher is for regexps that use back referencing.  Regexp matching
+  with back referencing is an NP-complete problem on the number of back
+  references.  The easiest way to match them is to use a backtracking
+  routine which basically goes through all possible paths in the TNFA
+  and chooses the one which results in the best (leftmost and longest)
+  match.  This can be spectacularly expensive and may run out of stack
+  space, but there really is no better known generic algorithm.	 Quoting
+  Henry Spencer from comp.compilers:
+  <URL: http://compilers.iecc.com/comparch/article/93-03-102>
+
+    POSIX.2 REs require longest match, which is really exciting to
+    implement since the obsolete ("basic") variant also includes
+    \<digit>.  I haven't found a better way of tackling this than doing
+    a preliminary match using a DFA (or simulation) on a modified RE
+    that just replicates subREs for \<digit>, and then doing a
+    backtracking match to determine whether the subRE matches were
+    right.  This can be rather slow, but I console myself with the
+    thought that people who use \<digit> deserve very slow execution.
+    (Pun unintentional but very appropriate.)
+
+*/
+
+typedef struct {
+  regoff_t pos;
+  const char *str_byte;
+  tre_tnfa_transition_t *state;
+  int state_id;
+  int next_c;
+  regoff_t *tags;
+#ifdef TRE_MBSTATE
+  mbstate_t mbstate;
+#endif /* TRE_MBSTATE */
+} tre_backtrack_item_t;
+
+typedef struct tre_backtrack_struct {
+  tre_backtrack_item_t item;
+  struct tre_backtrack_struct *prev;
+  struct tre_backtrack_struct *next;
+} *tre_backtrack_t;
+
+#ifdef TRE_MBSTATE
+#define BT_STACK_MBSTATE_IN  stack->item.mbstate = (mbstate)
+#define BT_STACK_MBSTATE_OUT (mbstate) = stack->item.mbstate
+#else /* !TRE_MBSTATE */
+#define BT_STACK_MBSTATE_IN
+#define BT_STACK_MBSTATE_OUT
+#endif /* !TRE_MBSTATE */
+
+#define tre_bt_mem_new		  tre_mem_new
+#define tre_bt_mem_alloc	  tre_mem_alloc
+#define tre_bt_mem_destroy	  tre_mem_destroy
+
+
+#define BT_STACK_PUSH(_pos, _str_byte, _str_wide, _state, _state_id, _next_c, _tags, _mbstate) \
+  do									      \
+    {									      \
+      int i;								      \
+      if (!stack->next)							      \
+	{								      \
+	  tre_backtrack_t s;						      \
+	  s = tre_bt_mem_alloc(mem, sizeof(*s));			      \
+	  if (!s)							      \
+	    {								      \
+	      tre_bt_mem_destroy(mem);					      \
+	      if (tags)							      \
+		xfree(tags);						      \
+	      if (pmatch)						      \
+		xfree(pmatch);						      \
+	      if (states_seen)						      \
+		xfree(states_seen);					      \
+	      return REG_ESPACE;					      \
+	    }								      \
+	  s->prev = stack;						      \
+	  s->next = NULL;						      \
+	  s->item.tags = tre_bt_mem_alloc(mem,				      \
+					  sizeof(*tags) * tnfa->num_tags);    \
+	  if (!s->item.tags)						      \
+	    {								      \
+	      tre_bt_mem_destroy(mem);					      \
+	      if (tags)							      \
+		xfree(tags);						      \
+	      if (pmatch)						      \
+		xfree(pmatch);						      \
+	      if (states_seen)						      \
+		xfree(states_seen);					      \
+	      return REG_ESPACE;					      \
+	    }								      \
+	  stack->next = s;						      \
+	  stack = s;							      \
+	}								      \
+      else								      \
+	stack = stack->next;						      \
+      stack->item.pos = (_pos);						      \
+      stack->item.str_byte = (_str_byte);				      \
+      stack->item.state = (_state);					      \
+      stack->item.state_id = (_state_id);				      \
+      stack->item.next_c = (_next_c);					      \
+      for (i = 0; i < tnfa->num_tags; i++)				      \
+	stack->item.tags[i] = (_tags)[i];				      \
+      BT_STACK_MBSTATE_IN;						      \
+    }									      \
+  while (0)
+
+#define BT_STACK_POP()							      \
+  do									      \
+    {									      \
+      int i;								      \
+      assert(stack->prev);						      \
+      pos = stack->item.pos;						      \
+      str_byte = stack->item.str_byte;					      \
+      state = stack->item.state;					      \
+      next_c = stack->item.next_c;					      \
+      for (i = 0; i < tnfa->num_tags; i++)				      \
+	tags[i] = stack->item.tags[i];					      \
+      BT_STACK_MBSTATE_OUT;						      \
+      stack = stack->prev;						      \
+    }									      \
+  while (0)
+
+#undef MIN
+#define MIN(a, b) ((a) <= (b) ? (a) : (b))
+
+static reg_errcode_t
+tre_tnfa_run_backtrack(const tre_tnfa_t *tnfa, const void *string,
+		       regoff_t *match_tags, int eflags, regoff_t *match_end_ofs)
+{
+  /* State variables required by GET_NEXT_WCHAR. */
+  tre_char_t prev_c = 0, next_c = 0;
+  const char *str_byte = string;
+  regoff_t pos = 0;
+  regoff_t pos_add_next = 1;
+#ifdef TRE_MBSTATE
+  mbstate_t mbstate;
+#endif /* TRE_MBSTATE */
+  int reg_notbol = eflags & REG_NOTBOL;
+  int reg_noteol = eflags & REG_NOTEOL;
+  int reg_newline = tnfa->cflags & REG_NEWLINE;
+
+  /* These are used to remember the necessary values of the above
+     variables to return to the position where the current search
+     started from. */
+  int next_c_start;
+  const char *str_byte_start;
+  regoff_t pos_start = -1;
+#ifdef TRE_MBSTATE
+  mbstate_t mbstate_start;
+#endif /* TRE_MBSTATE */
+
+  /* End offset of best match so far, or -1 if no match found yet. */
+  regoff_t match_eo = -1;
+  /* Tag arrays. */
+  int *next_tags;
+  regoff_t *tags = NULL;
+  /* Current TNFA state. */
+  tre_tnfa_transition_t *state;
+  int *states_seen = NULL;
+
+  /* Memory allocator to for allocating the backtracking stack. */
+  tre_mem_t mem = tre_bt_mem_new();
+
+  /* The backtracking stack. */
+  tre_backtrack_t stack;
+
+  tre_tnfa_transition_t *trans_i;
+  regmatch_t *pmatch = NULL;
+  int ret;
+
+#ifdef TRE_MBSTATE
+  memset(&mbstate, '\0', sizeof(mbstate));
+#endif /* TRE_MBSTATE */
+
+  if (!mem)
+    return REG_ESPACE;
+  stack = tre_bt_mem_alloc(mem, sizeof(*stack));
+  if (!stack)
+    {
+      ret = REG_ESPACE;
+      goto error_exit;
+    }
+  stack->prev = NULL;
+  stack->next = NULL;
+
+  if (tnfa->num_tags)
+    {
+      tags = xmalloc(sizeof(*tags) * tnfa->num_tags);
+      if (!tags)
+	{
+	  ret = REG_ESPACE;
+	  goto error_exit;
+	}
+    }
+  if (tnfa->num_submatches)
+    {
+      pmatch = xmalloc(sizeof(*pmatch) * tnfa->num_submatches);
+      if (!pmatch)
+	{
+	  ret = REG_ESPACE;
+	  goto error_exit;
+	}
+    }
+  if (tnfa->num_states)
+    {
+      states_seen = xmalloc(sizeof(*states_seen) * tnfa->num_states);
+      if (!states_seen)
+	{
+	  ret = REG_ESPACE;
+	  goto error_exit;
+	}
+    }
+
+ retry:
+  {
+    int i;
+    for (i = 0; i < tnfa->num_tags; i++)
+      {
+	tags[i] = -1;
+	if (match_tags)
+	  match_tags[i] = -1;
+      }
+    for (i = 0; i < tnfa->num_states; i++)
+      states_seen[i] = 0;
+  }
+
+  state = NULL;
+  pos = pos_start;
+  GET_NEXT_WCHAR();
+  pos_start = pos;
+  next_c_start = next_c;
+  str_byte_start = str_byte;
+#ifdef TRE_MBSTATE
+  mbstate_start = mbstate;
+#endif /* TRE_MBSTATE */
+
+  /* Handle initial states. */
+  next_tags = NULL;
+  for (trans_i = tnfa->initial; trans_i->state; trans_i++)
+    {
+      if (trans_i->assertions && CHECK_ASSERTIONS(trans_i->assertions))
+	{
+	  continue;
+	}
+      if (state == NULL)
+	{
+	  /* Start from this state. */
+	  state = trans_i->state;
+	  next_tags = trans_i->tags;
+	}
+      else
+	{
+	  /* Backtrack to this state. */
+	  BT_STACK_PUSH(pos, str_byte, 0, trans_i->state,
+			trans_i->state_id, next_c, tags, mbstate);
+	  {
+	    int *tmp = trans_i->tags;
+	    if (tmp)
+	      while (*tmp >= 0)
+		stack->item.tags[*tmp++] = pos;
+	  }
+	}
+    }
+
+  if (next_tags)
+    for (; *next_tags >= 0; next_tags++)
+      tags[*next_tags] = pos;
+
+
+  if (state == NULL)
+    goto backtrack;
+
+  while (1)
+    {
+      tre_tnfa_transition_t *next_state;
+      int empty_br_match;
+
+      if (state == tnfa->final)
+	{
+	  if (match_eo < pos
+	      || (match_eo == pos
+		  && match_tags
+		  && tre_tag_order(tnfa->num_tags, tnfa->tag_directions,
+				   tags, match_tags)))
+	    {
+	      int i;
+	      /* This match wins the previous match. */
+	      match_eo = pos;
+	      if (match_tags)
+		for (i = 0; i < tnfa->num_tags; i++)
+		  match_tags[i] = tags[i];
+	    }
+	  /* Our TNFAs never have transitions leaving from the final state,
+	     so we jump right to backtracking. */
+	  goto backtrack;
+	}
+
+      /* Go to the next character in the input string. */
+      empty_br_match = 0;
+      trans_i = state;
+      if (trans_i->state && trans_i->assertions & ASSERT_BACKREF)
+	{
+	  /* This is a back reference state.  All transitions leaving from
+	     this state have the same back reference "assertion".  Instead
+	     of reading the next character, we match the back reference. */
+	  regoff_t so, eo;
+	  int bt = trans_i->u.backref;
+	  regoff_t bt_len;
+	  int result;
+
+	  /* Get the substring we need to match against.  Remember to
+	     turn off REG_NOSUB temporarily. */
+	  tre_fill_pmatch(bt + 1, pmatch, tnfa->cflags & ~REG_NOSUB,
+			  tnfa, tags, pos);
+	  so = pmatch[bt].rm_so;
+	  eo = pmatch[bt].rm_eo;
+	  bt_len = eo - so;
+
+	  result = strncmp((const char*)string + so, str_byte - 1,
+				 (size_t)bt_len);
+
+	  if (result == 0)
+	    {
+	      /* Back reference matched.  Check for infinite loop. */
+	      if (bt_len == 0)
+		empty_br_match = 1;
+	      if (empty_br_match && states_seen[trans_i->state_id])
+		{
+		  goto backtrack;
+		}
+
+	      states_seen[trans_i->state_id] = empty_br_match;
+
+	      /* Advance in input string and resync `prev_c', `next_c'
+		 and pos. */
+	      str_byte += bt_len - 1;
+	      pos += bt_len - 1;
+	      GET_NEXT_WCHAR();
+	    }
+	  else
+	    {
+	      goto backtrack;
+	    }
+	}
+      else
+	{
+	  /* Check for end of string. */
+	  if (next_c == L'\0')
+		goto backtrack;
+
+	  /* Read the next character. */
+	  GET_NEXT_WCHAR();
+	}
+
+      next_state = NULL;
+      for (trans_i = state; trans_i->state; trans_i++)
+	{
+	  if (trans_i->code_min <= (tre_cint_t)prev_c
+	      && trans_i->code_max >= (tre_cint_t)prev_c)
+	    {
+	      if (trans_i->assertions
+		  && (CHECK_ASSERTIONS(trans_i->assertions)
+		      || CHECK_CHAR_CLASSES(trans_i, tnfa, eflags)))
+		{
+		  continue;
+		}
+
+	      if (next_state == NULL)
+		{
+		  /* First matching transition. */
+		  next_state = trans_i->state;
+		  next_tags = trans_i->tags;
+		}
+	      else
+		{
+		  /* Second matching transition.  We may need to backtrack here
+		     to take this transition instead of the first one, so we
+		     push this transition in the backtracking stack so we can
+		     jump back here if needed. */
+		  BT_STACK_PUSH(pos, str_byte, 0, trans_i->state,
+				trans_i->state_id, next_c, tags, mbstate);
+		  {
+		    int *tmp;
+		    for (tmp = trans_i->tags; tmp && *tmp >= 0; tmp++)
+		      stack->item.tags[*tmp] = pos;
+		  }
+#if 0 /* XXX - it's important not to look at all transitions here to keep
+	 the stack small! */
+		  break;
+#endif
+		}
+	    }
+	}
+
+      if (next_state != NULL)
+	{
+	  /* Matching transitions were found.  Take the first one. */
+	  state = next_state;
+
+	  /* Update the tag values. */
+	  if (next_tags)
+	    while (*next_tags >= 0)
+	      tags[*next_tags++] = pos;
+	}
+      else
+	{
+	backtrack:
+	  /* A matching transition was not found.  Try to backtrack. */
+	  if (stack->prev)
+	    {
+	      if (stack->item.state->assertions & ASSERT_BACKREF)
+		{
+		  states_seen[stack->item.state_id] = 0;
+		}
+
+	      BT_STACK_POP();
+	    }
+	  else if (match_eo < 0)
+	    {
+	      /* Try starting from a later position in the input string. */
+	      /* Check for end of string. */
+	      if (next_c == L'\0')
+		    {
+		      break;
+		    }
+	      next_c = next_c_start;
+#ifdef TRE_MBSTATE
+	      mbstate = mbstate_start;
+#endif /* TRE_MBSTATE */
+	      str_byte = str_byte_start;
+	      goto retry;
+	    }
+	  else
+	    {
+	      break;
+	    }
+	}
+    }
+
+  ret = match_eo >= 0 ? REG_OK : REG_NOMATCH;
+  *match_end_ofs = match_eo;
+
+ error_exit:
+  tre_bt_mem_destroy(mem);
+#ifndef TRE_USE_ALLOCA
+  if (tags)
+    xfree(tags);
+  if (pmatch)
+    xfree(pmatch);
+  if (states_seen)
+    xfree(states_seen);
+#endif /* !TRE_USE_ALLOCA */
+
+  return ret;
+}
+
+/***********************************************************************
+ from regexec.c
+***********************************************************************/
+
+/* Fills the POSIX.2 regmatch_t array according to the TNFA tag and match
+   endpoint values. */
+static void
+tre_fill_pmatch(size_t nmatch, regmatch_t pmatch[], int cflags,
+		const tre_tnfa_t *tnfa, regoff_t *tags, regoff_t match_eo)
+{
+  tre_submatch_data_t *submatch_data;
+  unsigned int i, j;
+  int *parents;
+
+  i = 0;
+  if (match_eo >= 0 && !(cflags & REG_NOSUB))
+    {
+      /* Construct submatch offsets from the tags. */
+      submatch_data = tnfa->submatch_data;
+      while (i < tnfa->num_submatches && i < nmatch)
+	{
+	  if (submatch_data[i].so_tag == tnfa->end_tag)
+	    pmatch[i].rm_so = match_eo;
+	  else
+	    pmatch[i].rm_so = tags[submatch_data[i].so_tag];
+
+	  if (submatch_data[i].eo_tag == tnfa->end_tag)
+	    pmatch[i].rm_eo = match_eo;
+	  else
+	    pmatch[i].rm_eo = tags[submatch_data[i].eo_tag];
+
+	  /* If either of the endpoints were not used, this submatch
+	     was not part of the match. */
+	  if (pmatch[i].rm_so == -1 || pmatch[i].rm_eo == -1)
+	    pmatch[i].rm_so = pmatch[i].rm_eo = -1;
+
+	  i++;
+	}
+      /* Reset all submatches that are not within all of their parent
+	 submatches. */
+      i = 0;
+      while (i < tnfa->num_submatches && i < nmatch)
+	{
+	  if (pmatch[i].rm_eo == -1)
+	    assert(pmatch[i].rm_so == -1);
+	  assert(pmatch[i].rm_so <= pmatch[i].rm_eo);
+
+	  parents = submatch_data[i].parents;
+	  if (parents != NULL)
+	    for (j = 0; parents[j] >= 0; j++)
+	      {
+		if (pmatch[i].rm_so < pmatch[parents[j]].rm_so
+		    || pmatch[i].rm_eo > pmatch[parents[j]].rm_eo)
+		  pmatch[i].rm_so = pmatch[i].rm_eo = -1;
+	      }
+	  i++;
+	}
+    }
+
+  while (i < nmatch)
+    {
+      pmatch[i].rm_so = -1;
+      pmatch[i].rm_eo = -1;
+      i++;
+    }
+}
+
+
+/*
+  Wrapper functions for POSIX compatible regexp matching.
+*/
+
+int
+regexec(const regex_t *restrict preg, const char *restrict string,
+	  size_t nmatch, regmatch_t pmatch[restrict], int eflags)
+{
+  tre_tnfa_t *tnfa = (void *)preg->TRE_REGEX_T_FIELD;
+  reg_errcode_t status;
+  regoff_t *tags = NULL, eo;
+  if (tnfa->cflags & REG_NOSUB) nmatch = 0;
+  if (tnfa->num_tags > 0 && nmatch > 0)
+    {
+      tags = xmalloc(sizeof(*tags) * tnfa->num_tags);
+      if (tags == NULL)
+	return REG_ESPACE;
+    }
+
+  /* Dispatch to the appropriate matcher. */
+  if (tnfa->have_backrefs)
+    {
+      /* The regex has back references, use the backtracking matcher. */
+      status = tre_tnfa_run_backtrack(tnfa, string, tags, eflags, &eo);
+    }
+  else
+    {
+      /* Exact matching, no back references, use the parallel matcher. */
+      status = tre_tnfa_run_parallel(tnfa, string, tags, eflags, &eo);
+    }
+
+  if (status == REG_OK)
+    /* A match was found, so fill the submatch registers. */
+    tre_fill_pmatch(nmatch, pmatch, tnfa->cflags, tnfa, tags, eo);
+  if (tags)
+    xfree(tags);
+  return status;
+}
diff --git a/third_party/musl/porting/liteos_m/kernel/src/regex/tre-mem.c b/third_party/musl/porting/liteos_m/kernel/src/regex/tre-mem.c
new file mode 100755
index 000000000..86f809d45
--- /dev/null
+++ b/third_party/musl/porting/liteos_m/kernel/src/regex/tre-mem.c
@@ -0,0 +1,158 @@
+/*
+  tre-mem.c - TRE memory allocator
+
+  Copyright (c) 2001-2009 Ville Laurikari <vl@iki.fi>
+  All rights reserved.
+
+  Redistribution and use in source and binary forms, with or without
+  modification, are permitted provided that the following conditions
+  are met:
+
+    1. Redistributions of source code must retain the above copyright
+       notice, this list of conditions and the following disclaimer.
+
+    2. Redistributions in binary form must reproduce the above copyright
+       notice, this list of conditions and the following disclaimer in the
+       documentation and/or other materials provided with the distribution.
+
+  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDER AND CONTRIBUTORS
+  ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+  A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT
+  HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+*/
+
+/*
+  This memory allocator is for allocating small memory blocks efficiently
+  in terms of memory overhead and execution speed.  The allocated blocks
+  cannot be freed individually, only all at once.  There can be multiple
+  allocators, though.
+*/
+
+#include <stdlib.h>
+#include <string.h>
+
+#include "tre.h"
+
+/*
+  This memory allocator is for allocating small memory blocks efficiently
+  in terms of memory overhead and execution speed.  The allocated blocks
+  cannot be freed individually, only all at once.  There can be multiple
+  allocators, though.
+*/
+
+/* Returns a new memory allocator or NULL if out of memory. */
+tre_mem_t
+tre_mem_new_impl(int provided, void *provided_block)
+{
+  tre_mem_t mem;
+  if (provided)
+    {
+      mem = provided_block;
+      memset(mem, 0, sizeof(*mem));
+    }
+  else
+    mem = xcalloc(1, sizeof(*mem));
+  if (mem == NULL)
+    return NULL;
+  return mem;
+}
+
+
+/* Frees the memory allocator and all memory allocated with it. */
+void
+tre_mem_destroy(tre_mem_t mem)
+{
+  tre_list_t *tmp, *l = mem->blocks;
+
+  while (l != NULL)
+    {
+      xfree(l->data);
+      tmp = l->next;
+      xfree(l);
+      l = tmp;
+    }
+  xfree(mem);
+}
+
+
+/* Allocates a block of `size' bytes from `mem'.  Returns a pointer to the
+   allocated block or NULL if an underlying malloc() failed. */
+void *
+tre_mem_alloc_impl(tre_mem_t mem, int provided, void *provided_block,
+		   int zero, size_t size)
+{
+  void *ptr;
+
+  if (mem->failed)
+    {
+      return NULL;
+    }
+
+  if (mem->n < size)
+    {
+      /* We need more memory than is available in the current block.
+	 Allocate a new block. */
+      tre_list_t *l;
+      if (provided)
+	{
+	  if (provided_block == NULL)
+	    {
+	      mem->failed = 1;
+	      return NULL;
+	    }
+	  mem->ptr = provided_block;
+	  mem->n = TRE_MEM_BLOCK_SIZE;
+	}
+      else
+	{
+	  int block_size;
+	  if (size * 8 > TRE_MEM_BLOCK_SIZE)
+	    block_size = size * 8;
+	  else
+	    block_size = TRE_MEM_BLOCK_SIZE;
+	  l = xmalloc(sizeof(*l));
+	  if (l == NULL)
+	    {
+	      mem->failed = 1;
+	      return NULL;
+	    }
+	  l->data = xmalloc(block_size);
+	  if (l->data == NULL)
+	    {
+	      xfree(l);
+	      mem->failed = 1;
+	      return NULL;
+	    }
+	  l->next = NULL;
+	  if (mem->current != NULL)
+	    mem->current->next = l;
+	  if (mem->blocks == NULL)
+	    mem->blocks = l;
+	  mem->current = l;
+	  mem->ptr = l->data;
+	  mem->n = block_size;
+	}
+    }
+
+  /* Make sure the next pointer will be aligned. */
+  size += ALIGN(mem->ptr + size, long);
+
+  /* Allocate from current block. */
+  ptr = mem->ptr;
+  mem->ptr += size;
+  mem->n -= size;
+
+  /* Set to zero if needed. */
+  if (zero)
+    memset(ptr, 0, size);
+
+  return ptr;
+}
diff --git a/third_party/musl/porting/liteos_m/kernel/src/regex/tre.h b/third_party/musl/porting/liteos_m/kernel/src/regex/tre.h
new file mode 100755
index 000000000..6e099375b
--- /dev/null
+++ b/third_party/musl/porting/liteos_m/kernel/src/regex/tre.h
@@ -0,0 +1,232 @@
+/*
+  tre-internal.h - TRE internal definitions
+
+  Copyright (c) 2001-2009 Ville Laurikari <vl@iki.fi>
+  All rights reserved.
+
+  Redistribution and use in source and binary forms, with or without
+  modification, are permitted provided that the following conditions
+  are met:
+
+    1. Redistributions of source code must retain the above copyright
+       notice, this list of conditions and the following disclaimer.
+
+    2. Redistributions in binary form must reproduce the above copyright
+       notice, this list of conditions and the following disclaimer in the
+       documentation and/or other materials provided with the distribution.
+
+  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDER AND CONTRIBUTORS
+  ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+  A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT
+  HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+*/
+
+#include <regex.h>
+#include <wchar.h>
+#include <wctype.h>
+#include "../include/features.h"
+
+#undef  TRE_MBSTATE
+
+#define NDEBUG
+
+#define TRE_REGEX_T_FIELD __opaque
+typedef int reg_errcode_t;
+
+typedef wchar_t tre_char_t;
+
+#define DPRINT(msg) do { } while(0)
+
+#define elementsof(x)	( sizeof(x) / sizeof(x[0]) )
+
+#define tre_mbrtowc(pwc, s, n, ps) (mbtowc((pwc), (s), (n)))
+
+/* Wide characters. */
+typedef wint_t tre_cint_t;
+#define TRE_CHAR_MAX 0x10ffff
+
+#define tre_isalnum iswalnum
+#define tre_isalpha iswalpha
+#define tre_isblank iswblank
+#define tre_iscntrl iswcntrl
+#define tre_isdigit iswdigit
+#define tre_isgraph iswgraph
+#define tre_islower iswlower
+#define tre_isprint iswprint
+#define tre_ispunct iswpunct
+#define tre_isspace iswspace
+#define tre_isupper iswupper
+#define tre_isxdigit iswxdigit
+
+#define tre_tolower towlower
+#define tre_toupper towupper
+#define tre_strlen  wcslen
+
+/* Use system provided iswctype() and wctype(). */
+typedef wctype_t tre_ctype_t;
+#define tre_isctype iswctype
+#define tre_ctype   wctype
+
+/* Returns number of bytes to add to (char *)ptr to make it
+   properly aligned for the type. */
+#define ALIGN(ptr, type) \
+  ((((long)ptr) % sizeof(type)) \
+   ? (sizeof(type) - (((long)ptr) % sizeof(type))) \
+   : 0)
+
+#undef MAX
+#undef MIN
+#define MAX(a, b) (((a) >= (b)) ? (a) : (b))
+#define MIN(a, b) (((a) <= (b)) ? (a) : (b))
+
+/* TNFA transition type. A TNFA state is an array of transitions,
+   the terminator is a transition with NULL `state'. */
+typedef struct tnfa_transition tre_tnfa_transition_t;
+
+struct tnfa_transition {
+  /* Range of accepted characters. */
+  tre_cint_t code_min;
+  tre_cint_t code_max;
+  /* Pointer to the destination state. */
+  tre_tnfa_transition_t *state;
+  /* ID number of the destination state. */
+  int state_id;
+  /* -1 terminated array of tags (or NULL). */
+  int *tags;
+  /* Assertion bitmap. */
+  int assertions;
+  /* Assertion parameters. */
+  union {
+    /* Character class assertion. */
+    tre_ctype_t class;
+    /* Back reference assertion. */
+    int backref;
+  } u;
+  /* Negative character class assertions. */
+  tre_ctype_t *neg_classes;
+};
+
+
+/* Assertions. */
+#define ASSERT_AT_BOL		  1   /* Beginning of line. */
+#define ASSERT_AT_EOL		  2   /* End of line. */
+#define ASSERT_CHAR_CLASS	  4   /* Character class in `class'. */
+#define ASSERT_CHAR_CLASS_NEG	  8   /* Character classes in `neg_classes'. */
+#define ASSERT_AT_BOW		 16   /* Beginning of word. */
+#define ASSERT_AT_EOW		 32   /* End of word. */
+#define ASSERT_AT_WB		 64   /* Word boundary. */
+#define ASSERT_AT_WB_NEG	128   /* Not a word boundary. */
+#define ASSERT_BACKREF		256   /* A back reference in `backref'. */
+#define ASSERT_LAST		256
+
+/* Tag directions. */
+typedef enum {
+  TRE_TAG_MINIMIZE = 0,
+  TRE_TAG_MAXIMIZE = 1
+} tre_tag_direction_t;
+
+/* Instructions to compute submatch register values from tag values
+   after a successful match.  */
+struct tre_submatch_data {
+  /* Tag that gives the value for rm_so (submatch start offset). */
+  int so_tag;
+  /* Tag that gives the value for rm_eo (submatch end offset). */
+  int eo_tag;
+  /* List of submatches this submatch is contained in. */
+  int *parents;
+};
+
+typedef struct tre_submatch_data tre_submatch_data_t;
+
+
+/* TNFA definition. */
+typedef struct tnfa tre_tnfa_t;
+
+struct tnfa {
+  tre_tnfa_transition_t *transitions;
+  unsigned int num_transitions;
+  tre_tnfa_transition_t *initial;
+  tre_tnfa_transition_t *final;
+  tre_submatch_data_t *submatch_data;
+  char *firstpos_chars;
+  int first_char;
+  unsigned int num_submatches;
+  tre_tag_direction_t *tag_directions;
+  int *minimal_tags;
+  int num_tags;
+  int num_minimals;
+  int end_tag;
+  int num_states;
+  int cflags;
+  int have_backrefs;
+  int have_approx;
+};
+
+/* from tre-mem.h: */
+
+#define TRE_MEM_BLOCK_SIZE 1024
+
+typedef struct tre_list {
+  void *data;
+  struct tre_list *next;
+} tre_list_t;
+
+typedef struct tre_mem_struct {
+  tre_list_t *blocks;
+  tre_list_t *current;
+  char *ptr;
+  size_t n;
+  int failed;
+  void **provided;
+} *tre_mem_t;
+
+#define tre_mem_new_impl   __tre_mem_new_impl
+#define tre_mem_alloc_impl __tre_mem_alloc_impl
+#define tre_mem_destroy    __tre_mem_destroy
+
+hidden tre_mem_t tre_mem_new_impl(int provided, void *provided_block);
+hidden void *tre_mem_alloc_impl(tre_mem_t mem, int provided, void *provided_block,
+                                int zero, size_t size);
+
+/* Returns a new memory allocator or NULL if out of memory. */
+#define tre_mem_new()  tre_mem_new_impl(0, NULL)
+
+/* Allocates a block of `size' bytes from `mem'.  Returns a pointer to the
+   allocated block or NULL if an underlying malloc() failed. */
+#define tre_mem_alloc(mem, size) tre_mem_alloc_impl(mem, 0, NULL, 0, size)
+
+/* Allocates a block of `size' bytes from `mem'.  Returns a pointer to the
+   allocated block or NULL if an underlying malloc() failed.  The memory
+   is set to zero. */
+#define tre_mem_calloc(mem, size) tre_mem_alloc_impl(mem, 0, NULL, 1, size)
+
+#ifdef TRE_USE_ALLOCA
+/* alloca() versions.  Like above, but memory is allocated with alloca()
+   instead of malloc(). */
+
+#define tre_mem_newa() \
+  tre_mem_new_impl(1, alloca(sizeof(struct tre_mem_struct)))
+
+#define tre_mem_alloca(mem, size)					      \
+  ((mem)->n >= (size)							      \
+   ? tre_mem_alloc_impl((mem), 1, NULL, 0, (size))			      \
+   : tre_mem_alloc_impl((mem), 1, alloca(TRE_MEM_BLOCK_SIZE), 0, (size)))
+#endif /* TRE_USE_ALLOCA */
+
+
+/* Frees the memory allocator and all memory allocated with it. */
+hidden void tre_mem_destroy(tre_mem_t mem);
+
+#define xmalloc malloc
+#define xcalloc calloc
+#define xfree free
+#define xrealloc realloc
+
diff --git a/third_party/musl/porting/liteos_m/kernel/src/stdio/__fdopen.c b/third_party/musl/porting/liteos_m/kernel/src/stdio/__fdopen.c
new file mode 100755
index 000000000..bc50be7d6
--- /dev/null
+++ b/third_party/musl/porting/liteos_m/kernel/src/stdio/__fdopen.c
@@ -0,0 +1,67 @@
+#include "stdio_impl.h"
+#include <stdlib.h>
+#include <sys/ioctl.h>
+#include <fcntl.h>
+#include <errno.h>
+#include <string.h>
+#include <pthread.h>
+
+int ioctl(int fd, int req, ...)
+{
+	return 0;
+}
+
+FILE *__fdopen(int fd, const char *mode)
+{
+	FILE *f;
+	struct winsize wsz;
+	pthread_mutex_t filelockinit = PTHREAD_RECURSIVE_MUTEX_INITIALIZER_NP;
+
+	/* Check for valid initial mode character */
+	if (!strchr("rwa", *mode)) {
+		errno = EINVAL;
+		return 0;
+	}
+
+	/* Allocate FILE+buffer or fail */
+	if (!(f=malloc(sizeof *f + UNGET + BUFSIZ + sizeof(pthread_mutex_t)))) return 0;
+
+	/* Zero-fill only the struct, not the buffer */
+	memset(f, 0, sizeof *f);
+
+	/* Impose mode restrictions */
+	if (!strchr(mode, '+')) f->flags = (*mode == 'r') ? F_NOWR : F_NORD;
+
+	/* Apply close-on-exec flag */
+	if (strchr(mode, 'e')) fcntl(fd, F_SETFD, FD_CLOEXEC);
+
+	/* Set append mode on fd if opened for append */
+	if (*mode == 'a') {
+		int flags = fcntl(fd, F_GETFL);
+		if (!(flags & O_APPEND))
+			fcntl(fd, F_SETFL, flags | O_APPEND);
+		f->flags |= F_APP;
+	}
+
+	f->fd = fd;
+	f->buf = (unsigned char *)f + sizeof *f + UNGET;
+	f->buf_size = BUFSIZ;
+	f->lock = (pthread_mutex_t *)((unsigned char *)f + sizeof *f + UNGET + BUFSIZ);
+	memcpy(f->lock, &filelockinit, sizeof(pthread_mutex_t));
+
+	/* Activate line buffered mode for terminals */
+	f->lbf = EOF;
+	if (!(f->flags & F_NOWR) && !ioctl(fd, TIOCGWINSZ, &wsz))
+		f->lbf = '\n';
+
+	/* Initialize op ptrs. No problem if some are unneeded. */
+	f->read = __stdio_read;
+	f->write = __stdio_write;
+	f->seek = __stdio_seek;
+	f->close = __stdio_close;
+
+	/* Add new FILE to open file list */
+	return __ofl_add(f);
+}
+
+weak_alias(__fdopen, fdopen);
diff --git a/third_party/musl/porting/liteos_m/kernel/src/stdio/__fmodeflags.c b/third_party/musl/porting/liteos_m/kernel/src/stdio/__fmodeflags.c
new file mode 100755
index 000000000..3c2370a5b
--- /dev/null
+++ b/third_party/musl/porting/liteos_m/kernel/src/stdio/__fmodeflags.c
@@ -0,0 +1,16 @@
+#include <fcntl.h>
+#include <string.h>
+
+int __fmodeflags(const char *mode)
+{
+	int flags;
+	if (strchr(mode, '+')) flags = O_RDWR;
+	else if (*mode == 'r') flags = O_RDONLY;
+	else flags = O_WRONLY;
+	if (strchr(mode, 'x')) flags |= O_EXCL;
+	if (strchr(mode, 'e')) flags |= O_CLOEXEC;
+	if (*mode != 'r') flags |= O_CREAT;
+	if (*mode == 'w') flags |= O_TRUNC;
+	if (*mode == 'a') flags |= O_APPEND;
+	return flags;
+}
diff --git a/third_party/musl/porting/liteos_m/kernel/src/stdio/__lockfile.c b/third_party/musl/porting/liteos_m/kernel/src/stdio/__lockfile.c
new file mode 100755
index 000000000..1399f9699
--- /dev/null
+++ b/third_party/musl/porting/liteos_m/kernel/src/stdio/__lockfile.c
@@ -0,0 +1,12 @@
+#include "stdio_impl.h"
+#include "pthread.h"
+
+int __lockfile(FILE *f)
+{
+	return pthread_mutex_lock((pthread_mutex_t *)f->lock);
+}
+
+int __unlockfile(FILE *f)
+{
+	return pthread_mutex_unlock((pthread_mutex_t *)f->lock);
+}
diff --git a/third_party/musl/porting/liteos_m/kernel/src/stdio/__stdio_close.c b/third_party/musl/porting/liteos_m/kernel/src/stdio/__stdio_close.c
new file mode 100755
index 000000000..c97688b27
--- /dev/null
+++ b/third_party/musl/porting/liteos_m/kernel/src/stdio/__stdio_close.c
@@ -0,0 +1,7 @@
+#include "stdio_impl.h"
+#include <unistd.h>
+
+int __stdio_close(FILE *f)
+{
+	return close(f->fd);
+}
\ No newline at end of file
diff --git a/third_party/musl/porting/liteos_m/kernel/src/stdio/__stdio_read.c b/third_party/musl/porting/liteos_m/kernel/src/stdio/__stdio_read.c
new file mode 100755
index 000000000..fcacffee4
--- /dev/null
+++ b/third_party/musl/porting/liteos_m/kernel/src/stdio/__stdio_read.c
@@ -0,0 +1,25 @@
+#include "stdio_impl.h"
+#include <sys/uio.h>
+#include <unistd.h>
+
+size_t __stdio_read(FILE *f, unsigned char *buf, size_t len)
+{
+	struct iovec iov[2] = {
+		{ .iov_base = buf, .iov_len = len - !!f->buf_size },
+		{ .iov_base = f->buf, .iov_len = f->buf_size }
+	};
+	ssize_t cnt;
+
+	cnt = read(f->fd, iov[0].iov_base, iov[0].iov_len);
+	if (iov[1].iov_len - iov[0].iov_len > 0) cnt += read(f->fd, iov[1].iov_base, iov[1].iov_len - iov[0].iov_len);
+	if (cnt <= 0) {
+		f->flags |= cnt ? F_ERR : F_EOF;
+		return 0;
+	}
+	if (cnt <= iov[0].iov_len) return cnt;
+	cnt -= iov[0].iov_len;
+	f->rpos = f->buf;
+	f->rend = f->buf + cnt;
+	if (f->buf_size) buf[len-1] = *f->rpos++;
+	return len;
+}
\ No newline at end of file
diff --git a/third_party/musl/porting/liteos_m/kernel/src/stdio/__stdio_seek.c b/third_party/musl/porting/liteos_m/kernel/src/stdio/__stdio_seek.c
new file mode 100755
index 000000000..57060258a
--- /dev/null
+++ b/third_party/musl/porting/liteos_m/kernel/src/stdio/__stdio_seek.c
@@ -0,0 +1,53 @@
+#include "stdio_impl.h"
+#include <unistd.h>
+
+#if 0
+static off64_t __stdio_lseek64(int fd, int offsetHigh, int offsetLow, off64_t *result, int whence)
+{
+    off64_t ret;
+    struct file *filep = NULL;
+    off64_t offset = ((off64_t)offsetHigh << 32) + (uint)offsetLow; /* 32: offsetHigh is high 32 bits */
+
+    /* Get the file structure corresponding to the file descriptor. */
+    ret = fs_getfilep(fd, &filep);
+    if (ret < 0) {
+        /* The errno value has already been set */
+        return (off64_t)-get_errno();
+    }
+
+    /* libc seekdir function should set the whence to SEEK_SET, so we can discard
+     * the whence argument here */
+    if (filep->f_oflags & O_DIRECTORY) {
+        /* defensive coding */
+        if (filep->f_dir == NULL) {
+            return (off64_t)-EINVAL;
+        }
+        if (offsetLow == 0) {
+            rewinddir(filep->f_dir);
+        } else {
+            seekdir(filep->f_dir, offsetLow);
+        }
+        ret = telldir(filep->f_dir);
+        if (ret < 0) {
+            return (off64_t)-get_errno();
+        }
+        goto out;
+    }
+
+    /* Then let file_seek do the real work */
+    ret = file_seek64(filep, offset, whence);
+    if (ret < 0) {
+        return (off64_t)-get_errno();
+    }
+
+out:
+    *result = ret;
+
+    return 0;
+}
+#endif
+off_t __stdio_seek(FILE *f, off_t off, int whence)
+{
+	off_t result = 0;
+ 	return lseek(f->fd, (unsigned int)off, whence) ? -1 : result;
+}
diff --git a/third_party/musl/porting/liteos_m/kernel/src/stdio/__stdio_write.c b/third_party/musl/porting/liteos_m/kernel/src/stdio/__stdio_write.c
new file mode 100755
index 000000000..cf9c1d315
--- /dev/null
+++ b/third_party/musl/porting/liteos_m/kernel/src/stdio/__stdio_write.c
@@ -0,0 +1,35 @@
+#include "stdio_impl.h"
+#include <sys/uio.h>
+
+size_t __stdio_write(FILE *f, const unsigned char *buf, size_t len)
+{
+	struct iovec iovs[2] = {
+		{ .iov_base = f->wbase, .iov_len = f->wpos-f->wbase },
+		{ .iov_base = (void *)buf, .iov_len = len }
+	};
+	struct iovec *iov = iovs;
+	size_t rem = iov[0].iov_len + iov[1].iov_len;
+	int iovcnt = 2;
+	ssize_t cnt;
+	for (;;) {
+        cnt = write(f->fd, iov[0].iov_base, iov[0].iov_len);
+		if (0 != iov[1].iov_len)  cnt += write(f->fd, iov[1].iov_base, iov[1].iov_len);
+		if (cnt == rem) {
+			f->wend = f->buf + f->buf_size;
+			f->wpos = f->wbase = f->buf;
+			return len;
+		}
+		if (cnt < 0) {
+			f->wpos = f->wbase = f->wend = 0;
+			f->flags |= F_ERR;
+			return iovcnt == 2 ? 0 : len-iov[0].iov_len;
+		}
+		rem -= cnt;
+		if (cnt > iov[0].iov_len) {
+			cnt -= iov[0].iov_len;
+			iov++; iovcnt--;
+		}
+		iov[0].iov_base = (char *)iov[0].iov_base + cnt;
+		iov[0].iov_len -= cnt;
+	}
+}
\ No newline at end of file
diff --git a/third_party/musl/porting/liteos_m/kernel/src/stdio/__stdout_write.c b/third_party/musl/porting/liteos_m/kernel/src/stdio/__stdout_write.c
new file mode 100755
index 000000000..8205b7b7b
--- /dev/null
+++ b/third_party/musl/porting/liteos_m/kernel/src/stdio/__stdout_write.c
@@ -0,0 +1,11 @@
+#include "stdio_impl.h"
+#include <sys/ioctl.h>
+
+size_t __stdout_write(FILE *f, const unsigned char *buf, size_t len)
+{
+    struct winsize wsz;
+    if (!(f->flags & F_SVB) && ioctl(f->fd, TIOCGWINSZ, &wsz)) {
+        f->lbf = EOF;
+    }
+    return __stdio_write(f, buf, len);
+}
diff --git a/third_party/musl/porting/liteos_m/kernel/src/stdio/__toread.c b/third_party/musl/porting/liteos_m/kernel/src/stdio/__toread.c
new file mode 100755
index 000000000..d2a377e09
--- /dev/null
+++ b/third_party/musl/porting/liteos_m/kernel/src/stdio/__toread.c
@@ -0,0 +1,14 @@
+#include <stdio_impl.h>
+
+int __toread(FILE *f)
+{
+	f->mode |= f->mode-1;
+	if (f->wpos != f->wbase) f->write(f, 0, 0);
+	f->wpos = f->wbase = f->wend = 0;
+	if (f->flags & F_NORD) {
+		f->flags |= F_ERR;
+		return EOF;
+	}
+	f->rpos = f->rend = f->buf + f->buf_size;
+	return (f->flags & F_EOF) ? EOF : 0;
+}
\ No newline at end of file
diff --git a/third_party/musl/porting/liteos_m/kernel/src/stdio/__towrite.c b/third_party/musl/porting/liteos_m/kernel/src/stdio/__towrite.c
new file mode 100755
index 000000000..433a9e677
--- /dev/null
+++ b/third_party/musl/porting/liteos_m/kernel/src/stdio/__towrite.c
@@ -0,0 +1,18 @@
+#include "stdio_impl.h"
+
+int __towrite(FILE *f)
+{
+	f->mode |= f->mode-1;
+	if (f->flags & F_NOWR) {
+		f->flags |= F_ERR;
+		return EOF;
+	}
+	/* Clear read buffer (easier than summoning nasal demons) */
+	f->rpos = f->rend = 0;
+
+	/* Activate write through the buffer. */
+	f->wpos = f->wbase = f->buf;
+	f->wend = f->buf + f->buf_size;
+
+	return 0;
+}
\ No newline at end of file
diff --git a/third_party/musl/porting/liteos_m/kernel/src/stdio/__uflow.c b/third_party/musl/porting/liteos_m/kernel/src/stdio/__uflow.c
new file mode 100755
index 000000000..2a88bca6b
--- /dev/null
+++ b/third_party/musl/porting/liteos_m/kernel/src/stdio/__uflow.c
@@ -0,0 +1,11 @@
+#include "stdio_impl.h"
+
+/* This function assumes it will never be called if there is already
+ * data buffered for reading. */
+
+int __uflow(FILE *f)
+{
+	unsigned char c;
+	if (!__toread(f) && f->read(f, &c, 1)==1) return c;
+	return EOF;
+}
diff --git a/third_party/musl/porting/liteos_m/kernel/src/stdio/clearerr.c b/third_party/musl/porting/liteos_m/kernel/src/stdio/clearerr.c
new file mode 100755
index 000000000..3bf94d307
--- /dev/null
+++ b/third_party/musl/porting/liteos_m/kernel/src/stdio/clearerr.c
@@ -0,0 +1,10 @@
+#include "stdio_impl.h"
+
+void clearerr(FILE *f)
+{
+	FLOCK(f);
+	f->flags &= ~(F_EOF|F_ERR);
+	FUNLOCK(f);
+}
+
+weak_alias(clearerr, clearerr_unlocked);
diff --git a/third_party/musl/porting/liteos_m/kernel/src/stdio/fclose.c b/third_party/musl/porting/liteos_m/kernel/src/stdio/fclose.c
new file mode 100755
index 000000000..46c2cdb32
--- /dev/null
+++ b/third_party/musl/porting/liteos_m/kernel/src/stdio/fclose.c
@@ -0,0 +1,43 @@
+#include "stdio_impl.h"
+#include <stdlib.h>
+
+static void dummy(FILE *f) { }
+weak_alias(dummy, __unlist_locked_file);
+
+int __fclose(FILE *f)
+{
+	int r;
+
+	FLOCK(f);
+	r = fflush(f);
+	r |= f->close(f);
+	FUNLOCK(f);
+
+	/* Past this point, f is closed and any further explict access
+	 * to it is undefined. However, it still exists as an entry in
+	 * the open file list and possibly in the thread's locked files
+	 * list, if it was closed while explicitly locked. Functions
+	 * which process these lists must tolerate dead FILE objects
+	 * (which necessarily have inactive buffer pointers) without
+	 * producing any side effects. */
+
+	if (f->flags & F_PERM) return r;
+
+	FILE **head = __ofl_lock();
+	if (f->prev) f->prev->next = f->next;
+	if (f->next) f->next->prev = f->prev;
+	if (*head == f) *head = f->next;
+	__ofl_unlock();
+
+	free(f->getln_buf);
+	free(f);
+
+	return r;
+}
+weak_alias(__fclose, fclose);
+
+int __wrap_fclose(FILE *f)
+{
+    return __fclose(f);
+}
+
diff --git a/third_party/musl/porting/liteos_m/kernel/src/stdio/feof.c b/third_party/musl/porting/liteos_m/kernel/src/stdio/feof.c
new file mode 100755
index 000000000..56da6b917
--- /dev/null
+++ b/third_party/musl/porting/liteos_m/kernel/src/stdio/feof.c
@@ -0,0 +1,14 @@
+#include "stdio_impl.h"
+
+#undef feof
+
+int feof(FILE *f)
+{
+	FLOCK(f);
+	int ret = !!(f->flags & F_EOF);
+	FUNLOCK(f);
+	return ret;
+}
+
+weak_alias(feof, feof_unlocked);
+weak_alias(feof, _IO_feof_unlocked);
diff --git a/third_party/musl/porting/liteos_m/kernel/src/stdio/fflush.c b/third_party/musl/porting/liteos_m/kernel/src/stdio/fflush.c
new file mode 100755
index 000000000..f2164eec0
--- /dev/null
+++ b/third_party/musl/porting/liteos_m/kernel/src/stdio/fflush.c
@@ -0,0 +1,54 @@
+#include "stdio_impl.h"
+
+/* stdout.c will override this if linked */
+static FILE *volatile dummy = 0;
+weak_alias(dummy, __stdout_used);
+weak_alias(dummy, __stderr_used);
+
+int __fflush(FILE *f)
+{
+	if (!f) {
+		int r = 0;
+		if (__stdout_used) r |= __fflush(__stdout_used);
+		if (__stderr_used) r |= __fflush(__stderr_used);
+
+		for (f=*__ofl_lock(); f; f=f->next) {
+			FLOCK(f);
+			if (f->wpos != f->wbase) r |= __fflush(f);
+			FUNLOCK(f);
+		}
+		__ofl_unlock();
+
+		return r;
+	}
+
+	FLOCK(f);
+
+	/* If writing, flush output */
+	if (f->wpos != f->wbase) {
+		f->write(f, 0, 0);
+		if (!f->wpos) {
+			FUNLOCK(f);
+			return EOF;
+		}
+	}
+
+	/* If reading, sync position, per POSIX */
+	if (f->rpos != f->rend) lseek(f->fd, f->rpos-f->rend, SEEK_CUR);
+
+	/* Clear read and write modes */
+	f->wpos = f->wbase = f->wend = 0;
+	f->rpos = f->rend = 0;
+
+	FUNLOCK(f);
+	return 0;
+}
+
+weak_alias(fflush, fflush_unlocked);
+weak_alias(__fflush, fflush);
+
+int __wrap_fflush(FILE *f)
+{
+    return __fflush(f);
+}
+
diff --git a/third_party/musl/porting/liteos_m/kernel/src/stdio/fgets.c b/third_party/musl/porting/liteos_m/kernel/src/stdio/fgets.c
new file mode 100755
index 000000000..d1109e757
--- /dev/null
+++ b/third_party/musl/porting/liteos_m/kernel/src/stdio/fgets.c
@@ -0,0 +1,46 @@
+#include "stdio_impl.h"
+#include <string.h>
+
+#define MIN(a,b) ((a)<(b) ? (a) : (b))
+
+char *fgets(char *restrict s, int n, FILE *restrict f)
+{
+	char *p = s;
+	unsigned char *z;
+	size_t k;
+	int c;
+
+	FLOCK(f);
+
+	if (n--<=1) {
+		f->mode |= f->mode-1;
+		FUNLOCK(f);
+		if (n) return 0;
+		*s = 0;
+		return s;
+	}
+
+	while (n) {
+		if (f->rpos != f->rend) {
+			z = memchr(f->rpos, '\n', f->rend - f->rpos);
+			k = z ? z - f->rpos + 1 : f->rend - f->rpos;
+			k = MIN(k, (size_t)n);
+			memcpy(p, f->rpos, k);
+			f->rpos += k;
+			p += k;
+			n -= k;
+			if (z || !n) break;
+		}
+		if ((c = getc_unlocked(f)) < 0) {
+			if (p==s || !feof(f)) s = 0;
+			break;
+		}
+		n--;
+		if ((*p++ = c) == '\n') break;
+	}
+	if (s) *p = 0;
+
+	FUNLOCK(f);
+
+	return s;
+}
\ No newline at end of file
diff --git a/third_party/musl/porting/liteos_m/kernel/src/stdio/fileno.c b/third_party/musl/porting/liteos_m/kernel/src/stdio/fileno.c
new file mode 100755
index 000000000..e6e669081
--- /dev/null
+++ b/third_party/musl/porting/liteos_m/kernel/src/stdio/fileno.c
@@ -0,0 +1,14 @@
+#include "stdio_impl.h"
+#include <errno.h>
+
+int fileno(FILE *f)
+{
+	FLOCK(f);
+	int fd = f->fd;
+	FUNLOCK(f);
+	if (fd < 0) {
+		errno = EBADF;
+		return -1;
+	}
+	return fd;
+}
\ No newline at end of file
diff --git a/third_party/musl/porting/liteos_m/kernel/src/stdio/fopen.c b/third_party/musl/porting/liteos_m/kernel/src/stdio/fopen.c
new file mode 100755
index 000000000..7dddf930b
--- /dev/null
+++ b/third_party/musl/porting/liteos_m/kernel/src/stdio/fopen.c
@@ -0,0 +1,42 @@
+#include "stdio_impl.h"
+#include <unistd.h>
+#include <fcntl.h>
+#include <string.h>
+#include <errno.h>
+#include <limits.h>
+
+FILE *fopen(const char *restrict filename, const char *restrict mode)
+{
+	FILE *f;
+	int fd;
+	int flags;
+
+	/* Check for valid initial mode character */
+	if (!strchr("rwa", *mode)) {
+		errno = EINVAL;
+		return 0;
+	}
+
+	/* Compute the flags to pass to open() */
+	flags = __fmodeflags(mode);
+
+	fd = open(filename, flags, 0666);
+	if (fd < 0) return 0;
+	if (flags & O_CLOEXEC)
+		fcntl(fd, F_SETFD, FD_CLOEXEC);
+
+#if !defined(__LP64__)
+	if (fd > SHRT_MAX) {
+		errno = EMFILE;
+		return 0;
+	}
+#endif
+
+	f = __fdopen(fd, mode);
+	if (f) return f;
+
+	close(fd);
+	return 0;
+}
+
+weak_alias(fopen, fopen64);
diff --git a/third_party/musl/porting/liteos_m/kernel/src/stdio/fputs.c b/third_party/musl/porting/liteos_m/kernel/src/stdio/fputs.c
new file mode 100755
index 000000000..1cf344f28
--- /dev/null
+++ b/third_party/musl/porting/liteos_m/kernel/src/stdio/fputs.c
@@ -0,0 +1,10 @@
+#include "stdio_impl.h"
+#include <string.h>
+
+int fputs(const char *restrict s, FILE *restrict f)
+{
+	size_t l = strlen(s);
+	return (fwrite(s, 1, l, f)==l) - 1;
+}
+
+weak_alias(fputs, fputs_unlocked);
diff --git a/third_party/musl/porting/liteos_m/kernel/src/stdio/fread.c b/third_party/musl/porting/liteos_m/kernel/src/stdio/fread.c
new file mode 100755
index 000000000..a2116da61
--- /dev/null
+++ b/third_party/musl/porting/liteos_m/kernel/src/stdio/fread.c
@@ -0,0 +1,38 @@
+#include "stdio_impl.h"
+#include <string.h>
+
+#define MIN(a,b) ((a)<(b) ? (a) : (b))
+
+size_t fread(void *restrict destv, size_t size, size_t nmemb, FILE *restrict f)
+{
+	unsigned char *dest = destv;
+	size_t len = size*nmemb, l = len, k;
+	if (!size) nmemb = 0;
+
+	FLOCK(f);
+
+	f->mode |= f->mode-1;
+
+	if (f->rpos != f->rend) {
+		/* First exhaust the buffer. */
+		k = MIN(f->rend - f->rpos, l);
+		memcpy(dest, f->rpos, k);
+		f->rpos += k;
+		dest += k;
+		l -= k;
+	}
+	
+	/* Read the remainder directly */
+	for (; l; l-=k, dest+=k) {
+		k = __toread(f) ? 0 : f->read(f, dest, l);
+		if (!k) {
+			FUNLOCK(f);
+			return (len-l)/size;
+		}
+	}
+
+	FUNLOCK(f);
+	return nmemb;
+}
+
+weak_alias(fread, fread_unlocked);
diff --git a/third_party/musl/porting/liteos_m/kernel/src/stdio/fseek.c b/third_party/musl/porting/liteos_m/kernel/src/stdio/fseek.c
new file mode 100755
index 000000000..4731d8a09
--- /dev/null
+++ b/third_party/musl/porting/liteos_m/kernel/src/stdio/fseek.c
@@ -0,0 +1,41 @@
+#include "stdio_impl.h"
+
+int __fseeko_unlocked(FILE *f, off_t off, int whence)
+{
+	/* Adjust relative offset for unread data in buffer, if any. */
+	if (whence == SEEK_CUR && f->rend) off -= f->rend - f->rpos;
+
+	/* Flush write buffer, and report error on failure. */
+	if (f->wpos != f->wbase) {
+		f->write(f, 0, 0);
+		if (!f->wpos) return -1;
+	}
+
+	/* Leave writing mode */
+	f->wpos = f->wbase = f->wend = 0;
+
+	/* Perform the underlying seek. */
+	if (lseek(f->fd, off, whence) < 0) return -1;
+
+	/* If seek succeeded, file is seekable and we discard read buffer. */
+	f->rpos = f->rend = 0;
+	f->flags &= ~F_EOF;
+
+	return 0;
+}
+
+int __fseeko(FILE *f, off_t off, int whence)
+{
+	int result;
+	FLOCK(f);
+	result = __fseeko_unlocked(f, off, whence);
+	FUNLOCK(f);
+	return result;
+}
+
+int fseek(FILE *f, long off, int whence)
+{
+	return __fseeko(f, off, whence);
+}
+
+weak_alias(__fseeko, fseeko);
diff --git a/third_party/musl/porting/liteos_m/kernel/src/stdio/ftell.c b/third_party/musl/porting/liteos_m/kernel/src/stdio/ftell.c
new file mode 100755
index 000000000..d15cc6652
--- /dev/null
+++ b/third_party/musl/porting/liteos_m/kernel/src/stdio/ftell.c
@@ -0,0 +1,39 @@
+#include "stdio_impl.h"
+#include <limits.h>
+#include <errno.h>
+
+off_t __ftello_unlocked(FILE *f)
+{
+	off_t pos = lseek(f->fd, 0,
+		(f->flags & F_APP) && f->wpos != f->wbase
+		? SEEK_END : SEEK_CUR);
+	if (pos < 0) return pos;
+
+	/* Adjust for data in buffer. */
+	if (f->rend)
+		pos += f->rpos - f->rend;
+	else if (f->wbase)
+		pos += f->wpos - f->wbase;
+	return pos;
+}
+
+off_t __ftello(FILE *f)
+{
+	off_t pos;
+	FLOCK(f);
+	pos = __ftello_unlocked(f);
+	FUNLOCK(f);
+	return pos;
+}
+
+long ftell(FILE *f)
+{
+	off_t pos = __ftello(f);
+	if (pos > LONG_MAX) {
+		errno = EOVERFLOW;
+		return -1;
+	}
+	return pos;
+}
+
+weak_alias(__ftello, ftello);
diff --git a/third_party/musl/porting/liteos_m/kernel/src/stdio/fwrite.c b/third_party/musl/porting/liteos_m/kernel/src/stdio/fwrite.c
new file mode 100755
index 000000000..7a567b2c5
--- /dev/null
+++ b/third_party/musl/porting/liteos_m/kernel/src/stdio/fwrite.c
@@ -0,0 +1,38 @@
+#include "stdio_impl.h"
+#include <string.h>
+
+size_t __fwritex(const unsigned char *restrict s, size_t l, FILE *restrict f)
+{
+	size_t i=0;
+
+	if (!f->wend && __towrite(f)) return 0;
+
+	if (l > f->wend - f->wpos) return f->write(f, s, l);
+
+	if (f->lbf >= 0) {
+		/* Match /^(.*\n|)/ */
+		for (i=l; i && s[i-1] != '\n'; i--);
+		if (i) {
+			size_t n = f->write(f, s, i);
+			if (n < i) return n;
+			s += i;
+			l -= i;
+		}
+	}
+
+	memcpy(f->wpos, s, l);
+	f->wpos += l;
+	return l+i;
+}
+
+size_t fwrite(const void *restrict src, size_t size, size_t nmemb, FILE *restrict f)
+{
+	size_t k, l = size*nmemb;
+	if (!size) nmemb = 0;
+	FLOCK(f);
+	k = __fwritex(src, l, f);
+	FUNLOCK(f);
+	return k==l ? nmemb : k/size;
+}
+
+weak_alias(fwrite, fwrite_unlocked);
diff --git a/third_party/musl/porting/liteos_m/kernel/src/stdio/ofl.c b/third_party/musl/porting/liteos_m/kernel/src/stdio/ofl.c
new file mode 100755
index 000000000..4dc74ce9e
--- /dev/null
+++ b/third_party/musl/porting/liteos_m/kernel/src/stdio/ofl.c
@@ -0,0 +1,28 @@
+#include "stdio_impl.h"
+#include <pthread.h>
+
+static FILE *ofl_head;
+
+static pthread_mutex_t locallock = PTHREAD_RECURSIVE_MUTEX_INITIALIZER_NP;
+
+static int LOCK(void)
+{
+    return pthread_mutex_lock(&locallock);
+}
+
+static void UNLOCK(void)
+{
+    (void)pthread_mutex_unlock(&locallock);
+}
+
+
+FILE **__ofl_lock()
+{
+	LOCK();
+	return &ofl_head;
+}
+
+void __ofl_unlock()
+{
+	UNLOCK();
+}
diff --git a/third_party/musl/porting/liteos_m/kernel/src/stdio/ofl_add.c b/third_party/musl/porting/liteos_m/kernel/src/stdio/ofl_add.c
new file mode 100755
index 000000000..d7de9f15a
--- /dev/null
+++ b/third_party/musl/porting/liteos_m/kernel/src/stdio/ofl_add.c
@@ -0,0 +1,11 @@
+#include "stdio_impl.h"
+
+FILE *__ofl_add(FILE *f)
+{
+	FILE **head = __ofl_lock();
+	f->next = *head;
+	if (*head) (*head)->prev = f;
+	*head = f;
+	__ofl_unlock();
+	return f;
+}
diff --git a/third_party/musl/porting/liteos_m/kernel/src/stdio/perror.c b/third_party/musl/porting/liteos_m/kernel/src/stdio/perror.c
new file mode 100755
index 000000000..03ffeab8d
--- /dev/null
+++ b/third_party/musl/porting/liteos_m/kernel/src/stdio/perror.c
@@ -0,0 +1,30 @@
+#include <stdio.h>
+#include <string.h>
+#include <errno.h>
+#include "stdio_impl.h"
+
+void perror(const char *msg)
+{
+	FILE *f = stderr;
+	char *errstr = strerror(errno);
+
+	FLOCK(f);
+
+	/* Save stderr's orientation and encoding rule, since perror is not
+	 * permitted to change them. */
+	void *old_locale = f->locale;
+	int old_mode = f->mode;
+
+	if (msg && *msg) {
+		fwrite(msg, strlen(msg), 1, f);
+		fputc(':', f);
+		fputc(' ', f);
+	}
+	fwrite(errstr, strlen(errstr), 1, f);
+	fputc('\n', f);
+
+	f->mode = old_mode;
+	f->locale = old_locale;
+
+	FUNLOCK(f);
+}
diff --git a/third_party/musl/porting/liteos_m/kernel/src/stdio/rewind.c b/third_party/musl/porting/liteos_m/kernel/src/stdio/rewind.c
new file mode 100755
index 000000000..6387b9959
--- /dev/null
+++ b/third_party/musl/porting/liteos_m/kernel/src/stdio/rewind.c
@@ -0,0 +1,9 @@
+#include "stdio_impl.h"
+
+void rewind(FILE *f)
+{
+    FLOCK(f);
+    __fseeko_unlocked(f, 0, SEEK_SET);
+    f->flags &= ~F_ERR;
+    FUNLOCK(f);
+}
diff --git a/third_party/musl/porting/liteos_m/kernel/src/stdio/stderr.c b/third_party/musl/porting/liteos_m/kernel/src/stdio/stderr.c
new file mode 100755
index 000000000..008ab0105
--- /dev/null
+++ b/third_party/musl/porting/liteos_m/kernel/src/stdio/stderr.c
@@ -0,0 +1,20 @@
+#include "stdio_impl.h"
+#include <pthread.h>
+
+#undef stderr
+
+static pthread_mutex_t locallock = PTHREAD_RECURSIVE_MUTEX_INITIALIZER_NP;
+static unsigned char buf[UNGET];
+hidden FILE __stderr_FILE = {
+	.buf = buf+UNGET,
+	.buf_size = 0,
+	.fd = 2,
+	.flags = F_PERM | F_NORD,
+	.lbf = -1,
+	.write = __stdio_write,
+	.seek = __stdio_seek,
+	.close = __stdio_close,
+	.lock = &locallock,
+};
+FILE *const stderr = &__stderr_FILE;
+FILE *volatile __stderr_used = &__stderr_FILE;
diff --git a/third_party/musl/porting/liteos_m/kernel/src/stdio/stdin.c b/third_party/musl/porting/liteos_m/kernel/src/stdio/stdin.c
new file mode 100755
index 000000000..5aa5262c2
--- /dev/null
+++ b/third_party/musl/porting/liteos_m/kernel/src/stdio/stdin.c
@@ -0,0 +1,17 @@
+#include "stdio_impl.h"
+
+#undef stdin
+
+static unsigned char buf[BUFSIZ+UNGET];
+hidden FILE __stdin_FILE = {
+	.buf = buf+UNGET,
+	.buf_size = sizeof buf-UNGET,
+	.fd = 0,
+	.flags = F_PERM | F_NOWR,
+	.read = __stdio_read,
+	.seek = __stdio_seek,
+	.close = __stdio_close,
+	.lock = -1,
+};
+FILE *const stdin = &__stdin_FILE;
+FILE *volatile __stdin_used = &__stdin_FILE;
diff --git a/third_party/musl/porting/liteos_m/kernel/src/stdio/stdout.c b/third_party/musl/porting/liteos_m/kernel/src/stdio/stdout.c
new file mode 100755
index 000000000..226fffceb
--- /dev/null
+++ b/third_party/musl/porting/liteos_m/kernel/src/stdio/stdout.c
@@ -0,0 +1,20 @@
+#include "stdio_impl.h"
+#include <pthread.h>
+
+#undef stdout
+
+static pthread_mutex_t locallock = PTHREAD_RECURSIVE_MUTEX_INITIALIZER_NP;
+static unsigned char buf[BUFSIZ+UNGET];
+hidden FILE __stdout_FILE = {
+	.buf = buf+UNGET,
+	.buf_size = sizeof buf-UNGET,
+	.fd = 1,
+	.flags = F_PERM | F_NORD,
+	.lbf = '\n',
+	.write = __stdout_write,
+	.seek = __stdio_seek,
+	.close = __stdio_close,
+	.lock = &locallock,
+};
+FILE *const stdout = &__stdout_FILE;
+FILE *volatile __stdout_used = &__stdout_FILE;
diff --git a/third_party/musl/porting/liteos_m/kernel/src/stdlib/abs.c b/third_party/musl/porting/liteos_m/kernel/src/stdlib/abs.c
new file mode 100755
index 000000000..e721fdc2b
--- /dev/null
+++ b/third_party/musl/porting/liteos_m/kernel/src/stdlib/abs.c
@@ -0,0 +1,6 @@
+#include <stdlib.h>
+
+int abs(int a)
+{
+	return a>0 ? a : -a;
+}
diff --git a/third_party/musl/porting/liteos_m/kernel/src/stdlib/atoi.c b/third_party/musl/porting/liteos_m/kernel/src/stdlib/atoi.c
new file mode 100755
index 000000000..9baca7b89
--- /dev/null
+++ b/third_party/musl/porting/liteos_m/kernel/src/stdlib/atoi.c
@@ -0,0 +1,16 @@
+#include <stdlib.h>
+#include <ctype.h>
+
+int atoi(const char *s)
+{
+	int n=0, neg=0;
+	while (isspace(*s)) s++;
+	switch (*s) {
+	case '-': neg=1;
+	case '+': s++;
+	}
+	/* Compute n as a negative number to avoid overflow on INT_MIN */
+	while (isdigit(*s))
+		n = 10*n - (*s++ - '0');
+	return neg ? n : -n;
+}
diff --git a/third_party/musl/porting/liteos_m/kernel/src/stdlib/atol.c b/third_party/musl/porting/liteos_m/kernel/src/stdlib/atol.c
new file mode 100755
index 000000000..140ea3ea3
--- /dev/null
+++ b/third_party/musl/porting/liteos_m/kernel/src/stdlib/atol.c
@@ -0,0 +1,17 @@
+#include <stdlib.h>
+#include <ctype.h>
+
+long atol(const char *s)
+{
+	long n=0;
+	int neg=0;
+	while (isspace(*s)) s++;
+	switch (*s) {
+	case '-': neg=1;
+	case '+': s++;
+	}
+	/* Compute n as a negative number to avoid overflow on LONG_MIN */
+	while (isdigit(*s))
+		n = 10*n - (*s++ - '0');
+	return neg ? n : -n;
+}
diff --git a/third_party/musl/porting/liteos_m/kernel/src/stdlib/atoll.c b/third_party/musl/porting/liteos_m/kernel/src/stdlib/atoll.c
new file mode 100755
index 000000000..b69304895
--- /dev/null
+++ b/third_party/musl/porting/liteos_m/kernel/src/stdlib/atoll.c
@@ -0,0 +1,17 @@
+#include <stdlib.h>
+#include <ctype.h>
+
+long long atoll(const char *s)
+{
+	long long n=0;
+	int neg=0;
+	while (isspace(*s)) s++;
+	switch (*s) {
+	case '-': neg=1;
+	case '+': s++;
+	}
+	/* Compute n as a negative number to avoid overflow on LLONG_MIN */
+	while (isdigit(*s))
+		n = 10*n - (*s++ - '0');
+	return neg ? n : -n;
+}
diff --git a/third_party/musl/porting/liteos_m/kernel/src/stdlib/strtol.c b/third_party/musl/porting/liteos_m/kernel/src/stdlib/strtol.c
new file mode 100755
index 000000000..4a3f7942e
--- /dev/null
+++ b/third_party/musl/porting/liteos_m/kernel/src/stdlib/strtol.c
@@ -0,0 +1,38 @@
+#include "stdio_impl.h"
+#include "intscan.h"
+#include "shgetc.h"
+#include <inttypes.h>
+#include <limits.h>
+#include <ctype.h>
+
+static unsigned long long strtox(const char *s, char **p, int base, unsigned long long lim)
+{
+	FILE f;
+	sh_fromstring(&f, s);
+	shlim(&f, 0);
+	unsigned long long y = __intscan(&f, base, 1, lim);
+	if (p) {
+		size_t cnt = shcnt(&f);
+		*p = (char *)s + cnt;
+	}
+	return y;
+}
+
+unsigned long long strtoull(const char *restrict s, char **restrict p, int base)
+{
+	return strtox(s, p, base, ULLONG_MAX);
+}
+
+unsigned long strtoul(const char *restrict s, char **restrict p, int base)
+{
+	return strtox(s, p, base, ULONG_MAX);
+}
+
+long strtol(const char *restrict s, char **restrict p, int base)
+{
+	return strtox(s, p, base, 0UL+LONG_MIN);
+}
+
+weak_alias(strtol, __strtol_internal);
+weak_alias(strtoul, __strtoul_internal);
+weak_alias(strtoull, __strtoull_internal);
diff --git a/third_party/musl/porting/liteos_m/kernel/src/string/memchr.c b/third_party/musl/porting/liteos_m/kernel/src/string/memchr.c
new file mode 100755
index 000000000..65f0d789b
--- /dev/null
+++ b/third_party/musl/porting/liteos_m/kernel/src/string/memchr.c
@@ -0,0 +1,27 @@
+#include <string.h>
+#include <stdint.h>
+#include <limits.h>
+
+#define SS (sizeof(size_t))
+#define ALIGN (sizeof(size_t)-1)
+#define ONES ((size_t)-1/UCHAR_MAX)
+#define HIGHS (ONES * (UCHAR_MAX/2+1))
+#define HASZERO(x) ((x)-ONES & ~(x) & HIGHS)
+
+void *memchr(const void *src, int c, size_t n)
+{
+	const unsigned char *s = src;
+	c = (unsigned char)c;
+#ifdef __GNUC__
+	for (; ((uintptr_t)s & ALIGN) && n && *s != c; s++, n--);
+	if (n && *s != c) {
+		typedef size_t __attribute__((__may_alias__)) word;
+		const word *w;
+		size_t k = ONES * c;
+		for (w = (const void *)s; n>=SS && !HASZERO(*w^k); w++, n-=SS);
+		s = (const void *)w;
+	}
+#endif
+	for (; n && *s != c; s++, n--);
+	return n ? (void *)s : 0;
+}
diff --git a/third_party/musl/porting/liteos_m/kernel/src/string/memcmp.c b/third_party/musl/porting/liteos_m/kernel/src/string/memcmp.c
new file mode 100755
index 000000000..bdbce9f0f
--- /dev/null
+++ b/third_party/musl/porting/liteos_m/kernel/src/string/memcmp.c
@@ -0,0 +1,8 @@
+#include <string.h>
+
+int memcmp(const void *vl, const void *vr, size_t n)
+{
+	const unsigned char *l=vl, *r=vr;
+	for (; n && *l == *r; n--, l++, r++);
+	return n ? *l-*r : 0;
+}
diff --git a/third_party/musl/porting/liteos_m/kernel/src/string/memcpy.c b/third_party/musl/porting/liteos_m/kernel/src/string/memcpy.c
new file mode 100755
index 000000000..06e88742b
--- /dev/null
+++ b/third_party/musl/porting/liteos_m/kernel/src/string/memcpy.c
@@ -0,0 +1,124 @@
+#include <string.h>
+#include <stdint.h>
+#include <endian.h>
+
+void *memcpy(void *restrict dest, const void *restrict src, size_t n)
+{
+	unsigned char *d = dest;
+	const unsigned char *s = src;
+
+#ifdef __GNUC__
+
+#if __BYTE_ORDER == __LITTLE_ENDIAN
+#define LS >>
+#define RS <<
+#else
+#define LS <<
+#define RS >>
+#endif
+
+	typedef uint32_t __attribute__((__may_alias__)) u32;
+	uint32_t w, x;
+
+	for (; (uintptr_t)s % 4 && n; n--) *d++ = *s++;
+
+	if ((uintptr_t)d % 4 == 0) {
+		for (; n>=16; s+=16, d+=16, n-=16) {
+			*(u32 *)(d+0) = *(u32 *)(s+0);
+			*(u32 *)(d+4) = *(u32 *)(s+4);
+			*(u32 *)(d+8) = *(u32 *)(s+8);
+			*(u32 *)(d+12) = *(u32 *)(s+12);
+		}
+		if (n&8) {
+			*(u32 *)(d+0) = *(u32 *)(s+0);
+			*(u32 *)(d+4) = *(u32 *)(s+4);
+			d += 8; s += 8;
+		}
+		if (n&4) {
+			*(u32 *)(d+0) = *(u32 *)(s+0);
+			d += 4; s += 4;
+		}
+		if (n&2) {
+			*d++ = *s++; *d++ = *s++;
+		}
+		if (n&1) {
+			*d = *s;
+		}
+		return dest;
+	}
+
+	if (n >= 32) switch ((uintptr_t)d % 4) {
+	case 1:
+		w = *(u32 *)s;
+		*d++ = *s++;
+		*d++ = *s++;
+		*d++ = *s++;
+		n -= 3;
+		for (; n>=17; s+=16, d+=16, n-=16) {
+			x = *(u32 *)(s+1);
+			*(u32 *)(d+0) = (w LS 24) | (x RS 8);
+			w = *(u32 *)(s+5);
+			*(u32 *)(d+4) = (x LS 24) | (w RS 8);
+			x = *(u32 *)(s+9);
+			*(u32 *)(d+8) = (w LS 24) | (x RS 8);
+			w = *(u32 *)(s+13);
+			*(u32 *)(d+12) = (x LS 24) | (w RS 8);
+		}
+		break;
+	case 2:
+		w = *(u32 *)s;
+		*d++ = *s++;
+		*d++ = *s++;
+		n -= 2;
+		for (; n>=18; s+=16, d+=16, n-=16) {
+			x = *(u32 *)(s+2);
+			*(u32 *)(d+0) = (w LS 16) | (x RS 16);
+			w = *(u32 *)(s+6);
+			*(u32 *)(d+4) = (x LS 16) | (w RS 16);
+			x = *(u32 *)(s+10);
+			*(u32 *)(d+8) = (w LS 16) | (x RS 16);
+			w = *(u32 *)(s+14);
+			*(u32 *)(d+12) = (x LS 16) | (w RS 16);
+		}
+		break;
+	case 3:
+		w = *(u32 *)s;
+		*d++ = *s++;
+		n -= 1;
+		for (; n>=19; s+=16, d+=16, n-=16) {
+			x = *(u32 *)(s+3);
+			*(u32 *)(d+0) = (w LS 8) | (x RS 24);
+			w = *(u32 *)(s+7);
+			*(u32 *)(d+4) = (x LS 8) | (w RS 24);
+			x = *(u32 *)(s+11);
+			*(u32 *)(d+8) = (w LS 8) | (x RS 24);
+			w = *(u32 *)(s+15);
+			*(u32 *)(d+12) = (x LS 8) | (w RS 24);
+		}
+		break;
+	}
+	if (n&16) {
+		*d++ = *s++; *d++ = *s++; *d++ = *s++; *d++ = *s++;
+		*d++ = *s++; *d++ = *s++; *d++ = *s++; *d++ = *s++;
+		*d++ = *s++; *d++ = *s++; *d++ = *s++; *d++ = *s++;
+		*d++ = *s++; *d++ = *s++; *d++ = *s++; *d++ = *s++;
+	}
+	if (n&8) {
+		*d++ = *s++; *d++ = *s++; *d++ = *s++; *d++ = *s++;
+		*d++ = *s++; *d++ = *s++; *d++ = *s++; *d++ = *s++;
+	}
+	if (n&4) {
+		*d++ = *s++; *d++ = *s++; *d++ = *s++; *d++ = *s++;
+	}
+	if (n&2) {
+		*d++ = *s++; *d++ = *s++;
+	}
+	if (n&1) {
+		*d = *s;
+	}
+	return dest;
+#endif
+
+	for (; n; n--) *d++ = *s++;
+	return dest;
+}
diff --git a/third_party/musl/porting/liteos_m/kernel/src/string/memrchr.c b/third_party/musl/porting/liteos_m/kernel/src/string/memrchr.c
new file mode 100755
index 000000000..d62bb6258
--- /dev/null
+++ b/third_party/musl/porting/liteos_m/kernel/src/string/memrchr.c
@@ -0,0 +1,10 @@
+#include <string.h>
+
+void *__memrchr(const void *m, int c, size_t n)
+{
+	const unsigned char *s = m;
+	c = (unsigned char)c;
+	while (n--) if (s[n]==c) return (void *)(s+n);
+	return 0;
+}
+
diff --git a/third_party/musl/porting/liteos_m/kernel/src/string/memset.c b/third_party/musl/porting/liteos_m/kernel/src/string/memset.c
new file mode 100755
index 000000000..5613a1486
--- /dev/null
+++ b/third_party/musl/porting/liteos_m/kernel/src/string/memset.c
@@ -0,0 +1,90 @@
+#include <string.h>
+#include <stdint.h>
+
+void *memset(void *dest, int c, size_t n)
+{
+	unsigned char *s = dest;
+	size_t k;
+
+	/* Fill head and tail with minimal branching. Each
+	 * conditional ensures that all the subsequently used
+	 * offsets are well-defined and in the dest region. */
+
+	if (!n) return dest;
+	s[0] = c;
+	s[n-1] = c;
+	if (n <= 2) return dest;
+	s[1] = c;
+	s[2] = c;
+	s[n-2] = c;
+	s[n-3] = c;
+	if (n <= 6) return dest;
+	s[3] = c;
+	s[n-4] = c;
+	if (n <= 8) return dest;
+
+	/* Advance pointer to align it at a 4-byte boundary,
+	 * and truncate n to a multiple of 4. The previous code
+	 * already took care of any head/tail that get cut off
+	 * by the alignment. */
+
+	k = -(uintptr_t)s & 3;
+	s += k;
+	n -= k;
+	n &= -4;
+
+#ifdef __GNUC__
+	typedef uint32_t __attribute__((__may_alias__)) u32;
+	typedef uint64_t __attribute__((__may_alias__)) u64;
+
+	u32 c32 = ((u32)-1)/255 * (unsigned char)c;
+
+	/* In preparation to copy 32 bytes at a time, aligned on
+	 * an 8-byte bounary, fill head/tail up to 28 bytes each.
+	 * As in the initial byte-based head/tail fill, each
+	 * conditional below ensures that the subsequent offsets
+	 * are valid (e.g. !(n<=24) implies n>=28). */
+
+	*(u32 *)(s+0) = c32;
+	*(u32 *)(s+n-4) = c32;
+	if (n <= 8) return dest;
+	*(u32 *)(s+4) = c32;
+	*(u32 *)(s+8) = c32;
+	*(u32 *)(s+n-12) = c32;
+	*(u32 *)(s+n-8) = c32;
+	if (n <= 24) return dest;
+	*(u32 *)(s+12) = c32;
+	*(u32 *)(s+16) = c32;
+	*(u32 *)(s+20) = c32;
+	*(u32 *)(s+24) = c32;
+	*(u32 *)(s+n-28) = c32;
+	*(u32 *)(s+n-24) = c32;
+	*(u32 *)(s+n-20) = c32;
+	*(u32 *)(s+n-16) = c32;
+
+	/* Align to a multiple of 8 so we can fill 64 bits at a time,
+	 * and avoid writing the same bytes twice as much as is
+	 * practical without introducing additional branching. */
+
+	k = 24 + ((uintptr_t)s & 4);
+	s += k;
+	n -= k;
+
+	/* If this loop is reached, 28 tail bytes have already been
+	 * filled, so any remainder when n drops below 32 can be
+	 * safely ignored. */
+
+	u64 c64 = c32 | ((u64)c32 << 32);
+	for (; n >= 32; n-=32, s+=32) {
+		*(u64 *)(s+0) = c64;
+		*(u64 *)(s+8) = c64;
+		*(u64 *)(s+16) = c64;
+		*(u64 *)(s+24) = c64;
+	}
+#else
+	/* Pure C fallback with no aliasing violations. */
+	for (; n; n--, s++) *s = c;
+#endif
+
+	return dest;
+}
diff --git a/third_party/musl/porting/liteos_m/kernel/src/string/strcasecmp.c b/third_party/musl/porting/liteos_m/kernel/src/string/strcasecmp.c
new file mode 100755
index 000000000..fe34ad5cc
--- /dev/null
+++ b/third_party/musl/porting/liteos_m/kernel/src/string/strcasecmp.c
@@ -0,0 +1,16 @@
+#include <strings.h>
+#include <ctype.h>
+
+int strcasecmp(const char *_l, const char *_r)
+{
+	const unsigned char *l=(void *)_l, *r=(void *)_r;
+	for (; *l && *r && (*l == *r || tolower(*l) == tolower(*r)); l++, r++);
+	return tolower(*l) - tolower(*r);
+}
+
+int __strcasecmp_l(const char *l, const char *r, locale_t loc)
+{
+	return strcasecmp(l, r);
+}
+
+weak_alias(__strcasecmp_l, strcasecmp_l);
\ No newline at end of file
diff --git a/third_party/musl/porting/liteos_m/kernel/src/string/strchr.c b/third_party/musl/porting/liteos_m/kernel/src/string/strchr.c
new file mode 100755
index 000000000..3cbc828be
--- /dev/null
+++ b/third_party/musl/porting/liteos_m/kernel/src/string/strchr.c
@@ -0,0 +1,7 @@
+#include <string.h>
+
+char *strchr(const char *s, int c)
+{
+	char *r = __strchrnul(s, c);
+	return *(unsigned char *)r == (unsigned char)c ? r : 0;
+}
diff --git a/third_party/musl/porting/liteos_m/kernel/src/string/strchrnul.c b/third_party/musl/porting/liteos_m/kernel/src/string/strchrnul.c
new file mode 100755
index 000000000..39e2635b3
--- /dev/null
+++ b/third_party/musl/porting/liteos_m/kernel/src/string/strchrnul.c
@@ -0,0 +1,28 @@
+#include <string.h>
+#include <stdint.h>
+#include <limits.h>
+
+#define ALIGN (sizeof(size_t))
+#define ONES ((size_t)-1/UCHAR_MAX)
+#define HIGHS (ONES * (UCHAR_MAX/2+1))
+#define HASZERO(x) ((x)-ONES & ~(x) & HIGHS)
+
+char *__strchrnul(const char *s, int c)
+{
+	c = (unsigned char)c;
+	if (!c) return (char *)s + strlen(s);
+
+#ifdef __GNUC__
+	typedef size_t __attribute__((__may_alias__)) word;
+	const word *w;
+	for (; (uintptr_t)s % ALIGN; s++)
+		if (!*s || *(unsigned char *)s == c) return (char *)s;
+	size_t k = ONES * c;
+	for (w = (void *)s; !HASZERO(*w) && !HASZERO(*w^k); w++);
+	s = (void *)w;
+#endif
+	for (; *s && *(unsigned char *)s != c; s++);
+	return (char *)s;
+}
+
+weak_alias(__strchrnul, strchrnul);
diff --git a/third_party/musl/porting/liteos_m/kernel/src/string/strcmp.c b/third_party/musl/porting/liteos_m/kernel/src/string/strcmp.c
new file mode 100755
index 000000000..808bd8370
--- /dev/null
+++ b/third_party/musl/porting/liteos_m/kernel/src/string/strcmp.c
@@ -0,0 +1,7 @@
+#include <string.h>
+
+int strcmp(const char *l, const char *r)
+{
+	for (; *l==*r && *l; l++, r++);
+	return *(unsigned char *)l - *(unsigned char *)r;
+}
diff --git a/third_party/musl/porting/liteos_m/kernel/src/string/strcspn.c b/third_party/musl/porting/liteos_m/kernel/src/string/strcspn.c
new file mode 100755
index 000000000..75e262b25
--- /dev/null
+++ b/third_party/musl/porting/liteos_m/kernel/src/string/strcspn.c
@@ -0,0 +1,17 @@
+#include "../include/string.h"
+
+#define BITOP(a,b,op) \
+ ((a)[(size_t)(b)/(8*sizeof *(a))] op (size_t)1<<((size_t)(b)%(8*sizeof *(a))))
+
+size_t strcspn(const char *s, const char *c)
+{
+	const char *a = s;
+	size_t byteset[32/sizeof(size_t)];
+
+	if (!c[0] || !c[1]) return __strchrnul(s, *c)-a;
+
+	memset(byteset, 0, sizeof byteset);
+	for (; *c && BITOP(byteset, *(unsigned char *)c, |=); c++);
+	for (; *s && !BITOP(byteset, *(unsigned char *)s, &); s++);
+	return s-a;
+}
diff --git a/third_party/musl/porting/liteos_m/kernel/src/string/strdup.c b/third_party/musl/porting/liteos_m/kernel/src/string/strdup.c
new file mode 100755
index 000000000..d4c274494
--- /dev/null
+++ b/third_party/musl/porting/liteos_m/kernel/src/string/strdup.c
@@ -0,0 +1,10 @@
+#include <stdlib.h>
+#include <string.h>
+
+char *strdup(const char *s)
+{
+	size_t l = strlen(s);
+	char *d = malloc(l+1);
+	if (!d) return NULL;
+	return memcpy(d, s, l+1);
+}
diff --git a/third_party/musl/porting/liteos_m/kernel/src/string/strlen.c b/third_party/musl/porting/liteos_m/kernel/src/string/strlen.c
new file mode 100755
index 000000000..309990f02
--- /dev/null
+++ b/third_party/musl/porting/liteos_m/kernel/src/string/strlen.c
@@ -0,0 +1,22 @@
+#include <string.h>
+#include <stdint.h>
+#include <limits.h>
+
+#define ALIGN (sizeof(size_t))
+#define ONES ((size_t)-1/UCHAR_MAX)
+#define HIGHS (ONES * (UCHAR_MAX/2+1))
+#define HASZERO(x) ((x)-ONES & ~(x) & HIGHS)
+
+size_t strlen(const char *s)
+{
+	const char *a = s;
+#ifdef __GNUC__
+	typedef size_t __attribute__((__may_alias__)) word;
+	const word *w;
+	for (; (uintptr_t)s % ALIGN; s++) if (!*s) return s-a;
+	for (w = (const void *)s; !HASZERO(*w); w++);
+	s = (const void *)w;
+#endif
+	for (; *s; s++);
+	return s-a;
+}
diff --git a/third_party/musl/porting/liteos_m/kernel/src/string/strncasecmp.c b/third_party/musl/porting/liteos_m/kernel/src/string/strncasecmp.c
new file mode 100755
index 000000000..24659721d
--- /dev/null
+++ b/third_party/musl/porting/liteos_m/kernel/src/string/strncasecmp.c
@@ -0,0 +1,10 @@
+#include <strings.h>
+#include <ctype.h>
+
+int strncasecmp(const char *_l, const char *_r, size_t n)
+{
+	const unsigned char *l=(void *)_l, *r=(void *)_r;
+	if (!n--) return 0;
+	for (; *l && *r && n && (*l == *r || tolower(*l) == tolower(*r)); l++, r++, n--);
+	return tolower(*l) - tolower(*r);
+}
diff --git a/third_party/musl/porting/liteos_m/kernel/src/string/strncmp.c b/third_party/musl/porting/liteos_m/kernel/src/string/strncmp.c
new file mode 100755
index 000000000..e228843f0
--- /dev/null
+++ b/third_party/musl/porting/liteos_m/kernel/src/string/strncmp.c
@@ -0,0 +1,9 @@
+#include <string.h>
+
+int strncmp(const char *_l, const char *_r, size_t n)
+{
+	const unsigned char *l=(void *)_l, *r=(void *)_r;
+	if (!n--) return 0;
+	for (; *l && *r && n && *l == *r ; l++, r++, n--);
+	return *l - *r;
+}
diff --git a/third_party/musl/porting/liteos_m/kernel/src/string/strrchr.c b/third_party/musl/porting/liteos_m/kernel/src/string/strrchr.c
new file mode 100755
index 000000000..98ad1b045
--- /dev/null
+++ b/third_party/musl/porting/liteos_m/kernel/src/string/strrchr.c
@@ -0,0 +1,6 @@
+#include <string.h>
+
+char *strrchr(const char *s, int c)
+{
+	return __memrchr(s, c, strlen(s) + 1);
+}
diff --git a/third_party/musl/porting/liteos_m/kernel/src/string/strstr.c b/third_party/musl/porting/liteos_m/kernel/src/string/strstr.c
new file mode 100755
index 000000000..55ba1c7b4
--- /dev/null
+++ b/third_party/musl/porting/liteos_m/kernel/src/string/strstr.c
@@ -0,0 +1,154 @@
+#include <string.h>
+#include <stdint.h>
+
+static char *twobyte_strstr(const unsigned char *h, const unsigned char *n)
+{
+	uint16_t nw = n[0]<<8 | n[1], hw = h[0]<<8 | h[1];
+	for (h++; *h && hw != nw; hw = hw<<8 | *++h);
+	return *h ? (char *)h-1 : 0;
+}
+
+static char *threebyte_strstr(const unsigned char *h, const unsigned char *n)
+{
+	uint32_t nw = n[0]<<24 | n[1]<<16 | n[2]<<8;
+	uint32_t hw = h[0]<<24 | h[1]<<16 | h[2]<<8;
+	for (h+=2; *h && hw != nw; hw = (hw|*++h)<<8);
+	return *h ? (char *)h-2 : 0;
+}
+
+static char *fourbyte_strstr(const unsigned char *h, const unsigned char *n)
+{
+	uint32_t nw = n[0]<<24 | n[1]<<16 | n[2]<<8 | n[3];
+	uint32_t hw = h[0]<<24 | h[1]<<16 | h[2]<<8 | h[3];
+	for (h+=3; *h && hw != nw; hw = hw<<8 | *++h);
+	return *h ? (char *)h-3 : 0;
+}
+
+#define MAX(a,b) ((a)>(b)?(a):(b))
+#define MIN(a,b) ((a)<(b)?(a):(b))
+
+#define BITOP(a,b,op) \
+ ((a)[(size_t)(b)/(8*sizeof *(a))] op (size_t)1<<((size_t)(b)%(8*sizeof *(a))))
+
+static char *twoway_strstr(const unsigned char *h, const unsigned char *n)
+{
+	const unsigned char *z;
+	size_t l, ip, jp, k, p, ms, p0, mem, mem0;
+	size_t byteset[32 / sizeof(size_t)] = { 0 };
+	size_t shift[256];
+
+	/* Computing length of needle and fill shift table */
+	for (l=0; n[l] && h[l]; l++)
+		BITOP(byteset, n[l], |=), shift[n[l]] = l+1;
+	if (n[l]) return 0; /* hit the end of h */
+
+	/* Compute maximal suffix */
+	ip = -1; jp = 0; k = p = 1;
+	while (jp+k<l) {
+		if (n[ip+k] == n[jp+k]) {
+			if (k == p) {
+				jp += p;
+				k = 1;
+			} else k++;
+		} else if (n[ip+k] > n[jp+k]) {
+			jp += k;
+			k = 1;
+			p = jp - ip;
+		} else {
+			ip = jp++;
+			k = p = 1;
+		}
+	}
+	ms = ip;
+	p0 = p;
+
+	/* And with the opposite comparison */
+	ip = -1; jp = 0; k = p = 1;
+	while (jp+k<l) {
+		if (n[ip+k] == n[jp+k]) {
+			if (k == p) {
+				jp += p;
+				k = 1;
+			} else k++;
+		} else if (n[ip+k] < n[jp+k]) {
+			jp += k;
+			k = 1;
+			p = jp - ip;
+		} else {
+			ip = jp++;
+			k = p = 1;
+		}
+	}
+	if (ip+1 > ms+1) ms = ip;
+	else p = p0;
+
+	/* Periodic needle? */
+	if (memcmp(n, n+p, ms+1)) {
+		mem0 = 0;
+		p = MAX(ms, l-ms-1) + 1;
+	} else mem0 = l-p;
+	mem = 0;
+
+	/* Initialize incremental end-of-haystack pointer */
+	z = h;
+
+	/* Search loop */
+	for (;;) {
+		/* Update incremental end-of-haystack pointer */
+		if (z-h < l) {
+			/* Fast estimate for MIN(l,63) */
+			size_t grow = l | 63;
+			const unsigned char *z2 = memchr(z, 0, grow);
+			if (z2) {
+				z = z2;
+				if (z-h < l) return 0;
+			} else z += grow;
+		}
+
+		/* Check last byte first; advance by shift on mismatch */
+		if (BITOP(byteset, h[l-1], &)) {
+			k = l-shift[h[l-1]];
+			if (k) {
+				if (k < mem) k = mem;
+				h += k;
+				mem = 0;
+				continue;
+			}
+		} else {
+			h += l;
+			mem = 0;
+			continue;
+		}
+
+		/* Compare right half */
+		for (k=MAX(ms+1,mem); n[k] && n[k] == h[k]; k++);
+		if (n[k]) {
+			h += k-ms;
+			mem = 0;
+			continue;
+		}
+		/* Compare left half */
+		for (k=ms+1; k>mem && n[k-1] == h[k-1]; k--);
+		if (k <= mem) return (char *)h;
+		h += p;
+		mem = mem0;
+	}
+}
+
+char *strstr(const char *h, const char *n)
+{
+	/* Return immediately on empty needle */
+	if (!n[0]) return (char *)h;
+
+	/* Use faster algorithms for short needles */
+	h = strchr(h, *n);
+	if (!h || !n[1]) return (char *)h;
+	if (!h[1]) return 0;
+	if (!n[2]) return twobyte_strstr((void *)h, (void *)n);
+	if (!h[2]) return 0;
+	if (!n[3]) return threebyte_strstr((void *)h, (void *)n);
+	if (!h[3]) return 0;
+	if (!n[4]) return fourbyte_strstr((void *)h, (void *)n);
+
+	return twoway_strstr((void *)h, (void *)n);
+}
diff --git a/third_party/musl/porting/liteos_m/kernel/src/string/wcschr.c b/third_party/musl/porting/liteos_m/kernel/src/string/wcschr.c
new file mode 100755
index 000000000..8dfc2f318
--- /dev/null
+++ b/third_party/musl/porting/liteos_m/kernel/src/string/wcschr.c
@@ -0,0 +1,8 @@
+#include <wchar.h>
+
+wchar_t *wcschr(const wchar_t *s, wchar_t c)
+{
+	if (!c) return (wchar_t *)s + wcslen(s);
+	for (; *s && *s != c; s++);
+	return *s ? (wchar_t *)s : 0;
+}
diff --git a/third_party/musl/porting/liteos_m/kernel/src/string/wcslen.c b/third_party/musl/porting/liteos_m/kernel/src/string/wcslen.c
new file mode 100755
index 000000000..1b7b66550
--- /dev/null
+++ b/third_party/musl/porting/liteos_m/kernel/src/string/wcslen.c
@@ -0,0 +1,8 @@
+#include <wchar.h>
+
+size_t wcslen(const wchar_t *s)
+{
+	const wchar_t *a;
+	for (a=s; *s; s++);
+	return s-a;
+}
diff --git a/third_party/musl/porting/liteos_m/kernel/src/time/__month_to_secs.c b/third_party/musl/porting/liteos_m/kernel/src/time/__month_to_secs.c
new file mode 100755
index 000000000..43248fb3c
--- /dev/null
+++ b/third_party/musl/porting/liteos_m/kernel/src/time/__month_to_secs.c
@@ -0,0 +1,10 @@
+int __month_to_secs(int month, int is_leap)
+{
+	static const int secs_through_month[] = {
+		0, 31*86400, 59*86400, 90*86400,
+		120*86400, 151*86400, 181*86400, 212*86400,
+		243*86400, 273*86400, 304*86400, 334*86400 };
+	int t = secs_through_month[month];
+	if (is_leap && month >= 2) t+=86400;
+	return t;
+}
diff --git a/third_party/musl/porting/liteos_m/kernel/src/time/__tm_to_secs.c b/third_party/musl/porting/liteos_m/kernel/src/time/__tm_to_secs.c
new file mode 100755
index 000000000..c29fa985a
--- /dev/null
+++ b/third_party/musl/porting/liteos_m/kernel/src/time/__tm_to_secs.c
@@ -0,0 +1,24 @@
+#include "time_impl.h"
+
+long long __tm_to_secs(const struct tm *tm)
+{
+	int is_leap;
+	long long year = tm->tm_year;
+	int month = tm->tm_mon;
+	if (month >= 12 || month < 0) {
+		int adj = month / 12;
+		month %= 12;
+		if (month < 0) {
+			adj--;
+			month += 12;
+		}
+		year += adj;
+	}
+	long long t = __year_to_secs(year, &is_leap);
+	t += __month_to_secs(month, is_leap);
+	t += 86400LL * (tm->tm_mday-1);
+	t += 3600LL * tm->tm_hour;
+	t += 60LL * tm->tm_min;
+	t += tm->tm_sec;
+	return t;
+}
diff --git a/third_party/musl/porting/liteos_m/kernel/src/time/__tz.c b/third_party/musl/porting/liteos_m/kernel/src/time/__tz.c
new file mode 100755
index 000000000..49c2f4bf8
--- /dev/null
+++ b/third_party/musl/porting/liteos_m/kernel/src/time/__tz.c
@@ -0,0 +1,234 @@
+#include "time_impl.h"
+#include <stdint.h>
+#include <limits.h>
+#include <stdlib.h>
+#include <string.h>
+#include <sys/mman.h>
+#include "libc.h"
+#include <pthread.h>
+
+long  __timezone = 0;
+int   __daylight = 0;
+char *__tzname[2] = { 0, 0 };
+
+weak_alias(__timezone, timezone);
+weak_alias(__daylight, daylight);
+weak_alias(__tzname, tzname);
+
+#ifndef PTHREAD_RECURSIVE_MUTEX_INITIALIZER_NP
+#define  PTHREAD_RECURSIVE_MUTEX_INITIALIZER_NP PTHREAD_MUTEX_INITIALIZER
+#endif
+
+static pthread_mutex_t locallock = PTHREAD_RECURSIVE_MUTEX_INITIALIZER_NP;
+
+static int LOCK(void)
+{
+	return pthread_mutex_lock(&locallock);
+}
+
+static void UNLOCK(void)
+{
+	(void)pthread_mutex_unlock(&locallock);
+}
+
+
+const char __utc[] = "UTC";
+
+static int dst_off;
+static int r0[5], r1[5];
+
+static const unsigned char *zi, *trans, *index_local, *types, *abbrevs, *abbrevs_end;
+
+#define VEC(...) ((const unsigned char[]){__VA_ARGS__})
+
+static uint32_t zi_read32(const unsigned char *z)
+{
+	return (unsigned)z[0]<<24 | z[1]<<16 | z[2]<<8 | z[3];
+}
+
+static void do_tzset(void)
+{
+}
+
+/* Search zoneinfo rules to find the one that applies to the given time,
+ * and determine alternate opposite-DST-status rule that may be needed. */
+
+static size_t scan_trans(long long t, int local, size_t *alt)
+{
+	int scale = 3 - (trans == zi+44);
+	uint64_t x;
+	int off = 0;
+
+	size_t a = 0, n = (index_local-trans)>>scale, m;
+
+	if (!n) {
+		if (alt) *alt = 0;
+		return 0;
+	}
+
+	/* Binary search for 'most-recent rule before t'. */
+	while (n > 1) {
+		m = a + n/2;
+		x = zi_read32(trans + (m<<scale));
+		if (scale == 3) x = x<<32 | zi_read32(trans + (m<<scale) + 4);
+		else x = (int32_t)x;
+		if (local) off = (int32_t)zi_read32(types + 6 * index_local[m-1]);
+		if (t - off < (int64_t)x) {
+			n /= 2;
+		} else {
+			a = m;
+			n -= n/2;
+		}
+	}
+
+	/* First and last entry are special. First means to use lowest-index_local
+	 * non-DST type. Last means to apply POSIX-style rule if available. */
+	n = (index_local-trans)>>scale;
+	if (a == n-1) return -1;
+	if (a == 0) {
+		x = zi_read32(trans + (a<<scale));
+		if (scale == 3) x = x<<32 | zi_read32(trans + (a<<scale) + 4);
+		else x = (int32_t)x;
+		if (local) off = (int32_t)zi_read32(types + 6 * index_local[a-1]);
+		if (t - off < (int64_t)x) {
+			for (a=0; a<(abbrevs-types)/6; a++) {
+				if (types[6*a+4] != types[4]) break;
+			}
+			if (a == (abbrevs-types)/6) a = 0;
+			if (types[6*a+4]) {
+				*alt = a;
+				return 0;
+			} else {
+				*alt = 0;
+				return a;
+			}
+		}
+	}
+
+	/* Try to find a neighboring opposite-DST-status rule. */
+	if (alt) {
+		if (a && types[6*index_local[a-1]+4] != types[6*index_local[a]+4])
+			*alt = index_local[a-1];
+		else if (a+1<n && types[6*index_local[a+1]+4] != types[6*index_local[a]+4])
+			*alt = index_local[a+1];
+		else
+			*alt = index_local[a];
+	}
+
+	return index_local[a];
+}
+
+static int days_in_month(int m, int is_leap)
+{
+	if (m==2) return 28+is_leap;
+	else return 30+((0xad5>>(m-1))&1);
+}
+
+/* Convert a POSIX DST rule plus year to seconds since epoch. */
+
+static long long rule_to_secs(const int *rule, int year)
+{
+	int is_leap;
+	long long t = __year_to_secs(year, &is_leap);
+	int x, m, n, d;
+	if (rule[0]!='M') {
+		x = rule[1];
+		if (rule[0]=='J' && (x < 60 || !is_leap)) x--;
+		t += 86400 * x;
+	} else {
+		m = rule[1];
+		n = rule[2];
+		d = rule[3];
+		t += __month_to_secs(m-1, is_leap);
+		int wday = (int)((t + 4*86400) % (7*86400)) / 86400;
+		int days = d - wday;
+		if (days < 0) days += 7;
+		if (n == 5 && days+28 >= days_in_month(m, is_leap)) n = 4;
+		t += 86400 * (days + 7*(n-1));
+	}
+	t += rule[4];
+	return t;
+}
+
+/* Determine the time zone in effect for a given time in seconds since the
+ * epoch. It can be given in local or universal time. The results will
+ * indicate whether DST is in effect at the queried time, and will give both
+ * the GMT offset for the active zone/DST rule and the opposite DST. This
+ * enables a caller to efficiently adjust for the case where an explicit
+ * DST specification mismatches what would be in effect at the time. */
+
+void __secs_to_zone(long long t, int local, int *isdst, long *offset, long *oppoff, const char **zonename)
+{
+	LOCK();
+
+	do_tzset();
+
+	if (zi) {
+		size_t alt, i = scan_trans(t, local, &alt);
+		if (i != -1) {
+			*isdst = types[6*i+4];
+			*offset = (int32_t)zi_read32(types+6*i);
+			*zonename = (const char *)abbrevs + types[6*i+5];
+			if (oppoff) *oppoff = (int32_t)zi_read32(types+6*alt);
+			UNLOCK();
+			return;
+		}
+	}
+
+	if (!__daylight) goto std;
+
+	/* FIXME: may be broken if DST changes right at year boundary?
+	 * Also, this could be more efficient.*/
+	long long y = t / 31556952 + 70;
+	while (__year_to_secs(y, 0) > t) y--;
+	while (__year_to_secs(y+1, 0) < t) y++;
+
+	long long t0 = rule_to_secs(r0, y);
+	long long t1 = rule_to_secs(r1, y);
+
+	if (!local) {
+		t0 += __timezone;
+		t1 += dst_off;
+	}
+	if (t0 < t1) {
+		if (t >= t0 && t < t1) goto dst;
+		goto std;
+	} else {
+		if (t >= t1 && t < t0) goto std;
+		goto dst;
+	}
+std:
+	*isdst = 0;
+	*offset = -__timezone;
+	if (oppoff) *oppoff = -dst_off;
+	*zonename = __tzname[0];
+	UNLOCK();
+	return;
+dst:
+	*isdst = 1;
+	*offset = -dst_off;
+	if (oppoff) *oppoff = -__timezone;
+	*zonename = __tzname[1];
+	UNLOCK();
+}
+
+static void __tzset(void)
+{
+	LOCK();
+	do_tzset();
+	UNLOCK();
+}
+
+weak_alias(__tzset, tzset);
+
+const char *__tm_to_tzname(const struct tm *tm)
+{
+	const void *p = tm->__tm_zone;
+	LOCK();
+	do_tzset();
+	if (p != __utc && p != __tzname[0] && p != __tzname[1] &&
+	    (!zi || (uintptr_t)p-(uintptr_t)abbrevs >= abbrevs_end - abbrevs))
+		p = "";
+	UNLOCK();
+	return p;
+}
diff --git a/third_party/musl/porting/liteos_m/kernel/src/time/__year_to_secs.c b/third_party/musl/porting/liteos_m/kernel/src/time/__year_to_secs.c
new file mode 100755
index 000000000..2824ec6dc
--- /dev/null
+++ b/third_party/musl/porting/liteos_m/kernel/src/time/__year_to_secs.c
@@ -0,0 +1,47 @@
+long long __year_to_secs(long long year, int *is_leap)
+{
+	if (year-2ULL <= 136) {
+		int y = year;
+		int leaps = (y-68)>>2;
+		if (!((y-68)&3)) {
+			leaps--;
+			if (is_leap) *is_leap = 1;
+		} else if (is_leap) *is_leap = 0;
+		return 31536000*(y-70) + 86400*leaps;
+	}
+
+	int cycles, centuries, leaps, rem;
+
+	if (!is_leap) is_leap = &(int){0};
+	cycles = (year-100) / 400;
+	rem = (year-100) % 400;
+	if (rem < 0) {
+		cycles--;
+		rem += 400;
+	}
+	if (!rem) {
+		*is_leap = 1;
+		centuries = 0;
+		leaps = 0;
+	} else {
+		if (rem >= 200) {
+			if (rem >= 300) centuries = 3, rem -= 300;
+			else centuries = 2, rem -= 200;
+		} else {
+			if (rem >= 100) centuries = 1, rem -= 100;
+			else centuries = 0;
+		}
+		if (!rem) {
+			*is_leap = 0;
+			leaps = 0;
+		} else {
+			leaps = rem / 4U;
+			rem %= 4U;
+			*is_leap = !rem;
+		}
+	}
+
+	leaps += 97*cycles + 24*centuries - *is_leap;
+
+	return (year-100) * 31536000LL + leaps * 86400LL + 946684800 + 86400;
+}
diff --git a/third_party/musl/porting/liteos_m/kernel/src/time/strftime.c b/third_party/musl/porting/liteos_m/kernel/src/time/strftime.c
new file mode 100755
index 000000000..cc53d5369
--- /dev/null
+++ b/third_party/musl/porting/liteos_m/kernel/src/time/strftime.c
@@ -0,0 +1,281 @@
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <langinfo.h>
+#include <locale.h>
+#include <time.h>
+#include <limits.h>
+#include "locale_impl.h"
+#include "time_impl.h"
+
+static int is_leap(int y)
+{
+	/* Avoid overflow */
+	if (y>INT_MAX-1900) y -= 2000;
+	y += 1900;
+	return !(y%4) && ((y%100) || !(y%400));
+}
+
+static int week_num(const struct tm *tm)
+{
+	int val = (tm->tm_yday + 7U - (tm->tm_wday+6U)%7) / 7;
+	/* If 1 Jan is just 1-3 days past Monday,
+	 * the previous week is also in this year. */
+	if ((tm->tm_wday + 371U - tm->tm_yday - 2) % 7 <= 2)
+		val++;
+	if (!val) {
+		val = 52;
+		/* If 31 December of prev year a Thursday,
+		 * or Friday of a leap year, then the
+		 * prev year has 53 weeks. */
+		int dec31 = (tm->tm_wday + 7U - tm->tm_yday - 1) % 7;
+		if (dec31 == 4 || (dec31 == 5 && is_leap(tm->tm_year%400-1)))
+			val++;
+	} else if (val == 53) {
+		/* If 1 January is not a Thursday, and not
+		 * a Wednesday of a leap year, then this
+		 * year has only 52 weeks. */
+		int jan1 = (tm->tm_wday + 371U - tm->tm_yday) % 7;
+		if (jan1 != 4 && (jan1 != 3 || !is_leap(tm->tm_year)))
+			val = 1;
+	}
+	return val;
+}
+
+const char *__strftime_fmt_1(char (*s)[100], size_t *l, int f, const struct tm *tm, locale_t loc, int pad)
+{
+	nl_item item;
+	long long val;
+	const char *fmt = "-";
+	int width = 2, def_pad = '0';
+
+	switch (f) {
+	case 'a':
+		if (tm->tm_wday > 6U) goto string;
+		item = ABDAY_1 + tm->tm_wday;
+		goto nl_strcat;
+	case 'A':
+		if (tm->tm_wday > 6U) goto string;
+		item = DAY_1 + tm->tm_wday;
+		goto nl_strcat;
+	case 'h':
+	case 'b':
+		if (tm->tm_mon > 11U) goto string;
+		item = ABMON_1 + tm->tm_mon;
+		goto nl_strcat;
+	case 'B':
+		if (tm->tm_mon > 11U) goto string;
+		item = MON_1 + tm->tm_mon;
+		goto nl_strcat;
+	case 'c':
+		item = D_T_FMT;
+		goto nl_strftime;
+	case 'C':
+		val = (1900LL+tm->tm_year) / 100;
+		goto number;
+	case 'e':
+		def_pad = '_';
+	case 'd':
+		val = tm->tm_mday;
+		goto number;
+	case 'D':
+		fmt = "%m/%d/%y";
+		goto recu_strftime;
+	case 'F':
+		fmt = "%Y-%m-%d";
+		goto recu_strftime;
+	case 'g':
+	case 'G':
+		val = tm->tm_year + 1900LL;
+		if (tm->tm_yday < 3 && week_num(tm) != 1) val--;
+		else if (tm->tm_yday > 360 && week_num(tm) == 1) val++;
+		if (f=='g') val %= 100;
+		else width = 4;
+		goto number;
+	case 'H':
+		val = tm->tm_hour;
+		goto number;
+	case 'I':
+		val = tm->tm_hour;
+		if (!val) val = 12;
+		else if (val > 12) val -= 12;
+		goto number;
+	case 'j':
+		val = tm->tm_yday+1;
+		width = 3;
+		goto number;
+	case 'm':
+		val = tm->tm_mon+1;
+		goto number;
+	case 'M':
+		val = tm->tm_min;
+		goto number;
+	case 'n':
+		*l = 1;
+		return "\n";
+	case 'p':
+		item = tm->tm_hour >= 12 ? PM_STR : AM_STR;
+		goto nl_strcat;
+	case 'r':
+		item = T_FMT_AMPM;
+		goto nl_strftime;
+	case 'R':
+		fmt = "%H:%M";
+		goto recu_strftime;
+	case 's':
+		val = __tm_to_secs(tm) - tm->__tm_gmtoff;
+		width = 1;
+		goto number;
+	case 'S':
+		val = tm->tm_sec;
+		goto number;
+	case 't':
+		*l = 1;
+		return "\t";
+	case 'T':
+		fmt = "%H:%M:%S";
+		goto recu_strftime;
+	case 'u':
+		val = tm->tm_wday ? tm->tm_wday : 7;
+		width = 1;
+		goto number;
+	case 'U':
+		val = (tm->tm_yday + 7U - tm->tm_wday) / 7;
+		goto number;
+	case 'W':
+		val = (tm->tm_yday + 7U - (tm->tm_wday+6U)%7) / 7;
+		goto number;
+	case 'V':
+		val = week_num(tm);
+		goto number;
+	case 'w':
+		val = tm->tm_wday;
+		width = 1;
+		goto number;
+	case 'x':
+		item = D_FMT;
+		goto nl_strftime;
+	case 'X':
+		item = T_FMT;
+		goto nl_strftime;
+	case 'y':
+		val = (tm->tm_year + 1900LL) % 100;
+		if (val < 0) val = -val;
+		goto number;
+	case 'Y':
+		val = tm->tm_year + 1900LL;
+		if (val >= 10000) {
+			*l = snprintf(*s, sizeof *s, "+%lld", val);
+			return *s;
+		}
+		width = 4;
+		goto number;
+	case 'z':
+		if (tm->tm_isdst < 0) {
+			*l = 0;
+			return "";
+		}
+		*l = snprintf(*s, sizeof *s, "%+.4ld",
+			tm->__tm_gmtoff/3600*100 + tm->__tm_gmtoff%3600/60);
+		return *s;
+	case 'Z':
+		if (tm->tm_isdst < 0) {
+			*l = 0;
+			return "";
+		}
+		fmt = __tm_to_tzname(tm);
+		goto string;
+	case '%':
+		*l = 1;
+		return "%";
+	default:
+		return 0;
+	}
+number:
+	switch (pad ? pad : def_pad) {
+	case '-': *l = snprintf(*s, sizeof *s, "%lld", val); break;
+	case '_': *l = snprintf(*s, sizeof *s, "%*lld", width, val); break;
+	case '0':
+	default:  *l = snprintf(*s, sizeof *s, "%0*lld", width, val); break;
+	}
+	return *s;
+nl_strcat:
+	fmt = __nl_langinfo_l(item, loc);
+string:
+	*l = strlen(fmt);
+	return fmt;
+nl_strftime:
+	fmt = __nl_langinfo_l(item, loc);
+recu_strftime:
+	*l = __strftime_l(*s, sizeof *s, fmt, tm, loc);
+	if (!*l) return 0;
+	return *s;
+}
+
+size_t __strftime_l(char *restrict s, size_t n, const char *restrict f, const struct tm *restrict tm, locale_t loc)
+{
+	size_t l, k;
+	char buf[100];
+	char *p;
+	const char *t;
+	int pad, plus;
+	unsigned long width;
+	for (l=0; l<n; f++) {
+		if (!*f) {
+			s[l] = 0;
+			return l;
+		}
+		if (*f != '%') {
+			s[l++] = *f;
+			continue;
+		}
+		f++;
+		pad = 0;
+		if (*f == '-' || *f == '_' || *f == '0') pad = *f++;
+		if ((plus = (*f == '+'))) f++;
+		width = strtoul(f, &p, 10);
+		if (*p == 'C' || *p == 'F' || *p == 'G' || *p == 'Y') {
+			if (!width && p!=f) width = 1;
+		} else {
+			width = 0;
+		}
+		f = p;
+		if (*f == 'E' || *f == 'O') f++;
+		t = __strftime_fmt_1(&buf, &k, *f, tm, loc, pad);
+		if (!t) break;
+		if (width) {
+			/* Trim off any sign and leading zeros, then
+			 * count remaining digits to determine behavior
+			 * for the + flag. */
+			if (*t=='+' || *t=='-') t++, k--;
+			for (; *t=='0' && t[1]-'0'<10U; t++, k--);
+			if (width < k) width = k;
+			size_t d;
+			for (d=0; t[d]-'0'<10U; d++);
+			if (tm->tm_year < -1900) {
+				s[l++] = '-';
+				width--;
+			} else if (plus && d+(width-k) >= (*p=='C'?3:5)) {
+				s[l++] = '+';
+				width--;
+			}
+			for (; width > k && l < n; width--)
+				s[l++] = '0';
+		}
+		if (k > n-l) k = n-l;
+		memcpy(s+l, t, k);
+		l += k;
+	}
+	if (n) {
+		if (l==n) l=n-1;
+		s[l] = 0;
+	}
+	return 0;
+}
+
+size_t strftime(char *restrict s, size_t n, const char *restrict f, const struct tm *restrict tm)
+{
+	return __strftime_l(s, n, f, tm, CURRENT_LOCALE);
+}
+
+weak_alias(__strftime_l, strftime_l);
diff --git a/third_party/musl/porting/liteos_m/kernel/src/time/strptime.c b/third_party/musl/porting/liteos_m/kernel/src/time/strptime.c
new file mode 100755
index 000000000..d4b8f2534
--- /dev/null
+++ b/third_party/musl/porting/liteos_m/kernel/src/time/strptime.c
@@ -0,0 +1,206 @@
+#include <stdlib.h>
+#include <langinfo.h>
+#include <time.h>
+#include <ctype.h>
+#include <stddef.h>
+#include <string.h>
+#include <strings.h>
+
+char *strptime(const char *restrict s, const char *restrict f, struct tm *restrict tm)
+{
+	int i, w, neg, adj, min, range, *dest, dummy;
+	const char *ex;
+	size_t len;
+	int want_century = 0, century = 0, relyear = 0;
+	while (*f) {
+		if (*f != '%') {
+			if (isspace(*f)) for (; *s && isspace(*s); s++);
+			else if (*s != *f) return 0;
+			else s++;
+			f++;
+			continue;
+		}
+		f++;
+		if (*f == '+') f++;
+		if (isdigit(*f)) {
+			char *new_f;
+			w=strtoul(f, &new_f, 10);
+			f = new_f;
+		} else {
+			w=-1;
+		}
+		adj=0;
+		switch (*f++) {
+		case 'a': case 'A':
+			dest = &tm->tm_wday;
+			min = ABDAY_1;
+			range = 7;
+			goto symbolic_range;
+		case 'b': case 'B': case 'h':
+			dest = &tm->tm_mon;
+			min = ABMON_1;
+			range = 12;
+			goto symbolic_range;
+		case 'c':
+			s = strptime(s, nl_langinfo(D_T_FMT), tm);
+			if (!s) return 0;
+			break;
+		case 'C':
+			dest = &century;
+			if (w<0) w=2;
+			want_century |= 2;
+			goto numeric_digits;
+		case 'd': case 'e':
+			dest = &tm->tm_mday;
+			min = 1;
+			range = 31;
+			goto numeric_range;
+		case 'D':
+			s = strptime(s, "%m/%d/%y", tm);
+			if (!s) return 0;
+			break;
+		case 'H':
+			dest = &tm->tm_hour;
+			min = 0;
+			range = 24;
+			goto numeric_range;
+		case 'I':
+			dest = &tm->tm_hour;
+			min = 1;
+			range = 12;
+			goto numeric_range;
+		case 'j':
+			dest = &tm->tm_yday;
+			min = 1;
+			range = 366;
+			adj = 1;
+			goto numeric_range;
+		case 'm':
+			dest = &tm->tm_mon;
+			min = 1;
+			range = 12;
+			adj = 1;
+			goto numeric_range;
+		case 'M':
+			dest = &tm->tm_min;
+			min = 0;
+			range = 60;
+			goto numeric_range;
+		case 'n': case 't':
+			for (; *s && isspace(*s); s++);
+			break;
+		case 'p':
+			ex = nl_langinfo(AM_STR);
+			len = strlen(ex);
+			if (!strncasecmp(s, ex, len)) {
+				tm->tm_hour %= 12;
+				s += len;
+				break;
+			}
+			ex = nl_langinfo(PM_STR);
+			len = strlen(ex);
+			if (!strncasecmp(s, ex, len)) {
+				tm->tm_hour %= 12;
+				tm->tm_hour += 12;
+				s += len;
+				break;
+			}
+			return 0;
+		case 'r':
+			s = strptime(s, nl_langinfo(T_FMT_AMPM), tm);
+			if (!s) return 0;
+			break;
+		case 'R':
+			s = strptime(s, "%H:%M", tm);
+			if (!s) return 0;
+			break;
+		case 'S':
+			dest = &tm->tm_sec;
+			min = 0;
+			range = 61;
+			goto numeric_range;
+		case 'T':
+			s = strptime(s, "%H:%M:%S", tm);
+			if (!s) return 0;
+			break;
+		case 'U':
+		case 'W':
+			/* Throw away result, for now. (FIXME?) */
+			dest = &dummy;
+			min = 0;
+			range = 54;
+			goto numeric_range;
+		case 'w':
+			dest = &tm->tm_wday;
+			min = 0;
+			range = 7;
+			goto numeric_range;
+		case 'x':
+			s = strptime(s, nl_langinfo(D_FMT), tm);
+			if (!s) return 0;
+			break;
+		case 'X':
+			s = strptime(s, nl_langinfo(T_FMT), tm);
+			if (!s) return 0;
+			break;
+		case 'y':
+			dest = &relyear;
+			w = 2;
+			want_century |= 1;
+			goto numeric_digits;
+		case 'Y':
+			dest = &tm->tm_year;
+			if (w<0) w=4;
+			adj = 1900;
+			want_century = 0;
+			goto numeric_digits;
+		case '%':
+			if (*s++ != '%') return 0;
+			break;
+		default:
+			return 0;
+		numeric_range:
+			if (!isdigit(*s)) return 0;
+			*dest = 0;
+			for (i=1; i<=min+range && isdigit(*s); i*=10)
+				*dest = *dest * 10 + *s++ - '0';
+			if (*dest - min >= (int)range) return 0;
+			*dest -= adj;
+			switch((char *)dest - (char *)tm) {
+			case offsetof(struct tm, tm_yday):
+				;
+			}
+			goto update;
+		numeric_digits:
+			neg = 0;
+			if (*s == '+') s++;
+			else if (*s == '-') neg=1, s++;
+			if (!isdigit(*s)) return 0;
+			for (*dest=i=0; i<w && isdigit(*s); i++)
+				*dest = *dest * 10 + *s++ - '0';
+			if (neg) *dest = -*dest;
+			*dest -= adj;
+			goto update;
+		symbolic_range:
+			for (i=2*range-1; i>=0; i--) {
+				ex = nl_langinfo(min+i);
+				len = strlen(ex);
+				if (strncasecmp(s, ex, len)) continue;
+				s += len;
+				*dest = i % range;
+				break;
+			}
+			if (i<0) return 0;
+			goto update;
+		update:
+			//FIXME
+			;
+		}
+	}
+	if (want_century) {
+		tm->tm_year = relyear;
+		if (want_century & 2) tm->tm_year += century * 100 - 1900;
+		else if (tm->tm_year <= 68) tm->tm_year += 100;
+	}
+	return (char *)s;
+}
diff --git a/third_party/musl/porting/liteos_m/kernel/src/time/time_impl.h b/third_party/musl/porting/liteos_m/kernel/src/time/time_impl.h
new file mode 100755
index 000000000..cd9454330
--- /dev/null
+++ b/third_party/musl/porting/liteos_m/kernel/src/time/time_impl.h
@@ -0,0 +1,14 @@
+#include <time.h>
+#include "../include/features.h"
+
+hidden int __days_in_month(int, int);
+hidden int __month_to_secs(int, int);
+hidden long long __year_to_secs(long long, int *);
+hidden long long __tm_to_secs(const struct tm *);
+hidden const char *__tm_to_tzname(const struct tm *);
+hidden int __secs_to_tm(long long, struct tm *);
+hidden void __secs_to_zone(long long, int, int *, long *, long *, const char **);
+hidden const char *__strftime_fmt_1(char (*)[100], size_t *, int, const struct tm *, locale_t, int);
+extern hidden const char __utc[];
+
+hidden size_t __strftime_l(char *restrict, size_t, const char *restrict, const struct tm *restrict, locale_t);
diff --git a/third_party/musl/scripts/create_alltypes.sh b/third_party/musl/scripts/create_alltypes.sh
new file mode 100755
index 000000000..4d1874d2f
--- /dev/null
+++ b/third_party/musl/scripts/create_alltypes.sh
@@ -0,0 +1,23 @@
+#!/usr/bin/env sh
+
+# not check args
+
+while getopts o: opt
+do
+    case $opt in
+        s) 
+            src=$OPTARG
+            ;;
+        o)
+            output=$OPTARG
+            ;;
+        ?)
+            #usage
+            ;;
+    esac
+done
+shift $(($OPTIND - 1))
+
+echo $0 "$@" $output 
+
+sed -f $@ > $output
diff --git a/third_party/musl/scripts/create_syscall.sh b/third_party/musl/scripts/create_syscall.sh
new file mode 100755
index 000000000..27d150e27
--- /dev/null
+++ b/third_party/musl/scripts/create_syscall.sh
@@ -0,0 +1,12 @@
+#!/usr/bin/env sh
+
+if [ $# -ne 2 ]; then
+    echo "$0 need 2 parameters, but the actual number is $#, please check!"
+    exit 1
+fi
+
+rm -f $2
+
+cp $1 $2
+
+sed  -n -e s/__NR_/SYS_/p < $1 >> $2 
diff --git a/third_party/musl/scripts/create_vesion.sh b/third_party/musl/scripts/create_vesion.sh
new file mode 100755
index 000000000..228a3e3fb
--- /dev/null
+++ b/third_party/musl/scripts/create_vesion.sh
@@ -0,0 +1,19 @@
+#!/usr/bin/env sh
+
+out_putdir=$3
+
+if [ ! -d $out_putdir ]
+then
+    mkdir -p $out_putdir
+fi
+
+cp $1 $out_putdir/VERSION
+cp $2 $out_putdir/version.sh
+
+cd $out_putdir
+
+version=$(sh version.sh)
+
+printf '#define VERSION "%s"\n' $version  > version.h
+
+rm VERSION version.sh
diff --git a/third_party/musl/scripts/install.py b/third_party/musl/scripts/install.py
new file mode 100755
index 000000000..8c6f9be5c
--- /dev/null
+++ b/third_party/musl/scripts/install.py
@@ -0,0 +1,32 @@
+#!/usr/bin/env python
+
+import os
+import sys
+import argparse
+from shutil import copy
+
+def musl_copy_file(src, dest):
+    dest_dir = os.path.dirname(dest)
+    if not os.path.exists(dest_dir):
+        os.makedirs(dest_dir)
+    copy(src, dest)
+
+def main():
+    parser = argparse.ArgumentParser(description=__doc__)
+
+    parser.add_argument('--input',
+                        required = True,
+                        help = 'The header source path',
+                        metavar = 'FILE')
+
+    parser.add_argument('--output',
+                        required = True,
+                        help = 'The output directory',
+                        metavar = 'FILE')
+
+    args = parser.parse_args()
+
+    musl_copy_file(args.input, args.output)
+
+if __name__ == "__main__":
+    sys.exit(main())
diff --git a/third_party/musl/scripts/porting.sh b/third_party/musl/scripts/porting.sh
new file mode 100755
index 000000000..a84293ce8
--- /dev/null
+++ b/third_party/musl/scripts/porting.sh
@@ -0,0 +1,31 @@
+SRC_DIR=
+DST_DIR=
+PORTING=
+
+while getopts "i:o:p:h" arg
+do 
+    case "${arg}" in
+        "i")
+            SRC_DIR=${OPTARG}
+	    ;;
+        "o")
+            DST_DIR=${OPTARG}
+	    ;;
+        "p")
+	    PORTING=${OPTARG}
+	    ;;
+        "h")
+	    echo "help"
+	    ;;
+	?)
+	    echo "unkonw argument"
+	    exit 1
+	    ;;
+    esac
+done
+
+if [ ! -d ${DST_DIR} ]; then
+    mkdir -p ${DST_DIR}
+fi
+cp -rfp ${SRC_DIR}/* ${DST_DIR}
+cp -rfp ${SRC_DIR}/porting/${PORTING}/user/* ${DST_DIR}
diff --git a/third_party/musl/scripts/search_source_files.py b/third_party/musl/scripts/search_source_files.py
new file mode 100755
index 000000000..4302fcc0e
--- /dev/null
+++ b/third_party/musl/scripts/search_source_files.py
@@ -0,0 +1,207 @@
+import os
+import argparse
+
+SRC_DIRS = ["src", "crt", "ldso"]
+
+def file_search(path, target_type):
+    base_srcs = []
+    if not os.path.isdir(path):
+        return base_srcs
+    src_list = os.listdir(path)
+    for src in src_list:
+        cur_path = os.path.join(path, src)
+        if os.path.isdir(cur_path):
+            # base_srcs += file_search(cur_path, target_type)
+            continue
+        elif target_type == "header":
+            if (cur_path.endswith(".h")):
+                base_srcs.append(cur_path)
+        elif target_type == "src":
+            if (cur_path.endswith(".c")):
+                base_srcs.append(cur_path)
+    return base_srcs
+
+def arch_file_search(path, arch):
+    arch_srcs = []
+    target_path = path + "/" + arch
+    if os.path.isdir(target_path):
+        src_list = os.listdir(target_path)
+        for src in src_list:
+            cur_path = os.path.join(target_path, src)
+            if os.path.isdir(cur_path):
+                # arch_srcs += file_search(cur_path, target_type)
+                continue
+            elif (cur_path.endswith(".c") or cur_path.endswith(".s") or
+                  cur_path.endswith(".S")):
+                arch_srcs.append(cur_path)  
+    return arch_srcs
+
+def get_base_srcs(path):
+    base_srcs = []
+    for src_dir in SRC_DIRS:
+        src_path = path + "/" + src_dir
+        src_list = os.listdir(src_path)
+        for src in src_list:
+            cur_path = os.path.join(src_path, src)
+            if os.path.isdir(cur_path) and src_dir == "src":
+                base_srcs += file_search(cur_path, "src")
+            else:
+                if (cur_path.endswith(".c")):
+                    base_srcs.append(cur_path)
+    base_srcs.sort()
+    return base_srcs
+
+def get_arch_srcs(path, arch):
+    arch_srcs = []
+    for src_dir in SRC_DIRS:
+        if src_dir == "src":
+            src_list = os.listdir(path + "/" + src_dir)
+            for src in src_list:
+                cur_path = os.path.join(path + "/" + src_dir, src)
+                arch_srcs += arch_file_search(cur_path, arch)
+        elif os.path.isdir(path + "/" + src_dir + "/" + arch):
+            src_path = path + "/" + src_dir + "/" + arch
+            src_list = os.listdir(src_path)
+            for src in src_list:
+                cur_path = os.path.join(src_path, src)
+                if os.path.isdir(cur_path):
+                    continue
+                else:
+                    if (cur_path.endswith(".c") or cur_path.endswith(".s") or
+                        cur_path.endswith(".S")):
+                        arch_srcs.append(cur_path)
+    arch_srcs.sort()
+    return arch_srcs
+
+def change_subfix(name):
+    new_name = ""
+    if name.endswith(".s"):
+        new_name = name.replace(".s", ".c")
+    elif name.endswith(".S"):
+        new_name = name.replace(".S", ".c")
+    else:
+        return name
+    return new_name
+
+def replace_srcs_with_arch(base_srcs, arch_srcs, arch):
+    target_srcs = base_srcs
+    arch_removed = []
+    for src in arch_srcs:
+        fake_name = change_subfix(src.replace("/" + arch, ""))
+        if fake_name in target_srcs:
+            target_srcs.remove(fake_name)
+            arch_removed.append(src)
+    return target_srcs, arch_removed
+
+def get_libc_srcs(target_srcs, relative_path):
+    libc_srcs = []
+    for src in target_srcs:
+        clean_path_src = src.replace(relative_path, "")
+        if clean_path_src.startswith("/src/") or clean_path_src.startswith("/compat/time32/"):
+            libc_srcs.append(src)
+    return libc_srcs
+
+def get_ldso_srcs(target_srcs, relative_path):
+    ldso_srcs = []
+    for src in target_srcs:
+        clean_path_src = src.replace(relative_path, "")
+        if clean_path_src.startswith("/ldso/"):
+            ldso_srcs.append(src)
+    return ldso_srcs
+
+def get_crt_srcs(target_srcs, relative_path):
+    crt_srcs = []
+    for src in target_srcs:
+        clean_path_src = src.replace(relative_path, "")
+        if clean_path_src.startswith("/crt/"):
+            crt_srcs.append(src)
+    return crt_srcs
+
+def get_header_dirs(path, arch):
+    header_dirs = {
+        path + "/arch/" + arch + "/bits",
+        path + "/arch/generic/bits",
+        path + "/include"
+    }
+    return header_dirs
+
+def get_generated_header(path):
+    generated_headers = [
+        path + "/include/bits/alltypes.h",
+        path + "/include/bits/syscall.h",
+    ]
+
+def get_all_header(header_dirs):
+    all_header = []
+    for dir in header_dirs:
+        file_list = os.listdir(dir)
+        for file in file_list:
+            cur_path = os.path.join(dir, file)
+            if os.path.isdir(cur_path):
+                all_header += file_search(cur_path, "header")
+            else:
+                if (cur_path.endswith(".h")):
+                    all_header.append(cur_path)
+    all_header.sort()
+    return all_header
+
+def rm_dup_header(all_header_files, arch):
+    header_files = all_header_files
+    header_to_rm = []
+    for file in header_files:
+        if "/arch/generic/bits" in file:
+            substitute_file = file.replace("/arch/generic/bits", "/arch/"+ arch +"/bits")
+            if substitute_file in header_files:
+                header_to_rm.append(file)
+
+    return  [i for i in header_files if i not in header_to_rm]
+
+def print_outputs(outputs):
+    for out in outputs:
+        print(out)
+        for content in outputs[out]:
+            print("    " + content)
+
+def search_for_files(path, arch):
+    if arch == "arm":
+        SRC_DIRS.append("compat/time32")
+
+    base_srcs = get_base_srcs(path)
+    arch_srcs = get_arch_srcs(path, arch)
+    target_srcs, arch_removed = replace_srcs_with_arch(base_srcs, arch_srcs, arch)
+    target_srcs += arch_srcs
+    
+    libc_srcs = get_libc_srcs(target_srcs, path)
+    ldso_srcs = get_ldso_srcs(target_srcs, path)
+    crt_srcs = get_crt_srcs(target_srcs, path)
+
+    all_header_files = get_all_header(get_header_dirs(path, arch))
+    header_files = rm_dup_header(all_header_files, arch)
+
+    outputs = {
+        "arch": arch_srcs,
+        "arch_rm": arch_removed,
+        "libc": libc_srcs, 
+        "ldso": ldso_srcs, 
+        "crt": crt_srcs, 
+        "header": header_files,
+    }
+    # print_outputs(outputs)
+    return libc_srcs, ldso_srcs, crt_srcs, header_files
+
+def main():
+    parser = argparse.ArgumentParser(description=__doc__)
+
+    parser.add_argument('--path',
+                        required = True,
+                        help = 'The path of musl source files')
+    parser.add_argument('--arch',
+                        required = True,
+                        help = 'The targeting architecture')
+    args = parser.parse_args()
+
+    return search_for_files(args.path, args.arch)
+
+
+if __name__ == "__main__":
+    main()
diff --git a/third_party/musl/src/aio/aio.c b/third_party/musl/src/aio/aio.c
index 5bb5733b5..6d34fa869 100755
--- a/third_party/musl/src/aio/aio.c
+++ b/third_party/musl/src/aio/aio.c
@@ -6,7 +6,6 @@
 #include <unistd.h>
 #include <stdlib.h>
 #include <sys/auxv.h>
-#include <unsupported_api.h>
 #include "syscall.h"
 #include "atomic.h"
 #include "pthread_impl.h"
@@ -320,19 +319,16 @@ static int submit(struct aiocb *cb, int op)
 
 int aio_read(struct aiocb *cb)
 {
-	unsupported_api(__FUNCTION__);
 	return submit(cb, LIO_READ);
 }
 
 int aio_write(struct aiocb *cb)
 {
-	unsupported_api(__FUNCTION__);
 	return submit(cb, LIO_WRITE);
 }
 
 int aio_fsync(int op, struct aiocb *cb)
 {
-	unsupported_api(__FUNCTION__);
 	if (op != O_SYNC && op != O_DSYNC) {
 		errno = EINVAL;
 		return -1;
@@ -342,13 +338,11 @@ int aio_fsync(int op, struct aiocb *cb)
 
 ssize_t aio_return(struct aiocb *cb)
 {
-	unsupported_api(__FUNCTION__);
 	return cb->__ret;
 }
 
 int aio_error(const struct aiocb *cb)
 {
-	unsupported_api(__FUNCTION__);
 	a_barrier();
 	return cb->__err & 0x7fffffff;
 }
@@ -360,7 +354,6 @@ int aio_cancel(int fd, struct aiocb *cb)
 	struct aio_thread *p;
 	struct aio_queue *q;
 
-	unsupported_api(__FUNCTION__);
 	/* Unspecified behavior case. Report an error. */
 	if (cb && fd != cb->aio_fildes) {
 		errno = EINVAL;
diff --git a/third_party/musl/src/aio/aio_suspend.c b/third_party/musl/src/aio/aio_suspend.c
index 3fc0301fd..34b66f878 100755
--- a/third_party/musl/src/aio/aio_suspend.c
+++ b/third_party/musl/src/aio/aio_suspend.c
@@ -1,7 +1,6 @@
 #include <aio.h>
 #include <errno.h>
 #include <time.h>
-#include <unsupported_api.h>
 #include "atomic.h"
 #include "pthread_impl.h"
 
@@ -13,7 +12,6 @@ int aio_suspend(const struct aiocb *const cbs[], int cnt, const struct timespec
 	int nzcnt = 0;
 	const struct aiocb *cb = 0;
 
-	unsupported_api(__FUNCTION__);
 	pthread_testcancel();
 
 	if (cnt<0) {
diff --git a/third_party/musl/src/aio/lio_listio.c b/third_party/musl/src/aio/lio_listio.c
index 545e07718..0799c15d8 100755
--- a/third_party/musl/src/aio/lio_listio.c
+++ b/third_party/musl/src/aio/lio_listio.c
@@ -3,7 +3,6 @@
 #include <unistd.h>
 #include <string.h>
 #include "pthread_impl.h"
-#include <unsupported_api.h>
 
 struct lio_state {
 	struct sigevent *sev;
@@ -69,8 +68,6 @@ static void *wait_thread(void *p)
 
 int lio_listio(int mode, struct aiocb *restrict const *restrict cbs, int cnt, struct sigevent *restrict sev)
 {
-	unsupported_api(__FUNCTION__);
-
 	int i, ret;
 	struct lio_state *st=0;
 
diff --git a/third_party/musl/src/conf/confstr.c b/third_party/musl/src/conf/confstr.c
index 3fa863c73..02cb1aa25 100755
--- a/third_party/musl/src/conf/confstr.c
+++ b/third_party/musl/src/conf/confstr.c
@@ -1,13 +1,10 @@
 #include <unistd.h>
 #include <stdio.h>
 #include <errno.h>
-#include <unsupported_api.h>
 
 size_t confstr(int name, char *buf, size_t len)
 {
 	const char *s = "";
-
-	unsupported_api(__FUNCTION__);
 	if (!name) {
 		s = "/bin:/usr/bin";
 	} else if ((name&~4U)!=1 && name-_CS_POSIX_V6_ILP32_OFF32_CFLAGS>33U) {
diff --git a/third_party/musl/src/conf/sysconf.c b/third_party/musl/src/conf/sysconf.c
index 994e38e26..3baaed322 100755
--- a/third_party/musl/src/conf/sysconf.c
+++ b/third_party/musl/src/conf/sysconf.c
@@ -4,7 +4,6 @@
 #include <sys/resource.h>
 #include <signal.h>
 #include <sys/sysinfo.h>
-#include <unsupported_api.h>
 #include "syscall.h"
 #include "libc.h"
 
@@ -167,7 +166,7 @@ long sysconf(int name)
 		[_SC_THREAD_ROBUST_PRIO_INHERIT] = -1,
 		[_SC_THREAD_ROBUST_PRIO_PROTECT] = -1,
 	};
-	unsupported_api(__FUNCTION__);
+
 	if (name >= sizeof(values)/sizeof(values[0]) || !values[name]) {
 		errno = EINVAL;
 		return -1;
diff --git a/third_party/musl/src/crypt/encrypt.c b/third_party/musl/src/crypt/encrypt.c
index 5a3f6503a..216abc919 100755
--- a/third_party/musl/src/crypt/encrypt.c
+++ b/third_party/musl/src/crypt/encrypt.c
@@ -1,7 +1,6 @@
 #include <stdint.h>
 #include <stdlib.h>
 #include <unistd.h>
-#include <unsupported_api.h>
 
 #include "crypt_des.h"
 
@@ -12,7 +11,6 @@ void setkey(const char *key)
 	unsigned char bkey[8];
 	int i, j;
 
-	unsupported_api(__FUNCTION__);
 	for (i = 0; i < 8; i++) {
 		bkey[i] = 0;
 		for (j = 7; j >= 0; j--, key++)
@@ -29,7 +27,6 @@ void encrypt(char *block, int edflag)
 	int i, j;
 	char *p;
 
-	unsupported_api(__FUNCTION__);
 	p = block;
 	for (i = 0; i < 2; i++) {
 		b[i] = 0;
diff --git a/third_party/musl/src/ctype/wcswidth.c b/third_party/musl/src/ctype/wcswidth.c
index ed0f9f204..5c8a5a4da 100755
--- a/third_party/musl/src/ctype/wcswidth.c
+++ b/third_party/musl/src/ctype/wcswidth.c
@@ -1,10 +1,8 @@
 #include <wchar.h>
-#include <unsupported_api.h>
 
 int wcswidth(const wchar_t *wcs, size_t n)
 {
 	int l=0, k=0;
-	unsupported_api(__FUNCTION__);
 	for (; n-- && *wcs && (k = wcwidth(*wcs)) >= 0; l+=k, wcs++);
 	return (k < 0) ? k : l;
 }
diff --git a/third_party/musl/src/ctype/wcwidth.c b/third_party/musl/src/ctype/wcwidth.c
index 6b86b2761..36256a538 100755
--- a/third_party/musl/src/ctype/wcwidth.c
+++ b/third_party/musl/src/ctype/wcwidth.c
@@ -1,5 +1,4 @@
 #include <wchar.h>
-#include <unsupported_api.h>
 
 static const unsigned char table[] = {
 #include "nonspacing.h"
@@ -11,7 +10,6 @@ static const unsigned char wtable[] = {
 
 int wcwidth(wchar_t wc)
 {
-	unsupported_api(__FUNCTION__);
 	if (wc < 0xffU)
 		return (wc+1 & 0x7f) >= 0x21 ? 1 : wc ? -1 : 0;
 	if ((wc & 0xfffeffffU) < 0xfffe) {
diff --git a/third_party/musl/src/dirent/__dirent.h b/third_party/musl/src/dirent/__dirent.h
index 5d79b9657..828a5f178 100644
--- a/third_party/musl/src/dirent/__dirent.h
+++ b/third_party/musl/src/dirent/__dirent.h
@@ -7,6 +7,5 @@ struct __dirstream
 	volatile int lock[1];
 	/* Any changes to this struct must preserve the property:
 	 * offsetof(struct __dirent, buf) % sizeof(off_t) == 0 */
-	// change buf len from 2048 to 4096 to support read 14 dirs at one readdir syscall
-	char buf[4096];
+	char buf[2048];
 };
diff --git a/third_party/musl/src/dirent/dirfd.c b/third_party/musl/src/dirent/dirfd.c
index 876d00c31..6c8600739 100755
--- a/third_party/musl/src/dirent/dirfd.c
+++ b/third_party/musl/src/dirent/dirfd.c
@@ -1,9 +1,7 @@
 #include <dirent.h>
 #include "__dirent.h"
-#include <unsupported_api.h>
 
 int dirfd(DIR *d)
 {
-	unsupported_api(__FUNCTION__);
 	return d->fd;
 }
diff --git a/third_party/musl/src/dirent/fdopendir.c b/third_party/musl/src/dirent/fdopendir.c
index d5bbfd2cc..d78fb87f9 100755
--- a/third_party/musl/src/dirent/fdopendir.c
+++ b/third_party/musl/src/dirent/fdopendir.c
@@ -4,15 +4,12 @@
 #include <errno.h>
 #include <stdlib.h>
 #include "__dirent.h"
-#include <unsupported_api.h>
 
 DIR *fdopendir(int fd)
 {
 	DIR *dir;
 	struct stat st;
 
-	unsupported_api(__FUNCTION__);
-
 	if (fstat(fd, &st) < 0) {
 		return 0;
 	}
diff --git a/third_party/musl/src/env/__init_tls.c b/third_party/musl/src/env/__init_tls.c
index b02f0566d..772baba32 100644
--- a/third_party/musl/src/env/__init_tls.c
+++ b/third_party/musl/src/env/__init_tls.c
@@ -8,55 +8,22 @@
 #include "libc.h"
 #include "atomic.h"
 #include "syscall.h"
-#include "stdio_impl.h"
-#include "lock.h"
 
 volatile int __thread_list_lock;
 
-static void *dummy_tsd[1] = { 0 };
-weak_alias(dummy_tsd, __pthread_tsd_main);
-static FILE *volatile dummy_file = 0;
-weak_alias(dummy_file, __stdin_used);
-weak_alias(dummy_file, __stdout_used);
-weak_alias(dummy_file, __stderr_used);
-
-static void dummy_0()
-{
-}
-weak_alias(dummy_0, __membarrier_init);
-
-static void init_file_lock(FILE *f)
-{
-	if (f && f->lock<0) f->lock = 0;
-}
-
 int __init_tp(void *p)
 {
 	pthread_t td = p;
+	td->self = td;
 	int r = __set_thread_area(TP_ADJ(p));
 	if (r < 0) return -1;
 	if (!r) libc.can_do_threads = 1;
-	libc.threads_minus_1 = 1;
-	libc.threaded = 0;
-	td->self = td;
 	td->detach_state = DT_JOINABLE;
-	td->tid = __syscall(SYS_gettid);
+	td->tid = __syscall(SYS_set_tid_address, &__thread_list_lock);
 	td->locale = &libc.global_locale;
 	td->robust_list.head = &td->robust_list.head;
 	td->sysinfo = __sysinfo;
 	td->next = td->prev = td;
-	td->tsd = (void **)__pthread_tsd_main;
-	for (FILE *f=*__ofl_lock(); f; f=f->next)
-		init_file_lock(f);
-	__ofl_unlock();
-	init_file_lock(__stdin_used);
-	init_file_lock(__stdout_used);
-	init_file_lock(__stderr_used);
-	__syscall(SYS_rt_sigprocmask, SIG_UNBLOCK, SIGPT_SET, 0, _NSIG/8);
-#if 0
-	__membarrier_init();
-#endif
-	libc.threaded = 1;
 	return 0;
 }
 
diff --git a/third_party/musl/src/env/__libc_start_main.c b/third_party/musl/src/env/__libc_start_main.c
index 9f0fec0e4..8fbe52627 100644
--- a/third_party/musl/src/env/__libc_start_main.c
+++ b/third_party/musl/src/env/__libc_start_main.c
@@ -89,7 +89,6 @@ static int libc_start_main_stage2(int (*main)(int,char **,char **), int argc, ch
 {
 	char **envp = argv+argc+1;
 	__libc_start_init();
-	__sig_init();
 
 	/* Pass control to the application */
 	exit(main(argc, argv, envp));
diff --git a/third_party/musl/src/exit/abort.c b/third_party/musl/src/exit/abort.c
index 38ce2c2d4..e1980f10a 100644
--- a/third_party/musl/src/exit/abort.c
+++ b/third_party/musl/src/exit/abort.c
@@ -10,15 +10,8 @@ hidden volatile int __abort_lock[1];
 
 _Noreturn void abort(void)
 {
-	sigset_t set, pending;
-	sigemptyset(&set);
-	sigaddset(&set, SIGABRT);
+	raise(SIGABRT);
 
-	sigpending(&pending);
-	__syscall(SYS_rt_sigprocmask, SIG_UNBLOCK, &set, 0, _NSIG / 8);
-	if (!sigismember(&pending, SIGABRT)) {
-		raise(SIGABRT);
-	}
 	/* If there was a SIGABRT handler installed and it returned, or if
 	 * SIGABRT was blocked or ignored, take an AS-safe lock to prevent
 	 * sigaction from installing a new SIGABRT handler, uninstall any
@@ -26,7 +19,8 @@ _Noreturn void abort(void)
 	 * the default action of abnormal termination. */
 	__block_all_sigs(0);
 	LOCK(__abort_lock);
-	signal(SIGABRT, SIG_DFL);
+	__syscall(SYS_rt_sigaction, SIGABRT,
+		&(struct k_sigaction){.handler = SIG_DFL}, 0, _NSIG/8);
 	__syscall(SYS_tkill, __pthread_self()->tid, SIGABRT);
 	__syscall(SYS_rt_sigprocmask, SIG_UNBLOCK,
 		&(long[_NSIG/(8*sizeof(long))]){1UL<<(SIGABRT-1)}, 0, _NSIG/8);
diff --git a/third_party/musl/src/fcntl/fcntl.c b/third_party/musl/src/fcntl/fcntl.c
index 37391e053..d3bff5c48 100644
--- a/third_party/musl/src/fcntl/fcntl.c
+++ b/third_party/musl/src/fcntl/fcntl.c
@@ -11,6 +11,7 @@ int fcntl(int fd, int cmd, ...)
 	va_start(ap, cmd);
 	arg = va_arg(ap, unsigned long);
 	va_end(ap);
+	if (cmd == F_SETFL) arg |= O_LARGEFILE;
 	if (cmd == F_SETLKW) return syscall_cp(SYS_fcntl, fd, cmd, (void *)arg);
 	if (cmd == F_GETOWN) {
 		struct f_owner_ex ex;
diff --git a/third_party/musl/src/fcntl/openat.c b/third_party/musl/src/fcntl/openat.c
index 7982a80d7..ad165ec32 100755
--- a/third_party/musl/src/fcntl/openat.c
+++ b/third_party/musl/src/fcntl/openat.c
@@ -1,13 +1,11 @@
 #include <fcntl.h>
 #include <stdarg.h>
 #include "syscall.h"
-#include <unsupported_api.h>
 
 int openat(int fd, const char *filename, int flags, ...)
 {
 	mode_t mode = 0;
 
-	unsupported_api(__FUNCTION__);
 	if ((flags & O_CREAT) || (flags & O_TMPFILE) == O_TMPFILE) {
 		va_list ap;
 		va_start(ap, flags);
diff --git a/third_party/musl/src/fcntl/posix_fadvise.c b/third_party/musl/src/fcntl/posix_fadvise.c
index 641dc56f7..75b8e1aed 100755
--- a/third_party/musl/src/fcntl/posix_fadvise.c
+++ b/third_party/musl/src/fcntl/posix_fadvise.c
@@ -1,11 +1,8 @@
 #include <fcntl.h>
-#include <unsupported_api.h>
-
 #include "syscall.h"
 
 int posix_fadvise(int fd, off_t base, off_t len, int advice)
 {
-	unsupported_api(__FUNCTION__);
 #if defined(SYSCALL_FADVISE_6_ARG)
 	/* Some archs, at least arm and powerpc, have the syscall
 	 * arguments reordered to avoid needing 7 argument registers
diff --git a/third_party/musl/src/internal/libc.h b/third_party/musl/src/internal/libc.h
index da237ed14..ac97dc7eb 100644
--- a/third_party/musl/src/internal/libc.h
+++ b/third_party/musl/src/internal/libc.h
@@ -44,8 +44,6 @@ hidden void __funcs_on_exit(void);
 hidden void __funcs_on_quick_exit(void);
 hidden void __libc_exit_fini(void);
 hidden void __fork_handler(int);
-hidden void __sig_init(void);
-hidden void arm_do_signal(int);
 
 extern hidden size_t __hwcap;
 extern hidden size_t __sysinfo;
diff --git a/third_party/musl/src/internal/pthread_impl.h b/third_party/musl/src/internal/pthread_impl.h
index 2e2109070..5742dfc55 100644
--- a/third_party/musl/src/internal/pthread_impl.h
+++ b/third_party/musl/src/internal/pthread_impl.h
@@ -145,7 +145,6 @@ extern hidden volatile int __aio_fut;
 extern hidden volatile int __eintr_valid_flag;
 
 hidden int __clone(int (*)(void *), void *, int, void *, ...);
-hidden int __thread_clone(int (*func)(void *), int flags, struct pthread *thread, unsigned char *sp);
 hidden int __set_thread_area(void *);
 hidden int __libc_sigaction(int, const struct sigaction *, struct sigaction *);
 hidden void __unmapself(void *, size_t);
@@ -163,8 +162,8 @@ static inline void __wake(volatile void *addr, int cnt, int priv)
 static inline void __futexwait(volatile void *addr, int val, int priv)
 {
 	if (priv) priv = FUTEX_PRIVATE;
-	__syscall(SYS_futex, addr, FUTEX_WAIT|priv, val, 0xffffffffu) != -ENOSYS ||
-	__syscall(SYS_futex, addr, FUTEX_WAIT, val, 0xffffffffu);
+	__syscall(SYS_futex, addr, FUTEX_WAIT|priv, val, 0) != -ENOSYS ||
+	__syscall(SYS_futex, addr, FUTEX_WAIT, val, 0);
 }
 
 hidden void __acquire_ptc(void);
@@ -188,10 +187,4 @@ extern hidden unsigned __default_guardsize;
 
 #define __ATTRP_C11_THREAD ((void*)(uintptr_t)-1)
 
-#define MUSL_TYPE_THREAD    (-1)
-#define MUSL_TYPE_PROCESS   (0)
-
-#define PTHREAD_MUTEX_TYPE_MASK 3
-#define PTHREAD_PRIORITY_LOWEST 31
-
 #endif
diff --git a/third_party/musl/src/ipc/ftok.c b/third_party/musl/src/ipc/ftok.c
index 5733836bd..c36b4b600 100755
--- a/third_party/musl/src/ipc/ftok.c
+++ b/third_party/musl/src/ipc/ftok.c
@@ -1,11 +1,9 @@
 #include <sys/ipc.h>
 #include <sys/stat.h>
-#include <unsupported_api.h>
 
 key_t ftok(const char *path, int id)
 {
 	struct stat st;
-	unsupported_api(__FUNCTION__);
 	if (stat(path, &st) < 0) return -1;
 
 	return ((st.st_ino & 0xffff) | ((st.st_dev & 0xff) << 16) | ((id & 0xffu) << 24));
diff --git a/third_party/musl/src/ipc/msgctl.c b/third_party/musl/src/ipc/msgctl.c
index 48a2a0a17..b043041a5 100755
--- a/third_party/musl/src/ipc/msgctl.c
+++ b/third_party/musl/src/ipc/msgctl.c
@@ -1,7 +1,5 @@
 #include <sys/msg.h>
 #include <endian.h>
-#include <unsupported_api.h>
-
 #include "syscall.h"
 #include "ipc.h"
 
@@ -11,7 +9,6 @@
 
 int msgctl(int q, int cmd, struct msqid_ds *buf)
 {
-	unsupported_api(__FUNCTION__);
 #ifdef SYSCALL_IPC_BROKEN_MODE
 	struct msqid_ds tmp;
 	if (cmd == IPC_SET) {
diff --git a/third_party/musl/src/ipc/msgget.c b/third_party/musl/src/ipc/msgget.c
index 9ff7a053b..30a4b42b8 100755
--- a/third_party/musl/src/ipc/msgget.c
+++ b/third_party/musl/src/ipc/msgget.c
@@ -1,12 +1,9 @@
 #include <sys/msg.h>
-#include <unsupported_api.h>
-
 #include "syscall.h"
 #include "ipc.h"
 
 int msgget(key_t k, int flag)
 {
-	unsupported_api(__FUNCTION__);
 #ifndef SYS_ipc
 	return syscall(SYS_msgget, k, flag);
 #else
diff --git a/third_party/musl/src/ipc/msgrcv.c b/third_party/musl/src/ipc/msgrcv.c
index c66eb52fa..9d1034b14 100755
--- a/third_party/musl/src/ipc/msgrcv.c
+++ b/third_party/musl/src/ipc/msgrcv.c
@@ -1,12 +1,9 @@
 #include <sys/msg.h>
-#include <unsupported_api.h>
-
 #include "syscall.h"
 #include "ipc.h"
 
 ssize_t msgrcv(int q, void *m, size_t len, long type, int flag)
 {
-	unsupported_api(__FUNCTION__);
 #ifndef SYS_ipc
 	return syscall_cp(SYS_msgrcv, q, m, len, type, flag);
 #else
diff --git a/third_party/musl/src/ipc/msgsnd.c b/third_party/musl/src/ipc/msgsnd.c
index 4db4d4ef4..99bb17e94 100755
--- a/third_party/musl/src/ipc/msgsnd.c
+++ b/third_party/musl/src/ipc/msgsnd.c
@@ -1,11 +1,9 @@
-#include <unsupported_api.h>
 #include <sys/msg.h>
 #include "syscall.h"
 #include "ipc.h"
 
 int msgsnd(int q, const void *m, size_t len, int flag)
 {
-	unsupported_api(__FUNCTION__);
 #ifndef SYS_ipc
 	return syscall_cp(SYS_msgsnd, q, m, len, flag);
 #else
diff --git a/third_party/musl/src/ipc/semctl.c b/third_party/musl/src/ipc/semctl.c
index 9e9f15e3b..ed9827477 100755
--- a/third_party/musl/src/ipc/semctl.c
+++ b/third_party/musl/src/ipc/semctl.c
@@ -1,8 +1,6 @@
 #include <sys/sem.h>
 #include <stdarg.h>
 #include <endian.h>
-#include <unsupported_api.h>
-
 #include "syscall.h"
 #include "ipc.h"
 
@@ -18,7 +16,6 @@ union semun {
 
 int semctl(int id, int num, int cmd, ...)
 {
-	unsupported_api(__FUNCTION__);
 	union semun arg = {0};
 	va_list ap;
 	switch (cmd & ~IPC_TIME64) {
diff --git a/third_party/musl/src/ipc/semget.c b/third_party/musl/src/ipc/semget.c
index 858d5bd61..2cdf626b5 100755
--- a/third_party/musl/src/ipc/semget.c
+++ b/third_party/musl/src/ipc/semget.c
@@ -1,8 +1,6 @@
 #include <sys/sem.h>
 #include <limits.h>
 #include <errno.h>
-#include <unsupported_api.h>
-
 #include "syscall.h"
 #include "ipc.h"
 
@@ -12,7 +10,6 @@ int semget(key_t key, int n, int fl)
 	 * of struct semid_ds, and thus might not check that the
 	 * n fits in the correct (per POSIX) userspace type, so
 	 * we have to check here. */
-	unsupported_api(__FUNCTION__);
 	if (n > USHRT_MAX) return __syscall_ret(-EINVAL);
 #ifndef SYS_ipc
 	return syscall(SYS_semget, key, n, fl);
diff --git a/third_party/musl/src/ipc/semop.c b/third_party/musl/src/ipc/semop.c
index 1c96614fb..5f0c7deaf 100755
--- a/third_party/musl/src/ipc/semop.c
+++ b/third_party/musl/src/ipc/semop.c
@@ -1,12 +1,9 @@
 #include <sys/sem.h>
-#include <unsupported_api.h>
-
 #include "syscall.h"
 #include "ipc.h"
 
 int semop(int id, struct sembuf *buf, size_t n)
 {
-	unsupported_api(__FUNCTION__);
 #ifndef SYS_ipc
 	return syscall(SYS_semop, id, buf, n);
 #else
diff --git a/third_party/musl/src/legacy/daemon.c b/third_party/musl/src/legacy/daemon.c
index 57838e781..1568b1dcb 100755
--- a/third_party/musl/src/legacy/daemon.c
+++ b/third_party/musl/src/legacy/daemon.c
@@ -1,11 +1,9 @@
 #define _GNU_SOURCE
 #include <fcntl.h>
 #include <unistd.h>
-#include <unsupported_api.h>
 
 int daemon(int nochdir, int noclose)
 {
-	unsupported_api(__FUNCTION__);
 	if (!nochdir && chdir("/"))
 		return -1;
 	if (!noclose) {
diff --git a/third_party/musl/src/legacy/getdtablesize.c b/third_party/musl/src/legacy/getdtablesize.c
index 672e0556c..b30c1933a 100755
--- a/third_party/musl/src/legacy/getdtablesize.c
+++ b/third_party/musl/src/legacy/getdtablesize.c
@@ -2,12 +2,10 @@
 #include <unistd.h>
 #include <limits.h>
 #include <sys/resource.h>
-#include <unsupported_api.h>
 
 int getdtablesize(void)
 {
 	struct rlimit rl;
-	unsupported_api(__FUNCTION__);
 	getrlimit(RLIMIT_NOFILE, &rl);
 	return rl.rlim_cur < INT_MAX ? rl.rlim_cur : INT_MAX;
 }
diff --git a/third_party/musl/src/legacy/getusershell.c b/third_party/musl/src/legacy/getusershell.c
index c17ada773..5fecdec2e 100755
--- a/third_party/musl/src/legacy/getusershell.c
+++ b/third_party/musl/src/legacy/getusershell.c
@@ -1,7 +1,6 @@
 #define _GNU_SOURCE
 #include <stdio.h>
 #include <unistd.h>
-#include <unsupported_api.h>
 
 static const char defshells[] = "/bin/sh\n/bin/csh\n";
 
@@ -11,7 +10,6 @@ static FILE *f;
 
 void endusershell(void)
 {
-	unsupported_api(__FUNCTION__);
 	if (f) fclose(f);
 	f = 0;
 }
diff --git a/third_party/musl/src/legacy/isastream.c b/third_party/musl/src/legacy/isastream.c
index 9398088e5..4dafdb082 100755
--- a/third_party/musl/src/legacy/isastream.c
+++ b/third_party/musl/src/legacy/isastream.c
@@ -1,8 +1,7 @@
 #include <stropts.h>
 #include <fcntl.h>
-#include <unsupported_api.h>
+
 int isastream(int fd)
 {
-	unsupported_api(__FUNCTION__);
 	return fcntl(fd, F_GETFD) < 0 ? -1 : 0;
 }
diff --git a/third_party/musl/src/legacy/ulimit.c b/third_party/musl/src/legacy/ulimit.c
index 5580bf885..1f59e8e61 100755
--- a/third_party/musl/src/legacy/ulimit.c
+++ b/third_party/musl/src/legacy/ulimit.c
@@ -1,12 +1,10 @@
 #include <sys/resource.h>
 #include <ulimit.h>
 #include <stdarg.h>
-#include <unsupported_api.h>
 
 long ulimit(int cmd, ...)
 {
 	struct rlimit rl;
-	unsupported_api(__FUNCTION__);
 	getrlimit(RLIMIT_FSIZE, &rl);
 	if (cmd == UL_SETFSIZE) {
 		long val;
diff --git a/third_party/musl/src/legacy/utmpx.c b/third_party/musl/src/legacy/utmpx.c
index a9f05a2a4..7aa65da33 100755
--- a/third_party/musl/src/legacy/utmpx.c
+++ b/third_party/musl/src/legacy/utmpx.c
@@ -2,50 +2,41 @@
 #include <utmpx.h>
 #include <stddef.h>
 #include <errno.h>
-#include <unsupported_api.h>
 
 void endutxent(void)
 {
-	unsupported_api(__FUNCTION__);
 }
 
 void setutxent(void)
 {
-	unsupported_api(__FUNCTION__);
 }
 
 struct utmpx *getutxent(void)
 {
-	unsupported_api(__FUNCTION__);
 	return NULL;
 }
 
 struct utmpx *getutxid(const struct utmpx *ut)
 {
-	unsupported_api(__FUNCTION__);
 	return NULL;
 }
 
 struct utmpx *getutxline(const struct utmpx *ut)
 {
-	unsupported_api(__FUNCTION__);
 	return NULL;
 }
 
 struct utmpx *pututxline(const struct utmpx *ut)
 {
-	unsupported_api(__FUNCTION__);
 	return NULL;
 }
 
 void updwtmpx(const char *f, const struct utmpx *u)
 {
-	unsupported_api(__FUNCTION__);
 }
 
 static int __utmpxname(const char *f)
 {
-	unsupported_api(__FUNCTION__);
 	errno = ENOTSUP;
 	return -1;
 }
diff --git a/third_party/musl/src/linux/adjtime.c b/third_party/musl/src/linux/adjtime.c
index 871623a96..5a707f2f2 100755
--- a/third_party/musl/src/linux/adjtime.c
+++ b/third_party/musl/src/linux/adjtime.c
@@ -3,12 +3,10 @@
 #include <sys/timex.h>
 #include <errno.h>
 #include "syscall.h"
-#include <unsupported_api.h>
 
 int adjtime(const struct timeval *in, struct timeval *out)
 {
 	struct timex tx = { 0 };
-	unsupported_api(__FUNCTION__);
 	if (in) {
 		if (in->tv_sec > 1000 || in->tv_usec > 1000000000) {
 			errno = EINVAL;
diff --git a/third_party/musl/src/linux/cap.c b/third_party/musl/src/linux/cap.c
index f80e660f0..8d035e07a 100755
--- a/third_party/musl/src/linux/cap.c
+++ b/third_party/musl/src/linux/cap.c
@@ -1,265 +1,11 @@
-/*
- * Copyright (c) 2013-2019, Huawei Technologies Co., Ltd. All rights reserved.
- * Copyright (c) 2020, Huawei Device Co., Ltd. All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without modification,
- * are permitted provided that the following conditions are met:
- *
- * 1. Redistributions of source code must retain the above copyright notice, this list of
- *    conditions and the following disclaimer.
- *
- * 2. Redistributions in binary form must reproduce the above copyright notice, this list
- *    of conditions and the following disclaimer in the documentation and/or other materials
- *    provided with the distribution.
- *
- * 3. Neither the name of the copyright holder nor the names of its contributors may be used
- *    to endorse or promote products derived from this software without specific prior written
- *    permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
- * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
- * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
- * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
- * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
- * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
- * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
- * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
- * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
- * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
- * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-
-#include <errno.h>
-#include <unistd.h>
-#include <stdio.h>
 #include "syscall.h"
-#include "sys/capability.h"
-
-static unsigned int __linux_caps_maps[] = {
-	CAP_CHOWN, CAP_DAC_OVERRIDE, CAP_DAC_READ_SEARCH, CAP_FOWNER,
-	CAP_KILL, CAP_SETGID, CAP_SETUID, CAP_SETPCAP, CAP_NET_BIND_SERVICE,
-	CAP_NET_BROADCAST, CAP_NET_ADMIN, CAP_NET_RAW, CAP_SYS_PTRACE, CAP_SYS_ADMIN,
-	CAP_SYS_NICE, CAP_SYS_TIME, CAP_SYS_BOOT};
-
-static unsigned int __ohos_caps_maps[] = {
-	OHOS_CAP_CHOWN, OHOS_CAP_DAC_EXECUTE, OHOS_CAP_DAC_WRITE, OHOS_CAP_DAC_READ_SEARCH, OHOS_CAP_FOWNER, OHOS_CAP_KILL,
-	OHOS_CAP_SETGID, OHOS_CAP_SETUID, OHOS_CAP_NET_BIND_SERVICE, OHOS_CAP_NET_BROADCAST, OHOS_CAP_NET_ADMIN,
-	OHOS_CAP_NET_RAW, OHOS_CAP_FS_MOUNT, OHOS_CAP_FS_FORMAT, OHOS_CAP_SCHED_SETPRIORITY,
-	OHOS_CAP_SET_TIMEOFDAY, OHOS_CAP_CLOCK_SETTIME, OHOS_CAP_CAPSET, OHOS_CAP_REBOOT, OHOS_CAP_SHELL_EXEC};
-
-static unsigned int linux_caps_to_ohos(unsigned int caps)
-{
-	int num = sizeof(__linux_caps_maps) / sizeof(int);
-	int loop;
-	unsigned int result = 0;
-	for (loop = 0; loop < num; loop++) {
-		if (!((1 << __linux_caps_maps[loop]) & caps)) {
-			continue;
-		}
-
-		switch (__linux_caps_maps[loop]) {
-			case CAP_CHOWN:
-				result |= 1 << OHOS_CAP_CHOWN;
-				break;
-			case CAP_DAC_OVERRIDE:
-				result |= 1 << OHOS_CAP_DAC_EXECUTE;
-				result |= 1 << OHOS_CAP_DAC_WRITE;
-				result |= 1 << OHOS_CAP_DAC_READ_SEARCH;
-				break;
-			case CAP_DAC_READ_SEARCH:
-				result |= 1 << OHOS_CAP_DAC_READ_SEARCH;
-				break;
-			case CAP_FOWNER:
-				result |= 1 << OHOS_CAP_FOWNER;
-				break;
-			case CAP_KILL:
-				result |= 1 << OHOS_CAP_KILL;
-				break;
-			case CAP_SETGID:
-				result |= 1 << OHOS_CAP_SETGID;
-				break;
-			case CAP_SETUID:
-				result |= 1 << OHOS_CAP_SETUID;
-				break;
-			case CAP_SETPCAP:
-				result |= 1 << OHOS_CAP_CAPSET;
-				break;
-			case CAP_NET_BIND_SERVICE:
-				result |= 1 << OHOS_CAP_NET_BIND_SERVICE;
-				break;
-			case CAP_NET_BROADCAST:
-				result |= 1 << OHOS_CAP_NET_BROADCAST;
-				break;
-			case CAP_NET_ADMIN:
-				result |= 1 << OHOS_CAP_NET_ADMIN;
-				break;
-			case CAP_NET_RAW:
-				result |= 1 << OHOS_CAP_NET_RAW;
-				break;
-			case CAP_SYS_PTRACE:
-				result |= 1 << OHOS_CAP_SHELL_EXEC;
-				break;
-			case CAP_SYS_ADMIN:
-				result |= 1 << OHOS_CAP_FS_MOUNT;
-				result |= 1 << OHOS_CAP_FS_FORMAT;
-				break;
-			case CAP_SYS_NICE:
-				result |= 1 << OHOS_CAP_SCHED_SETPRIORITY;
-				break;
-			case CAP_SYS_TIME:
-				result |= 1 << OHOS_CAP_SET_TIMEOFDAY;
-				result |= 1 << OHOS_CAP_CLOCK_SETTIME;
-				break;
-			case CAP_SYS_BOOT:
-				result |= 1 << OHOS_CAP_REBOOT;
-				break;
-			default:
-				break;
-		}
-	}
-
-	return result;
-}
-
-static unsigned int ohos_caps_to_linux(unsigned int caps)
-{
-	int num = sizeof(__ohos_caps_maps) / sizeof(int);
-	int loop;
-	unsigned int result = 0;
-	for (loop = 0; loop < num; loop++) {
-		if (!((1 << __ohos_caps_maps[loop]) & caps)) {
-			continue;
-		}
-
-		switch (__ohos_caps_maps[loop]) {
-			case OHOS_CAP_CHOWN:
-				result |= 1 << CAP_CHOWN;
-				break;
-			case OHOS_CAP_DAC_EXECUTE:
-			case OHOS_CAP_DAC_WRITE:
-				result |= 1 << CAP_DAC_OVERRIDE;
-				break;
-			case OHOS_CAP_DAC_READ_SEARCH:
-				result |= 1 << CAP_DAC_READ_SEARCH;
-				break;
-			case OHOS_CAP_FOWNER:
-				result |= 1 << CAP_FOWNER;
-				break;
-			case OHOS_CAP_KILL:
-				result |= 1 << CAP_KILL;
-				break;
-			case OHOS_CAP_SETGID:
-				result |= 1 << CAP_SETGID;
-				break;
-			case OHOS_CAP_SETUID:
-				result |= 1 << CAP_SETUID;
-				break;
-			case OHOS_CAP_CAPSET:
-				result |= 1 << CAP_SETPCAP;
-				break;
-			case OHOS_CAP_NET_BIND_SERVICE:
-				result |= 1 << CAP_NET_BIND_SERVICE;
-				break;
-			case OHOS_CAP_NET_BROADCAST:
-				result |= 1 << CAP_NET_BROADCAST;
-				break;
-			case OHOS_CAP_NET_ADMIN:
-				result |= 1 << CAP_NET_ADMIN;
-				break;
-			case OHOS_CAP_NET_RAW:
-				result |= 1 << CAP_NET_RAW;
-				break;
-			case OHOS_CAP_SHELL_EXEC:
-				result |= 1 << CAP_SYS_PTRACE;
-				break;
-			case OHOS_CAP_FS_MOUNT:
-			case OHOS_CAP_FS_FORMAT:
-				result |= 1 << CAP_SYS_ADMIN;
-				break;
-			case OHOS_CAP_SCHED_SETPRIORITY:
-				result |= 1 << CAP_SYS_NICE;
-				break;
-			case OHOS_CAP_SET_TIMEOFDAY:
-			case OHOS_CAP_CLOCK_SETTIME:
-				result |= 1 << CAP_SYS_TIME;
-				break;
-			case OHOS_CAP_REBOOT:
-				result |= 1 << CAP_SYS_BOOT;
-				break;
-			default:
-				break;
-		}
-	}
-
-	return result;
-}
-
-int linux_capget(cap_user_header_t hdr_ptr, cap_user_data_t data_ptr)
-{
-	unsigned int capvalue = 0;
-
-	if (hdr_ptr == NULL || data_ptr == NULL) {
-		errno = EINVAL;
-		return -1;
-	}
-
-	switch (hdr_ptr->version) {
-		case _LINUX_CAPABILITY_VERSION_1:
-		case _LINUX_CAPABILITY_VERSION_2:
-		case _LINUX_CAPABILITY_VERSION_3:
-			break;
-		default:
-			errno = EINVAL;
-			return -1;
-	}
-
-	if (syscall(SYS_ohoscapget, hdr_ptr->pid, &capvalue)) {
-		return -1;
-	}
-
-	data_ptr[0].effective = ohos_caps_to_linux(capvalue);
-	data_ptr[0].permitted = ohos_caps_to_linux(capvalue);
-	data_ptr[0].inheritable = ohos_caps_to_linux(capvalue);
-	return 0;
-}
-
-int linux_capset(cap_user_header_t hdr_ptr, const cap_user_data_t data_ptr)
-{
-	unsigned int capvalue = 0;
-
-	if (hdr_ptr == NULL || data_ptr == NULL) {
-		errno = EINVAL;
-		return -1;
-	}
-
-	if (hdr_ptr->pid) {
-		errno = EPERM;
-		return -1;
-	}
-
-	switch (hdr_ptr->version) {
-		case _LINUX_CAPABILITY_VERSION_1:
-		case _LINUX_CAPABILITY_VERSION_2:
-		case _LINUX_CAPABILITY_VERSION_3:
-			break;
-		default:
-			errno = EINVAL;
-			return -1;
-	}
-
-	capvalue = linux_caps_to_ohos(data_ptr[0].effective);
-	return syscall(SYS_ohoscapset, capvalue);
-}
-
-weak_alias(linux_capget, capget);
-weak_alias(linux_capset, capset);
 
-int ohos_capget(pid_t pid, unsigned int *caps)
+int capset(void *a, void *b)
 {
-	return syscall(SYS_ohoscapget, pid, caps);
+	return syscall(SYS_capset, a, b);
 }
 
-int ohos_capset(unsigned int caps)
+int capget(void *a, void *b)
 {
-	return syscall(SYS_ohoscapset, caps);
+	return syscall(SYS_capget, a, b);
 }
diff --git a/third_party/musl/src/linux/clone.c b/third_party/musl/src/linux/clone.c
index 0db0250ae..8c1af7d3d 100755
--- a/third_party/musl/src/linux/clone.c
+++ b/third_party/musl/src/linux/clone.c
@@ -4,7 +4,6 @@
 #include <sched.h>
 #include "pthread_impl.h"
 #include "syscall.h"
-#include <unsupported_api.h>
 
 int clone(int (*func)(void *), void *stack, int flags, void *arg, ...)
 {
@@ -12,7 +11,6 @@ int clone(int (*func)(void *), void *stack, int flags, void *arg, ...)
 	pid_t *ptid, *ctid;
 	void  *tls;
 
-	unsupported_api(__FUNCTION__);
 	va_start(ap, arg);
 	ptid = va_arg(ap, pid_t *);
 	tls  = va_arg(ap, void *);
diff --git a/third_party/musl/src/linux/epoll.c b/third_party/musl/src/linux/epoll.c
index 3fc76b908..deff5b101 100755
--- a/third_party/musl/src/linux/epoll.c
+++ b/third_party/musl/src/linux/epoll.c
@@ -2,11 +2,9 @@
 #include <signal.h>
 #include <errno.h>
 #include "syscall.h"
-#include <unsupported_api.h>
 
 int epoll_create(int size)
 {
-	unsupported_api(__FUNCTION__);
 	return epoll_create1(0);
 }
 
@@ -21,7 +19,6 @@ int epoll_create1(int flags)
 
 int epoll_ctl(int fd, int op, int fd2, struct epoll_event *ev)
 {
-	unsupported_api(__FUNCTION__);
 	return syscall(SYS_epoll_ctl, fd, op, fd2, ev);
 }
 
@@ -36,6 +33,5 @@ int epoll_pwait(int fd, struct epoll_event *ev, int cnt, int to, const sigset_t
 
 int epoll_wait(int fd, struct epoll_event *ev, int cnt, int to)
 {
-	unsupported_api(__FUNCTION__);
 	return epoll_pwait(fd, ev, cnt, to, 0);
 }
diff --git a/third_party/musl/src/linux/ppoll.c b/third_party/musl/src/linux/ppoll.c
index 060cad70b..e614600ab 100755
--- a/third_party/musl/src/linux/ppoll.c
+++ b/third_party/musl/src/linux/ppoll.c
@@ -3,7 +3,6 @@
 #include <signal.h>
 #include <errno.h>
 #include "syscall.h"
-#include <unsupported_api.h>
 
 #define IS32BIT(x) !((x)+0x80000000ULL>>32)
 #define CLAMP(x) (int)(IS32BIT(x) ? (x) : 0x7fffffffU+((0ULL+(x))>>63))
@@ -12,7 +11,6 @@ int ppoll(struct pollfd *fds, nfds_t n, const struct timespec *to, const sigset_
 {
 	time_t s = to ? to->tv_sec : 0;
 	long ns = to ? to->tv_nsec : 0;
-	unsupported_api(__FUNCTION__);
 #ifdef SYS_ppoll_time64
 	int r = -ENOSYS;
 	if (SYS_ppoll == SYS_ppoll_time64 || !IS32BIT(s))
diff --git a/third_party/musl/src/linux/utimes.c b/third_party/musl/src/linux/utimes.c
index b6f6df064..6ca025d95 100755
--- a/third_party/musl/src/linux/utimes.c
+++ b/third_party/musl/src/linux/utimes.c
@@ -1,10 +1,8 @@
 #include <sys/time.h>
-#include <unsupported_api.h>
 #include "fcntl.h"
 #include "syscall.h"
 
 int utimes(const char *path, const struct timeval times[2])
 {
-	unsupported_api(__FUNCTION__);
 	return __futimesat(AT_FDCWD, path, times);
 }
diff --git a/third_party/musl/src/locale/dcngettext.c b/third_party/musl/src/locale/dcngettext.c
index d36634e63..4c3043938 100755
--- a/third_party/musl/src/locale/dcngettext.c
+++ b/third_party/musl/src/locale/dcngettext.c
@@ -6,7 +6,6 @@
 #include <sys/stat.h>
 #include <sys/mman.h>
 #include <ctype.h>
-#include <unsupported_api.h>
 #include "locale_impl.h"
 #include "atomic.h"
 #include "pleval.h"
@@ -259,18 +258,15 @@ notrans:
 
 char *dcgettext(const char *domainname, const char *msgid, int category)
 {
-	unsupported_api(__FUNCTION__);
 	return dcngettext(domainname, msgid, 0, 1, category);
 }
 
 char *dngettext(const char *domainname, const char *msgid1, const char *msgid2, unsigned long int n)
 {
-	unsupported_api(__FUNCTION__);
 	return dcngettext(domainname, msgid1, msgid2, n, LC_MESSAGES);
 }
 
 char *dgettext(const char *domainname, const char *msgid)
 {
-	unsupported_api(__FUNCTION__);
 	return dcngettext(domainname, msgid, 0, 1, LC_MESSAGES);
 }
diff --git a/third_party/musl/src/locale/duplocale.c b/third_party/musl/src/locale/duplocale.c
index 2ed823d19..030b64cb0 100755
--- a/third_party/musl/src/locale/duplocale.c
+++ b/third_party/musl/src/locale/duplocale.c
@@ -1,13 +1,11 @@
 #include <stdlib.h>
 #include <string.h>
-#include <unsupported_api.h>
 #include "locale_impl.h"
 #include "libc.h"
 
 locale_t __duplocale(locale_t old)
 {
 	locale_t new = malloc(sizeof *new);
-	unsupported_api(__FUNCTION__);
 	if (!new) return 0;
 	if (old == LC_GLOBAL_LOCALE) old = &libc.global_locale;
 	*new = *old;
diff --git a/third_party/musl/src/locale/freelocale.c b/third_party/musl/src/locale/freelocale.c
index 74ca22b72..802b8bfe1 100755
--- a/third_party/musl/src/locale/freelocale.c
+++ b/third_party/musl/src/locale/freelocale.c
@@ -1,10 +1,8 @@
 #include <stdlib.h>
-#include <unsupported_api.h>
 #include "locale_impl.h"
 
 void freelocale(locale_t l)
 {
-	unsupported_api(__FUNCTION__);
 	if (__loc_is_allocated(l)) free(l);
 }
 
diff --git a/third_party/musl/src/locale/langinfo.c b/third_party/musl/src/locale/langinfo.c
index db10108ed..14773093b 100755
--- a/third_party/musl/src/locale/langinfo.c
+++ b/third_party/musl/src/locale/langinfo.c
@@ -1,6 +1,5 @@
 #include <locale.h>
 #include <langinfo.h>
-#include <unsupported_api.h>
 #include "locale_impl.h"
 
 static const char c_time[] =
@@ -33,8 +32,6 @@ char *__nl_langinfo_l(nl_item item, locale_t loc)
 	int idx = item & 65535;
 	const char *str;
 
-	unsupported_api(__FUNCTION__);
-
 	if (item == CODESET) return loc->cat[LC_CTYPE] ? "UTF-8" : "ASCII";
 
 	/* _NL_LOCALE_NAME extension */
@@ -69,7 +66,6 @@ char *__nl_langinfo_l(nl_item item, locale_t loc)
 
 char *__nl_langinfo(nl_item item)
 {
-	unsupported_api(__FUNCTION__);
 	return __nl_langinfo_l(item, CURRENT_LOCALE);
 }
 
diff --git a/third_party/musl/src/locale/strcoll.c b/third_party/musl/src/locale/strcoll.c
index 355a8aa5e..dd3cbc480 100644
--- a/third_party/musl/src/locale/strcoll.c
+++ b/third_party/musl/src/locale/strcoll.c
@@ -9,7 +9,7 @@ int __strcoll_l(const char *l, const char *r, locale_t loc)
 
 int strcoll(const char *l, const char *r)
 {
-	return strcmp(l, r);
+	return __strcoll_l(l, r, CURRENT_LOCALE);
 }
 
 weak_alias(__strcoll_l, strcoll_l);
diff --git a/third_party/musl/src/locale/strfmon.c b/third_party/musl/src/locale/strfmon.c
index fd1550d0e..7cf2136a0 100755
--- a/third_party/musl/src/locale/strfmon.c
+++ b/third_party/musl/src/locale/strfmon.c
@@ -3,7 +3,6 @@
 #include <stdarg.h>
 #include <monetary.h>
 #include <errno.h>
-#include <unsupported_api.h>
 #include "locale_impl.h"
 
 static ssize_t vstrfmon_l(char *s, size_t n, locale_t loc, const char *fmt, va_list ap)
@@ -81,7 +80,6 @@ ssize_t strfmon_l(char *restrict s, size_t n, locale_t loc, const char *restrict
 	va_list ap;
 	ssize_t ret;
 
-	unsupported_api(__FUNCTION__);
 	va_start(ap, fmt);
 	ret = vstrfmon_l(s, n, loc, fmt, ap);
 	va_end(ap);
diff --git a/third_party/musl/src/locale/textdomain.c b/third_party/musl/src/locale/textdomain.c
index 27f3a3ff6..d72753979 100755
--- a/third_party/musl/src/locale/textdomain.c
+++ b/third_party/musl/src/locale/textdomain.c
@@ -3,7 +3,6 @@
 #include <stdlib.h>
 #include <errno.h>
 #include <limits.h>
-#include <unsupported_api.h>
 
 static char *current_domain;
 
@@ -14,7 +13,6 @@ char *__gettextdomain()
 
 char *textdomain(const char *domainname)
 {
-	unsupported_api(__FUNCTION__);
 	if (!domainname) return __gettextdomain();
 
 	size_t domlen = strlen(domainname);
@@ -35,12 +33,10 @@ char *textdomain(const char *domainname)
 
 char *gettext(const char *msgid)
 {
-	unsupported_api(__FUNCTION__);
 	return dgettext(0, msgid);
 }
 
 char *ngettext(const char *msgid1, const char *msgid2, unsigned long int n)
 {
-	unsupported_api(__FUNCTION__);
 	return dngettext(0, msgid1, msgid2, n);
 }
diff --git a/third_party/musl/src/malloc/malloc.c b/third_party/musl/src/malloc/malloc.c
index df00631f9..96982596b 100644
--- a/third_party/musl/src/malloc/malloc.c
+++ b/third_party/musl/src/malloc/malloc.c
@@ -495,7 +495,7 @@ void __bin_chunk(struct chunk *self)
 	if (reclaim) {
 		uintptr_t a = (uintptr_t)self + SIZE_ALIGN+PAGE_SIZE-1 & -PAGE_SIZE;
 		uintptr_t b = (uintptr_t)next - SIZE_ALIGN & -PAGE_SIZE;
-#if 0
+#if 1
 		__madvise((void *)a, b-a, MADV_DONTNEED);
 #else
 		__mmap((void *)a, b-a, PROT_READ|PROT_WRITE,
diff --git a/third_party/musl/src/misc/gethostid.c b/third_party/musl/src/misc/gethostid.c
index f6c223da7..25bb35db8 100755
--- a/third_party/musl/src/misc/gethostid.c
+++ b/third_party/musl/src/misc/gethostid.c
@@ -1,8 +1,6 @@
 #include <unistd.h>
-#include <unsupported_api.h>
 
 long gethostid()
 {
-	unsupported_api(__FUNCTION__);
 	return 0;
 }
diff --git a/third_party/musl/src/misc/getpriority.c b/third_party/musl/src/misc/getpriority.c
index 42382122c..5c0b1682b 100755
--- a/third_party/musl/src/misc/getpriority.c
+++ b/third_party/musl/src/misc/getpriority.c
@@ -3,5 +3,7 @@
 
 int getpriority(int which, id_t who)
 {
-    return syscall(SYS_getpriority, which, who);
+	int ret = syscall(SYS_getpriority, which, who);
+	if (ret < 0) return ret;
+	return 20-ret;
 }
diff --git a/third_party/musl/src/misc/getrlimit.c b/third_party/musl/src/misc/getrlimit.c
index 69b73fcc1..2ab2f0f4f 100755
--- a/third_party/musl/src/misc/getrlimit.c
+++ b/third_party/musl/src/misc/getrlimit.c
@@ -1,6 +1,5 @@
 #include <sys/resource.h>
 #include <errno.h>
-#include <unsupported_api.h>
 #include "syscall.h"
 
 #define FIX(x) do{ if ((x)>=SYSCALL_RLIM_INFINITY) (x)=RLIM_INFINITY; }while(0)
@@ -8,7 +7,6 @@
 int getrlimit(int resource, struct rlimit *rlim)
 {
 	unsigned long k_rlim[2];
-	unsupported_api(__FUNCTION__);
 	int ret = syscall(SYS_prlimit64, 0, resource, 0, rlim);
 	if (!ret) {
 		FIX(rlim->rlim_cur);
diff --git a/third_party/musl/src/misc/getrusage.c b/third_party/musl/src/misc/getrusage.c
index ea491ef78..8e03e2e3d 100755
--- a/third_party/musl/src/misc/getrusage.c
+++ b/third_party/musl/src/misc/getrusage.c
@@ -1,13 +1,11 @@
 #include <sys/resource.h>
 #include <string.h>
 #include <errno.h>
-#include <unsupported_api.h>
 #include "syscall.h"
 
 int getrusage(int who, struct rusage *ru)
 {
 	int r;
-	unsupported_api(__FUNCTION__);
 #ifdef SYS_getrusage_time64
 	long long kru64[18];
 	r = __syscall(SYS_getrusage_time64, who, kru64);
diff --git a/third_party/musl/src/misc/lockf.c b/third_party/musl/src/misc/lockf.c
index f6d9a0bbd..16a80bec1 100755
--- a/third_party/musl/src/misc/lockf.c
+++ b/third_party/musl/src/misc/lockf.c
@@ -1,7 +1,6 @@
 #include <unistd.h>
 #include <fcntl.h>
 #include <errno.h>
-#include <unsupported_api.h>
 
 int lockf(int fd, int op, off_t size)
 {
@@ -10,7 +9,6 @@ int lockf(int fd, int op, off_t size)
 		.l_whence = SEEK_CUR,
 		.l_len = size,
 	};
-	unsupported_api(__FUNCTION__);
 	switch (op) {
 	case F_TEST:
 		l.l_type = F_RDLCK;
diff --git a/third_party/musl/src/misc/mntent.c b/third_party/musl/src/misc/mntent.c
index 2ddaaeed3..eabb8200b 100755
--- a/third_party/musl/src/misc/mntent.c
+++ b/third_party/musl/src/misc/mntent.c
@@ -2,7 +2,6 @@
 #include <string.h>
 #include <mntent.h>
 #include <errno.h>
-#include <unsupported_api.h>
 
 static char *internal_buf;
 static size_t internal_bufsize;
@@ -11,7 +10,6 @@ static size_t internal_bufsize;
 
 FILE *setmntent(const char *name, const char *mode)
 {
-	unsupported_api(__FUNCTION__);
 	return fopen(name, mode);
 }
 
@@ -28,7 +26,6 @@ struct mntent *getmntent_r(FILE *f, struct mntent *mnt, char *linebuf, int bufle
 	mnt->mnt_freq = 0;
 	mnt->mnt_passno = 0;
 
-	unsupported_api(__FUNCTION__);
 	do {
 		if (use_internal) {
 			getline(&internal_buf, &internal_bufsize, f);
@@ -63,13 +60,11 @@ struct mntent *getmntent_r(FILE *f, struct mntent *mnt, char *linebuf, int bufle
 struct mntent *getmntent(FILE *f)
 {
 	static struct mntent mnt;
-	unsupported_api(__FUNCTION__);
 	return getmntent_r(f, &mnt, SENTINEL, 0);
 }
 
 int addmntent(FILE *f, const struct mntent *mnt)
 {
-	unsupported_api(__FUNCTION__);
 	if (fseek(f, 0, SEEK_END)) return 1;
 	return fprintf(f, "%s\t%s\t%s\t%s\t%d\t%d\n",
 		mnt->mnt_fsname, mnt->mnt_dir, mnt->mnt_type, mnt->mnt_opts,
@@ -78,6 +73,5 @@ int addmntent(FILE *f, const struct mntent *mnt)
 
 char *hasmntopt(const struct mntent *mnt, const char *opt)
 {
-	unsupported_api(__FUNCTION__);
 	return strstr(mnt->mnt_opts, opt);
 }
diff --git a/third_party/musl/src/misc/openpty.c b/third_party/musl/src/misc/openpty.c
index 9c1ed0369..c10740606 100755
--- a/third_party/musl/src/misc/openpty.c
+++ b/third_party/musl/src/misc/openpty.c
@@ -4,7 +4,6 @@
 #include <pty.h>
 #include <stdio.h>
 #include <pthread.h>
-#include <unsupported_api.h>
 
 /* Nonstandard, but vastly superior to the standard functions */
 
@@ -13,7 +12,6 @@ int openpty(int *pm, int *ps, char *name, const struct termios *tio, const struc
 	int m, s, n=0, cs;
 	char buf[20];
 
-	unsupported_api(__FUNCTION__);
 	m = open("/dev/ptmx", O_RDWR|O_NOCTTY);
 	if (m < 0) return -1;
 
diff --git a/third_party/musl/src/misc/pty.c b/third_party/musl/src/misc/pty.c
index 8842b0e51..a0577147a 100755
--- a/third_party/musl/src/misc/pty.c
+++ b/third_party/musl/src/misc/pty.c
@@ -3,12 +3,10 @@
 #include <stdio.h>
 #include <fcntl.h>
 #include <errno.h>
-#include <unsupported_api.h>
 #include "syscall.h"
 
 int posix_openpt(int flags)
 {
-	unsupported_api(__FUNCTION__);
 	int r = open("/dev/ptmx", flags);
 	if (r < 0 && errno == ENOSPC) errno = EAGAIN;
 	return r;
@@ -16,7 +14,6 @@ int posix_openpt(int flags)
 
 int grantpt(int fd)
 {
-	unsupported_api(__FUNCTION__);
 	return 0;
 }
 
diff --git a/third_party/musl/src/misc/realpath.c b/third_party/musl/src/misc/realpath.c
index 58167a483..d2708e59d 100644
--- a/third_party/musl/src/misc/realpath.c
+++ b/third_party/musl/src/misc/realpath.c
@@ -9,7 +9,10 @@
 
 char *realpath(const char *restrict filename, char *restrict resolved)
 {
-	int ret;
+	int fd;
+	ssize_t r;
+	struct stat st1, st2;
+	char buf[15+3*sizeof(int)];
 	char tmp[PATH_MAX];
 
 	if (!filename) {
@@ -17,8 +20,24 @@ char *realpath(const char *restrict filename, char *restrict resolved)
 		return 0;
 	}
 
-	ret = syscall(SYS_realpath, filename, tmp);
-	if (ret < 0) return 0;
+	fd = sys_open(filename, O_PATH|O_NONBLOCK|O_CLOEXEC);
+	if (fd < 0) return 0;
+	__procfdname(buf, fd);
 
+	r = readlink(buf, tmp, sizeof tmp - 1);
+	if (r < 0) goto err;
+	tmp[r] = 0;
+
+	fstat(fd, &st1);
+	r = stat(tmp, &st2);
+	if (r<0 || st1.st_dev != st2.st_dev || st1.st_ino != st2.st_ino) {
+		if (!r) errno = ELOOP;
+		goto err;
+	}
+
+	__syscall(SYS_close, fd);
 	return resolved ? strcpy(resolved, tmp) : strdup(tmp);
+err:
+	__syscall(SYS_close, fd);
+	return 0;
 }
diff --git a/third_party/musl/src/misc/setrlimit.c b/third_party/musl/src/misc/setrlimit.c
index 715667551..7a66ab297 100755
--- a/third_party/musl/src/misc/setrlimit.c
+++ b/third_party/musl/src/misc/setrlimit.c
@@ -1,6 +1,5 @@
 #include <sys/resource.h>
 #include <errno.h>
-#include <unsupported_api.h>
 #include "syscall.h"
 #include "libc.h"
 
@@ -39,7 +38,6 @@ static void do_setrlimit(void *p)
 
 int setrlimit(int resource, const struct rlimit *rlim)
 {
-	unsupported_api(__FUNCTION__);
 	struct ctx c = { .res = resource, .rlim = rlim, .err = -1 };
 	__synccall(do_setrlimit, &c);
 	if (c.err) {
diff --git a/third_party/musl/src/misc/syslog.c b/third_party/musl/src/misc/syslog.c
index 1c5dcbc43..13d4b0a6d 100755
--- a/third_party/musl/src/misc/syslog.c
+++ b/third_party/musl/src/misc/syslog.c
@@ -9,7 +9,6 @@
 #include <pthread.h>
 #include <errno.h>
 #include <fcntl.h>
-#include <unsupported_api.h>
 #include "lock.h"
 
 static volatile int lock[1];
@@ -21,7 +20,6 @@ static int log_fd = -1;
 
 int setlogmask(int maskpri)
 {
-	unsupported_api(__FUNCTION__);
 	LOCK(lock);
 	int ret = log_mask;
 	if (maskpri) log_mask = maskpri;
@@ -40,7 +38,6 @@ static const struct {
 void closelog(void)
 {
 	int cs;
-	unsupported_api(__FUNCTION__);
 	pthread_setcancelstate(PTHREAD_CANCEL_DISABLE, &cs);
 	LOCK(lock);
 	close(log_fd);
@@ -58,7 +55,6 @@ static void __openlog()
 void openlog(const char *ident, int opt, int facility)
 {
 	int cs;
-	unsupported_api(__FUNCTION__);
 	pthread_setcancelstate(PTHREAD_CANCEL_DISABLE, &cs);
 	LOCK(lock);
 
@@ -139,7 +135,6 @@ static void __vsyslog(int priority, const char *message, va_list ap)
 
 void syslog(int priority, const char *message, ...)
 {
-	unsupported_api(__FUNCTION__);
 	va_list ap;
 	va_start(ap, message);
 	__vsyslog(priority, message, ap);
diff --git a/third_party/musl/src/misc/wordexp.c b/third_party/musl/src/misc/wordexp.c
index 19d4fe1fd..db83a69f3 100755
--- a/third_party/musl/src/misc/wordexp.c
+++ b/third_party/musl/src/misc/wordexp.c
@@ -9,7 +9,6 @@
 #include <signal.h>
 #include <errno.h>
 #include <fcntl.h>
-#include <unsupported_api.h>
 #include "pthread_impl.h"
 
 static void reap(pid_t pid)
@@ -171,7 +170,6 @@ nospace:
 int wordexp(const char *restrict s, wordexp_t *restrict we, int flags)
 {
 	int r, cs;
-	unsupported_api(__FUNCTION__);
 	pthread_setcancelstate(PTHREAD_CANCEL_DISABLE, &cs);
 	r = do_wordexp(s, we, flags);
 	pthread_setcancelstate(cs, 0);
diff --git a/third_party/musl/src/mman/mlock.c b/third_party/musl/src/mman/mlock.c
index e56c3228e..71af582fe 100755
--- a/third_party/musl/src/mman/mlock.c
+++ b/third_party/musl/src/mman/mlock.c
@@ -1,10 +1,8 @@
 #include <sys/mman.h>
 #include "syscall.h"
-#include <unsupported_api.h>
 
 int mlock(const void *addr, size_t len)
 {
-	unsupported_api(__FUNCTION__);
 #ifdef SYS_mlock
 	return syscall(SYS_mlock, addr, len);
 #else
diff --git a/third_party/musl/src/mman/mlockall.c b/third_party/musl/src/mman/mlockall.c
index bc2411e65..0ba4e662c 100755
--- a/third_party/musl/src/mman/mlockall.c
+++ b/third_party/musl/src/mman/mlockall.c
@@ -1,9 +1,7 @@
 #include <sys/mman.h>
-#include <unsupported_api.h>
 #include "syscall.h"
 
 int mlockall(int flags)
 {
-	unsupported_api(__FUNCTION__);
 	return syscall(SYS_mlockall, flags);
 }
diff --git a/third_party/musl/src/mman/msync.c b/third_party/musl/src/mman/msync.c
index 61cbf5f0d..fcd8cdf9f 100755
--- a/third_party/musl/src/mman/msync.c
+++ b/third_party/musl/src/mman/msync.c
@@ -1,9 +1,7 @@
 #include <sys/mman.h>
-#include <unsupported_api.h>
 #include "syscall.h"
 
 int msync(void *start, size_t len, int flags)
 {
-	unsupported_api(__FUNCTION__);
 	return syscall_cp(SYS_msync, start, len, flags);
 }
diff --git a/third_party/musl/src/mman/munlock.c b/third_party/musl/src/mman/munlock.c
index 8a6463a1e..2cccef0c5 100755
--- a/third_party/musl/src/mman/munlock.c
+++ b/third_party/musl/src/mman/munlock.c
@@ -1,9 +1,7 @@
 #include <sys/mman.h>
-#include <unsupported_api.h>
 #include "syscall.h"
 
 int munlock(const void *addr, size_t len)
 {
-	unsupported_api(__FUNCTION__);
 	return syscall(SYS_munlock, addr, len);
 }
diff --git a/third_party/musl/src/mman/munlockall.c b/third_party/musl/src/mman/munlockall.c
index 432700742..6e9d39d68 100755
--- a/third_party/musl/src/mman/munlockall.c
+++ b/third_party/musl/src/mman/munlockall.c
@@ -1,9 +1,7 @@
 #include <sys/mman.h>
-#include <unsupported_api.h>
 #include "syscall.h"
 
 int munlockall(void)
 {
-	unsupported_api(__FUNCTION__);
 	return syscall(SYS_munlockall);
 }
diff --git a/third_party/musl/src/mman/posix_madvise.c b/third_party/musl/src/mman/posix_madvise.c
index 8498ec939..e5e5acb84 100755
--- a/third_party/musl/src/mman/posix_madvise.c
+++ b/third_party/musl/src/mman/posix_madvise.c
@@ -1,11 +1,9 @@
 #define _GNU_SOURCE
 #include <sys/mman.h>
-#include <unsupported_api.h>
 #include "syscall.h"
 
 int posix_madvise(void *addr, size_t len, int advice)
 {
-	unsupported_api(__FUNCTION__);
 	if (advice == MADV_DONTNEED) return 0;
 	return -__syscall(SYS_madvise, addr, len, advice);
 }
diff --git a/third_party/musl/src/mman/shm_open.c b/third_party/musl/src/mman/shm_open.c
index ef8a8c946..79784bd30 100755
--- a/third_party/musl/src/mman/shm_open.c
+++ b/third_party/musl/src/mman/shm_open.c
@@ -5,7 +5,6 @@
 #include <string.h>
 #include <limits.h>
 #include <pthread.h>
-#include <unsupported_api.h>
 
 char *__shm_mapname(const char *name, char *buf)
 {
@@ -29,7 +28,6 @@ int shm_open(const char *name, int flag, mode_t mode)
 {
 	int cs;
 	char buf[NAME_MAX+10];
-	unsupported_api(__FUNCTION__);
 	if (!(name = __shm_mapname(name, buf))) return -1;
 	pthread_setcancelstate(PTHREAD_CANCEL_DISABLE, &cs);
 	int fd = open(name, flag|O_NOFOLLOW|O_CLOEXEC|O_NONBLOCK, mode);
@@ -40,7 +38,6 @@ int shm_open(const char *name, int flag, mode_t mode)
 int shm_unlink(const char *name)
 {
 	char buf[NAME_MAX+10];
-	unsupported_api(__FUNCTION__);
 	if (!(name = __shm_mapname(name, buf))) return -1;
 	return unlink(name);
 }
diff --git a/third_party/musl/src/mq/mq_close.c b/third_party/musl/src/mq/mq_close.c
index 645220cbd..a61f094d4 100644
--- a/third_party/musl/src/mq/mq_close.c
+++ b/third_party/musl/src/mq/mq_close.c
@@ -3,5 +3,5 @@
 
 int mq_close(mqd_t mqd)
 {
-	return syscall(SYS_mqclose, mqd);
+	return syscall(SYS_close, mqd);
 }
diff --git a/third_party/musl/src/multibyte/wcsnrtombs.c b/third_party/musl/src/multibyte/wcsnrtombs.c
index 95e25e708..676932b5d 100755
--- a/third_party/musl/src/multibyte/wcsnrtombs.c
+++ b/third_party/musl/src/multibyte/wcsnrtombs.c
@@ -1,33 +1,41 @@
 #include <wchar.h>
-#include <limits.h>
-#include <string.h>
 
 size_t wcsnrtombs(char *restrict dst, const wchar_t **restrict wcs, size_t wn, size_t n, mbstate_t *restrict st)
 {
+	size_t l, cnt=0, n2;
+	char *s, buf[256];
 	const wchar_t *ws = *wcs;
-	size_t cnt = 0;
-	if (!dst) n=0;
-	while (ws && wn) {
-		char tmp[MB_LEN_MAX];
-		size_t l = wcrtomb(n<MB_LEN_MAX ? tmp : dst, *ws, 0);
-		if (l==-1) {
-			cnt = -1;
+	const wchar_t *tmp_ws;
+
+	if (!dst) s = buf, n = sizeof buf;
+	else s = dst;
+
+	while ( ws && n && ( (n2=wn)>=n || n2>32 ) ) {
+		if (n2>=n) n2=n;
+		tmp_ws = ws;
+		l = wcsrtombs(s, &ws, n2, 0);
+		if (!(l+1)) {
+			cnt = l;
+			n = 0;
 			break;
 		}
-		if (dst) {
-			if (n<MB_LEN_MAX) {
-				if (l>n) break;
-				memcpy(dst, tmp, l);
-			}
-			dst += l;
+		if (s != buf) {
+			s += l;
 			n -= l;
 		}
-		if (!*ws) {
-			ws = 0;
+		wn = ws ? wn - (ws - tmp_ws) : 0;
+		cnt += l;
+	}
+	if (ws) while (n && wn) {
+		l = wcrtomb(s, *ws, 0);
+		if ((l+1)<=1) {
+			if (!l) ws = 0;
+			else cnt = l;
 			break;
 		}
-		ws++;
-		wn--;
+		ws++; wn--;
+		/* safe - this loop runs fewer than sizeof(buf) times */
+		s+=l; n-=l;
 		cnt += l;
 	}
 	if (dst) *wcs = ws;
diff --git a/third_party/musl/src/network/ent.c b/third_party/musl/src/network/ent.c
index e8f840ede..c6e012306 100755
--- a/third_party/musl/src/network/ent.c
+++ b/third_party/musl/src/network/ent.c
@@ -1,26 +1,21 @@
 #include <netdb.h>
-#include <unsupported_api.h>
 
 void sethostent(int x)
 {
-	unsupported_api(__FUNCTION__);
 }
 
 struct hostent *gethostent()
 {
-	unsupported_api(__FUNCTION__);
 	return 0;
 }
 
 struct netent *getnetent()
 {
-	unsupported_api(__FUNCTION__);
 	return 0;
 }
 
 void endhostent(void)
 {
-	unsupported_api(__FUNCTION__);
 }
 
 weak_alias(sethostent, setnetent);
diff --git a/third_party/musl/src/network/ether.c b/third_party/musl/src/network/ether.c
index e3d295107..4304a972f 100755
--- a/third_party/musl/src/network/ether.c
+++ b/third_party/musl/src/network/ether.c
@@ -1,7 +1,6 @@
 #include <stdlib.h>
 #include <netinet/ether.h>
 #include <stdio.h>
-#include <unsupported_api.h>
 
 struct ether_addr *ether_aton_r (const char *x, struct ether_addr *p_a)
 {
@@ -45,18 +44,15 @@ char *ether_ntoa (const struct ether_addr *p_a) {
 
 int ether_line(const char *l, struct ether_addr *e, char *hostname)
 {
-	unsupported_api(__FUNCTION__);
 	return -1;
 }
 
 int ether_ntohost(char *hostname, const struct ether_addr *e)
 {
-	unsupported_api(__FUNCTION__);
 	return -1;
 }
 
 int ether_hostton(const char *hostname, struct ether_addr *e)
 {
-	unsupported_api(__FUNCTION__);
 	return -1;
 }
diff --git a/third_party/musl/src/network/freeaddrinfo.c b/third_party/musl/src/network/freeaddrinfo.c
index e86e3dacb..62241c239 100755
--- a/third_party/musl/src/network/freeaddrinfo.c
+++ b/third_party/musl/src/network/freeaddrinfo.c
@@ -3,12 +3,10 @@
 #include <netdb.h>
 #include "lookup.h"
 #include "lock.h"
-#include <unsupported_api.h>
 
 void freeaddrinfo(struct addrinfo *p)
 {
 	size_t cnt;
-	unsupported_api(__FUNCTION__);
 	for (cnt=1; p->ai_next; cnt++, p=p->ai_next);
 	struct aibuf *b = (void *)((char *)p - offsetof(struct aibuf, ai));
 	b -= b->slot;
diff --git a/third_party/musl/src/network/gai_strerror.c b/third_party/musl/src/network/gai_strerror.c
index 1415e9769..9596580e9 100755
--- a/third_party/musl/src/network/gai_strerror.c
+++ b/third_party/musl/src/network/gai_strerror.c
@@ -1,5 +1,4 @@
 #include <netdb.h>
-#include <unsupported_api.h>
 #include "locale_impl.h"
 
 static const char msgs[] =
@@ -20,7 +19,6 @@ static const char msgs[] =
 const char *gai_strerror(int ecode)
 {
 	const char *s;
-	unsupported_api(__FUNCTION__);
 	for (s=msgs, ecode++; ecode && *s; ecode++, s++) for (; *s; s++);
 	if (!*s) s++;
 	return LCTRANS_CUR(s);
diff --git a/third_party/musl/src/network/getaddrinfo.c b/third_party/musl/src/network/getaddrinfo.c
index 97452d0c3..efaab3068 100755
--- a/third_party/musl/src/network/getaddrinfo.c
+++ b/third_party/musl/src/network/getaddrinfo.c
@@ -7,7 +7,6 @@
 #include <unistd.h>
 #include <endian.h>
 #include <errno.h>
-#include <unsupported_api.h>
 #include "lookup.h"
 
 int getaddrinfo(const char *restrict host, const char *restrict serv, const struct addrinfo *restrict hint, struct addrinfo **restrict res)
@@ -19,8 +18,6 @@ int getaddrinfo(const char *restrict host, const char *restrict serv, const stru
 	int family = AF_UNSPEC, flags = 0, proto = 0, socktype = 0;
 	struct aibuf *out;
 
-	unsupported_api(__FUNCTION__);
-
 	if (!host && !serv) return EAI_NONAME;
 
 	if (hint) {
diff --git a/third_party/musl/src/network/gethostbyaddr.c b/third_party/musl/src/network/gethostbyaddr.c
index 03fdaf840..598e2241a 100755
--- a/third_party/musl/src/network/gethostbyaddr.c
+++ b/third_party/musl/src/network/gethostbyaddr.c
@@ -3,7 +3,6 @@
 #include <netdb.h>
 #include <errno.h>
 #include <stdlib.h>
-#include <unsupported_api.h>
 
 struct hostent *gethostbyaddr(const void *a, socklen_t l, int af)
 {
@@ -11,7 +10,6 @@ struct hostent *gethostbyaddr(const void *a, socklen_t l, int af)
 	size_t size = 63;
 	struct hostent *res;
 	int err;
-	unsupported_api(__FUNCTION__);
 	do {
 		free(h);
 		h = malloc(size+=size+1);
diff --git a/third_party/musl/src/network/gethostbyaddr_r.c b/third_party/musl/src/network/gethostbyaddr_r.c
index ce4e3f677..0f1e61aa0 100755
--- a/third_party/musl/src/network/gethostbyaddr_r.c
+++ b/third_party/musl/src/network/gethostbyaddr_r.c
@@ -6,7 +6,6 @@
 #include <netinet/in.h>
 #include <errno.h>
 #include <inttypes.h>
-#include <unsupported_api.h>
 
 int gethostbyaddr_r(const void *a, socklen_t l, int af,
 	struct hostent *h, char *buf, size_t buflen,
@@ -20,7 +19,7 @@ int gethostbyaddr_r(const void *a, socklen_t l, int af,
 	int i;
 
 	*res = 0;
-	unsupported_api(__FUNCTION__);
+
 	/* Load address argument into sockaddr structure */
 	if (af==AF_INET6 && l==16) memcpy(&sa.sin6.sin6_addr, a, 16);
 	else if (af==AF_INET && l==4) memcpy(&sa.sin.sin_addr, a, 4);
diff --git a/third_party/musl/src/network/gethostbyname.c b/third_party/musl/src/network/gethostbyname.c
index 80b427ca9..bfedf52ad 100755
--- a/third_party/musl/src/network/gethostbyname.c
+++ b/third_party/musl/src/network/gethostbyname.c
@@ -4,10 +4,8 @@
 #include <netdb.h>
 #include <string.h>
 #include <netinet/in.h>
-#include <unsupported_api.h>
 
 struct hostent *gethostbyname(const char *name)
 {
-	unsupported_api(__FUNCTION__);
 	return gethostbyname2(name, AF_INET);
 }
diff --git a/third_party/musl/src/network/gethostbyname2.c b/third_party/musl/src/network/gethostbyname2.c
index 8410dd0b9..dc9d6621b 100755
--- a/third_party/musl/src/network/gethostbyname2.c
+++ b/third_party/musl/src/network/gethostbyname2.c
@@ -4,7 +4,6 @@
 #include <netdb.h>
 #include <errno.h>
 #include <stdlib.h>
-#include <unsupported_api.h>
 
 struct hostent *gethostbyname2(const char *name, int af)
 {
@@ -12,7 +11,6 @@ struct hostent *gethostbyname2(const char *name, int af)
 	size_t size = 63;
 	struct hostent *res;
 	int err;
-	unsupported_api(__FUNCTION__);
 	do {
 		free(h);
 		h = malloc(size+=size+1);
diff --git a/third_party/musl/src/network/gethostbyname2_r.c b/third_party/musl/src/network/gethostbyname2_r.c
index 853ef7cbc..fc8948776 100755
--- a/third_party/musl/src/network/gethostbyname2_r.c
+++ b/third_party/musl/src/network/gethostbyname2_r.c
@@ -7,7 +7,6 @@
 #include <errno.h>
 #include <stdint.h>
 #include "lookup.h"
-#include <unsupported_api.h>
 
 int gethostbyname2_r(const char *name, int af,
 	struct hostent *h, char *buf, size_t buflen,
@@ -19,7 +18,6 @@ int gethostbyname2_r(const char *name, int af,
 	size_t align, need;
 
 	*res = 0;
-	unsupported_api(__FUNCTION__);
 	cnt = __lookup_name(addrs, canon, name, af, AI_CANONNAME);
 	if (cnt<0) switch (cnt) {
 	case EAI_NONAME:
diff --git a/third_party/musl/src/network/gethostbyname_r.c b/third_party/musl/src/network/gethostbyname_r.c
index c89d6f2ec..cd8725417 100755
--- a/third_party/musl/src/network/gethostbyname_r.c
+++ b/third_party/musl/src/network/gethostbyname_r.c
@@ -2,12 +2,10 @@
 
 #include <sys/socket.h>
 #include <netdb.h>
-#include <unsupported_api.h>
 
 int gethostbyname_r(const char *name,
 	struct hostent *h, char *buf, size_t buflen,
 	struct hostent **res, int *err)
 {
-	unsupported_api(__FUNCTION__);
 	return gethostbyname2_r(name, AF_INET, h, buf, buflen, res, err);
 }
diff --git a/third_party/musl/src/network/getifaddrs.c b/third_party/musl/src/network/getifaddrs.c
index 09088957d..fed75bd8d 100755
--- a/third_party/musl/src/network/getifaddrs.c
+++ b/third_party/musl/src/network/getifaddrs.c
@@ -7,7 +7,6 @@
 #include <syscall.h>
 #include <net/if.h>
 #include <netinet/in.h>
-#include <unsupported_api.h>
 #include "netlink.h"
 
 #define IFADDRS_HASH_SIZE 64
@@ -209,7 +208,6 @@ int getifaddrs(struct ifaddrs **ifap)
 {
 	struct ifaddrs_ctx _ctx, *ctx = &_ctx;
 	int r;
-	unsupported_api(__FUNCTION__);
 	memset(ctx, 0, sizeof *ctx);
 	r = __rtnetlink_enumerate(AF_UNSPEC, AF_UNSPEC, netlink_msg_to_ifaddr, ctx);
 	if (r == 0) *ifap = &ctx->first->ifa;
diff --git a/third_party/musl/src/network/getnameinfo.c b/third_party/musl/src/network/getnameinfo.c
index 9734c0c25..f77e73ade 100755
--- a/third_party/musl/src/network/getnameinfo.c
+++ b/third_party/musl/src/network/getnameinfo.c
@@ -9,7 +9,6 @@
 #include <net/if.h>
 #include <ctype.h>
 #include <resolv.h>
-#include <unsupported_api.h>
 #include "lookup.h"
 #include "stdio_impl.h"
 
@@ -130,7 +129,6 @@ int getnameinfo(const struct sockaddr *restrict sa, socklen_t sl,
 	unsigned char *a;
 	unsigned scopeid;
 
-	unsupported_api(__FUNCTION__);
 	switch (af) {
 	case AF_INET:
 		a = (void *)&((struct sockaddr_in *)sa)->sin_addr;
diff --git a/third_party/musl/src/network/getservbyname.c b/third_party/musl/src/network/getservbyname.c
index fb721bfda..dd3037678 100755
--- a/third_party/musl/src/network/getservbyname.c
+++ b/third_party/musl/src/network/getservbyname.c
@@ -1,13 +1,11 @@
 #define _GNU_SOURCE
 #include <netdb.h>
-#include <unsupported_api.h>
 
 struct servent *getservbyname(const char *name, const char *prots)
 {
 	static struct servent se;
 	static char *buf[2];
 	struct servent *res;
-	unsupported_api(__FUNCTION__);
 	if (getservbyname_r(name, prots, &se, (void *)buf, sizeof buf, &res))
 		return 0;
 	return &se;
diff --git a/third_party/musl/src/network/getservbyname_r.c b/third_party/musl/src/network/getservbyname_r.c
index 3f03930e5..cad6317ab 100755
--- a/third_party/musl/src/network/getservbyname_r.c
+++ b/third_party/musl/src/network/getservbyname_r.c
@@ -7,7 +7,6 @@
 #include <string.h>
 #include <stdlib.h>
 #include "lookup.h"
-#include <unsupported_api.h>
 
 #define ALIGN (sizeof(struct { char a; char *b; }) - sizeof(char *))
 
@@ -18,7 +17,6 @@ int getservbyname_r(const char *name, const char *prots,
 	int cnt, proto, align;
 
 	*res = 0;
-	unsupported_api(__FUNCTION__);
 
 	/* Don't treat numeric port number strings as service records. */
 	char *end = "";
diff --git a/third_party/musl/src/network/getservbyport.c b/third_party/musl/src/network/getservbyport.c
index 9aaeab0f0..c9ecbb11c 100755
--- a/third_party/musl/src/network/getservbyport.c
+++ b/third_party/musl/src/network/getservbyport.c
@@ -1,13 +1,11 @@
 #define _GNU_SOURCE
 #include <netdb.h>
-#include <unsupported_api.h>
 
 struct servent *getservbyport(int port, const char *prots)
 {
 	static struct servent se;
 	static long buf[32/sizeof(long)];
 	struct servent *res;
-	unsupported_api(__FUNCTION__);
 	if (getservbyport_r(port, prots, &se, (void *)buf, sizeof buf, &res))
 		return 0;
 	return &se;
diff --git a/third_party/musl/src/network/getservbyport_r.c b/third_party/musl/src/network/getservbyport_r.c
index 18cfd6a72..b7f21c6b3 100755
--- a/third_party/musl/src/network/getservbyport_r.c
+++ b/third_party/musl/src/network/getservbyport_r.c
@@ -6,7 +6,6 @@
 #include <errno.h>
 #include <string.h>
 #include <stdlib.h>
-#include <unsupported_api.h>
 
 int getservbyport_r(int port, const char *prots,
 	struct servent *se, char *buf, size_t buflen, struct servent **res)
@@ -16,7 +15,6 @@ int getservbyport_r(int port, const char *prots,
 		.sin_family = AF_INET,
 		.sin_port = port,
 	};
-	unsupported_api(__FUNCTION__);
 
 	if (!prots) {
 		int r = getservbyport_r(port, "tcp", se, buf, buflen, res);
diff --git a/third_party/musl/src/network/if_indextoname.c b/third_party/musl/src/network/if_indextoname.c
index d4fb019ce..3b368bf0d 100755
--- a/third_party/musl/src/network/if_indextoname.c
+++ b/third_party/musl/src/network/if_indextoname.c
@@ -4,14 +4,13 @@
 #include <sys/ioctl.h>
 #include <string.h>
 #include <errno.h>
-#include <unsupported_api.h>
 #include "syscall.h"
 
 char *if_indextoname(unsigned index, char *name)
 {
 	struct ifreq ifr;
 	int fd, r;
-	unsupported_api(__FUNCTION__);
+
 	if ((fd = socket(AF_UNIX, SOCK_DGRAM|SOCK_CLOEXEC, 0)) < 0) return 0;
 	ifr.ifr_ifindex = index;
 	r = ioctl(fd, SIOCGIFNAME, &ifr);
diff --git a/third_party/musl/src/network/if_nameindex.c b/third_party/musl/src/network/if_nameindex.c
index a9990fa39..2deaef769 100755
--- a/third_party/musl/src/network/if_nameindex.c
+++ b/third_party/musl/src/network/if_nameindex.c
@@ -5,7 +5,6 @@
 #include <stdlib.h>
 #include <string.h>
 #include <pthread.h>
-#include <unsupported_api.h>
 #include "netlink.h"
 
 #define IFADDRS_HASH_SIZE 64
diff --git a/third_party/musl/src/network/if_nametoindex.c b/third_party/musl/src/network/if_nametoindex.c
index 6447fe098..331413c68 100755
--- a/third_party/musl/src/network/if_nametoindex.c
+++ b/third_party/musl/src/network/if_nametoindex.c
@@ -3,14 +3,13 @@
 #include <sys/socket.h>
 #include <sys/ioctl.h>
 #include <string.h>
-#include <unsupported_api.h>
 #include "syscall.h"
 
 unsigned if_nametoindex(const char *name)
 {
 	struct ifreq ifr;
 	int fd, r;
-	unsupported_api(__FUNCTION__);
+
 	if ((fd = socket(AF_UNIX, SOCK_DGRAM|SOCK_CLOEXEC, 0)) < 0) return 0;
 	strncpy(ifr.ifr_name, name, sizeof ifr.ifr_name);
 	r = ioctl(fd, SIOCGIFINDEX, &ifr);
diff --git a/third_party/musl/src/network/inet_legacy.c b/third_party/musl/src/network/inet_legacy.c
index 6d91b6e17..621b47b05 100644
--- a/third_party/musl/src/network/inet_legacy.c
+++ b/third_party/musl/src/network/inet_legacy.c
@@ -12,12 +12,12 @@ struct in_addr inet_makeaddr(in_addr_t n, in_addr_t h)
 	if (n < 256) h |= n<<24;
 	else if (n < 65536) h |= n<<16;
 	else h |= n<<8;
-	return (struct in_addr){ htonl(h) };
+	return (struct in_addr){ h };
 }
 
 in_addr_t inet_lnaof(struct in_addr in)
 {
-	uint32_t h = ntohl(in.s_addr);
+	uint32_t h = in.s_addr;
 	if (h>>24 < 128) return h & 0xffffff;
 	if (h>>24 < 192) return h & 0xffff;
 	return h & 0xff;
@@ -25,7 +25,7 @@ in_addr_t inet_lnaof(struct in_addr in)
 
 in_addr_t inet_netof(struct in_addr in)
 {
-	uint32_t h = ntohl(in.s_addr);
+	uint32_t h = in.s_addr;
 	if (h>>24 < 128) return h >> 24;
 	if (h>>24 < 192) return h >> 16;
 	return h >> 8;
diff --git a/third_party/musl/src/network/netname.c b/third_party/musl/src/network/netname.c
index 1351b688d..ba6e66568 100755
--- a/third_party/musl/src/network/netname.c
+++ b/third_party/musl/src/network/netname.c
@@ -1,15 +1,12 @@
 #include <netdb.h>
-#include <unsupported_api.h>
 
 struct netent *getnetbyaddr(uint32_t net, int type)
 {
-	unsupported_api(__FUNCTION__);
 	return 0;
 }
 
 struct netent *getnetbyname(const char *name)
 {
-	unsupported_api(__FUNCTION__);
 	return 0;
 }
 
diff --git a/third_party/musl/src/network/proto.c b/third_party/musl/src/network/proto.c
index f5b7db45a..c4fd34efb 100755
--- a/third_party/musl/src/network/proto.c
+++ b/third_party/musl/src/network/proto.c
@@ -1,6 +1,5 @@
 #include <netdb.h>
 #include <string.h>
-#include <unsupported_api.h>
 
 /* do we really need all these?? */
 
@@ -46,7 +45,6 @@ static const unsigned char protos[] = {
 
 void endprotoent(void)
 {
-	unsupported_api(__FUNCTION__);
 	idx = 0;
 }
 
diff --git a/third_party/musl/src/network/recvmsg.c b/third_party/musl/src/network/recvmsg.c
index 29f01cb62..03641625e 100644
--- a/third_party/musl/src/network/recvmsg.c
+++ b/third_party/musl/src/network/recvmsg.c
@@ -3,7 +3,6 @@
 #include <time.h>
 #include <sys/time.h>
 #include <string.h>
-#include <errno.h>
 #include "syscall.h"
 
 hidden void __convert_scm_timestamps(struct msghdr *, socklen_t);
@@ -51,10 +50,6 @@ void __convert_scm_timestamps(struct msghdr *msg, socklen_t csize)
 ssize_t recvmsg(int fd, struct msghdr *msg, int flags)
 {
 	ssize_t r;
-	if (!msg) {
-		errno = EFAULT;
-		return -1;
-	}
 	socklen_t orig_controllen = msg->msg_controllen;
 #if LONG_MAX > INT_MAX
 	struct msghdr h, *orig = msg;
diff --git a/third_party/musl/src/network/serv.c b/third_party/musl/src/network/serv.c
index f7e4f209b..41424e806 100755
--- a/third_party/musl/src/network/serv.c
+++ b/third_party/musl/src/network/serv.c
@@ -1,18 +1,14 @@
 #include <netdb.h>
-#include <unsupported_api.h>
 
 void endservent(void)
 {
-	unsupported_api(__FUNCTION__);
 }
 
 void setservent(int stayopen)
 {
-	unsupported_api(__FUNCTION__);
 }
 
 struct servent *getservent(void)
 {
-	unsupported_api(__FUNCTION__);
 	return 0;
 }
diff --git a/third_party/musl/src/network/sockatmark.c b/third_party/musl/src/network/sockatmark.c
index 8162c8c73..f474551aa 100755
--- a/third_party/musl/src/network/sockatmark.c
+++ b/third_party/musl/src/network/sockatmark.c
@@ -1,11 +1,9 @@
 #include <sys/socket.h>
 #include <sys/ioctl.h>
-#include <unsupported_api.h>
 
 int sockatmark(int s)
 {
 	int ret;
-	unsupported_api(__FUNCTION__);
 	if (ioctl(s, SIOCATMARK, &ret) < 0)
 		return -1;
 	return ret;
diff --git a/third_party/musl/src/passwd/getgr_r.c b/third_party/musl/src/passwd/getgr_r.c
index 7ab45f552..f3e8f603a 100755
--- a/third_party/musl/src/passwd/getgr_r.c
+++ b/third_party/musl/src/passwd/getgr_r.c
@@ -1,6 +1,5 @@
 #include "pwf.h"
 #include <pthread.h>
-#include <unsupported_api.h>
 
 #define FIX(x) (gr->gr_##x = gr->gr_##x-line+buf)
 
@@ -41,12 +40,10 @@ static int getgr_r(const char *name, gid_t gid, struct group *gr, char *buf, siz
 
 int getgrnam_r(const char *name, struct group *gr, char *buf, size_t size, struct group **res)
 {
-	unsupported_api(__FUNCTION__);
 	return getgr_r(name, 0, gr, buf, size, res);
 }
 
 int getgrgid_r(gid_t gid, struct group *gr, char *buf, size_t size, struct group **res)
 {
-	unsupported_api(__FUNCTION__);
 	return getgr_r(0, gid, gr, buf, size, res);
 }
diff --git a/third_party/musl/src/passwd/getgrent.c b/third_party/musl/src/passwd/getgrent.c
index c84ef5e63..835b9ab5a 100755
--- a/third_party/musl/src/passwd/getgrent.c
+++ b/third_party/musl/src/passwd/getgrent.c
@@ -1,4 +1,3 @@
-#include <unsupported_api.h>
 #include "pwf.h"
 
 static FILE *f;
@@ -7,7 +6,6 @@ static struct group gr;
 
 void setgrent()
 {
-	unsupported_api(__FUNCTION__);
 	if (f) fclose(f);
 	f = 0;
 }
@@ -18,7 +16,6 @@ struct group *getgrent()
 {
 	struct group *res;
 	size_t size=0, nmem=0;
-	unsupported_api(__FUNCTION__);
 	if (!f) f = fopen("/etc/group", "rbe");
 	if (!f) return 0;
 	__getgrent_a(f, &gr, &line, &size, &mem, &nmem, &res);
@@ -29,7 +26,6 @@ struct group *getgrgid(gid_t gid)
 {
 	struct group *res;
 	size_t size=0, nmem=0;
-	unsupported_api(__FUNCTION__);
 	__getgr_a(0, gid, &gr, &line, &size, &mem, &nmem, &res);
 	return res;
 }
@@ -38,7 +34,6 @@ struct group *getgrnam(const char *name)
 {
 	struct group *res;
 	size_t size=0, nmem=0;
-	unsupported_api(__FUNCTION__);
 	__getgr_a(name, 0, &gr, &line, &size, &mem, &nmem, &res);
 	return res;
 }
diff --git a/third_party/musl/src/passwd/getpw_r.c b/third_party/musl/src/passwd/getpw_r.c
index f09333d14..0c87ab05d 100755
--- a/third_party/musl/src/passwd/getpw_r.c
+++ b/third_party/musl/src/passwd/getpw_r.c
@@ -1,6 +1,5 @@
 #include "pwf.h"
 #include <pthread.h>
-#include <unsupported_api.h>
 
 #define FIX(x) (pw->pw_##x = pw->pw_##x-line+buf)
 
@@ -34,7 +33,6 @@ static int getpw_r(const char *name, uid_t uid, struct passwd *pw, char *buf, si
 
 int getpwnam_r(const char *name, struct passwd *pw, char *buf, size_t size, struct passwd **res)
 {
-	unsupported_api(__FUNCTION__);
 	return getpw_r(name, 0, pw, buf, size, res);
 }
 
diff --git a/third_party/musl/src/passwd/getpwent.c b/third_party/musl/src/passwd/getpwent.c
index 1b5403187..f2bd516e5 100755
--- a/third_party/musl/src/passwd/getpwent.c
+++ b/third_party/musl/src/passwd/getpwent.c
@@ -1,4 +1,3 @@
-#include <unsupported_api.h>
 #include "pwf.h"
 
 static FILE *f;
@@ -8,7 +7,6 @@ static size_t size;
 
 void setpwent()
 {
-	unsupported_api(__FUNCTION__);
 	if (f) fclose(f);
 	f = 0;
 }
@@ -18,7 +16,6 @@ weak_alias(setpwent, endpwent);
 struct passwd *getpwent()
 {
 	struct passwd *res;
-	unsupported_api(__FUNCTION__);
 	if (!f) f = fopen("/etc/passwd", "rbe");
 	if (!f) return 0;
 	__getpwent_a(f, &pw, &line, &size, &res);
@@ -28,7 +25,6 @@ struct passwd *getpwent()
 struct passwd *getpwuid(uid_t uid)
 {
 	struct passwd *res;
-	unsupported_api(__FUNCTION__);
 	__getpw_a(0, uid, &pw, &line, &size, &res);
 	return res;
 }
@@ -36,7 +32,6 @@ struct passwd *getpwuid(uid_t uid)
 struct passwd *getpwnam(const char *name)
 {
 	struct passwd *res;
-	unsupported_api(__FUNCTION__);
 	__getpw_a(name, 0, &pw, &line, &size, &res);
 	return res;
 }
diff --git a/third_party/musl/src/process/fexecve.c b/third_party/musl/src/process/fexecve.c
index cc02ad936..554c1981b 100755
--- a/third_party/musl/src/process/fexecve.c
+++ b/third_party/musl/src/process/fexecve.c
@@ -3,11 +3,9 @@
 #include <errno.h>
 #include <fcntl.h>
 #include "syscall.h"
-#include <unsupported_api.h>
 
 int fexecve(int fd, char *const argv[], char *const envp[])
 {
-	unsupported_api(__FUNCTION__);
 	int r = __syscall(SYS_execveat, fd, "", argv, envp, AT_EMPTY_PATH);
 	if (r != -ENOSYS) return __syscall_ret(r);
 	char buf[15 + 3*sizeof(int)];
diff --git a/third_party/musl/src/process/fork.c b/third_party/musl/src/process/fork.c
index b5b8dca0a..fb42478ae 100644
--- a/third_party/musl/src/process/fork.c
+++ b/third_party/musl/src/process/fork.c
@@ -30,7 +30,6 @@ pid_t fork(void)
 		self->next = self->prev = self;
 		__thread_list_lock = 0;
 		libc.threads_minus_1 = 0;
-		signal(SIGSYS, arm_do_signal);
 	}
 	__restore_sigs(&set);
 	__fork_handler(!ret);
diff --git a/third_party/musl/src/process/posix_spawn.c b/third_party/musl/src/process/posix_spawn.c
index 5a5d94c69..29652197c 100755
--- a/third_party/musl/src/process/posix_spawn.c
+++ b/third_party/musl/src/process/posix_spawn.c
@@ -5,7 +5,6 @@
 #include <signal.h>
 #include <fcntl.h>
 #include <sys/wait.h>
-#include <unsupported_api.h>
 #include "syscall.h"
 #include "pthread_impl.h"
 #include "fdop.h"
@@ -171,7 +170,6 @@ int posix_spawn(pid_t *restrict res, const char *restrict path,
 	int ec=0, cs;
 	struct args args;
 
-	unsupported_api(__FUNCTION__);
 	if (pipe2(args.p, O_CLOEXEC))
 		return errno;
 
diff --git a/third_party/musl/src/process/posix_spawn_file_actions_addclose.c b/third_party/musl/src/process/posix_spawn_file_actions_addclose.c
index 7f6fc8569..cdda59799 100755
--- a/third_party/musl/src/process/posix_spawn_file_actions_addclose.c
+++ b/third_party/musl/src/process/posix_spawn_file_actions_addclose.c
@@ -2,11 +2,9 @@
 #include <stdlib.h>
 #include <errno.h>
 #include "fdop.h"
-#include <unsupported_api.h>
 
 int posix_spawn_file_actions_addclose(posix_spawn_file_actions_t *fa, int fd)
 {
-	unsupported_api(__FUNCTION__);
 	struct fdop *op = malloc(sizeof *op);
 	if (!op) return ENOMEM;
 	op->cmd = FDOP_CLOSE;
diff --git a/third_party/musl/src/process/posix_spawn_file_actions_adddup2.c b/third_party/musl/src/process/posix_spawn_file_actions_adddup2.c
index 19e518116..0367498fd 100755
--- a/third_party/musl/src/process/posix_spawn_file_actions_adddup2.c
+++ b/third_party/musl/src/process/posix_spawn_file_actions_adddup2.c
@@ -2,11 +2,9 @@
 #include <stdlib.h>
 #include <errno.h>
 #include "fdop.h"
-#include <unsupported_api.h>
 
 int posix_spawn_file_actions_adddup2(posix_spawn_file_actions_t *fa, int srcfd, int fd)
 {
-	unsupported_api(__FUNCTION__);
 	struct fdop *op = malloc(sizeof *op);
 	if (!op) return ENOMEM;
 	op->cmd = FDOP_DUP2;
diff --git a/third_party/musl/src/process/posix_spawn_file_actions_addopen.c b/third_party/musl/src/process/posix_spawn_file_actions_addopen.c
index 35c52d3c6..368922c76 100755
--- a/third_party/musl/src/process/posix_spawn_file_actions_addopen.c
+++ b/third_party/musl/src/process/posix_spawn_file_actions_addopen.c
@@ -3,11 +3,9 @@
 #include <string.h>
 #include <errno.h>
 #include "fdop.h"
-#include <unsupported_api.h>
 
 int posix_spawn_file_actions_addopen(posix_spawn_file_actions_t *restrict fa, int fd, const char *restrict path, int flags, mode_t mode)
 {
-	unsupported_api(__FUNCTION__);
 	struct fdop *op = malloc(sizeof *op + strlen(path) + 1);
 	if (!op) return ENOMEM;
 	op->cmd = FDOP_OPEN;
diff --git a/third_party/musl/src/process/posix_spawnattr_destroy.c b/third_party/musl/src/process/posix_spawnattr_destroy.c
index b66614fc4..fc714a1b2 100755
--- a/third_party/musl/src/process/posix_spawnattr_destroy.c
+++ b/third_party/musl/src/process/posix_spawnattr_destroy.c
@@ -1,8 +1,6 @@
 #include <spawn.h>
-#include <unsupported_api.h>
 
 int posix_spawnattr_destroy(posix_spawnattr_t *attr)
 {
-	unsupported_api(__FUNCTION__);
 	return 0;
 }
diff --git a/third_party/musl/src/process/posix_spawnattr_getflags.c b/third_party/musl/src/process/posix_spawnattr_getflags.c
index d3942db77..aa635ddaf 100755
--- a/third_party/musl/src/process/posix_spawnattr_getflags.c
+++ b/third_party/musl/src/process/posix_spawnattr_getflags.c
@@ -1,9 +1,7 @@
 #include <spawn.h>
-#include <unsupported_api.h>
 
 int posix_spawnattr_getflags(const posix_spawnattr_t *restrict attr, short *restrict flags)
 {
-	unsupported_api(__FUNCTION__);
 	*flags = attr->__flags;
 	return 0;
 }
diff --git a/third_party/musl/src/process/posix_spawnattr_getpgroup.c b/third_party/musl/src/process/posix_spawnattr_getpgroup.c
index be42a87e2..0480527d6 100755
--- a/third_party/musl/src/process/posix_spawnattr_getpgroup.c
+++ b/third_party/musl/src/process/posix_spawnattr_getpgroup.c
@@ -1,9 +1,7 @@
 #include <spawn.h>
-#include <unsupported_api.h>
 
 int posix_spawnattr_getpgroup(const posix_spawnattr_t *restrict attr, pid_t *restrict pgrp)
 {
-	unsupported_api(__FUNCTION__);
 	*pgrp = attr->__pgrp;
 	return 0;
 }
diff --git a/third_party/musl/src/process/posix_spawnattr_getsigdefault.c b/third_party/musl/src/process/posix_spawnattr_getsigdefault.c
index 6687b8640..a49050aa4 100755
--- a/third_party/musl/src/process/posix_spawnattr_getsigdefault.c
+++ b/third_party/musl/src/process/posix_spawnattr_getsigdefault.c
@@ -1,9 +1,7 @@
 #include <spawn.h>
-#include <unsupported_api.h>
 
 int posix_spawnattr_getsigdefault(const posix_spawnattr_t *restrict attr, sigset_t *restrict def)
 {
-	unsupported_api(__FUNCTION__);
 	*def = attr->__def;
 	return 0;
 }
diff --git a/third_party/musl/src/process/posix_spawnattr_getsigmask.c b/third_party/musl/src/process/posix_spawnattr_getsigmask.c
index 5d56dae47..f60ad7f37 100755
--- a/third_party/musl/src/process/posix_spawnattr_getsigmask.c
+++ b/third_party/musl/src/process/posix_spawnattr_getsigmask.c
@@ -1,9 +1,7 @@
 #include <spawn.h>
-#include <unsupported_api.h>
 
 int posix_spawnattr_getsigmask(const posix_spawnattr_t *restrict attr, sigset_t *restrict mask)
 {
-	unsupported_api(__FUNCTION__);
 	*mask = attr->__mask;
 	return 0;
 }
diff --git a/third_party/musl/src/process/posix_spawnattr_init.c b/third_party/musl/src/process/posix_spawnattr_init.c
index cf2dc2754..0dcd868f3 100755
--- a/third_party/musl/src/process/posix_spawnattr_init.c
+++ b/third_party/musl/src/process/posix_spawnattr_init.c
@@ -1,9 +1,7 @@
 #include <spawn.h>
-#include <unsupported_api.h>
 
 int posix_spawnattr_init(posix_spawnattr_t *attr)
 {
-	unsupported_api(__FUNCTION__);
 	*attr = (posix_spawnattr_t){ 0 };
 	return 0;
 }
diff --git a/third_party/musl/src/process/posix_spawnattr_sched.c b/third_party/musl/src/process/posix_spawnattr_sched.c
index f7a3cc03f..3143635ba 100755
--- a/third_party/musl/src/process/posix_spawnattr_sched.c
+++ b/third_party/musl/src/process/posix_spawnattr_sched.c
@@ -1,30 +1,25 @@
 #include <spawn.h>
 #include <sched.h>
 #include <errno.h>
-#include <unsupported_api.h>
 
 int posix_spawnattr_getschedparam(const posix_spawnattr_t *restrict attr,
 	struct sched_param *restrict schedparam)
 {
-	unsupported_api(__FUNCTION__);
 	return ENOSYS;
 }
 
 int posix_spawnattr_setschedparam(posix_spawnattr_t *restrict attr,
 	const struct sched_param *restrict schedparam)
 {
-	unsupported_api(__FUNCTION__);
 	return ENOSYS;
 }
 
 int posix_spawnattr_getschedpolicy(const posix_spawnattr_t *restrict attr, int *restrict policy)
 {
-	unsupported_api(__FUNCTION__);
 	return ENOSYS;
 }
 
 int posix_spawnattr_setschedpolicy(posix_spawnattr_t *attr, int policy)
 {
-	unsupported_api(__FUNCTION__);
 	return ENOSYS;
 }
diff --git a/third_party/musl/src/process/posix_spawnattr_setflags.c b/third_party/musl/src/process/posix_spawnattr_setflags.c
index afeb2af5f..687809921 100755
--- a/third_party/musl/src/process/posix_spawnattr_setflags.c
+++ b/third_party/musl/src/process/posix_spawnattr_setflags.c
@@ -1,10 +1,8 @@
 #include <spawn.h>
 #include <errno.h>
-#include <unsupported_api.h>
 
 int posix_spawnattr_setflags(posix_spawnattr_t *attr, short flags)
 {
-	unsupported_api(__FUNCTION__);
 	const unsigned all_flags =
 		POSIX_SPAWN_RESETIDS |
 		POSIX_SPAWN_SETPGROUP |
diff --git a/third_party/musl/src/process/posix_spawnattr_setpgroup.c b/third_party/musl/src/process/posix_spawnattr_setpgroup.c
index 217cb9e0b..f39596a6e 100755
--- a/third_party/musl/src/process/posix_spawnattr_setpgroup.c
+++ b/third_party/musl/src/process/posix_spawnattr_setpgroup.c
@@ -1,9 +1,7 @@
 #include <spawn.h>
-#include <unsupported_api.h>
 
 int posix_spawnattr_setpgroup(posix_spawnattr_t *attr, pid_t pgrp)
 {
-	unsupported_api(__FUNCTION__);
 	attr->__pgrp = pgrp;
 	return 0;
 }
diff --git a/third_party/musl/src/process/posix_spawnattr_setsigdefault.c b/third_party/musl/src/process/posix_spawnattr_setsigdefault.c
index 4c142b343..568697267 100755
--- a/third_party/musl/src/process/posix_spawnattr_setsigdefault.c
+++ b/third_party/musl/src/process/posix_spawnattr_setsigdefault.c
@@ -1,10 +1,7 @@
 #include <spawn.h>
-#include <unsupported_api.h>
 
 int posix_spawnattr_setsigdefault(posix_spawnattr_t *restrict attr, const sigset_t *restrict def)
 {
-	unsupported_api(__FUNCTION__);
-
 	attr->__def = *def;
 	return 0;
 }
diff --git a/third_party/musl/src/process/posix_spawnattr_setsigmask.c b/third_party/musl/src/process/posix_spawnattr_setsigmask.c
index 46173effe..f2532f8e0 100755
--- a/third_party/musl/src/process/posix_spawnattr_setsigmask.c
+++ b/third_party/musl/src/process/posix_spawnattr_setsigmask.c
@@ -1,10 +1,7 @@
 #include <spawn.h>
-#include <unsupported_api.h>
 
 int posix_spawnattr_setsigmask(posix_spawnattr_t *restrict attr, const sigset_t *restrict mask)
 {
-	unsupported_api(__FUNCTION__);
-
 	attr->__mask = *mask;
 	return 0;
 }
diff --git a/third_party/musl/src/process/posix_spawnp.c b/third_party/musl/src/process/posix_spawnp.c
index e1ac20d68..aad6133b9 100755
--- a/third_party/musl/src/process/posix_spawnp.c
+++ b/third_party/musl/src/process/posix_spawnp.c
@@ -1,6 +1,5 @@
 #include <spawn.h>
 #include <unistd.h>
-#include <unsupported_api.h>
 
 int posix_spawnp(pid_t *restrict res, const char *restrict file,
 	const posix_spawn_file_actions_t *fa,
@@ -8,8 +7,7 @@ int posix_spawnp(pid_t *restrict res, const char *restrict file,
 	char *const argv[restrict], char *const envp[restrict])
 {
 	posix_spawnattr_t spawnp_attr = { 0 };
-	unsupported_api(__FUNCTION__);
 	if (attr) spawnp_attr = *attr;
-	spawnp_attr.__fn = (void *)__execvpe;
+	spawnp_attr.__fn = (void *)__execvpe;	
 	return posix_spawn(res, file, fa, &spawnp_attr, argv, envp);
 }
diff --git a/third_party/musl/src/process/system.c b/third_party/musl/src/process/system.c
index 50aaa7532..5af59b809 100755
--- a/third_party/musl/src/process/system.c
+++ b/third_party/musl/src/process/system.c
@@ -4,7 +4,6 @@
 #include <sys/wait.h>
 #include <spawn.h>
 #include <errno.h>
-#include <unsupported_api.h>
 #include "pthread_impl.h"
 
 extern char **__environ;
@@ -17,8 +16,6 @@ int system(const char *cmd)
 	int status = -1, ret;
 	posix_spawnattr_t attr;
 
-	unsupported_api(__FUNCTION__);
-
 	pthread_testcancel();
 
 	if (!cmd) return 1;
diff --git a/third_party/musl/src/process/waitid.c b/third_party/musl/src/process/waitid.c
index 6622e06dc..d688650d8 100755
--- a/third_party/musl/src/process/waitid.c
+++ b/third_party/musl/src/process/waitid.c
@@ -1,9 +1,7 @@
 #include <sys/wait.h>
-#include <unsupported_api.h>
 #include "syscall.h"
 
 int waitid(idtype_t type, id_t id, siginfo_t *info, int options)
 {
-	unsupported_api(__FUNCTION__);
 	return syscall_cp(SYS_waitid, type, id, info, options, 0);
 }
diff --git a/third_party/musl/src/sched/affinity.c b/third_party/musl/src/sched/affinity.c
index 14b061f2d..948ece413 100755
--- a/third_party/musl/src/sched/affinity.c
+++ b/third_party/musl/src/sched/affinity.c
@@ -6,41 +6,28 @@
 
 int sched_setaffinity(pid_t tid, size_t size, const cpu_set_t *set)
 {
-    if (size != sizeof(cpu_set_t)) {
-        errno = EINVAL;
-        return -1;
-    }
-    return syscall(SYS_sched_setaffinity, tid, (unsigned short)(set->__bits[0]), MUSL_TYPE_PROCESS);
+	return syscall(SYS_sched_setaffinity, tid, size, set);
 }
 
 int pthread_setaffinity_np(pthread_t td, size_t size, const cpu_set_t *set)
 {
-    if (size != sizeof(cpu_set_t)) {
-        return EINVAL;
-    }
-    return -__syscall(SYS_sched_setaffinity, td->tid, (unsigned short)(set->__bits[0]), MUSL_TYPE_THREAD);
+	return -__syscall(SYS_sched_setaffinity, td->tid, size, set);
 }
 
-static int do_getaffinity(pid_t tid, size_t size, cpu_set_t *set, int flag)
+static int do_getaffinity(pid_t tid, size_t size, cpu_set_t *set)
 {
-    unsigned int cpuset;
-    if (size != sizeof(cpu_set_t)) {
-        return -EINVAL;
-    }
-    int ret = __syscall(SYS_sched_getaffinity, tid, &cpuset, flag);
-    if (ret < 0) {
-        return ret;
-    }
-    set->__bits[0] = (long)cpuset;
-    return 0;
+	long ret = __syscall(SYS_sched_getaffinity, tid, size, set);
+	if (ret < 0) return ret;
+	if (ret < size) memset((char *)set+ret, 0, size-ret);
+	return 0;
 }
 
 int sched_getaffinity(pid_t tid, size_t size, cpu_set_t *set)
 {
-    return __syscall_ret(do_getaffinity(tid, size, set, MUSL_TYPE_PROCESS));
+	return __syscall_ret(do_getaffinity(tid, size, set));
 }
 
 int pthread_getaffinity_np(pthread_t td, size_t size, cpu_set_t *set)
 {
-    return -do_getaffinity(td->tid, size, set, MUSL_TYPE_THREAD);
+	return -do_getaffinity(td->tid, size, set);
 }
diff --git a/third_party/musl/src/sched/sched_getparam.c b/third_party/musl/src/sched/sched_getparam.c
index 463b5297c..76f10e49d 100644
--- a/third_party/musl/src/sched/sched_getparam.c
+++ b/third_party/musl/src/sched/sched_getparam.c
@@ -1,24 +1,8 @@
 #include <sched.h>
 #include <errno.h>
-#include <string.h>
 #include "syscall.h"
-#include "pthread_impl.h"
 
 int sched_getparam(pid_t pid, struct sched_param *param)
 {
-	int r;
-	if (!param) {
-		r = -EINVAL;
-		goto exit;
-	}
-
-	memset(param, 0, sizeof(struct sched_param));
-	r = __syscall(SYS_sched_getparam, pid, MUSL_TYPE_PROCESS);
-	if (r >= 0) {
-		param->sched_priority = r;
-		r = 0;
-	}
-
-exit:
-	return __syscall_ret(r);
+	return __syscall_ret(-ENOSYS);
 }
diff --git a/third_party/musl/src/sched/sched_getscheduler.c b/third_party/musl/src/sched/sched_getscheduler.c
index 0f988f596..394e508b4 100644
--- a/third_party/musl/src/sched/sched_getscheduler.c
+++ b/third_party/musl/src/sched/sched_getscheduler.c
@@ -1,10 +1,8 @@
 #include <sched.h>
 #include <errno.h>
 #include "syscall.h"
-#include "pthread_impl.h"
 
 int sched_getscheduler(pid_t pid)
 {
-	int r = __syscall(SYS_sched_getscheduler, pid, MUSL_TYPE_PROCESS);
-	return __syscall_ret(r);
+	return __syscall_ret(-ENOSYS);
 }
diff --git a/third_party/musl/src/sched/sched_setparam.c b/third_party/musl/src/sched/sched_setparam.c
index 95e27b1d8..18623ee49 100644
--- a/third_party/musl/src/sched/sched_setparam.c
+++ b/third_party/musl/src/sched/sched_setparam.c
@@ -1,18 +1,8 @@
 #include <sched.h>
 #include <errno.h>
 #include "syscall.h"
-#include "pthread_impl.h"
 
 int sched_setparam(pid_t pid, const struct sched_param *param)
 {
-	int r;
-	if (!param) {
-		r = -EINVAL;
-		goto exit;
-	}
-
-	r = __syscall(SYS_sched_setparam, pid, param->sched_priority, MUSL_TYPE_PROCESS);
-
-exit:
-	return __syscall_ret(r);
+	return __syscall_ret(-ENOSYS);
 }
diff --git a/third_party/musl/src/sched/sched_setscheduler.c b/third_party/musl/src/sched/sched_setscheduler.c
index 8bd4147f8..4435f2164 100644
--- a/third_party/musl/src/sched/sched_setscheduler.c
+++ b/third_party/musl/src/sched/sched_setscheduler.c
@@ -1,18 +1,8 @@
 #include <sched.h>
 #include <errno.h>
 #include "syscall.h"
-#include "pthread_impl.h"
 
 int sched_setscheduler(pid_t pid, int sched, const struct sched_param *param)
 {
-	int r;
-	if (!param) {
-		r = -EINVAL;
-		goto exit;
-	}
-
-	r = __syscall(SYS_sched_setscheduler, pid, sched, param->sched_priority, MUSL_TYPE_PROCESS);
-
-exit:
-	return __syscall_ret(r);
+	return __syscall_ret(-ENOSYS);
 }
diff --git a/third_party/musl/src/sched/sched_yield.c b/third_party/musl/src/sched/sched_yield.c
index 3b5101dbe..ee6f0e7f1 100644
--- a/third_party/musl/src/sched/sched_yield.c
+++ b/third_party/musl/src/sched/sched_yield.c
@@ -3,5 +3,5 @@
 
 int sched_yield()
 {
-	return syscall(SYS_sched_yield, 0);
+	return syscall(SYS_sched_yield);
 }
diff --git a/third_party/musl/src/select/pselect.c b/third_party/musl/src/select/pselect.c
index ef454b379..54cfb291b 100755
--- a/third_party/musl/src/select/pselect.c
+++ b/third_party/musl/src/select/pselect.c
@@ -2,7 +2,6 @@
 #include <signal.h>
 #include <stdint.h>
 #include <errno.h>
-#include <unsupported_api.h>
 #include "syscall.h"
 
 #define IS32BIT(x) !((x)+0x80000000ULL>>32)
@@ -13,7 +12,6 @@ int pselect(int n, fd_set *restrict rfds, fd_set *restrict wfds, fd_set *restric
 	syscall_arg_t data[2] = { (uintptr_t)mask, _NSIG/8 };
 	time_t s = ts ? ts->tv_sec : 0;
 	long ns = ts ? ts->tv_nsec : 0;
-	unsupported_api(__FUNCTION__);
 #ifdef SYS_pselect6_time64
 	int r = -ENOSYS;
 	if (SYS_pselect6 == SYS_pselect6_time64 || !IS32BIT(s))
diff --git a/third_party/musl/src/select/select.c b/third_party/musl/src/select/select.c
index b4b1ba988..8a7868840 100644
--- a/third_party/musl/src/select/select.c
+++ b/third_party/musl/src/select/select.c
@@ -36,9 +36,9 @@ int select(int n, fd_set *restrict rfds, fd_set *restrict wfds, fd_set *restrict
 #endif
 #ifdef SYS_select
 	return syscall_cp(SYS_select, n, rfds, wfds, efds,
-		tv ? ((long long[]){s, us}) : 0);
+		tv ? ((long[]){s, us}) : 0);
 #else
 	return syscall_cp(SYS_pselect6, n, rfds, wfds, efds,
-		tv ? ((long long[]){s, ns}) : 0, ((syscall_arg_t[]){ 0, _NSIG/8 }));
+		tv ? ((long[]){s, ns}) : 0, ((syscall_arg_t[]){ 0, _NSIG/8 }));
 #endif
 }
diff --git a/third_party/musl/src/signal/arm/restore.s b/third_party/musl/src/signal/arm/restore.s
index 5450c9a1b..fb086d9ba 100644
--- a/third_party/musl/src/signal/arm/restore.s
+++ b/third_party/musl/src/signal/arm/restore.s
@@ -1,18 +1,5 @@
 .syntax unified
 
-.global arm_signal_process
-.global arm_do_signal
-.hidden arm_do_signal
-.type arm_do_signal,%function
-arm_do_signal:
-	stmfd sp!, {r0-r12}
-	mov r4, sp
-	bic sp, sp, #7
-	blx arm_signal_process
-	mov sp, r4
-	ldmfd sp!, {r0-r12}
-	b __restore
-
 .global __restore
 .hidden __restore
 .type __restore,%function
diff --git a/third_party/musl/src/signal/getitimer.c b/third_party/musl/src/signal/getitimer.c
index 8a8046a76..36d1eb9dc 100644
--- a/third_party/musl/src/signal/getitimer.c
+++ b/third_party/musl/src/signal/getitimer.c
@@ -3,5 +3,16 @@
 
 int getitimer(int which, struct itimerval *old)
 {
+	if (sizeof(time_t) > sizeof(long)) {
+		long old32[4];
+		int r = __syscall(SYS_getitimer, which, old32);
+		if (!r) {
+			old->it_interval.tv_sec = old32[0];
+			old->it_interval.tv_usec = old32[1];
+			old->it_value.tv_sec = old32[2];
+			old->it_value.tv_usec = old32[3];
+		}
+		return __syscall_ret(r);
+	}
 	return syscall(SYS_getitimer, which, old);
 }
diff --git a/third_party/musl/src/signal/killpg.c b/third_party/musl/src/signal/killpg.c
index 238b69bdc..315ed4474 100755
--- a/third_party/musl/src/signal/killpg.c
+++ b/third_party/musl/src/signal/killpg.c
@@ -1,10 +1,8 @@
 #include <signal.h>
 #include <errno.h>
-#include <unsupported_api.h>
 
 int killpg(pid_t pgid, int sig)
 {
-	unsupported_api(__FUNCTION__);
 	if (pgid < 0) {
 		errno = EINVAL;
 		return -1;
diff --git a/third_party/musl/src/signal/psiginfo.c b/third_party/musl/src/signal/psiginfo.c
index bdf5cae39..2b15982be 100755
--- a/third_party/musl/src/signal/psiginfo.c
+++ b/third_party/musl/src/signal/psiginfo.c
@@ -1,8 +1,6 @@
 #include <signal.h>
-#include <unsupported_api.h>
 
 void psiginfo(const siginfo_t *si, const char *msg)
 {
-	unsupported_api(__FUNCTION__);
 	psignal(si->si_signo, msg);
 }
diff --git a/third_party/musl/src/signal/setitimer.c b/third_party/musl/src/signal/setitimer.c
index 9ddac66eb..0dfbeb4db 100644
--- a/third_party/musl/src/signal/setitimer.c
+++ b/third_party/musl/src/signal/setitimer.c
@@ -6,5 +6,21 @@
 
 int setitimer(int which, const struct itimerval *restrict new, struct itimerval *restrict old)
 {
+	if (sizeof(time_t) > sizeof(long)) {
+		time_t is = new->it_interval.tv_sec, vs = new->it_value.tv_sec;
+		long ius = new->it_interval.tv_usec, vus = new->it_value.tv_usec;
+		if (!IS32BIT(is) || !IS32BIT(vs))
+			return __syscall_ret(-ENOTSUP);
+		long old32[4];
+		int r = __syscall(SYS_setitimer, which,
+			((long[]){is, ius, vs, vus}), old32);
+		if (!r && old) {
+			old->it_interval.tv_sec = old32[0];
+			old->it_interval.tv_usec = old32[1];
+			old->it_value.tv_sec = old32[2];
+			old->it_value.tv_usec = old32[3];
+		}
+		return __syscall_ret(r);
+	}
 	return syscall(SYS_setitimer, which, new, old);
 }
diff --git a/third_party/musl/src/signal/sigaction.c b/third_party/musl/src/signal/sigaction.c
index 02b6a1530..c109bea0c 100755
--- a/third_party/musl/src/signal/sigaction.c
+++ b/third_party/musl/src/signal/sigaction.c
@@ -1,271 +1,12 @@
 #include <signal.h>
 #include <errno.h>
 #include <string.h>
-#include "stdbool.h"
 #include "syscall.h"
 #include "pthread_impl.h"
 #include "libc.h"
 #include "lock.h"
 #include "ksigaction.h"
 
-#define DEFAULT_SIG_NUM 64
-#define SIGNO2SET(s)            ((sigset_t)1 << (s))
-#define NULL_SIGNAL_SET         ((sigset_t)0x00000000)
-#define SET_BIT(bitmap, pos)    (bitmap |= (1u << pos))
-#define CLEAR_BIT(bitmap, pos)  (bitmap &= ~(1u << pos))
-#define CHECK_BIT(bitmap, pos)  ((bitmap & (1u << pos)) ? 1 : 0)
-#define SIG_FLAG_NOIGNORE 1
-
-
-struct sigactq {
-	struct sigaction act;
-	bool	ign_flag;
-	unsigned char   signo;
-	unsigned char   sigmask;
-	unsigned char   reserve[2];
-};
-typedef struct sigactq sigactq_t;
-
-
-
-
-typedef void (*sa_sighandler_t)(int);
-typedef struct sigaction sigaction_t;
-
-static sigactq_t g_sig_arr[DEFAULT_SIG_NUM];
-static pthread_spinlock_t sig_lite_lock;
-
-struct sig_default_act {
-	unsigned char singNo;
-	unsigned char flag;
-	sa_sighandler_t action;
-};
-
-
-static void __sig_core(int signo);
-static void __sig_kill(int signo);
-static void __sig_cont(int signo);
-static void __sig_stop(int signo);
-static void __sig_ignore(int signo);
-static const struct sig_default_act sig_default_action[] = {
-	{SIGHUP, 0, __sig_kill},
-	{SIGINT, 0, __sig_kill},
-	{SIGQUIT, 0, __sig_core},
-	{SIGILL, 0, __sig_core},
-	{SIGTRAP, 0, __sig_core},
-	{SIGABRT, 0, __sig_core},
-	{SIGBUS, 0, __sig_core},
-	{SIGFPE, 0, __sig_core},
-	{SIGKILL, SIG_FLAG_NOIGNORE, __sig_kill},
-	{SIGUSR1, 0, __sig_kill},
-	{SIGSEGV, 0, __sig_core},
-	{SIGUSR2, 0, __sig_kill},
-	{SIGPIPE, 0, __sig_kill},
-	{SIGALRM, 0, __sig_kill},
-	{SIGTERM, 0, __sig_kill},
-	{SIGSTKFLT, 0, __sig_kill},
-	{SIGCHLD, 0, __sig_ignore},
-	{SIGCONT, SIG_FLAG_NOIGNORE, __sig_cont},
-	{SIGSTOP, SIG_FLAG_NOIGNORE, __sig_stop},
-	{SIGTSTP, 0, __sig_stop},
-	{SIGTTIN, 0, __sig_stop},
-	{SIGTTOU, 0, __sig_stop},
-	{SIGURG, 0, __sig_ignore},
-	{SIGXCPU, 0, __sig_core},
-	{SIGXFSZ, 0, __sig_core},
-	{SIGVTALRM, 0, __sig_kill},
-	{SIGPROF, 0, __sig_kill},
-	{SIGWINCH, 0, __sig_ignore},
-	{SIGIO, 0, __sig_kill},
-	{SIGPWR, 0, __sig_kill},
-	{SIGSYS, 0, __sig_ignore},
-	{32, 0, __sig_ignore},
-	{33, 0, __sig_ignore},
-	{34, 0, __sig_ignore},
-	{35, 0, __sig_ignore},
-	{36, 0, __sig_ignore},
-	{37, 0, __sig_ignore},
-	{38, 0, __sig_ignore},
-	{39, 0, __sig_ignore},
-	{40, 0, __sig_ignore},
-	{41, 0, __sig_ignore},
-	{42, 0, __sig_ignore},
-	{43, 0, __sig_ignore},
-	{44, 0, __sig_ignore},
-	{45, 0, __sig_ignore},
-	{46, 0, __sig_ignore},
-	{47, 0, __sig_ignore},
-	{48, 0, __sig_ignore},
-	{49, 0, __sig_ignore},
-	{50, 0, __sig_ignore},
-	{51, 0, __sig_ignore},
-	{52, 0, __sig_ignore},
-	{53, 0, __sig_ignore},
-	{54, 0, __sig_ignore},
-	{55, 0, __sig_ignore},
-	{56, 0, __sig_ignore},
-	{57, 0, __sig_ignore},
-	{58, 0, __sig_ignore},
-	{59, 0, __sig_ignore},
-	{60, 0, __sig_ignore},
-	{61, 0, __sig_ignore},
-	{62, 0, __sig_ignore},
-	{63, 0, __sig_ignore},
-	{64, 0, __sig_ignore},
-};
-
-static void __sig_core(int signo)
-{
-	exit(-1);
-}
-
-static void __sig_kill(int signo)
-{
-	exit(-1);
-}
-
-static void __sig_cont(int signo)
-{
-	return;
-}
-
-static void __sig_stop(int signo)
-{
-    return;
-}
-
-static void __sig_ignore(int signo)
-{
-    return;
-}
-
-static sigactq_t *__sig_find_action(int sig)
-{
-	int i;
-
-	for (i = 0; i < sizeof(sig_default_action) / sizeof(struct sig_default_act); i++) {
-		if (g_sig_arr[i].signo == sig) {
-			return (g_sig_arr + i);
-		}
-	}
-}
-
-static void __sig_copy_sigaction(sigaction_t *src, sigaction_t *dst)
-{
-	dst->sa_handler = src->sa_handler;
-	dst->sa_mask = src->sa_mask;
-	dst->sa_flags = src->sa_flags;
-}
-
-static int __sig_cannot_catche(int sig, sa_sighandler_t handler)
-{
-	int i;
-
-	for (i = 0; i < sizeof(sig_default_action) / sizeof(struct sig_default_act); i++) {
-		if (sig == sig_default_action[i].singNo) {
-			return (sig_default_action[i].flag == SIG_FLAG_NOIGNORE) && (handler != SIG_DFL);
-		}
-	}
-	/* This sig can be catch and ignore return false */
-	return 0;
-}
-
-static void __sig_operation(unsigned int receivedSigno)
-{
-	int i;
-
-	for (i = 0; i < sizeof(sig_default_action) / sizeof(struct sig_default_act); i++) {
-		if (!g_sig_arr[i].ign_flag && g_sig_arr[i].signo == receivedSigno && g_sig_arr[i].act.sa_handler) {
-			(*g_sig_arr[i].act.sa_handler)(g_sig_arr[i].signo);
-		}
-	}
-}
-
-void arm_signal_process(unsigned int receivedSig)
-{
-	__sig_operation(receivedSig);
-}
-
-static void __sig_add_def_action()
-{
-	int i;
-
-	for (i = 0; i < sizeof(sig_default_action) / sizeof(struct sig_default_act); i++) {
-		g_sig_arr[i].signo = (unsigned char)sig_default_action[i].singNo;
-		g_sig_arr[i].act.sa_handler = sig_default_action[i].action;
-		sigemptyset(&g_sig_arr[i].act.sa_mask);
-		g_sig_arr[i].act.sa_flags = sig_default_action[i].flag;
-		g_sig_arr[i].ign_flag = false;
-	}
-}
-
-static sa_sighandler_t __sig_find_def_action(unsigned char signo)
-{
-	int i;
-
-	for (i = 0; i < sizeof(sig_default_action) / sizeof(struct sig_default_act); i++) {
-		if (signo == sig_default_action[i].singNo) {
-			return sig_default_action[i].action;
-		}
-	}
-	return NULL;
-}
-
-static int __sig_dfl_opr(int sig, sigactq_t *sigact, const sigaction_t *act)
-{
-	sa_sighandler_t def_handler = NULL;
-
-	def_handler = __sig_find_def_action(sig);
-
-	if (def_handler != NULL) {
-		/* Replace it from signal action queue */
-		sigact->act.sa_handler = def_handler;
-		sigact->act.sa_mask = act->sa_mask;
-		sigact->act.sa_flags = act->sa_flags;
-	}
-	return 0;
-}
-
-static int __sig_action_opr(int sig, const sigaction_t *act, sigaction_t *oact)
-{
-	int ret = 0;
-	sa_sighandler_t handler = NULL;
-	sigactq_t *sigact = NULL;
-
-	if (act == NULL) return -EINVAL;
-
-	if (sig < SIGHUP || sig > (_NSIG - 1)) return -EINVAL;
-
-	handler = act->sa_handler;
-	/* Skip sig that can not be catched */
-	if (__sig_cannot_catche(sig, handler)) return -EINVAL;
-
-	pthread_spin_lock(&sig_lite_lock);
-	sigact = __sig_find_action(sig);
-	if (sigact && oact) __sig_copy_sigaction(&sigact->act, oact);
-
-	sigact->ign_flag = false;
-
-	if (handler == SIG_IGN && sigact) {
-		sigact->ign_flag = true;
-	} else if (handler == SIG_DFL) {
-		ret = __sig_dfl_opr(sig, sigact, act);
-	} else {
-		sigact->act.sa_handler = handler;
-		sigact->act.sa_mask = act->sa_mask;
-		sigact->act.sa_flags = act->sa_flags;
-	}
-	pthread_spin_unlock(&sig_lite_lock);
-	return ret;
-}
-
-void __sig_init(void)
-{
-	signal(SIGSYS, arm_do_signal);
-	pthread_spin_init(&sig_lite_lock, 0);
-	__sig_add_def_action();
-}
-
 static volatile int dummy_lock[1] = { 0 };
 
 extern hidden volatile int __abort_lock[1];
@@ -284,10 +25,8 @@ volatile int __eintr_valid_flag;
 
 int __libc_sigaction(int sig, const struct sigaction *restrict sa, struct sigaction *restrict old)
 {
-	sigaction_t ksa, ksa_old;
+	struct k_sigaction ksa, ksa_old;
 	unsigned long set[_NSIG/(8*sizeof(long))];
-	int r = 0;
-
 	if (sa) {
 		if ((uintptr_t)sa->sa_handler > 1UL) {
 			a_or_l(handler_set+(sig-1)/(8*sizeof(long)),
@@ -319,25 +58,20 @@ int __libc_sigaction(int sig, const struct sigaction *restrict sa, struct sigact
 			__block_all_sigs(&set);
 			LOCK(__abort_lock);
 		}
-		ksa.sa_handler = sa->sa_handler;
-		ksa.sa_flags = sa->sa_flags | SA_RESTORER;
-		ksa.sa_restorer = (sa->sa_flags & SA_SIGINFO) ? __restore_rt : __restore;
-		memcpy(&ksa.sa_mask, &sa->sa_mask, _NSIG/8);
-	}
-
-	if (sig == SIGSYS) {
-		return syscall(SYS_rt_sigaction, sig, sa?&ksa:0, old?&ksa_old:0, _NSIG/8);
-	} else {
-		r = __sig_action_opr(sig, (const sigaction_t*)sa?&ksa:0, (sigaction_t*)old?&ksa_old:0);
+		ksa.handler = sa->sa_handler;
+		ksa.flags = sa->sa_flags | SA_RESTORER;
+		ksa.restorer = (sa->sa_flags & SA_SIGINFO) ? __restore_rt : __restore;
+		memcpy(&ksa.mask, &sa->sa_mask, _NSIG/8);
 	}
+	int r = __syscall(SYS_rt_sigaction, sig, sa?&ksa:0, old?&ksa_old:0, _NSIG/8);
 	if (sig == SIGABRT && sa && sa->sa_handler != SIG_DFL) {
 		UNLOCK(__abort_lock);
 		__restore_sigs(&set);
 	}
 	if (old && !r) {
-		old->sa_handler = ksa_old.sa_handler;
-		old->sa_flags = ksa_old.sa_flags;
-		memcpy(&old->sa_mask, &ksa_old.sa_mask, _NSIG/8);
+		old->sa_handler = ksa_old.handler;
+		old->sa_flags = ksa_old.flags;
+		memcpy(&old->sa_mask, &ksa_old.mask, _NSIG/8);
 	}
 	return __syscall_ret(r);
 }
diff --git a/third_party/musl/src/signal/sigaltstack.c b/third_party/musl/src/signal/sigaltstack.c
index 619e38750..d3a6e8215 100755
--- a/third_party/musl/src/signal/sigaltstack.c
+++ b/third_party/musl/src/signal/sigaltstack.c
@@ -1,12 +1,9 @@
 #include <signal.h>
 #include <errno.h>
-#include <unsupported_api.h>
-
 #include "syscall.h"
 
 int sigaltstack(const stack_t *restrict ss, stack_t *restrict old)
 {
-	unsupported_api(__FUNCTION__);
 	if (ss) {
 		if (!(ss->ss_flags & SS_DISABLE) && ss->ss_size < MINSIGSTKSZ) {
 			errno = ENOMEM;
diff --git a/third_party/musl/src/signal/siginterrupt.c b/third_party/musl/src/signal/siginterrupt.c
index 487318b4a..700634003 100755
--- a/third_party/musl/src/signal/siginterrupt.c
+++ b/third_party/musl/src/signal/siginterrupt.c
@@ -1,10 +1,9 @@
 #include <signal.h>
-#include <unsupported_api.h>
 
 int siginterrupt(int sig, int flag)
 {
 	struct sigaction sa;
-	unsupported_api(__FUNCTION__);
+
 	sigaction(sig, 0, &sa);
 	if (flag) sa.sa_flags &= ~SA_RESTART;
 	else sa.sa_flags |= SA_RESTART;
diff --git a/third_party/musl/src/signal/siglongjmp.c b/third_party/musl/src/signal/siglongjmp.c
index 803f2dd86..bc317acce 100755
--- a/third_party/musl/src/signal/siglongjmp.c
+++ b/third_party/musl/src/signal/siglongjmp.c
@@ -1,12 +1,9 @@
 #include <setjmp.h>
 #include <signal.h>
-#include <unsupported_api.h>
-
 #include "syscall.h"
 #include "pthread_impl.h"
 
 _Noreturn void siglongjmp(sigjmp_buf buf, int ret)
 {
-	unsupported_api(__FUNCTION__);
 	longjmp(buf, ret);
 }
diff --git a/third_party/musl/src/signal/sigqueue.c b/third_party/musl/src/signal/sigqueue.c
index e169defa0..b75f0c5ce 100755
--- a/third_party/musl/src/signal/sigqueue.c
+++ b/third_party/musl/src/signal/sigqueue.c
@@ -1,8 +1,6 @@
 #include <signal.h>
 #include <string.h>
 #include <unistd.h>
-#include <unsupported_api.h>
-
 #include "syscall.h"
 #include "pthread_impl.h"
 
@@ -11,7 +9,6 @@ int sigqueue(pid_t pid, int sig, const union sigval value)
 	siginfo_t si;
 	sigset_t set;
 	int r;
-	unsupported_api(__FUNCTION__);
 	memset(&si, 0, sizeof si);
 	si.si_signo = sig;
 	si.si_code = SI_QUEUE;
diff --git a/third_party/musl/src/stat/fchmod.c b/third_party/musl/src/stat/fchmod.c
index 7e469a931..7a503eefc 100755
--- a/third_party/musl/src/stat/fchmod.c
+++ b/third_party/musl/src/stat/fchmod.c
@@ -1,13 +1,10 @@
 #include <sys/stat.h>
 #include <errno.h>
 #include <fcntl.h>
-#include <unsupported_api.h>
-
 #include "syscall.h"
 
 int fchmod(int fd, mode_t mode)
 {
-	unsupported_api(__FUNCTION__);
 	int ret = __syscall(SYS_fchmod, fd, mode);
 	if (ret != -EBADF || __syscall(SYS_fcntl, fd, F_GETFD) < 0)
 		return __syscall_ret(ret);
diff --git a/third_party/musl/src/stat/fchmodat.c b/third_party/musl/src/stat/fchmodat.c
index 2c777e1b7..4ee00b0a3 100755
--- a/third_party/musl/src/stat/fchmodat.c
+++ b/third_party/musl/src/stat/fchmodat.c
@@ -1,14 +1,11 @@
 #include <sys/stat.h>
 #include <fcntl.h>
 #include <errno.h>
-#include <unsupported_api.h>
-
 #include "syscall.h"
 #include "kstat.h"
 
 int fchmodat(int fd, const char *path, mode_t mode, int flag)
 {
-	unsupported_api(__FUNCTION__);
 	if (!flag) return syscall(SYS_fchmodat, fd, path, mode, flag);
 
 	if (flag != AT_SYMLINK_NOFOLLOW)
diff --git a/third_party/musl/src/stat/futimens.c b/third_party/musl/src/stat/futimens.c
index 2ab329a08..360225b86 100755
--- a/third_party/musl/src/stat/futimens.c
+++ b/third_party/musl/src/stat/futimens.c
@@ -1,8 +1,6 @@
 #include <sys/stat.h>
-#include <unsupported_api.h>
 
 int futimens(int fd, const struct timespec times[2])
 {
-	unsupported_api(__FUNCTION__);
 	return utimensat(fd, 0, times, 0);
 }
diff --git a/third_party/musl/src/stat/mkfifo.c b/third_party/musl/src/stat/mkfifo.c
index 9081d7ef4..60efcf73f 100644
--- a/third_party/musl/src/stat/mkfifo.c
+++ b/third_party/musl/src/stat/mkfifo.c
@@ -1,7 +1,6 @@
 #include <sys/stat.h>
-#include "syscall.h"
 
 int mkfifo(const char *path, mode_t mode)
 {
-	return syscall(SYS_mkfifo, path, mode);
+	return mknod(path, mode | S_IFIFO, 0);
 }
diff --git a/third_party/musl/src/stat/mkfifoat.c b/third_party/musl/src/stat/mkfifoat.c
index 768a31786..d3a1f9708 100755
--- a/third_party/musl/src/stat/mkfifoat.c
+++ b/third_party/musl/src/stat/mkfifoat.c
@@ -1,8 +1,6 @@
 #include <sys/stat.h>
-#include <unsupported_api.h>
 
 int mkfifoat(int fd, const char *path, mode_t mode)
 {
-	unsupported_api(__FUNCTION__);
 	return mknodat(fd, path, mode | S_IFIFO, 0);
 }
diff --git a/third_party/musl/src/stat/mknod.c b/third_party/musl/src/stat/mknod.c
index 5c40a9ee9..beebd84e0 100755
--- a/third_party/musl/src/stat/mknod.c
+++ b/third_party/musl/src/stat/mknod.c
@@ -1,11 +1,9 @@
 #include <sys/stat.h>
 #include <fcntl.h>
 #include "syscall.h"
-#include <unsupported_api.h>
 
 int mknod(const char *path, mode_t mode, dev_t dev)
 {
-	unsupported_api(__FUNCTION__);
 #ifdef SYS_mknod
 	return syscall(SYS_mknod, path, mode, dev);
 #else
diff --git a/third_party/musl/src/stat/mknodat.c b/third_party/musl/src/stat/mknodat.c
index 15510c456..7c97c91aa 100755
--- a/third_party/musl/src/stat/mknodat.c
+++ b/third_party/musl/src/stat/mknodat.c
@@ -1,9 +1,7 @@
 #include <sys/stat.h>
 #include "syscall.h"
-#include <unsupported_api.h>
 
 int mknodat(int fd, const char *path, mode_t mode, dev_t dev)
 {
-	unsupported_api(__FUNCTION__);
 	return syscall(SYS_mknodat, fd, path, mode, dev);
 }
diff --git a/third_party/musl/src/stat/statvfs.c b/third_party/musl/src/stat/statvfs.c
index c7f14a04b..f65d1b548 100755
--- a/third_party/musl/src/stat/statvfs.c
+++ b/third_party/musl/src/stat/statvfs.c
@@ -1,7 +1,5 @@
 #include <sys/statvfs.h>
 #include <sys/statfs.h>
-#include <unsupported_api.h>
-
 #include "syscall.h"
 
 static int __statfs(const char *path, struct statfs *buf)
@@ -16,7 +14,6 @@ static int __statfs(const char *path, struct statfs *buf)
 
 static int __fstatfs(int fd, struct statfs *buf)
 {
-	unsupported_api(__FUNCTION__);
 	*buf = (struct statfs){0};
 #ifdef SYS_fstatfs64
 	return syscall(SYS_fstatfs64, fd, sizeof *buf, buf);
@@ -55,8 +52,6 @@ int statvfs(const char *restrict path, struct statvfs *restrict buf)
 int fstatvfs(int fd, struct statvfs *buf)
 {
 	struct statfs kbuf;
-
-	unsupported_api(__FUNCTION__);
 	if (__fstatfs(fd, &kbuf)<0) return -1;
 	fixup(buf, &kbuf);
 	return 0;
diff --git a/third_party/musl/src/stat/utimensat.c b/third_party/musl/src/stat/utimensat.c
index ed3283eb8..730723a9e 100755
--- a/third_party/musl/src/stat/utimensat.c
+++ b/third_party/musl/src/stat/utimensat.c
@@ -2,8 +2,6 @@
 #include <sys/time.h>
 #include <fcntl.h>
 #include <errno.h>
-#include <unsupported_api.h>
-
 #include "syscall.h"
 
 #define IS32BIT(x) !((x)+0x80000000ULL>>32)
@@ -12,7 +10,6 @@
 int utimensat(int fd, const char *path, const struct timespec times[2], int flags)
 {
 	int r;
-	unsupported_api(__FUNCTION__);
 	if (times && times[0].tv_nsec==UTIME_NOW && times[1].tv_nsec==UTIME_NOW)
 		times = 0;
 #ifdef SYS_utimensat_time64
diff --git a/third_party/musl/src/stdio/flockfile.c b/third_party/musl/src/stdio/flockfile.c
index eb1771bcd..8e2206514 100755
--- a/third_party/musl/src/stdio/flockfile.c
+++ b/third_party/musl/src/stdio/flockfile.c
@@ -1,11 +1,8 @@
-#include <unsupported_api.h>
-
 #include "stdio_impl.h"
 #include "pthread_impl.h"
 
 void flockfile(FILE *f)
 {
-	unsupported_api(__FUNCTION__);
 	if (!ftrylockfile(f)) return;
 	__lockfile(f);
 	__register_locked_file(f, __pthread_self());
diff --git a/third_party/musl/src/stdio/open_wmemstream.c b/third_party/musl/src/stdio/open_wmemstream.c
index 760da562b..ed1b561d9 100755
--- a/third_party/musl/src/stdio/open_wmemstream.c
+++ b/third_party/musl/src/stdio/open_wmemstream.c
@@ -4,7 +4,6 @@
 #include <limits.h>
 #include <string.h>
 #include <stdlib.h>
-#include <unsupported_api.h>
 #include "libc.h"
 
 struct cookie {
@@ -71,7 +70,6 @@ FILE *open_wmemstream(wchar_t **bufp, size_t *sizep)
 	struct wms_FILE *f;
 	wchar_t *buf;
 
-	unsupported_api(__FUNCTION__);
 	if (!(f=malloc(sizeof *f))) return 0;
 	if (!(buf=malloc(sizeof *buf))) {
 		free(f);
diff --git a/third_party/musl/src/stdio/popen.c b/third_party/musl/src/stdio/popen.c
index c75e27f68..92cb57ee9 100755
--- a/third_party/musl/src/stdio/popen.c
+++ b/third_party/musl/src/stdio/popen.c
@@ -3,7 +3,6 @@
 #include <errno.h>
 #include <string.h>
 #include <spawn.h>
-#include <unsupported_api.h>
 #include "stdio_impl.h"
 #include "syscall.h"
 
@@ -16,7 +15,6 @@ FILE *popen(const char *cmd, const char *mode)
 	FILE *f;
 	posix_spawn_file_actions_t fa;
 
-	unsupported_api(__FUNCTION__);
 	if (*mode == 'r') {
 		op = 0;
 	} else if (*mode == 'w') {
@@ -25,7 +23,7 @@ FILE *popen(const char *cmd, const char *mode)
 		errno = EINVAL;
 		return 0;
 	}
-
+	
 	if (pipe2(p, O_CLOEXEC)) return NULL;
 	f = fdopen(p[op], mode);
 	if (!f) {
diff --git a/third_party/musl/src/stdio/tmpfile.c b/third_party/musl/src/stdio/tmpfile.c
index ad02d4bed..ae493987b 100755
--- a/third_party/musl/src/stdio/tmpfile.c
+++ b/third_party/musl/src/stdio/tmpfile.c
@@ -1,8 +1,6 @@
 #include <stdio.h>
 #include <fcntl.h>
 #include <stdlib.h>
-#include <unsupported_api.h>
-
 #include "stdio_impl.h"
 
 #define MAXTRIES 100
@@ -13,7 +11,6 @@ FILE *tmpfile(void)
 	int fd;
 	FILE *f;
 	int try;
-	unsupported_api(__FUNCTION__);
 	for (try=0; try<MAXTRIES; try++) {
 		__randname(s+13);
 		fd = sys_open(s, O_RDWR|O_CREAT|O_EXCL, 0600);
diff --git a/third_party/musl/src/stdio/tmpnam.c b/third_party/musl/src/stdio/tmpnam.c
index c3d536487..d667a8368 100755
--- a/third_party/musl/src/stdio/tmpnam.c
+++ b/third_party/musl/src/stdio/tmpnam.c
@@ -4,8 +4,6 @@
 #include <sys/stat.h>
 #include <string.h>
 #include <stdlib.h>
-#include <unsupported_api.h>
-
 #include "syscall.h"
 #include "kstat.h"
 
@@ -17,7 +15,6 @@ char *tmpnam(char *buf)
 	char s[] = "/tmp/tmpnam_XXXXXX";
 	int try;
 	int r;
-	unsupported_api(__FUNCTION__);
 	for (try=0; try<MAXTRIES; try++) {
 		__randname(s+12);
 #ifdef SYS_lstat
diff --git a/third_party/musl/src/stdlib/qsort.c b/third_party/musl/src/stdlib/qsort.c
index 294b6afb1..da58fd317 100755
--- a/third_party/musl/src/stdlib/qsort.c
+++ b/third_party/musl/src/stdlib/qsort.c
@@ -19,103 +19,200 @@
  * IN THE SOFTWARE.
  */
 
+/* Minor changes by Rich Felker for integration in musl, 2011-04-27. */
+
+/* Smoothsort, an adaptive variant of Heapsort.  Memory usage: O(1).
+   Run time: Worst case O(n log n), close to O(n) in the mostly-sorted case. */
+
+#include <stdint.h>
 #include <stdlib.h>
 #include <string.h>
 
+#include "atomic.h"
+#define ntz(x) a_ctz_l((x))
+
 typedef int (*cmpfun)(const void *, const void *);
 
-#define MIDDLE_ONE(a, b, c)                                      \
-    (*cmp)(a, b) < 0 ?                                           \
-    ((*cmp)(b, c) < 0 ? (b) : ((*cmp)(a, c) < 0 ? (c) : (a))):   \
-    ((*cmp)(b, c) > 0 ? (b) : ((*cmp)(a, c) < 0 ? (a) : (c)))
-
-#define SWAPN(a, b, n)                                           \
-    do {                                                         \
-        register char *x = (char *)(a);                          \
-        register char *y = (char *)(b);                          \
-        register char tmp;                                       \
-        int i = (n) / sizeof(char);                              \
-        for (--i; i >= 0; i--) {                                 \
-            tmp = *x;                                            \
-            *x++ = *y;                                           \
-            *y++ = tmp;                                          \
-        }                                                        \
-    } while (0)
+static inline int pntz(size_t p[2]) {
+	int r = ntz(p[0] - 1);
+	if(r != 0 || (r = 8*sizeof(size_t) + ntz(p[1])) != 8*sizeof(size_t)) {
+		return r;
+	}
+	return 0;
+}
+
+static void cycle(size_t width, unsigned char* ar[], int n)
+{
+	unsigned char tmp[256];
+	size_t l;
+	int i;
+
+	if(n < 2) {
+		return;
+	}
+
+	ar[n] = tmp;
+	while(width) {
+		l = sizeof(tmp) < width ? sizeof(tmp) : width;
+		memcpy(ar[n], ar[0], l);
+		for(i = 0; i < n; i++) {
+			memcpy(ar[i], ar[i + 1], l);
+			ar[i] += l;
+		}
+		width -= l;
+	}
+}
+
+/* shl() and shr() need n > 0 */
+static inline void shl(size_t p[2], int n)
+{
+	if(n >= 8 * sizeof(size_t)) {
+		n -= 8 * sizeof(size_t);
+		p[1] = p[0];
+		p[0] = 0;
+	}
+	p[1] <<= n;
+	p[1] |= p[0] >> (sizeof(size_t) * 8 - n);
+	p[0] <<= n;
+}
+
+static inline void shr(size_t p[2], int n)
+{
+	if(n >= 8 * sizeof(size_t)) {
+		n -= 8 * sizeof(size_t);
+		p[0] = p[1];
+		p[1] = 0;
+	}
+	p[0] >>= n;
+	p[0] |= p[1] << (sizeof(size_t) * 8 - n);
+	p[1] >>= n;
+}
+
+static void sift(unsigned char *head, size_t width, cmpfun cmp, int pshift, size_t lp[])
+{
+	unsigned char *rt, *lf;
+	unsigned char *ar[14 * sizeof(size_t) + 1];
+	int i = 1;
+
+	ar[0] = head;
+	while(pshift > 1) {
+		rt = head - width;
+		lf = head - width - lp[pshift - 2];
+
+		if((*cmp)(ar[0], lf) >= 0 && (*cmp)(ar[0], rt) >= 0) {
+			break;
+		}
+		if((*cmp)(lf, rt) >= 0) {
+			ar[i++] = lf;
+			head = lf;
+			pshift -= 1;
+		} else {
+			ar[i++] = rt;
+			head = rt;
+			pshift -= 2;
+		}
+	}
+	cycle(width, ar, i);
+}
+
+static void trinkle(unsigned char *head, size_t width, cmpfun cmp, size_t pp[2], int pshift, int trusty, size_t lp[])
+{
+	unsigned char *stepson,
+	              *rt, *lf;
+	size_t p[2];
+	unsigned char *ar[14 * sizeof(size_t) + 1];
+	int i = 1;
+	int trail;
+
+	p[0] = pp[0];
+	p[1] = pp[1];
+
+	ar[0] = head;
+	while(p[0] != 1 || p[1] != 0) {
+		stepson = head - lp[pshift];
+		if((*cmp)(stepson, ar[0]) <= 0) {
+			break;
+		}
+		if(!trusty && pshift > 1) {
+			rt = head - width;
+			lf = head - width - lp[pshift - 2];
+			if((*cmp)(rt, stepson) >= 0 || (*cmp)(lf, stepson) >= 0) {
+				break;
+			}
+		}
+
+		ar[i++] = stepson;
+		head = stepson;
+		trail = pntz(p);
+		shr(p, trail);
+		pshift += trail;
+		trusty = 0;
+	}
+	if(!trusty) {
+		cycle(width, ar, i);
+		sift(head, width, cmp, pshift, lp);
+	}
+}
 
 void qsort(void *base, size_t nel, size_t width, cmpfun cmp)
 {
-    char *start, *end, *m, *l, *r;
-    int i, j, swapflag = 0;
-    char temp[width];
-
-    if (width == 0 || base == NULL || nel == 0) {
-        return;
-    }
-
-    start = (char *)base;
-    end = start + (nel - 1) * width;
-loop:
-    if (nel < 7) { // insertion sort
-insertqort:
-        for (l = start + width; l <= end; l += width) {
-            memcpy(temp, l, width);
-            for (m = l - width; m >= start; m -= width) {
-                if ((*cmp)(m, temp) > 0) {
-                    memcpy((m + width), m, width);
-                } else {
-                    break;
-                }
-            }
-            memcpy((m + width), temp, width);
-        }
-        return;
-    }
-
-    // quick sort
-    m = start + (nel >> 1) * width;
-    m = MIDDLE_ONE(start, m, end);
-    if (m != start) {
-        SWAPN(start, m, width);
-        m = start;
-    }
-    l = start + width;
-    r = end;
-
-    while (l <= r) {
-        while (l <= r && (*cmp)(l, m) < 0) {
-            l += width;
-        }
-        while (l <= r && (*cmp)(r, m) >= 0) {
-            r -= width;
-        }
-        if (l < r) {
-            SWAPN(l, r, width);
-            l += width;
-            r -= width;
-            swapflag = 1;
-        }
-    }
-    SWAPN(m, l - width, width);
-    m = l - width;
-    if (swapflag == 0) {
-        goto insertqort;
-    }
-
-    if (m - start > end - m) {
-        qsort(start, (m - start) / width, width, (*cmp));
-        if (m == end) {
-            return;
-        }
-        start = m + width;
-        nel = (end - start) / width + 1;
-        goto loop;
-    } else {
-        qsort(m + width, (end - m) / width, width, (*cmp));
-        if (m == start) {
-            return;
-        }
-        end = m - width;
-        nel = (end - start) / width + 1;
-        goto loop;
-    }
+	size_t lp[12*sizeof(size_t)];
+	size_t i, size = width * nel;
+	unsigned char *head, *high;
+	size_t p[2] = {1, 0};
+	int pshift = 1;
+	int trail;
+
+	if (!size) return;
+
+	head = base;
+	high = head + size - width;
+
+	/* Precompute Leonardo numbers, scaled by element width */
+	for(lp[0]=lp[1]=width, i=2; (lp[i]=lp[i-2]+lp[i-1]+width) < size; i++);
+
+	while(head < high) {
+		if((p[0] & 3) == 3) {
+			sift(head, width, cmp, pshift, lp);
+			shr(p, 2);
+			pshift += 2;
+		} else {
+			if(lp[pshift - 1] >= high - head) {
+				trinkle(head, width, cmp, p, pshift, 0, lp);
+			} else {
+				sift(head, width, cmp, pshift, lp);
+			}
+			
+			if(pshift == 1) {
+				shl(p, 1);
+				pshift = 0;
+			} else {
+				shl(p, pshift - 1);
+				pshift = 1;
+			}
+		}
+		
+		p[0] |= 1;
+		head += width;
+	}
+
+	trinkle(head, width, cmp, p, pshift, 0, lp);
+
+	while(pshift != 1 || p[0] != 1 || p[1] != 0) {
+		if(pshift <= 1) {
+			trail = pntz(p);
+			shr(p, trail);
+			pshift += trail;
+		} else {
+			shl(p, 2);
+			pshift -= 2;
+			p[0] ^= 7;
+			shr(p, 1);
+			trinkle(head - lp[pshift] - width, width, cmp, p, pshift + 1, 1, lp);
+			shl(p, 1);
+			p[0] |= 1;
+			trinkle(head - width, width, cmp, p, pshift, 1, lp);
+		}
+		head -= width;
+	}
 }
diff --git a/third_party/musl/src/string/strcasecmp.c b/third_party/musl/src/string/strcasecmp.c
index 0c91b2541..002c6aa15 100755
--- a/third_party/musl/src/string/strcasecmp.c
+++ b/third_party/musl/src/string/strcasecmp.c
@@ -1,6 +1,5 @@
 #include <strings.h>
 #include <ctype.h>
-#include <unsupported_api.h>
 
 int strcasecmp(const char *_l, const char *_r)
 {
@@ -11,7 +10,6 @@ int strcasecmp(const char *_l, const char *_r)
 
 int __strcasecmp_l(const char *l, const char *r, locale_t loc)
 {
-	unsupported_api(__FUNCTION__);
 	return strcasecmp(l, r);
 }
 
diff --git a/third_party/musl/src/string/strncasecmp.c b/third_party/musl/src/string/strncasecmp.c
index 2b8143a0c..e0ef93c20 100755
--- a/third_party/musl/src/string/strncasecmp.c
+++ b/third_party/musl/src/string/strncasecmp.c
@@ -1,6 +1,5 @@
 #include <strings.h>
 #include <ctype.h>
-#include <unsupported_api.h>
 
 int strncasecmp(const char *_l, const char *_r, size_t n)
 {
@@ -12,7 +11,6 @@ int strncasecmp(const char *_l, const char *_r, size_t n)
 
 int __strncasecmp_l(const char *l, const char *r, size_t n, locale_t loc)
 {
-	unsupported_api(__FUNCTION__);
 	return strncasecmp(l, r, n);
 }
 
diff --git a/third_party/musl/src/termios/cfsetospeed.c b/third_party/musl/src/termios/cfsetospeed.c
index 5e4be9396..c9cbdd9d9 100755
--- a/third_party/musl/src/termios/cfsetospeed.c
+++ b/third_party/musl/src/termios/cfsetospeed.c
@@ -2,11 +2,9 @@
 #include <termios.h>
 #include <sys/ioctl.h>
 #include <errno.h>
-#include <unsupported_api.h>
 
 int cfsetospeed(struct termios *tio, speed_t speed)
 {
-	unsupported_api(__FUNCTION__);
 	if (speed & ~CBAUD) {
 		errno = EINVAL;
 		return -1;
@@ -18,7 +16,6 @@ int cfsetospeed(struct termios *tio, speed_t speed)
 
 int cfsetispeed(struct termios *tio, speed_t speed)
 {
-	unsupported_api(__FUNCTION__);
 	return speed ? cfsetospeed(tio, speed) : 0;
 }
 
diff --git a/third_party/musl/src/thread/__timedwait.c b/third_party/musl/src/thread/__timedwait.c
index b4ca0fea1..666093be9 100644
--- a/third_party/musl/src/thread/__timedwait.c
+++ b/third_party/musl/src/thread/__timedwait.c
@@ -11,8 +11,6 @@
 static int __futex4_cp(volatile void *addr, int op, int val, const struct timespec *to)
 {
 	int r;
-	unsigned int useconds = 0xffffffffU;
-#if 0
 #ifdef SYS_futex_time64
 	time_t s = to ? to->tv_sec : 0;
 	long ns = to ? to->tv_nsec : 0;
@@ -23,18 +21,9 @@ static int __futex4_cp(volatile void *addr, int op, int val, const struct timesp
 	if (SYS_futex == SYS_futex_time64 || r!=-ENOSYS) return r;
 	to = to ? (void *)(long[]){CLAMP(s), ns} : 0;
 #endif
-#endif
-
-	if (to) {
-		useconds = (to->tv_sec * 1000000 + to->tv_nsec / 1000);
-		if ((useconds == 0) && (to->tv_nsec != 0)) {
-			useconds = 1;
-		}
-	}
-
-	r = __syscall_cp(SYS_futex, addr, op, val, useconds);
+	r = __syscall_cp(SYS_futex, addr, op, val, to);
 	if (r != -ENOSYS) return r;
-	return __syscall_cp(SYS_futex, addr, op & ~FUTEX_PRIVATE, val, useconds);
+	return __syscall_cp(SYS_futex, addr, op & ~FUTEX_PRIVATE, val, to);
 }
 
 static volatile int dummy = 0;
diff --git a/third_party/musl/src/thread/__wait.c b/third_party/musl/src/thread/__wait.c
index 587395611..dc33c1a30 100644
--- a/third_party/musl/src/thread/__wait.c
+++ b/third_party/musl/src/thread/__wait.c
@@ -10,8 +10,8 @@ void __wait(volatile int *addr, volatile int *waiters, int val, int priv)
 	}
 	if (waiters) a_inc(waiters);
 	while (*addr==val) {
-		__syscall(SYS_futex, addr, FUTEX_WAIT|priv, val, 0xffffffffu) != -ENOSYS
-		|| __syscall(SYS_futex, addr, FUTEX_WAIT, val, 0xffffffffu);
+		__syscall(SYS_futex, addr, FUTEX_WAIT|priv, val, 0) != -ENOSYS
+		|| __syscall(SYS_futex, addr, FUTEX_WAIT, val, 0);
 	}
 	if (waiters) a_dec(waiters);
 }
diff --git a/third_party/musl/src/thread/arm/__set_thread_area.c b/third_party/musl/src/thread/arm/__set_thread_area.c
index 4d73c5d3c..09de65aab 100644
--- a/third_party/musl/src/thread/arm/__set_thread_area.c
+++ b/third_party/musl/src/thread/arm/__set_thread_area.c
@@ -26,9 +26,6 @@ extern hidden uintptr_t __a_barrier_ptr, __a_cas_ptr, __a_gettp_ptr;
 
 int __set_thread_area(void *p)
 {
-#ifdef SYS_set_thread_area
-	return __syscall(SYS_set_thread_area, p);
-#else
 #if !__ARM_ARCH_7A__ && !__ARM_ARCH_7R__ && __ARM_ARCH < 7
 	if (__hwcap & HWCAP_TLS) {
 		size_t *aux;
@@ -52,5 +49,4 @@ int __set_thread_area(void *p)
 	}
 #endif
 	return __syscall(0xf0005, p);
-#endif
 }
diff --git a/third_party/musl/src/thread/pthread_attr_get.c b/third_party/musl/src/thread/pthread_attr_get.c
index 0e4db95e5..4aa5afdb2 100755
--- a/third_party/musl/src/thread/pthread_attr_get.c
+++ b/third_party/musl/src/thread/pthread_attr_get.c
@@ -1,4 +1,3 @@
-#include <unsupported_api.h>
 #include "pthread_impl.h"
 
 int pthread_attr_getdetachstate(const pthread_attr_t *a, int *state)
@@ -32,7 +31,7 @@ int pthread_attr_getschedpolicy(const pthread_attr_t *restrict a, int *restrict
 
 int pthread_attr_getscope(const pthread_attr_t *restrict a, int *restrict scope)
 {
-	*scope = PTHREAD_SCOPE_PROCESS;
+	*scope = PTHREAD_SCOPE_SYSTEM;
 	return 0;
 }
 
@@ -71,7 +70,6 @@ int pthread_condattr_getpshared(const pthread_condattr_t *restrict a, int *restr
 
 int pthread_mutexattr_getprotocol(const pthread_mutexattr_t *restrict a, int *restrict protocol)
 {
-	unsupported_api(__FUNCTION__);
 	*protocol = PTHREAD_PRIO_NONE;
 	return 0;
 }
@@ -83,7 +81,6 @@ int pthread_mutexattr_getpshared(const pthread_mutexattr_t *restrict a, int *res
 
 int pthread_mutexattr_getrobust(const pthread_mutexattr_t *restrict a, int *restrict robust)
 {
-	unsupported_api(__FUNCTION__);
 	*robust = a->__attr / 4U % 2;
 	return 0;
 }
diff --git a/third_party/musl/src/thread/pthread_attr_init.c b/third_party/musl/src/thread/pthread_attr_init.c
index aa43c71d6..463a8d207 100644
--- a/third_party/musl/src/thread/pthread_attr_init.c
+++ b/third_party/musl/src/thread/pthread_attr_init.c
@@ -6,8 +6,6 @@ int pthread_attr_init(pthread_attr_t *a)
 	__acquire_ptc();
 	a->_a_stacksize = __default_stacksize;
 	a->_a_guardsize = __default_guardsize;
-	a->_a_policy = SCHED_RR;
-	a->_a_prio = 25;
 	__release_ptc();
 	return 0;
 }
diff --git a/third_party/musl/src/thread/pthread_attr_setschedparam.c b/third_party/musl/src/thread/pthread_attr_setschedparam.c
index 233ce58c8..d4c1204fd 100644
--- a/third_party/musl/src/thread/pthread_attr_setschedparam.c
+++ b/third_party/musl/src/thread/pthread_attr_setschedparam.c
@@ -2,10 +2,6 @@
 
 int pthread_attr_setschedparam(pthread_attr_t *restrict a, const struct sched_param *restrict param)
 {
-	if (param->sched_priority < 0 || param->sched_priority > PTHREAD_PRIORITY_LOWEST) {
-		return EINVAL;
-	}
-
 	a->_a_prio = param->sched_priority;
 	return 0;
 }
diff --git a/third_party/musl/src/thread/pthread_attr_setschedpolicy.c b/third_party/musl/src/thread/pthread_attr_setschedpolicy.c
index df19df73f..bb71f393e 100644
--- a/third_party/musl/src/thread/pthread_attr_setschedpolicy.c
+++ b/third_party/musl/src/thread/pthread_attr_setschedpolicy.c
@@ -2,10 +2,6 @@
 
 int pthread_attr_setschedpolicy(pthread_attr_t *a, int policy)
 {
-	if (policy != SCHED_RR && policy != SCHED_FIFO) {
-		return EINVAL;
-	}
-
 	a->_a_policy = policy;
 	return 0;
 }
diff --git a/third_party/musl/src/thread/pthread_attr_setscope.c b/third_party/musl/src/thread/pthread_attr_setscope.c
index f632883bd..46b520c04 100644
--- a/third_party/musl/src/thread/pthread_attr_setscope.c
+++ b/third_party/musl/src/thread/pthread_attr_setscope.c
@@ -4,9 +4,9 @@ int pthread_attr_setscope(pthread_attr_t *a, int scope)
 {
 	switch (scope) {
 	case PTHREAD_SCOPE_SYSTEM:
-		return ENOTSUP;
-	case PTHREAD_SCOPE_PROCESS:
 		return 0;
+	case PTHREAD_SCOPE_PROCESS:
+		return ENOTSUP;
 	default:
 		return EINVAL;
 	}
diff --git a/third_party/musl/src/thread/pthread_barrier_wait.c b/third_party/musl/src/thread/pthread_barrier_wait.c
index 5a56b5e44..cc2a8bbf5 100644
--- a/third_party/musl/src/thread/pthread_barrier_wait.c
+++ b/third_party/musl/src/thread/pthread_barrier_wait.c
@@ -84,8 +84,8 @@ int pthread_barrier_wait(pthread_barrier_t *b)
 			a_spin();
 		a_inc(&inst->finished);
 		while (inst->finished == 1)
-			__syscall(SYS_futex,&inst->finished,FUTEX_WAIT|FUTEX_PRIVATE,1,0xffffffffu) != -ENOSYS
-			|| __syscall(SYS_futex,&inst->finished,FUTEX_WAIT,1,0xffffffffu);
+			__syscall(SYS_futex,&inst->finished,FUTEX_WAIT|FUTEX_PRIVATE,1,0) != -ENOSYS
+			|| __syscall(SYS_futex,&inst->finished,FUTEX_WAIT,1,0);
 		return PTHREAD_BARRIER_SERIAL_THREAD;
 	}
 
diff --git a/third_party/musl/src/thread/pthread_cancel.c b/third_party/musl/src/thread/pthread_cancel.c
index c372f05fb..2f9d5e975 100755
--- a/third_party/musl/src/thread/pthread_cancel.c
+++ b/third_party/musl/src/thread/pthread_cancel.c
@@ -48,11 +48,23 @@ extern hidden const char __cp_begin[1], __cp_end[1], __cp_cancel[1];
 static void cancel_handler(int sig, siginfo_t *si, void *ctx)
 {
 	pthread_t self = __pthread_self();
+	ucontext_t *uc = ctx;
+	uintptr_t pc = uc->uc_mcontext.MC_PC;
+
 	a_barrier();
 	if (!self->cancel || self->canceldisable == PTHREAD_CANCEL_DISABLE) return;
-	if(self->cancelasync){
-		pthread_exit(PTHREAD_CANCELED);
+
+	_sigaddset(&uc->uc_sigmask, SIGCANCEL);
+
+	if (self->cancelasync || pc >= (uintptr_t)__cp_begin && pc < (uintptr_t)__cp_end) {
+		uc->uc_mcontext.MC_PC = (uintptr_t)__cp_cancel;
+#ifdef CANCEL_GOT
+		uc->uc_mcontext.MC_GOT = CANCEL_GOT;
+#endif
+		return;
 	}
+
+	__syscall(SYS_tkill, self->tid, SIGCANCEL);
 }
 
 void __testcancel()
diff --git a/third_party/musl/src/thread/pthread_create.c b/third_party/musl/src/thread/pthread_create.c
index 7cc0d5481..5f4910925 100644
--- a/third_party/musl/src/thread/pthread_create.c
+++ b/third_party/musl/src/thread/pthread_create.c
@@ -15,6 +15,7 @@ weak_alias(dummy_0, __release_ptc);
 weak_alias(dummy_0, __pthread_tsd_run_dtors);
 weak_alias(dummy_0, __do_orphaned_stdio_locks);
 weak_alias(dummy_0, __dl_thread_cleanup);
+weak_alias(dummy_0, __membarrier_init);
 
 static int tl_lock_count;
 static int tl_lock_waiters;
@@ -101,7 +102,6 @@ _Noreturn void __pthread_exit(void *result)
 	/* Process robust list in userspace to handle non-pshared mutexes
 	 * and the detached thread case where the robust list head will
 	 * be invalid when the kernel would process it. */
-#if 0
 	__vm_lock();
 	volatile void *volatile *rp;
 	while ((rp=self->robust_list.head) && rp != &self->robust_list.head) {
@@ -117,7 +117,6 @@ _Noreturn void __pthread_exit(void *result)
 			__wake(&m->_m_lock, 1, priv);
 	}
 	__vm_unlock();
-#endif
 
 	__do_orphaned_stdio_locks();
 	__dl_thread_cleanup();
@@ -125,8 +124,13 @@ _Noreturn void __pthread_exit(void *result)
 	/* This atomic potentially competes with a concurrent pthread_detach
 	 * call; the loser is responsible for freeing thread resources. */
 	int state = a_cas(&self->detach_state, DT_JOINABLE, DT_EXITING);
-#if 0
+
 	if (state==DT_DETACHED && self->map_base) {
+		/* Detached threads must block even implementation-internal
+		 * signals, since they will not have a stack in their last
+		 * moments of existence. */
+		__block_all_sigs(&set);
+
 		/* Robust list will no longer be valid, and was already
 		 * processed above, so unregister it with the kernel. */
 		if (self->robust_list.off)
@@ -143,20 +147,11 @@ _Noreturn void __pthread_exit(void *result)
 
 	/* Wake any joiner. */
 	__wake(&self->detach_state, 1, 1);
-#endif
 
 	/* After the kernel thread exits, its tid may be reused. Clear it
 	 * to prevent inadvertent use and inform functions that would use
 	 * it that it's no longer available. */
-	if (self->detach_state == DT_DETACHED) {
-		/* Detached threads must block even implementation-internal
-		 * signals, since they will not have a stack in their last
-		 * moments of existence. */
-		__block_all_sigs(&set);
-		self->tid = 0;
-	}
-
-	__tl_unlock();
+	self->tid = 0;
 	UNLOCK(self->killlock);
 
 	for (;;) __syscall(SYS_exit, 0);
@@ -183,7 +178,16 @@ struct start_args {
 
 static int start(void *p)
 {
-	struct start_args *args = (struct start_args *)p;
+	struct start_args *args = p;
+	int state = args->control;
+	if (state) {
+		if (a_cas(&args->control, 1, 2)==1)
+			__wait(&args->control, 0, 2, 1);
+		if (args->control) {
+			__syscall(SYS_set_tid_address, &args->control);
+			for (;;) __syscall(SYS_exit, 0);
+		}
+	}
 	__syscall(SYS_rt_sigprocmask, SIG_SETMASK, &args->sig_mask, 0, _NSIG/8);
 	__pthread_exit(args->start_func(args->start_arg));
 	return 0;
@@ -191,7 +195,7 @@ static int start(void *p)
 
 static int start_c11(void *p)
 {
-	struct start_args *args = (struct start_args *)p;
+	struct start_args *args = p;
 	int (*start)(void*) = (int(*)(void*)) args->start_func;
 	__pthread_exit((void *)(uintptr_t)start(args->start_arg));
 	return 0;
@@ -205,35 +209,14 @@ weak_alias(dummy, __pthread_tsd_size);
 static void *dummy_tsd[1] = { 0 };
 weak_alias(dummy_tsd, __pthread_tsd_main);
 
-int __pthread_init_and_check_attr(const pthread_attr_t *restrict attrp, pthread_attr_t *attr)
-{
-	int policy = 0;
-	struct sched_param param = { 0 };
-	int c11 = (attrp == __ATTRP_C11_THREAD);
-	int ret;
-
-	if (attrp && !c11) memcpy(attr, attrp, sizeof(pthread_attr_t));
-
-	if (!attrp || c11) {
-		pthread_attr_init(attr);
-	}
-
-	if (!attr->_a_sched) {
-		ret = pthread_getschedparam(pthread_self(), &policy, &param);
-		if (ret) return ret;
-		attr->_a_policy = policy;
-		attr->_a_prio = param.sched_priority;
-	}
-
-	if (attr->_a_policy != SCHED_RR && attr->_a_policy != SCHED_FIFO) {
-		return EINVAL;
-	}
+static FILE *volatile dummy_file = 0;
+weak_alias(dummy_file, __stdin_used);
+weak_alias(dummy_file, __stdout_used);
+weak_alias(dummy_file, __stderr_used);
 
-	if (attr->_a_prio < 0 || attr->_a_prio > PTHREAD_PRIORITY_LOWEST) {
-		return EINVAL;
-	}
-
-	return 0;
+static void init_file_lock(FILE *f)
+{
+	if (f && f->lock<0) f->lock = 0;
 }
 
 int __pthread_create(pthread_t *restrict res, const pthread_attr_t *restrict attrp, void *(*entry)(void *), void *restrict arg)
@@ -249,14 +232,25 @@ int __pthread_create(pthread_t *restrict res, const pthread_attr_t *restrict att
 	sigset_t set;
 
 	if (!libc.can_do_threads) return ENOSYS;
-	if (!entry) return EINVAL;
 	self = __pthread_self();
-	__acquire_ptc();
+	if (!libc.threaded) {
+		for (FILE *f=*__ofl_lock(); f; f=f->next)
+			init_file_lock(f);
+		__ofl_unlock();
+		init_file_lock(__stdin_used);
+		init_file_lock(__stdout_used);
+		init_file_lock(__stderr_used);
+		__syscall(SYS_rt_sigprocmask, SIG_UNBLOCK, SIGPT_SET, 0, _NSIG/8);
+		self->tsd = (void **)__pthread_tsd_main;
+		__membarrier_init();
+		libc.threaded = 1;
+	}
+	if (attrp && !c11) attr = *attrp;
 
-	ret = __pthread_init_and_check_attr(attrp, &attr);
-	if (ret) {
-		__release_ptc();
-		return ret;
+	__acquire_ptc();
+	if (!attrp || c11) {
+		attr._a_stacksize = __default_stacksize;
+		attr._a_guardsize = __default_guardsize;
 	}
 
 	if (attr._a_stackaddr) {
@@ -283,7 +277,7 @@ int __pthread_create(pthread_t *restrict res, const pthread_attr_t *restrict att
 
 	if (!tsd) {
 		if (guard) {
-			map = __mmap(0, size, PROT_READ|PROT_WRITE|PROT_NONE, MAP_PRIVATE|MAP_ANON, -1, 0);
+			map = __mmap(0, size, PROT_NONE, MAP_PRIVATE|MAP_ANON, -1, 0);
 			if (map == MAP_FAILED) goto fail;
 			if (__mprotect(map+guard, size-guard, PROT_READ|PROT_WRITE)
 			    && errno != ENOSYS) {
@@ -343,7 +337,7 @@ int __pthread_create(pthread_t *restrict res, const pthread_attr_t *restrict att
 
 	__tl_lock();
 	libc.threads_minus_1++;
-	ret = __thread_clone((c11 ? start_c11 : start), flags, new, stack);
+	ret = __clone((c11 ? start_c11 : start), stack, flags, args, &new->tid, TP_ADJ(new), &__thread_list_lock);
 
 	/* All clone failures translate to EAGAIN. If explicit scheduling
 	 * was requested, attempt it before unlocking the thread list so
@@ -351,29 +345,33 @@ int __pthread_create(pthread_t *restrict res, const pthread_attr_t *restrict att
 	 * clean up all transient resource usage before returning. */
 	if (ret < 0) {
 		ret = -EAGAIN;
-	} else {
+	} else if (attr._a_sched) {
+		ret = __syscall(SYS_sched_setscheduler,
+			new->tid, attr._a_policy, &attr._a_prio);
+		if (a_swap(&args->control, ret ? 3 : 0)==2)
+			__wake(&args->control, 1, 1);
+		if (ret)
+			__wait(&args->control, 0, 3, 0);
+	}
+
+	if (ret >= 0) {
 		new->next = self->next;
 		new->prev = self;
 		new->next->prev = new;
 		new->prev->next = new;
-
-		*res = new;
-		__tl_unlock();
-		__restore_sigs(&set);
-		__release_ptc();
-		ret = __syscall(SYS_sched_setscheduler,
-			new->tid, attr._a_policy, attr._a_prio, MUSL_TYPE_THREAD);
+	} else {
+		libc.threads_minus_1--;
 	}
+	__tl_unlock();
+	__restore_sigs(&set);
+	__release_ptc();
 
 	if (ret < 0) {
-		libc.threads_minus_1--;
-		__tl_unlock();
-		__restore_sigs(&set);
-		__release_ptc();
 		if (map) __munmap(map, size);
 		return -ret;
 	}
 
+	*res = new;
 	return 0;
 fail:
 	__release_ptc();
diff --git a/third_party/musl/src/thread/pthread_detach.c b/third_party/musl/src/thread/pthread_detach.c
index a29e25308..77772af2c 100644
--- a/third_party/musl/src/thread/pthread_detach.c
+++ b/third_party/musl/src/thread/pthread_detach.c
@@ -3,16 +3,11 @@
 
 static int __pthread_detach(pthread_t t)
 {
-	int ret;
-
 	/* If the cas fails, detach state is either already-detached
 	 * or exiting/exited, and pthread_join will trap or cleanup. */
 	if (a_cas(&t->detach_state, DT_JOINABLE, DT_DETACHED) != DT_JOINABLE)
 		return __pthread_join(t, 0);
-	ret = __syscall(SYS_pthread_set_detach, t->tid);
-	if (ret) a_swap(&t->detach_state, DT_JOINABLE);
-	if (ret == ESRCH) ret = 0;
-	return ret;
+	return 0;
 }
 
 weak_alias(__pthread_detach, pthread_detach);
diff --git a/third_party/musl/src/thread/pthread_getconcurrency.c b/third_party/musl/src/thread/pthread_getconcurrency.c
index 4156988ee..269429a8a 100755
--- a/third_party/musl/src/thread/pthread_getconcurrency.c
+++ b/third_party/musl/src/thread/pthread_getconcurrency.c
@@ -1,8 +1,6 @@
 #include <pthread.h>
-#include <unsupported_api.h>
 
 int pthread_getconcurrency()
 {
-	unsupported_api(__FUNCTION__);
 	return 0;
 }
diff --git a/third_party/musl/src/thread/pthread_getcpuclockid.c b/third_party/musl/src/thread/pthread_getcpuclockid.c
index 41c6b7d98..9df14fb68 100755
--- a/third_party/musl/src/thread/pthread_getcpuclockid.c
+++ b/third_party/musl/src/thread/pthread_getcpuclockid.c
@@ -1,9 +1,7 @@
-#include <unsupported_api.h>
 #include "pthread_impl.h"
 
 int pthread_getcpuclockid(pthread_t t, clockid_t *clockid)
 {
-	unsupported_api(__FUNCTION__);
 	*clockid = (-t->tid-1)*8U + 6;
 	return 0;
 }
diff --git a/third_party/musl/src/thread/pthread_getschedparam.c b/third_party/musl/src/thread/pthread_getschedparam.c
index 0948509a1..1cba073d0 100644
--- a/third_party/musl/src/thread/pthread_getschedparam.c
+++ b/third_party/musl/src/thread/pthread_getschedparam.c
@@ -8,18 +8,9 @@ int pthread_getschedparam(pthread_t t, int *restrict policy, struct sched_param
 	if (!t->tid) {
 		r = ESRCH;
 	} else {
-		r = __syscall(SYS_sched_getparam, t->tid, MUSL_TYPE_THREAD);
-		if (r >= 0) {
-			param->sched_priority = r;
-			r = __syscall(SYS_sched_getscheduler, t->tid, MUSL_TYPE_THREAD);
-			if (r >= 0) {
-				*policy = r;
-				r = 0;
-			}
-		}
-
-		if (r < 0) {
-			r = -r;
+		r = -__syscall(SYS_sched_getparam, t->tid, param);
+		if (!r) {
+			*policy = __syscall(SYS_sched_getscheduler, t->tid);
 		}
 	}
 	UNLOCK(t->killlock);
diff --git a/third_party/musl/src/thread/pthread_join.c b/third_party/musl/src/thread/pthread_join.c
index 9801bf14c..17dae85d7 100644
--- a/third_party/musl/src/thread/pthread_join.c
+++ b/third_party/musl/src/thread/pthread_join.c
@@ -10,37 +10,19 @@ weak_alias(dummy1, __tl_sync);
 static int __pthread_timedjoin_np(pthread_t t, void **res, const struct timespec *at)
 {
 	int state, cs, r = 0;
-	unsigned int tid;
-	pthread_t self = __pthread_self();
 	__pthread_testcancel();
 	__pthread_setcancelstate(PTHREAD_CANCEL_DISABLE, &cs);
 	if (cs == PTHREAD_CANCEL_ENABLE) __pthread_setcancelstate(cs, 0);
-	if (t == self) {
-		r = EINVAL;
-		goto out;
+	while ((state = t->detach_state) && r != ETIMEDOUT && r != EINVAL) {
+		if (state >= DT_DETACHED) a_crash();
+		r = __timedwait_cp(&t->detach_state, state, CLOCK_REALTIME, at, 1);
 	}
-
-	switch (t->detach_state) {
-		case DT_JOINABLE: {
-			r = __syscall(SYS_pthread_join, t->tid);
-			break;
-		}
-		case DT_EXITING:
-			break;
-		case DT_DETACHED:
-		default:
-			r = EINVAL;
-			break;
-	}
-
-out:
 	__pthread_setcancelstate(cs, 0);
-	if (r == ESRCH || r == EINVAL) return r;
+	if (r == ETIMEDOUT || r == EINVAL) return r;
 	__tl_sync(t);
 	if (res) *res = t->result;
-	tid = t->tid;
-	t->tid = 0;
-	return __syscall(SYS_pthread_deatch, tid);
+	if (t->map_base) __munmap(t->map_base, t->map_size);
+	return 0;
 }
 
 int __pthread_join(pthread_t t, void **res)
diff --git a/third_party/musl/src/thread/pthread_mutex_consistent.c b/third_party/musl/src/thread/pthread_mutex_consistent.c
index 52cc962c5..27c74e5b6 100755
--- a/third_party/musl/src/thread/pthread_mutex_consistent.c
+++ b/third_party/musl/src/thread/pthread_mutex_consistent.c
@@ -1,11 +1,8 @@
-#include <unsupported_api.h>
 #include "pthread_impl.h"
 #include "atomic.h"
 
 int pthread_mutex_consistent(pthread_mutex_t *m)
 {
-	unsupported_api(__FUNCTION__);
-
 	int old = m->_m_lock;
 	int own = old & 0x3fffffff;
 	if (!(m->_m_type & 4) || !own || !(old & 0x40000000))
diff --git a/third_party/musl/src/thread/pthread_mutex_getprioceiling.c b/third_party/musl/src/thread/pthread_mutex_getprioceiling.c
index c6699947f..8c75a6612 100755
--- a/third_party/musl/src/thread/pthread_mutex_getprioceiling.c
+++ b/third_party/musl/src/thread/pthread_mutex_getprioceiling.c
@@ -1,8 +1,6 @@
-#include <unsupported_api.h>
 #include "pthread_impl.h"
 
 int pthread_mutex_getprioceiling(const pthread_mutex_t *restrict m, int *restrict ceiling)
 {
-	unsupported_api(__FUNCTION__);
 	return EINVAL;
 }
diff --git a/third_party/musl/src/thread/pthread_mutex_timedlock.c b/third_party/musl/src/thread/pthread_mutex_timedlock.c
index ef3ffdbfc..9279fc543 100644
--- a/third_party/musl/src/thread/pthread_mutex_timedlock.c
+++ b/third_party/musl/src/thread/pthread_mutex_timedlock.c
@@ -65,13 +65,15 @@ int __pthread_mutex_timedlock(pthread_mutex_t *restrict m, const struct timespec
 	r = __pthread_mutex_trylock(m);
 	if (r != EBUSY) return r;
 
+	if (type&8) return pthread_mutex_timedlock_pi(m, at);
+	
 	int spins = 100;
 	while (spins-- && m->_m_lock && !m->_m_waiters) a_spin();
 
 	while ((r=__pthread_mutex_trylock(m)) == EBUSY) {
 		r = m->_m_lock;
 		int own = r & 0x3fffffff;
-		if (!r)
+		if (!own && (!r || (type&4)))
 			continue;
 		if ((type&3) == PTHREAD_MUTEX_ERRORCHECK
 		    && own == __pthread_self()->tid)
diff --git a/third_party/musl/src/thread/pthread_mutex_trylock.c b/third_party/musl/src/thread/pthread_mutex_trylock.c
index 9fb6c5128..a24e7c58a 100644
--- a/third_party/musl/src/thread/pthread_mutex_trylock.c
+++ b/third_party/musl/src/thread/pthread_mutex_trylock.c
@@ -10,21 +10,44 @@ int __pthread_mutex_trylock_owner(pthread_mutex_t *m)
 	old = m->_m_lock;
 	own = old & 0x3fffffff;
 	if (own == tid) {
-		if ((type&PTHREAD_MUTEX_TYPE_MASK) == PTHREAD_MUTEX_RECURSIVE) {
+		if ((type&8) && m->_m_count<0) {
+			old &= 0x40000000;
+			m->_m_count = 0;
+			goto success;
+		}
+		if ((type&3) == PTHREAD_MUTEX_RECURSIVE) {
 			if ((unsigned)m->_m_count >= INT_MAX) return EAGAIN;
 			m->_m_count++;
 			return 0;
 		}
 	}
 	if (own == 0x3fffffff) return ENOTRECOVERABLE;
-	tid |= 0x80000000;
-	if (own) return EBUSY;
+	if (own || (old && !(type & 4))) return EBUSY;
+
+	if (type & 128) {
+		if (!self->robust_list.off) {
+			self->robust_list.off = (char*)&m->_m_lock-(char *)&m->_m_next;
+			__syscall(SYS_set_robust_list, &self->robust_list, 3*sizeof(long));
+		}
+		if (m->_m_waiters) tid |= 0x80000000;
+		self->robust_list.pending = &m->_m_next;
+	}
+	tid |= old & 0x40000000;
+
 	if (a_cas(&m->_m_lock, old, tid) != old) {
 		self->robust_list.pending = 0;
+		if ((type&12)==12 && m->_m_waiters) return ENOTRECOVERABLE;
 		return EBUSY;
 	}
 
-#if 0
+success:
+	if ((type&8) && m->_m_waiters) {
+		int priv = (type & 128) ^ 128;
+		__syscall(SYS_futex, &m->_m_lock, FUTEX_UNLOCK_PI|priv);
+		self->robust_list.pending = 0;
+		return (type&4) ? ENOTRECOVERABLE : EBUSY;
+	}
+
 	volatile void *next = self->robust_list.head;
 	m->_m_next = next;
 	m->_m_prev = &self->robust_list.head;
@@ -32,13 +55,18 @@ int __pthread_mutex_trylock_owner(pthread_mutex_t *m)
 		((char *)next - sizeof(void *)) = &m->_m_next;
 	self->robust_list.head = &m->_m_next;
 	self->robust_list.pending = 0;
-#endif
+
+	if (old) {
+		m->_m_count = 0;
+		return EOWNERDEAD;
+	}
+
 	return 0;
 }
 
 int __pthread_mutex_trylock(pthread_mutex_t *m)
 {
-	if ((m->_m_type&PTHREAD_MUTEX_TYPE_MASK) == PTHREAD_MUTEX_NORMAL)
+	if ((m->_m_type&15) == PTHREAD_MUTEX_NORMAL)
 		return a_cas(&m->_m_lock, 0, EBUSY) & EBUSY;
 	return __pthread_mutex_trylock_owner(m);
 }
diff --git a/third_party/musl/src/thread/pthread_mutex_unlock.c b/third_party/musl/src/thread/pthread_mutex_unlock.c
index 6922c8f04..b66423e6c 100644
--- a/third_party/musl/src/thread/pthread_mutex_unlock.c
+++ b/third_party/musl/src/thread/pthread_mutex_unlock.c
@@ -5,7 +5,7 @@ int __pthread_mutex_unlock(pthread_mutex_t *m)
 	pthread_t self;
 	int waiters = m->_m_waiters;
 	int cont;
-	int type = m->_m_type & PTHREAD_MUTEX_TYPE_MASK;
+	int type = m->_m_type & 15;
 	int priv = (m->_m_type & 128) ^ 128;
 	int new = 0;
 	int old;
@@ -16,13 +16,34 @@ int __pthread_mutex_unlock(pthread_mutex_t *m)
 		int own = old & 0x3fffffff;
 		if (own != self->tid)
 			return EPERM;
-		if ((type&PTHREAD_MUTEX_TYPE_MASK) == PTHREAD_MUTEX_RECURSIVE && m->_m_count)
+		if ((type&3) == PTHREAD_MUTEX_RECURSIVE && m->_m_count)
 			return m->_m_count--, 0;
-
+		if ((type&4) && (old&0x40000000))
+			new = 0x7fffffff;
+		if (!priv) {
+			self->robust_list.pending = &m->_m_next;
+			__vm_lock();
+		}
+		volatile void *prev = m->_m_prev;
+		volatile void *next = m->_m_next;
+		*(volatile void *volatile *)prev = next;
+		if (next != &self->robust_list.head) *(volatile void *volatile *)
+			((char *)next - sizeof(void *)) = prev;
+	}
+	if (type&8) {
+		if (old<0 || a_cas(&m->_m_lock, old, new)!=old) {
+			if (new) a_store(&m->_m_waiters, -1);
+			__syscall(SYS_futex, &m->_m_lock, FUTEX_UNLOCK_PI|priv);
+		}
+		cont = 0;
+		waiters = 0;
+	} else {
+		cont = a_swap(&m->_m_lock, new);
+	}
+	if (type != PTHREAD_MUTEX_NORMAL && !priv) {
+		self->robust_list.pending = 0;
+		__vm_unlock();
 	}
-
-	cont = a_swap(&m->_m_lock, new);
-
 	if (waiters || cont<0)
 		__wake(&m->_m_lock, 1, priv);
 	return 0;
diff --git a/third_party/musl/src/thread/pthread_mutexattr_setprotocol.c b/third_party/musl/src/thread/pthread_mutexattr_setprotocol.c
index cde69b8a1..511cc32d8 100755
--- a/third_party/musl/src/thread/pthread_mutexattr_setprotocol.c
+++ b/third_party/musl/src/thread/pthread_mutexattr_setprotocol.c
@@ -1,5 +1,4 @@
 #include "pthread_impl.h"
-#include <unsupported_api.h>
 #include "syscall.h"
 
 static pthread_once_t check_pi_once;
@@ -13,7 +12,6 @@ static void check_pi()
 
 int pthread_mutexattr_setprotocol(pthread_mutexattr_t *a, int protocol)
 {
-	unsupported_api(__FUNCTION__);
 	switch (protocol) {
 	case PTHREAD_PRIO_NONE:
 		a->__attr &= ~8;
diff --git a/third_party/musl/src/thread/pthread_mutexattr_setrobust.c b/third_party/musl/src/thread/pthread_mutexattr_setrobust.c
index 859350db3..04db92a62 100755
--- a/third_party/musl/src/thread/pthread_mutexattr_setrobust.c
+++ b/third_party/musl/src/thread/pthread_mutexattr_setrobust.c
@@ -1,5 +1,4 @@
 #include "pthread_impl.h"
-#include <unsupported_api.h>
 #include "syscall.h"
 
 static pthread_once_t check_robust_once;
@@ -14,7 +13,6 @@ static void check_robust()
 
 int pthread_mutexattr_setrobust(pthread_mutexattr_t *a, int robust)
 {
-	unsupported_api(__FUNCTION__);
 	if (robust > 1U) return EINVAL;
 	if (robust) {
 		pthread_once(&check_robust_once, check_robust);
diff --git a/third_party/musl/src/thread/pthread_self.c b/third_party/musl/src/thread/pthread_self.c
index 886ea4029..bd3bf95bb 100644
--- a/third_party/musl/src/thread/pthread_self.c
+++ b/third_party/musl/src/thread/pthread_self.c
@@ -1,13 +1,6 @@
 #include "pthread_impl.h"
 #include <threads.h>
 
-pthread_t __pthread_self()
-{
-	uintptr_t p;
-	p = __syscall(SYS_get_thread_area);
-	return (void *)(p - sizeof(struct pthread));
-}
-
 static pthread_t __pthread_self_internal()
 {
 	return __pthread_self();
diff --git a/third_party/musl/src/thread/pthread_setconcurrency.c b/third_party/musl/src/thread/pthread_setconcurrency.c
index a39423332..091abf98c 100755
--- a/third_party/musl/src/thread/pthread_setconcurrency.c
+++ b/third_party/musl/src/thread/pthread_setconcurrency.c
@@ -1,10 +1,8 @@
 #include <pthread.h>
 #include <errno.h>
-#include <unsupported_api.h>
 
 int pthread_setconcurrency(int val)
 {
-	unsupported_api(__FUNCTION__);
 	if (val < 0) return EINVAL;
 	if (val > 0) return EAGAIN;
 	return 0;
diff --git a/third_party/musl/src/thread/pthread_setschedparam.c b/third_party/musl/src/thread/pthread_setschedparam.c
index 1d781d132..038d13d8a 100755
--- a/third_party/musl/src/thread/pthread_setschedparam.c
+++ b/third_party/musl/src/thread/pthread_setschedparam.c
@@ -4,17 +4,8 @@
 int pthread_setschedparam(pthread_t t, int policy, const struct sched_param *param)
 {
 	int r;
-
-	if (policy != SCHED_RR && policy != SCHED_FIFO) {
-		return EINVAL;
-	}
-
-	if (param->sched_priority < 0 || param->sched_priority > PTHREAD_PRIORITY_LOWEST) {
-		return EINVAL;
-	}
-
 	LOCK(t->killlock);
-	r = !t->tid ? ESRCH : -__syscall(SYS_sched_setscheduler, t->tid, policy, param->sched_priority, MUSL_TYPE_THREAD);
+	r = !t->tid ? ESRCH : -__syscall(SYS_sched_setscheduler, t->tid, policy, param);
 	UNLOCK(t->killlock);
 	return r;
 }
diff --git a/third_party/musl/src/thread/pthread_setschedprio.c b/third_party/musl/src/thread/pthread_setschedprio.c
index 68bf3486d..5bf4a0197 100644
--- a/third_party/musl/src/thread/pthread_setschedprio.c
+++ b/third_party/musl/src/thread/pthread_setschedprio.c
@@ -4,13 +4,8 @@
 int pthread_setschedprio(pthread_t t, int prio)
 {
 	int r;
-
-	if (prio < 0 || prio > PTHREAD_PRIORITY_LOWEST) {
-		return EINVAL;
-	}
-
 	LOCK(t->killlock);
-	r = !t->tid ? ESRCH : -__syscall(SYS_sched_setparam, t->tid, prio, MUSL_TYPE_THREAD);
+	r = !t->tid ? ESRCH : -__syscall(SYS_sched_setparam, t->tid, &prio);
 	UNLOCK(t->killlock);
 	return r;
 }
diff --git a/third_party/musl/src/thread/sem_open.c b/third_party/musl/src/thread/sem_open.c
index f85eecb7d..de8555c5a 100644
--- a/third_party/musl/src/thread/sem_open.c
+++ b/third_party/musl/src/thread/sem_open.c
@@ -85,6 +85,7 @@ sem_t *sem_open(const char *name, int flags, ...)
 					close(fd);
 					goto fail;
 				}
+				close(fd);
 				break;
 			}
 			if (errno != ENOENT)
@@ -119,6 +120,7 @@ sem_t *sem_open(const char *name, int flags, ...)
 			unlink(tmp);
 			goto fail;
 		}
+		close(fd);
 		e = link(tmp, name) ? errno : 0;
 		unlink(tmp);
 		if (!e) break;
diff --git a/third_party/musl/src/thread/thrd_yield.c b/third_party/musl/src/thread/thrd_yield.c
index 4138c146f..f7ad13219 100644
--- a/third_party/musl/src/thread/thrd_yield.c
+++ b/third_party/musl/src/thread/thrd_yield.c
@@ -3,5 +3,5 @@
 
 void thrd_yield()
 {
-	__syscall(SYS_sched_yield, -1);
+	__syscall(SYS_sched_yield);
 }
diff --git a/third_party/musl/src/time/__map_file.c b/third_party/musl/src/time/__map_file.c
index 80e0df3db..d3cefa828 100644
--- a/third_party/musl/src/time/__map_file.c
+++ b/third_party/musl/src/time/__map_file.c
@@ -14,8 +14,6 @@ const char unsigned *__map_file(const char *pathname, size_t *size)
 		map = __mmap(0, st.st_size, PROT_READ, MAP_SHARED, fd, 0);
 		*size = st.st_size;
 	}
-	if (map == MAP_FAILED) {
-		__syscall(SYS_close, fd);
-	}
+	__syscall(SYS_close, fd);
 	return map == MAP_FAILED ? 0 : map;
 }
diff --git a/third_party/musl/src/time/__tz.c b/third_party/musl/src/time/__tz.c
index 0ff172f9d..185642e88 100755
--- a/third_party/musl/src/time/__tz.c
+++ b/third_party/musl/src/time/__tz.c
@@ -6,7 +6,6 @@
 #include <sys/mman.h>
 #include "libc.h"
 #include "lock.h"
-#include <unsupported_api.h>
 
 long  __timezone = 0;
 int   __daylight = 0;
@@ -403,7 +402,6 @@ dst:
 
 static void __tzset()
 {
-	unsupported_api(__FUNCTION__);
 	LOCK(lock);
 	do_tzset();
 	UNLOCK(lock);
diff --git a/third_party/musl/src/time/clock.c b/third_party/musl/src/time/clock.c
index 06994710b..6724012b9 100755
--- a/third_party/musl/src/time/clock.c
+++ b/third_party/musl/src/time/clock.c
@@ -1,12 +1,10 @@
 #include <time.h>
 #include <limits.h>
-#include <unsupported_api.h>
 
 clock_t clock()
 {
 	struct timespec ts;
 
-	unsupported_api(__FUNCTION__);
 	if (__clock_gettime(CLOCK_PROCESS_CPUTIME_ID, &ts))
 		return -1;
 
diff --git a/third_party/musl/src/time/clock_getcpuclockid.c b/third_party/musl/src/time/clock_getcpuclockid.c
index aa916f3d3..8a0e2d4c3 100755
--- a/third_party/musl/src/time/clock_getcpuclockid.c
+++ b/third_party/musl/src/time/clock_getcpuclockid.c
@@ -1,14 +1,11 @@
 #include <time.h>
 #include <errno.h>
 #include <unistd.h>
-#include <unsupported_api.h>
 #include "syscall.h"
 
 int clock_getcpuclockid(pid_t pid, clockid_t *clk)
 {
 	struct timespec ts;
-	unsupported_api(__FUNCTION__);
-
 	clockid_t id = (-pid-1)*8U + 2;
 	int ret = __syscall(SYS_clock_getres, id, &ts);
 	if (ret) return -ret;
diff --git a/third_party/musl/src/time/times.c b/third_party/musl/src/time/times.c
index 9c50144f6..c4a100f79 100644
--- a/third_party/musl/src/time/times.c
+++ b/third_party/musl/src/time/times.c
@@ -3,5 +3,5 @@
 
 clock_t times(struct tms *tms)
 {
-	return syscall(SYS_times, tms);
+	return __syscall(SYS_times, tms);
 }
diff --git a/third_party/musl/src/time/utime.c b/third_party/musl/src/time/utime.c
index 36279de35..e7592b297 100755
--- a/third_party/musl/src/time/utime.c
+++ b/third_party/musl/src/time/utime.c
@@ -2,11 +2,9 @@
 #include <sys/stat.h>
 #include <time.h>
 #include <fcntl.h>
-#include <unsupported_api.h>
 
 int utime(const char *path, const struct utimbuf *times)
 {
-	unsupported_api(__FUNCTION__);
 	return utimensat(AT_FDCWD, path, times ? ((struct timespec [2]){
 		{ .tv_sec = times->actime }, { .tv_sec = times->modtime }})
 		: 0, 0);
diff --git a/third_party/musl/src/unistd/ctermid.c b/third_party/musl/src/unistd/ctermid.c
index dc30487f7..1612770af 100755
--- a/third_party/musl/src/unistd/ctermid.c
+++ b/third_party/musl/src/unistd/ctermid.c
@@ -1,9 +1,7 @@
 #include <stdio.h>
 #include <string.h>
-#include <unsupported_api.h>
 
 char *ctermid(char *s)
 {
-	unsupported_api(__FUNCTION__);
 	return s ? strcpy(s, "/dev/tty") : "/dev/tty";
 }
diff --git a/third_party/musl/src/unistd/faccessat.c b/third_party/musl/src/unistd/faccessat.c
index 29e24e03a..76bbd4c72 100755
--- a/third_party/musl/src/unistd/faccessat.c
+++ b/third_party/musl/src/unistd/faccessat.c
@@ -1,7 +1,6 @@
 #include <unistd.h>
 #include <fcntl.h>
 #include <sys/wait.h>
-#include <unsupported_api.h>
 #include "syscall.h"
 #include "pthread_impl.h"
 
@@ -26,7 +25,6 @@ static int checker(void *p)
 
 int faccessat(int fd, const char *filename, int amode, int flag)
 {
-	unsupported_api(__FUNCTION__);
 	if (!flag || (flag==AT_EACCESS && getuid()==geteuid() && getgid()==getegid()))
 		return syscall(SYS_faccessat, fd, filename, amode, flag);
 
diff --git a/third_party/musl/src/unistd/fchdir.c b/third_party/musl/src/unistd/fchdir.c
index 54f9eb232..dee45ba68 100755
--- a/third_party/musl/src/unistd/fchdir.c
+++ b/third_party/musl/src/unistd/fchdir.c
@@ -1,13 +1,10 @@
 #include <unistd.h>
 #include <errno.h>
 #include <fcntl.h>
-#include <unsupported_api.h>
-
 #include "syscall.h"
 
 int fchdir(int fd)
 {
-	unsupported_api(__FUNCTION__);
 	int ret = __syscall(SYS_fchdir, fd);
 	if (ret != -EBADF || __syscall(SYS_fcntl, fd, F_GETFD) < 0)
 		return __syscall_ret(ret);
diff --git a/third_party/musl/src/unistd/fchown.c b/third_party/musl/src/unistd/fchown.c
index 441e39cb4..737b3672f 100755
--- a/third_party/musl/src/unistd/fchown.c
+++ b/third_party/musl/src/unistd/fchown.c
@@ -1,13 +1,10 @@
 #include <unistd.h>
 #include <errno.h>
 #include <fcntl.h>
-#include <unsupported_api.h>
-
 #include "syscall.h"
 
 int fchown(int fd, uid_t uid, gid_t gid)
 {
-	unsupported_api(__FUNCTION__);
 	int ret = __syscall(SYS_fchown, fd, uid, gid);
 	if (ret != -EBADF || __syscall(SYS_fcntl, fd, F_GETFD) < 0)
 		return __syscall_ret(ret);
diff --git a/third_party/musl/src/unistd/fchownat.c b/third_party/musl/src/unistd/fchownat.c
index 88fce2c18..62457a3ec 100755
--- a/third_party/musl/src/unistd/fchownat.c
+++ b/third_party/musl/src/unistd/fchownat.c
@@ -1,10 +1,7 @@
 #include <unistd.h>
-#include <unsupported_api.h>
-
 #include "syscall.h"
 
 int fchownat(int fd, const char *path, uid_t uid, gid_t gid, int flag)
 {
-	unsupported_api(__FUNCTION__);
 	return syscall(SYS_fchownat, fd, path, uid, gid, flag);
 }
diff --git a/third_party/musl/src/unistd/fdatasync.c b/third_party/musl/src/unistd/fdatasync.c
index ee88d08da..3895ae530 100755
--- a/third_party/musl/src/unistd/fdatasync.c
+++ b/third_party/musl/src/unistd/fdatasync.c
@@ -1,10 +1,7 @@
 #include <unistd.h>
-#include <unsupported_api.h>
-
 #include "syscall.h"
 
 int fdatasync(int fd)
 {
-	unsupported_api(__FUNCTION__);
 	return syscall_cp(SYS_fdatasync, fd);
 }
diff --git a/third_party/musl/src/unistd/gethostname.c b/third_party/musl/src/unistd/gethostname.c
index 91eecdf7a..633ef571a 100755
--- a/third_party/musl/src/unistd/gethostname.c
+++ b/third_party/musl/src/unistd/gethostname.c
@@ -1,12 +1,10 @@
 #include <unistd.h>
 #include <sys/utsname.h>
-#include <unsupported_api.h>
 
 int gethostname(char *name, size_t len)
 {
 	size_t i;
 	struct utsname uts;
-	unsupported_api(__FUNCTION__);
 	if (uname(&uts)) return -1;
 	if (len > sizeof uts.nodename) len = sizeof uts.nodename;
 	for (i=0; i<len && (name[i] = uts.nodename[i]); i++);
diff --git a/third_party/musl/src/unistd/getlogin.c b/third_party/musl/src/unistd/getlogin.c
index 004a9c4d1..06011913a 100755
--- a/third_party/musl/src/unistd/getlogin.c
+++ b/third_party/musl/src/unistd/getlogin.c
@@ -1,9 +1,7 @@
 #include <unistd.h>
 #include <stdlib.h>
-#include <unsupported_api.h>
 
 char *getlogin(void)
 {
-	unsupported_api(__FUNCTION__);
 	return getenv("LOGNAME");
 }
diff --git a/third_party/musl/src/unistd/getlogin_r.c b/third_party/musl/src/unistd/getlogin_r.c
index 41bd656ef..53866c6dc 100755
--- a/third_party/musl/src/unistd/getlogin_r.c
+++ b/third_party/musl/src/unistd/getlogin_r.c
@@ -1,12 +1,10 @@
 #include <unistd.h>
 #include <string.h>
 #include <errno.h>
-#include <unsupported_api.h>
 
 int getlogin_r(char *name, size_t size)
 {
 	char *logname = getlogin();
-	unsupported_api(__FUNCTION__);
 	if (!logname) return ENXIO; /* or...? */
 	if (strlen(logname) >= size) return ERANGE;
 	strcpy(name, logname);
diff --git a/third_party/musl/src/unistd/getsid.c b/third_party/musl/src/unistd/getsid.c
index ecb02e0b0..93ba690e7 100755
--- a/third_party/musl/src/unistd/getsid.c
+++ b/third_party/musl/src/unistd/getsid.c
@@ -1,9 +1,7 @@
 #include <unistd.h>
 #include "syscall.h"
-#include <unsupported_api.h>
 
 pid_t getsid(pid_t pid)
 {
-	unsupported_api(__FUNCTION__);
 	return syscall(SYS_getsid, pid);
 }
diff --git a/third_party/musl/src/unistd/lchown.c b/third_party/musl/src/unistd/lchown.c
index e155ee02d..ccd5ee025 100755
--- a/third_party/musl/src/unistd/lchown.c
+++ b/third_party/musl/src/unistd/lchown.c
@@ -1,11 +1,9 @@
 #include <unistd.h>
 #include <fcntl.h>
 #include "syscall.h"
-#include <unsupported_api.h>
 
 int lchown(const char *path, uid_t uid, gid_t gid)
 {
-	unsupported_api(__FUNCTION__);
 #ifdef SYS_lchown
 	return syscall(SYS_lchown, path, uid, gid);
 #else
diff --git a/third_party/musl/src/unistd/link.c b/third_party/musl/src/unistd/link.c
index 184b66806..feec18e53 100755
--- a/third_party/musl/src/unistd/link.c
+++ b/third_party/musl/src/unistd/link.c
@@ -1,11 +1,9 @@
 #include <unistd.h>
 #include <fcntl.h>
 #include "syscall.h"
-#include <unsupported_api.h>
 
 int link(const char *existing, const char *new)
 {
-	unsupported_api(__FUNCTION__);
 #ifdef SYS_link
 	return syscall(SYS_link, existing, new);
 #else
diff --git a/third_party/musl/src/unistd/linkat.c b/third_party/musl/src/unistd/linkat.c
index 595df5b6f..6a9a0b775 100755
--- a/third_party/musl/src/unistd/linkat.c
+++ b/third_party/musl/src/unistd/linkat.c
@@ -1,9 +1,7 @@
 #include <unistd.h>
 #include "syscall.h"
-#include <unsupported_api.h>
 
 int linkat(int fd1, const char *existing, int fd2, const char *new, int flag)
 {
-	unsupported_api(__FUNCTION__);
 	return syscall(SYS_linkat, fd1, existing, fd2, new, flag);
 }
diff --git a/third_party/musl/src/unistd/nice.c b/third_party/musl/src/unistd/nice.c
index ec55a1375..6c25c8c32 100755
--- a/third_party/musl/src/unistd/nice.c
+++ b/third_party/musl/src/unistd/nice.c
@@ -2,12 +2,10 @@
 #include <sys/resource.h>
 #include <limits.h>
 #include "syscall.h"
-#include <unsupported_api.h>
 
 int nice(int inc)
 {
 	int prio = inc;
-	unsupported_api(__FUNCTION__);
 	// Only query old priority if it can affect the result.
 	// This also avoids issues with integer overflow.
 	if (inc > -2*NZERO && inc < 2*NZERO)
diff --git a/third_party/musl/src/unistd/pipe2.c b/third_party/musl/src/unistd/pipe2.c
index 2125dd322..f24f74fb0 100755
--- a/third_party/musl/src/unistd/pipe2.c
+++ b/third_party/musl/src/unistd/pipe2.c
@@ -1,13 +1,11 @@
 #include <unistd.h>
 #include <errno.h>
 #include <fcntl.h>
-#include <unsupported_api.h>
 #include "syscall.h"
 
 int pipe2(int fd[2], int flag)
 {
 	if (!flag) return pipe(fd);
-	unsupported_api(__FUNCTION__);
 	int ret = __syscall(SYS_pipe2, fd, flag);
 	if (ret != -ENOSYS) return __syscall_ret(ret);
 	ret = pipe(fd);
diff --git a/third_party/musl/src/unistd/readlink.c b/third_party/musl/src/unistd/readlink.c
index 4d7c456de..a152d5249 100755
--- a/third_party/musl/src/unistd/readlink.c
+++ b/third_party/musl/src/unistd/readlink.c
@@ -1,11 +1,9 @@
-#include <unsupported_api.h>
 #include <unistd.h>
 #include <fcntl.h>
 #include "syscall.h"
 
 ssize_t readlink(const char *restrict path, char *restrict buf, size_t bufsize)
 {
-	unsupported_api(__FUNCTION__);
 #ifdef SYS_readlink
 	return syscall(SYS_readlink, path, buf, bufsize);
 #else
diff --git a/third_party/musl/src/unistd/readlinkat.c b/third_party/musl/src/unistd/readlinkat.c
index c7bbefd0a..9af45cd5a 100755
--- a/third_party/musl/src/unistd/readlinkat.c
+++ b/third_party/musl/src/unistd/readlinkat.c
@@ -1,10 +1,7 @@
 #include <unistd.h>
-#include <unsupported_api.h>
-
 #include "syscall.h"
 
 ssize_t readlinkat(int fd, const char *restrict path, char *restrict buf, size_t bufsize)
 {
-	unsupported_api(__FUNCTION__);
 	return syscall(SYS_readlinkat, fd, path, buf, bufsize);
 }
diff --git a/third_party/musl/src/unistd/renameat.c b/third_party/musl/src/unistd/renameat.c
index 77d5d9a43..c3b40a258 100755
--- a/third_party/musl/src/unistd/renameat.c
+++ b/third_party/musl/src/unistd/renameat.c
@@ -1,11 +1,8 @@
 #include <stdio.h>
-#include <unsupported_api.h>
-
 #include "syscall.h"
 
 int renameat(int oldfd, const char *old, int newfd, const char *new)
 {
-	unsupported_api(__FUNCTION__);
 #ifdef SYS_renameat
 	return syscall(SYS_renameat, oldfd, old, newfd, new);
 #else
diff --git a/third_party/musl/src/unistd/setegid.c b/third_party/musl/src/unistd/setegid.c
index 3abdfaf82..e6da2573c 100644
--- a/third_party/musl/src/unistd/setegid.c
+++ b/third_party/musl/src/unistd/setegid.c
@@ -1,13 +1,8 @@
 #include <unistd.h>
 #include "libc.h"
 #include "syscall.h"
-#include "errno.h"
 
 int setegid(gid_t egid)
 {
-	if (egid == -1) {
-		errno = EINVAL;
-		return -1;
-	}
 	return __setxid(SYS_setresgid, -1, egid, -1);
 }
diff --git a/third_party/musl/src/unistd/seteuid.c b/third_party/musl/src/unistd/seteuid.c
index ea2562c74..ef8b9df43 100644
--- a/third_party/musl/src/unistd/seteuid.c
+++ b/third_party/musl/src/unistd/seteuid.c
@@ -1,13 +1,8 @@
 #include <unistd.h>
 #include "syscall.h"
 #include "libc.h"
-#include "errno.h"
 
 int seteuid(uid_t euid)
 {
-	if (euid == -1) {
-		errno = EINVAL;
-		return -1;
-	}
 	return __setxid(SYS_setresuid, -1, euid, -1);
 }
diff --git a/third_party/musl/src/unistd/setsid.c b/third_party/musl/src/unistd/setsid.c
index 54e4d9347..609bbe4ac 100755
--- a/third_party/musl/src/unistd/setsid.c
+++ b/third_party/musl/src/unistd/setsid.c
@@ -1,10 +1,7 @@
 #include <unistd.h>
-#include <unsupported_api.h>
-
 #include "syscall.h"
 
 pid_t setsid(void)
 {
-	unsupported_api(__FUNCTION__);
 	return syscall(SYS_setsid);
 }
diff --git a/third_party/musl/src/unistd/setxid.c b/third_party/musl/src/unistd/setxid.c
index 647beaeb9..0239f8afa 100644
--- a/third_party/musl/src/unistd/setxid.c
+++ b/third_party/musl/src/unistd/setxid.c
@@ -30,7 +30,7 @@ int __setxid(int nr, int id, int eid, int sid)
 	/* err is initially nonzero so that failure of the first thread does not
 	 * trigger the safety kill above. */
 	struct ctx c = { .nr = nr, .id = id, .eid = eid, .sid = sid, .err = -1 };
-	do_setxid(&c);
+	__synccall(do_setxid, &c);
 	if (c.err) {
 		if (c.err>0) errno = c.err;
 		return -1;
diff --git a/third_party/musl/src/unistd/symlink.c b/third_party/musl/src/unistd/symlink.c
index 4b9294fb4..0973d78a8 100755
--- a/third_party/musl/src/unistd/symlink.c
+++ b/third_party/musl/src/unistd/symlink.c
@@ -1,12 +1,9 @@
 #include <unistd.h>
 #include <fcntl.h>
-#include <unsupported_api.h>
-
 #include "syscall.h"
 
 int symlink(const char *existing, const char *new)
 {
-	unsupported_api(__FUNCTION__);
 #ifdef SYS_symlink
 	return syscall(SYS_symlink, existing, new);
 #else
diff --git a/third_party/musl/src/unistd/symlinkat.c b/third_party/musl/src/unistd/symlinkat.c
index f2f7eb780..d1c59b4db 100755
--- a/third_party/musl/src/unistd/symlinkat.c
+++ b/third_party/musl/src/unistd/symlinkat.c
@@ -1,10 +1,7 @@
 #include <unistd.h>
-#include <unsupported_api.h>
-
 #include "syscall.h"
 
 int symlinkat(const char *existing, int fd, const char *new)
 {
-	unsupported_api(__FUNCTION__);
 	return syscall(SYS_symlinkat, existing, fd, new);
 }
diff --git a/third_party/musl/src/unistd/sync.c b/third_party/musl/src/unistd/sync.c
index 666aaf7d7..f18765aa8 100755
--- a/third_party/musl/src/unistd/sync.c
+++ b/third_party/musl/src/unistd/sync.c
@@ -1,10 +1,7 @@
 #include <unistd.h>
-#include <unsupported_api.h>
-
 #include "syscall.h"
 
 void sync(void)
 {
-	unsupported_api(__FUNCTION__);
 	__syscall(SYS_sync);
 }
diff --git a/third_party/musl/src/unistd/tcgetpgrp.c b/third_party/musl/src/unistd/tcgetpgrp.c
index 5fc8ae273..50080c7e8 100755
--- a/third_party/musl/src/unistd/tcgetpgrp.c
+++ b/third_party/musl/src/unistd/tcgetpgrp.c
@@ -1,12 +1,10 @@
 #include <unistd.h>
 #include <termios.h>
 #include <sys/ioctl.h>
-#include <unsupported_api.h>
 
 pid_t tcgetpgrp(int fd)
 {
 	int pgrp;
-	unsupported_api(__FUNCTION__);
 	if (ioctl(fd, TIOCGPGRP, &pgrp) < 0)
 		return -1;
 	return pgrp;
diff --git a/third_party/musl/src/unistd/ttyname.c b/third_party/musl/src/unistd/ttyname.c
index 31f3dc189..0f3e11411 100755
--- a/third_party/musl/src/unistd/ttyname.c
+++ b/third_party/musl/src/unistd/ttyname.c
@@ -1,13 +1,11 @@
 #include <unistd.h>
 #include <errno.h>
 #include <limits.h>
-#include <unsupported_api.h>
 
 char *ttyname(int fd)
 {
 	static char buf[TTY_NAME_MAX];
 	int result;
-	unsupported_api(__FUNCTION__);
 	if ((result = ttyname_r(fd, buf, sizeof buf))) {
 		errno = result;
 		return NULL;
diff --git a/third_party/musl/src/unistd/unlinkat.c b/third_party/musl/src/unistd/unlinkat.c
index 96ba4069c..e0e25d22a 100755
--- a/third_party/musl/src/unistd/unlinkat.c
+++ b/third_party/musl/src/unistd/unlinkat.c
@@ -1,10 +1,7 @@
 #include <unistd.h>
-#include <unsupported_api.h>
-
 #include "syscall.h"
 
 int unlinkat(int fd, const char *path, int flag)
 {
-	unsupported_api(__FUNCTION__);
 	return syscall(SYS_unlinkat, fd, path, flag);
 }
